<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Linux-基础IO]]></title>
    <url>%2F2019%2F04%2F12%2FLinux-%E5%9F%BA%E7%A1%80IO%2F</url>
    <content type="text"><![CDATA[文件的输入输出在c语言之前了解过。比如标准库的IO接口 回顾C语言的库函数fopen，fread，fwrite，fseek，fclose这几个函数。关键在于参数的使用。 例如fopen，FILE *fopen(const char *path, const char *mode),在不同的模式下打开文件所能作的操作也不同。 文件使用方式 含义 如果指定文件不存在 r–只读 为了输入数据，打开一个已经存在的文本 文件出错 w–只写 为了输出数据，打开一个文本文件 建立一个新文件 a–追加 向文本文件尾添加数据 出错 rb–只读 为了输入数据，打开一个二进制文件 出错 wb–只写 为了输出数据，打开一个二进制文件 建立一个新文件 ab–追加 向一个二进制文件尾添加数据 出错 r+–读写 为了读和写，打开一个文本文件 出错 w+–读写 为了读和写，建立一个新的文件 建立一个新文件 a+–读写 打开一个文件，在文件尾进行读写 建立一个新的文件 rb+–读写 为了读和写打开一个二进制文件 出错 wb+–读写 为了读和写，新建一个新的二进制文件 建立一个新的文件 ab+–读写 打开一个二进制文件，在文件尾进行读和写 建立一个新的文件 先回顾一下C语言中的文件操作 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; int main()&#123; int ret; FILE *fp = NULL; fp = fopen("./tmp.txt","r+"); if(fp == NULL)&#123; perror("打开失败"); return -1; &#125; fseek(fp, 5, SEEK_END); char *ptr = "nihao---\n"; ret = fwrite(ptr, 1, strlen(ptr), fp); printf("write item:%d\n",ret); fseek(fp, 0, SEEK_SET); char buf[1024] = &#123;0&#125;; ret = fread(buf, 1, 1023, fp); perror("读取失败"); printf("read buf[%s]-[%d]",buf,ret); fclose(fp); return 0; &#125; 先打开当前路径下的tmp.txt文件以读写的方式打开，之后利用fseek函数跳转读写位置从当前文件位置的末尾开始向后五个位置跳转。然后写入数据，一个字节写入，写入长度为*ptr的字符串长度，然后再跳转到文件的开头开始读取数据读取到buf中。fread返回值是读取的数据长度。最后关闭文件。 这是C语言库函数中的使用方法。 系统调用IO接口open write read close lseek 1234int open(const char *pathname, int flags, mode_t mode);ssize_t write(int fd, const void *buf, size_t count);ssize_t read(int fd, void *buf, size_t count);off_t lseek(int fd, off_t offset, int whence);]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux进程控制]]></title>
    <url>%2F2019%2F04%2F08%2FLinux%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[在之前的Linux进程概念中提到了一些关于进程的创建。进程的创建通过fork函数创建子进程。 进程终止进程终止顾名思义，进程结束。但是结束有各种可能，可能成功，可能失败，也可能异常。 进程常见退出方法123456正常退出1、从main返回2、调用exit3、_exit异常退出ctrl + c exit函数12345#include &lt;unistd.h&gt; void _exit(int status);参数：status 定义了进程的终止状态，父进程通过wait来获取该值 说明：虽然status是int，但是仅有低8位可以被父进程所用。所以_exit(-1)时，在终端执行$?发现返回值 是255。 1234567891011121314151617181920#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;string.h&gt; #include &lt;errno.h&gt; int main()&#123; int pid = fork(); if(pid &lt; 0)&#123; perror("fork error"); printf("fork error:%s\n",strerror(errno)); &#125; int i = 0; for( ;i &lt; 256; i++)&#123; printf("errno:[%s]\n",strerror(i)); &#125; printf("hello bit"); sleep(1); _exit(257); &#125; 在这之中调用的是_exit函数，关于这两个函数，并没有什么太大的区别，exit()就是对-exit进行的一个分装。通过man手册可以详细了解。 _ exit()的退出是简单粗暴的，exit()还做了一些其他的工作。可自行查看 他们俩的共同点就是都会关闭文件描述符，都会清空内存，但是exit还会额外地清空输入输出流缓存，移除临时创建的文件，调用注册好的出口函数等等。 进程等待为什么要进行进程等待？ 之前写过僵尸进程的危害，一个僵尸进程对内存的资源泄漏是积少成多的。一个两个倒没啥，但是如果多了将无法再创建新的进程，并且就连最强大的杀死进程kill -9也无法将其杀死，所以进程等待的必要性是很重要的。当父进程创建一个子进程时，通过进程等待，回收子进程资源，获取子进程的退出信息，而不让其保存在操作系统中。 总的来说：因为父进程不知道子进程什么时候退出，因此只能在子进程进程创建之后调用wait()，进行进程等待。因为调用wait就是一直在等待子进程的退出。 进程等待的方法wait()接口是一个阻塞函数，功能是等待子进程退出，如果子进程没有退出，一直等待到有子进程退出 123456#include &lt;type.h&gt;#include &lt;wait.h&gt;pid_t wait(int *status);函数的返回值：成功返回等待的pid，失败返回-1参数：输出型参数，获取子进程的状态，不关心则可以设置为NULL waitpid()函数 12345678910111213pid_t waitpid(pid_t pid, int *status,int options);返回值： 当正常返回的时候waitpid返回收集到的子进程的进程ID； 如果设置了选项WNOHANG,而调用中waitpid发现没有已退出的子进程可收集,则返回0； 如果调用中出错,则返回-1,这时errno会被设置成相应的值以指示错误所在； 参数： pid： Pid=-1,等待任一个子进程。与wait等效。 Pid&gt;0.等待其进程ID与pid相等的子进程。 status: WIFEXITED(status): 若为正常终止子进程返回的状态，则为真。（查看进程是否是正常退出） WEXITSTATUS(status): 若WIFEXITED非零，提取子进程退出码。（查看进程的退出码） options: WNOHANG: 若pid指定的子进程没有结束，则waitpid()函数返回0，不予以等待。若正常结束，则返回该子进 程的ID。 第二种wait还是一种封装方式。只不过需要讨论以下status的参数获取。 status是输出型参数，由操作系统填充。status的使用只在低16位上 从图片可以看出status低八位中的低七位保存异常的情况，高八位保存的是我们的数据 1234567891011121314151617181920212223242526272829303132333435363738/*进程等待-避免产生建时进程demo*/#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;int main()&#123; int pid = fork(); if (pid &lt; 0) &#123; perror("fork error"); exit(-1); &#125;else if (pid == 0) &#123; sleep(5); exit(255);//此时返回的是1 &#125; int status; while (waitpid(pid, &amp;status, WNOHANG) == 0) &#123; printf("no exit~~~smoking~~\n"); sleep(1); &#125; //低7位为0则正常退出 if (!(status &amp; 0x7f)) &#123; printf("child exit code:%d\n", (status &gt;&gt; 8) &amp; 0xff); &#125; //man 2 wait 自行查看这个WIFEXITED的参数返回设置 if (WIFEXITED(status)) &#123; printf("child exit code:%d\n", WEXITSTATUS(status)); &#125; if (WIFSIGNALED(status)) &#123; printf("exit signal:%d\n", WTERMSIG(status)); &#125; while(1) &#123; printf("打麻将~~~\n"); sleep(1); &#125; return 0;&#125; 但是waitpid第三个参数可以将waitpid设置为非阻塞，没有子进程退出则立即报错返回0. 阻塞：为了完成某个功能发起调用，如果当前不具备完成条件，一直等待，直到完成后返回 非阻塞：为了完成某个功能发起调用，如果当前不具备完成条件，直接报错返回 当自己进程没有退出正在执行sleep函数时，waitpid()一直在运行等待子进程的退出。退出成功后，输出此时status此时右移到低八位的数值—–就是exit()的返回值。然后判断子进程是否正常退出，如果非正常退出将有退出信号。 进程替换父进程创建了子进程，子进程如果总是做着和父进程相同的工作，那么子进程没有太大的意义。所以这时候可以调用exec函数来执行另一个程序。当进程调用一种exec函数时，该进程的用户空间代码和数据完全被新程序替换，从新程序的启动例程开始执行。调用exec并不创建新进程，所以调用exec前后该进程的id并未改变。 也可以这样认为：替换的是程序所运行的程序，将另一段程序加载到内存中，通过页表将原先进程的映射关系，重新建立到新程序在内存中的地址，相当于替换了进程所运行的程序以及所要处理的数据，因此，替换了代码段，重新初始化数据段。 替换进程正在运行的程序（替换代码段以及运行数据，更行页表，从main函数重新运行） 替换函数通过exec函数群来实现 execve是系统调用接口，以下是函数群 123456int execl(const char *path, const char *arg, ...);int execlp(const char *file, const char *arg, ...);int execle(const char *path, const char *arg, ..., char * const envp[]);int execv(const char *path, char *const argv[]);int execvp(const char *file, char *const argv[]);int execvpe(const char *file, char *const argv[], char *const envp[]); execl(ls,ls,-a,-l,-i,null) 参数是平铺赋予 execv(/bin/ls,argv) 参数是通过参数数组赋予argv[0]=ls,argv[1]=-a,argv[2]=-l…argv[4]=NULL execl与execv区别：参数的赋予是以指针数组赋予还是以不定参数形式赋予 最后必须将null写入！！！ 最后必须将null写入！！！ 最后必须将null写入！！！ 有无p的区别：是否自动到PATH所制定的路径下找程序文件 有无e的区别：是否自定义环境变量的区别 如果带e的话将当前进程的环境变量也将会发生改变。 1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;unistd.h&gt;#include &lt;stdlib.h&gt;int main()&#123; printf("hello world\n"); execl("./env","env","-l",NULL);//谁调用就对谁进行程序替换 //如果 execl() 执行成功，下面执行不到，因为当前进程已经被执行的 ./env 替换了 //所以执行之后一直都是第一个printf循环执行 char *env[32]; env[0] = "MYENV=10000"; env[1] = NULL; extern char **environ;//保存环境变量 execle("./env","env","-l",NULL,environ); printf("hello world~~\n"); return 0;&#125; exec 只是用另一个新程序替换了当前进程的正文、数据、堆和栈段（进程替换） 不断的强调这句话因为，exec的替换的理解：我们可以想象为我们在当前内存空间中执行的程序替换到一个新的内存空间中。程序将在新的空间中执行 这里的理解感觉有些繁琐，但是进程替换之后，执行成功之后不会返回，而且exec函数族下面的代码执行不到，只有调用失败了，才会返回-1，失败后从原程序的调用点接着往下执行。 从物理角度来理解：将进程的虚拟地址空间所映射在物理内存的区域进行改变，改编成另一个程序中在内存中的位置，更新页表信息，重新初始化虚拟地址空间，为了让进程运行另一个程序 自主minishell的实现1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;wait.h&gt;#include &lt;unistd.h&gt;#include &lt;ctype.h&gt;int main()&#123; while(1)&#123; printf("[liuyucheng@localhost]$ "); fflush(stdout); char buf[1024] = &#123;0&#125;; if(scanf("%[^\n]%*c", buf) != 1)&#123; getchar(); continue; &#125; //取出空白字符，获取程序名称和参数 char *argv[32];//将自己定义的缓冲区的字符放入该数组中 int argc = 0; char *ptr = buf; while(*ptr != '\0')&#123; //若参数c为空格字符，则返回TRUE，否则返回NULL(0)。 if(!isspace(*ptr))&#123; argv[argc++] = ptr; while(!isspace(*ptr) &amp;&amp; *ptr != '\0')&#123; ptr++; &#125; &#125;else&#123; *ptr = '\0'; ptr++; &#125; &#125; argv[argc] = NULL; int pid = fork(); //创建子进程 if(pid &lt; 0)&#123; exit(-1);//退出返回-1 &#125; else if(pid == 0)&#123;//如果子进程创建成功 execvp(argv[0], argv);//程序替换,此时argv保存了指令的字符串，替换到argv[0]中，这样execvp自动在当前PATH路径下寻找指令，例如ls，ll exit(0); &#125; wait(NULL);//等待子进程退出 &#125; return 0;&#125; 如图则为程序运行。不过cd指令不行。不能跳到另一个文件夹中。 将所学的几个进程都用到了，很有帮助。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之二叉树]]></title>
    <url>%2F2019%2F04%2F04%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[树的概念树是一种非线性的结构，它是由n(n&gt;0)个有限结点组成一个具有层次关系的集合。把他叫做树是因为它看起来像一个倒挂的树，它的根是朝上的，但是它的叶是朝下的。 它具有以下特点：每个节点有零个或多个子结点；没有父结点的称为根节点；每一个非根节点有且只有一个父结点；除了根节点外，每个子节点可以分为多个不相交的子树。 关于树，还有一些相关知识，我们需要了解。 节点的度：一个节点含有的子树的个数称为该节点的度。 双亲节点或父节点：若一个节点含有子节点，那么这个节点就是该子节点的父节点 孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点 节点的层次：从根节点开始定义，根为第一次，根的子节点为第二层，以此类推 树的高度或深度：树中节点的最大层次 二叉树的概念]]></content>
      <tags>
        <tag>C-数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux进程概念]]></title>
    <url>%2F2019%2F03%2F31%2FLinux%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[进程是什么？在操作系统中，我们经常能听到这样的话。我们要终止一个进程或者杀死一个进程，父进程创建了子进程这一类的话。往往我们听到都会觉得很高大上，这跟编程语言完全不同的感觉，操作了整个计算机。 进程的概念冯诺依曼体系结构在进程之前首先要提一下我们的“祖师爷”——冯诺依曼体系结构。 这个是一个计算机入门第一节课必然会提到的知识。 冯诺依曼体系结构提出了计算机采用二进制；计算机应该按照程序顺序执行。 它由输入设备，输出设备，存储器，控制器，运算器组成 注意！注意！注意！ 1、这里的存储器指的是内存。 2、不考虑缓存情况，这里的cpu（控制器+运算器）只能对内存进行读写，不能访问外设（输入或输出设备） 3、外设要输入或输出数据，也只能写入内存或者从内存中读取 操作系统（0S）任何计算机系统都包含一个基本的程序集合，称为操作系统(OS) 操作系统的存在就是让计算机更加的好用，能更方便的、统筹合理的管理计算机的软硬件资源。 那么是怎么管理的？ 我们可以先举一个例子，学校的管理，首先我们被辅导员统一管理，辅导员又由院内领导管理，院内领导又由校长管理。 学生-&gt;辅导员-&gt;院内领导-&gt;校长 这么一个层次结构。但在这之前管理需要制定一个制度来管理，每一个层次的人都遵守这个制度。这样才能按部就班的进行工作的分配。 那么操作系统也一样。总的来说就是：先描述，再组织 描述用struct结构体，比如进程有task_struct这样一个结构体来描述 组织可以用链表或者其他高效的数据结构 系统调用和库函数概念在开发角度，操作系统对外会表现一个整体，但是会暴露自己的部分接口，供上层开发使用，这部分由操作系统提供的接口，叫做系统调用。 系统调用在使用上，功能比较基础，对用户的要求也相对比较高，所以，有心的开发者可以对部分系统调用进行适度封装，从而形成了库，有了库，就很有利于更上层用户或者开发者进行二次开发 进程概念从用户角度：进程就是一个正在运行中的程序。 操作系统角度：操作系统运行一个程序，需要描述这个程序的运行过程，这个描述通过一个结构体task_struct{}来描述，统称为PCB，因此对操作系统来说进程就是PCB(process control block)程序控制块 进程的描述信息有：标识符PID，进程状态，优先级，程序计数器，上下文数据，内存指针，IO状态信息，记账信息。都需要操作系统进行调度。 那么在Linux操作系统下，怎么查看进程呢 查看进程输入ls /porc指令即可 前面蓝色数字代表的进程的ID。如果你想查看PID为1的进程信息，你需要查看/porc/1这个文件夹 我们也可以使用ps -ef -aux指令来直接显示进程状态 还有getpid()和getppid()这两个函数用来查看当前程序的进程和父进程PID。 12345int main()&#123; printf("getpid:%d",getpid()); printf("getppid:%d",getppid()); return 0;&#125; 进程创建Linux中非常重要的函数——fork()，它从已存在的进程中创建一个新进程。新进程为子进程，而原进程为父进程。 12345#include &lt;unistd.h&gt;pid_t fork(void);返回值： 父进程：返回值大于0，子进程的pid 子进程：返回值等于0 写这么个程序来初始fork函数 12345678910111213141516171819#include &lt;stdio.h&gt;#include &lt;unistd.h&gt; int main()&#123; printf("parent pid:%d\n",getpid()); int a = 100; pid_t pid = fork(); if(pid &lt; 0)&#123; return -1; &#125;else if(pid == 0)&#123; a = 20; printf("child !! pid:%d----a:%d--%p\n",getpid(),a ,&amp;a); &#125;else&#123; sleep(1); printf("parent !! pid:%d----a:%d--%p\n",getpid(), a, &amp;a); &#125; printf("nihaoa %d\n",a); return 0; &#125; 关于fork函数需要理解，每当调用一次fork函数时，会返回两个两次。一次是在调用进程中（父进程）返回一次，返回值是新派生的进程的进程ID。一次是在子进程中返回，返回值是0，代表当前进程为子进程。如果返回-1，那么则代表在创建子进程的过程中出现了错误。 将上面代码执行之后 先返回了子进程的pid，之后再返回了父进程的pid。 fork()相当于创建了一个新的子进程，但是拷贝的是fork()函数之后的所有数据，之前的并不会拷贝。在代码之上就可以看到parentpid只打印了一次 总的来说：复制pcb，代码共享，但是子进程并非从头开始，而是从fork()函数之后开始，数据独有 借用一下网上大佬对fork()的理解 12(1)一个进程进行自身的复制，这样每个副本可以独立的完成具体的操作，在多核处理器中可以并行处理数据。这也是网络服务器的其中一个典型用途，多进程处理多连接请求。 (2)一个进程想执行另一个程序。比如一个软件包含了两个程序，主程序想调起另一个程序的话，它就可以先调用fork来创建一个自身的拷贝，然后通过exec函数来替换成将要运行的新程序。 那么创建子进程的意义是什么————压力分摊/干其他工作 进程状态进程状态一般有：就绪态，阻塞态，运行态 在Linux下：R运行状态，S睡眠状态，D磁盘休眠状态，T停止状态，X死亡状态 这些当我们使用指令ps -aux就可以看到 僵尸进程在进程状态中有两个比较特殊的存在。僵尸和孤儿 僵尸进程是进程退出后，但是资源没有释放，处于僵死状态的进程。 产生原因：子进程先于父进程退出，操作系统检测到进程的退出，通知父进程，但是父进程这时候正在执行其他操作，没有关注这个通知，这时候操作系统为了保护子进程，不会释放子进程资源，因为子进程的PCB中包含有退出原因。这时候因为既没有运行也没有退出，因此处于僵死状态，成为僵尸进程。 12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;unistd.h&gt; #include &lt;errno.h&gt; int main() &#123; pid_t pid; //循环创建子进程 while(1) &#123; pid = fork(); if (pid &lt; 0) &#123; perror("fork error:"); exit(1); &#125; else if (pid == 0) &#123; printf("I am a child process.\nI am exiting.\n"); //子进程退出，成为僵尸进程 exit(0); &#125; else &#123; //父进程休眠20s继续创建子进程 sleep(20); continue; &#125; &#125; return 0; &#125; 执行这上面这个程序，子进程中途退出了。 z+这个标志就是僵尸进程的标志。 那么怎么避免僵尸进程的产生？ 我们一般处理就是关闭父进程，这样僵尸子进程也随之消失了。 所以我们最好设置进程等待，等待子进程完成了工作，并且通知了父进程之后，在退出。 孤儿进程孤儿进程与僵尸进程在理解上可以认为相反。 父进程先于子进程退出，父进程退出后，子进程成为后台进程，并且父进程为1号进程。 守护进程：特殊（脱离了与终端的关联+会话的关联）的孤儿进程 进程优先级优先级：决定资源的优先分配权的等级划分 那么进程为什么具有优先级呢？ 为了让操作系统的运行更加的合理——交互式进程（一旦有操作优先处理）和批处理进程（一直处理程序，但对CPU要求不高） 设置优先级，可以使用指令ps -elf先查看进程 可以看到 PRI 和 NI这两个数值 PRI：优先级 NI：nice值 PRI是无法直接调整的，但是可以通过调整nice值来调整优先级的大小 PRI = PRI + NI，但是NI也是有范围的——(-20~19) 指令操作为renice -n size -p pid 运行时操作为nice -n size ./main(可执行文件) 这里稍微提一下，程序在运行时具有并行和并发两种执行。 并行：CPU资源足够，多个程序同时运行 并发：CPU资源不够，多个程序切换调度运行（可以看看我之前的一篇关于操作系统的博客，有关调度方法的介绍） Linux下指令top指令可以查看进程的优先级 进入top后按“r”–&gt;输入进程PID–&gt;输入nice值 环境变量环境变量是保存系统运行环境参数的变量 环境变量在安装java的过程中，可能接触过，需要进入系统环境变量，然后设置PATH添加java的路径 在Linux下可以通过命令指令自己设置 12345echo 通过变量名称，查看指定环境变量env 查看所有环境变量set 查看环境变量以及临时变量export 声明一个环境unset 删除一个临时变量 常见的环境变量：HOME SHELL USER PATH 环境变量的全局特性：在子进程中获取继承于父进程的环境变量信息 三种获取环境变量的参数 12345main(int argc, char *argc[],char *env[]) 参数获取extern char **environ; 全局变量获取char *getenv(const char *env_name) 接口获取 写一个获取变量的demo 1234567891011121314151617181920 #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; W&gt;int main(int argc, char *argv[], char *env[])&#123; //main函数的参数值是从操作系统命令行上获得的。当我们要运行一个可执行文件时，在DOS提示符下键入文件名，再输入实际参数&gt; 即可把这些实参传送到main的形参中去。 //C:\&gt;可执行文件名 参数 参数…… //argv参数是字符串指针数组，其各元素值为命令行中各字符串(参数均按字符串处理)的首地址 //env：字符指针的数组，每一个元素是指向一个环境变量的字符指针 int i; for(i = 0;i &lt; argc; i++)&#123; printf("argv[%d]=[%s]\n",i , argv[i]); &#125; extern char **environ; for(i = 0;environ[i] != NULL;i++)&#123; printf("env[%d]=[%s]\n",i, environ[i]); &#125; char *ptr = getenv("MYENV"); printf("MYENV:[%s]\n",ptr); return 0; &#125; 如果输入export MYENV=&quot;10000&quot;，在运行程序 MYENV将变成MYENV:[10000] 程序地址空间 内核空间 运行参数/环境变量 栈 栈区（从上往下取）中间有共享区 堆区（从下往上取）中间有共享区 堆 初始化全局数据 未初始化全局数据 代码段 地址是什么？地址是内存的编号，指向内存的一块区域 虚拟地址空间： 12345678mm_struct&#123;long int sizecode_startcode_enddata_startadata_end&#125; 上图之中，中间的物理内存地址，两边的为虚拟内存地址。 右边是父进程将虚拟地址通过页表查找到物理内存的地址，这时父进程在运行一个程序。此时父进程又创建了一个子进程(图最右)。子进程也通过页表找到物理内存的地址，这时子进程运行的程序在物理内存的另一个新空间运行。 这是虚拟内存地址使用的过程。它的作用就是保持进程的独立性，通过页表映射物理地址，充分的利用物理地址，增加内存访问控制。 这就是进程有关的知识。总结一下 进程从用户角度和操作系统角度去理解。前者就是一个运行的程序，后者表示运行一个程序，需要描述一个程序的运行过程，通过一个结构体task_struct{}来描述，叫做PCB。对操作系统来说，进程就是PCB 进程的创建需要一个我们必须要掌握的函数——fork()函数，创建一个子进程。并且fork()函数会有两个返回值，在返回的过程中父进程之前的数据不进行拷贝，之后与父进程的运行一致。创建子进程是为了分摊压力/干其他工作 进程的状态有运行态，睡眠状态，磁盘休眠状态，停止状态，死亡状态。每一种状态是容易理解的。但是还有两个特殊的进程 僵尸进程和孤儿进程，前者是进程退出后资源没有释放，操作系统通知父进程，但是父进程此时正在处理其他事情，没有关注子进程的退出通知，系统为了保护资源，没有释放掉，并且在子进程的PCB中也保留了退出原因，此时既没有运行也没有完全退出，处于了僵死状态。但是后者是父进程先于子进程先退出，子进程成为了后台程序，由一号进程接管。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux的文件权限]]></title>
    <url>%2F2019%2F03%2F30%2FLinux%E7%9A%84%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%2F</url>
    <content type="text"><![CDATA[Linux的权限Linux下有三种用户，普通用户和超级用户和系统用户 超级用户就是我们所说的root，普通用户是我们自己所创建的一个用户，能在有限的权限内进行操作。 系统用户是Linux系统正常工作所必需的内建的用户，主要是为了满足相应的系统进程对文件属主的要求而建立的，系统用户不能用来登录，如bin、daemon、adm、lp等用户。 Linux权限的管理文件访问者的管理文件访问者的管理分为：文件和文件目录的所有者u—user、文件和文件目录的所有者的组的用户g—group、其他用户o—others. 文件类型和访问权限 上图是我在我的云服务器上输入ll指令出来的当前文件夹下的文件显示 d代表的文件类型，在这之外还有许多文件类型 1234567d：文件夹-：普通文件l：软链接（类似windows的快捷方式）b：块设备文件（例如硬盘、光驱等）p：管道文件c：字符设备文件s：套接口文件（socket） rwxr-xr-x这代表的是权限，每三个代表的是文件访问者的管理。前三位是user的权限，中间三位是group的权限，后三位是其他用户的权限。 rwx又分别为可读文件，可写文件，可执行文件。 读（r/4）：Read对文件而言，具有读取文件内容的权限；对目录来说，具有浏览该目录信息的权限 写（w/2）：Write对文件而言，具有修改文件内容的权限；对目录来说具有删除移动目录内文件的权限 执行（x/1）：execute对文件而言，具有执行文件的权限；对目录来说，具有进入目录的权限 “—”：表示不具有该项权限 Linux表示 说明 Linux表示 说明 r– 只读 -w- 仅可写 –x 仅可执行 rw- 可读可写 -wx 可写和可执行 r-x 可读可执行 rwx 可读可写可执行 — 无权限 8进制数值表示法 权限符号 八进制 二进制 r 4 100 w 2 010 x 1 001 rw 6 110 rx 5 101 wx 3 011 rwx 7 111 — 0 000 文件访问权限的相关方法123chomd 设置文件的访问权限格式：chmod [参数] 权限 文件名 这是最常用的文件访问，它的使用有两种方式 1、chmod u+w filename，chmod o-x filename 通过用户表示符 +/-= 权限字符 这里用户表示符还有a,代表了所有文件访问管理者 2、三位8进制数字表示，chmod 741 filename 123chown修改文件的拥有者格式：chown [参数] 用户名 文件名 chown user1 f1 chown -R user1 filegroup1 1234chgrp修改文件或目录的所属组格式：chgrp [参数] 用户组名 文件名常用选项：-R 递归修改文件或目录的所属组 umask功能：查看或修改文件掩码 比如新建了一个文件夹默认权限为666，新建目录为777。但实际上你所创建的文件和目录，看到的往往不是上面这个值。 原因就是创建文件或目录的时候还要受到umask的影响。假如默认权限mask，则实际创建出来的文件权限是：mask &amp; ~umask 其实就是——默认权限mask-文件掩码umask 沾滞位当一堆用户在做一个项目时，大家都在同一个服务器上。这时每个人的文件都被保存在一个文件夹下。那么当文件具有可读可写可执行的某一权限时，每个人都可以对别人的文件进行操作，那这样张三岂不是可以把李四的文章随便删除？ 为了解决这一方法，引出了沾滞位这一概念。 当一个目录被设置为“沾滞位”（chmod + t），则该目录下的文件只能由 123一、超级管理员删除 二、该目录的所有者删除 三、该文件的所有者删除 权限的总结目录的可执行权限是表示你可否在目录下执行命令。 如果目录没有-x权限，则无法对目录执行任何命令，甚至无法cd进入目录, 即使目录仍然有-r 读权限(这个地方很容易犯错，认为有读权限就可以进入目录读取目录下的文件) 而如果目录具有-x权限，但没有-r权限，则用户可以执行命令，可以cd进入目录。但由于没有目录的读权限，所以在目录下，即使可以执行ls命令，但仍然没有权限独出目录下的文档。]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之链表练习题]]></title>
    <url>%2F2019%2F03%2F27%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8%E7%BB%83%E4%B9%A0%E9%A2%98%2F</url>
    <content type="text"><![CDATA[这些练习都是力扣中的真题，挺容易对链表有个更进一步了解的 1、删除链表中等于给定值 val 的所有节点 1234567891011121314151617181920212223void SListRemoveAll(SList *s, SLDataType v)&#123; if (s-&gt;first == NULL)&#123; return; &#125; if(s-&gt;first-&gt;value == v)&#123; Node *next = s-&gt;first; s-&gt;first = s-&gt;first-&gt;next; free(s-&gt;first); &#125; else&#123; Node *c = s-&gt;first; while(c-&gt;next != NULL)&#123; if(c-&gt;next-&gt;value == v)&#123; Node *next = c-&gt;next; c-&gt;next = c-&gt;next-&gt;next; free(c-&gt;next); &#125; else&#123; c = c-&gt;next; &#125; &#125; &#125;&#125; 2、 反转一个单链表。 1234567891011121314void SListReverse(SList *head)&#123; Node *result = NULL; Node *c = head; while(c != NULL)&#123; Node *next = c-&gt;next; c-&gt;next = result; result = c; c = next; &#125; return result;&#125; 3、给定一个带有头结点 head 的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个 中间结点。 12345678910111213141516171819Node* middleNode(SList *head)&#123; if(head == NULL)&#123; return NULL; &#125;//利用快慢指针的思想 Node *fast = head; Node *slow = head; while(1)&#123; fast = fast-&gt;next; if(fast == NULL)&#123; break; &#125; slow = slow-&gt;next; fast = fast-&gt;next; if(fast == NULL)&#123; break; &#125; &#125; return slow;&#125; 4、输入一个链表，输出该链表中倒数第k个结点。 1234567891011121314151617Node *FindKthToTail(Node *head, unsigned int k)&#123; Node *front = head; Node *back = head; //让前面的先走k步 int i; for(i = 0;i &lt; k &amp;&amp; front != NULL;i++)&#123; front = front-&gt;next; &#125; if(i &lt; k)&#123; return NULL; &#125; while(front != NULL)&#123; front = front-&gt;next; back = back-&gt;next; &#125; return back;&#125; 5、 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成 的。新链表也是有序的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445Node* mergeTwoList(SList *c1, SList *c2)&#123; struct SList *c1 = l1; struct SList *c2 = l2; struct SList *result = NULL; struct SList *last = NULL; if(l1 == NULL)&#123; return l2; &#125; if(l2 == NULL)&#123; return l1; &#125; while(l1 != NULL &amp;&amp; l2 != NULL)&#123; if(l1-&gt;value &lt;= l2-&gt;value)&#123; if(result == NULL)&#123; result = last = l1; &#125; else&#123; last-&gt;next = last; last = l1; &#125; l1 = l1-&gt;next; &#125; else&#123; if(result == NULL)&#123; result = last = l2; &#125; else&#123; last-&gt;next = last; last = l2; &#125; l2 = l2-&gt;next; &#125; &#125; //两个有序链表不一定等长，多出来的直接接到新链表之后就可以 if(l1 != NULL)&#123; last-&gt;next = l1; &#125; if(l2 != NULL)&#123; last-&gt;next = l2; &#125; return result;&#125; 6、 编写代码，以给定值x为基准将链表分割成两部分，所有小于x的结点排在大于或等于x的结点之前 1234567891011121314151617181920212223242526272829303132333435363738394041424344Node *partition(SList* head, int x)&#123; SList *small; SList *big; SList *lastsmall; SList *lastbig; SList *node = head; while(node != NULL)&#123; if(node-&gt;value &lt; x)&#123; if(small == NULL)&#123; small = smalllast =node; &#125; else&#123; lastsmall-&gt;next = node; lastsmall = node; // lastsmall表示的是最后一个节点，它等于node说明他就是最后一个结点，因为node每次将判断好的结点放在最后一个位置 &#125; &#125; else&#123; if(big == NULL)&#123; big = lastbig =node; &#125; else&#123; lastbig-&gt;next = node; lastbig = node; &#125; &#125; node = node-&gt;next; &#125; if(lastsmall != NULL)&#123; //如果比x小的结点存在，则该链表最后接上big链表 lastsmall-&gt;next = big; &#125; if(lastbig != NULL)&#123; //如果比x大的结点存在，则该链表最后指向NULL lastbig-&gt;next = NULL; &#125; if(lastsmall != NULL)&#123; return small; &#125; else&#123; return big; &#125;&#125; 7、在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。 123456789101112131415161718192021222324252627282930313233343536373839Node *deleteDuplication(SList* head)&#123; if(head == NULL)&#123; return NULL; &#125; SList *fake = (Node*)malloc(sizeof(Node));//先定义一个假结点 fake-&gt;next = head; SList *prev = fake; SList *p1 = head; SList *p2 = head-&gt;next; while(p2 != NULL)&#123;//不要忘了判断，否则p2为空后继续走，将会发生内存泄漏 //前后指针，一个在前走，一个在后走，在前走的同时判断有没有重复的 if(p1-&gt;val != p2-&gt;val)&#123; prev = p1; p1 = p2; p2 = p2-&gt;next; &#125; else&#123; while(p2 != NULL &amp;&amp; p1-&gt;val == p2-&gt;val)&#123; p2 = p2-&gt;next; &#125; SList *cur = p1; while(cur != p2)&#123; SList *next = cur-&gt;next; free(cur); cur = next; &#125; prev-&gt;next = p2;//很关键的一步，删完之后继续连接未删除的 p1 = p2; if(p2 != NULL)&#123; p2 = p2-&gt;next; &#125; &#125; &#125; head = fake-&gt;next; //prev在链表中一直相当于记录，就是fake free(fake); return head;&#125; 8、对于一个链表，请设计一个时间复杂度为O(n),额外空间复杂度为O(1)的算法，判断其是否为回文结构。 11-&gt;2-&gt;2-&gt;1 思路还是很好理解的 1、找到中间结点 2、从中间结点开始往后逆转整个链表 3、将头结点和逆转数组作比较 1234567891011121314151617181920ListNode *middleNode(ListNode *head)&#123; if(head == NULL)&#123; return NULL; &#125; ListNode *slow = head; ListNode *fast = head; while(1)&#123; fast = fast-&gt;next; if(fast == NULL)&#123; break; &#125; slow = slow-&gt;next; fast = fast-&gt;next; if(fast == NULL)&#123; break; &#125; &#125; return slow;&#125; 1234567891011121314151617ListNode *reverlist(ListNode *head)&#123; if(head == NULL)&#123; return NULL; &#125; ListNode *result = NULL; ListNode *cur = head; while(cur != NULL)&#123; ListNode *next = cur-&gt;next; cur-&gt;next = result; result = cur; cur = next; &#125; return result;&#125; 1234567891011121314bool chkPalindrome(ListNode* A)&#123; ListNode *middle = middleNode(A); ListNode *r = reverselist(middle-&gt;next); ListNode *n1 = A, *n2 = r; while(n1 != NULL &amp;&amp; n2 != NULL)&#123; if(n1-&gt;val != n2-&gt;val)&#123; return false; &#125; n1 = n1-&gt;next; n2 = n2-&gt;next; &#125; return true;&#125;]]></content>
      <tags>
        <tag>C-数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django建立一个音乐网站(五)]]></title>
    <url>%2F2019%2F03%2F25%2FDjango%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AA%E9%9F%B3%E4%B9%90%E7%BD%91%E7%AB%99-%E4%BA%94%2F</url>
    <content type="text"><![CDATA[接下来就是后台管理了。 在这本书这个项目之前，我最初接触python看的是《python基础教程—从实践到入门》，这本后面讲解了django，而且这里面讲解是从admin开始。如果有兴趣了解的可以看看书或者从网上寻找资料，但是django版本不是很高，看起来可能让人容易懵 后台管理是管理员对用户数据进行管理的存在。在这之中也可以对用户进行权限的赋予（知道为啥VIP牛X了吧）。 登陆后台管理操作 1234python manage.py runserver#启动之后，在浏览器输入栏输入127.0.0.1:8000/admin即可进入 在整个网站中，index和user算两个app所以分别定义模型，因此在Admin后台系统是区分两个模块的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#index的__init__.py#对功能模块进行命名from django.apps import AppConfigimport os#修改App在Admin后台显示的名称#default_app_config的值来自apps.py的类名default_app_config = 'index.IndexConfig'#获取当前App的命名def get_cuurrent_app_name(_file): return os.path.split(os.path.dirname(_file))[-1]#重写类IndexConfigclass IndexConfig(AppConfig): name = get_cuurrent_app_name(__file__) verbose_name = '网站首页' ------------------------------------------------------------------------------------------------ #index的admin.pyfrom django.contrib import adminfrom .models import *#修改title和headeradmin.site.site_title = '我的音乐后台管理系统'admin.site.site_header = '我的音乐'#模型Label@admin.register(Label)class LabelAdmin(admin.ModelAdmin): #设置模型字段，用于Admin后台数据的表头设置 list_display = ['label_id', 'label_name'] #设置可搜索的字段并在Admin后台数据生成搜索框,如有外键应使用双下画线链接两个模型的字段 search_fields = ['label_name'] #设置排序方式 ordering = ['label_id']#模型Song@admin.register(Song)class SongAdmin(admin.ModelAdmin): list_display = ['song_id','song_name','song_singer','song_album','song_languages','song_release'] search_fields = ['song_name','song_singer','song_album','song_languages'] #设置过滤器，在后台数据的右侧生成导航栏,如有外键应使用双下画线连接两个模型的字段 list_filter = ['song_singer','song_album','song_languages'] ordering = ['song_id']#模型Dynamic@admin.register(Dynamic)class DynamicAdmin(admin.ModelAdmin): list_display = ['dynamic_id','song','dynamic_plays','dynamic_search','dynamic_down'] search_fields = ['song'] list_filter = ['dynamic_plays','dynamic_search','dynamic_down'] ordering = ['dynamic_id']#模型Comment@admin.register(Comment)class CommentAdmin(admin.ModelAdmin): list_display = ['comment_id','comment_text','comment_user','song','comment_date'] search_fields = ['comment_user','song','comment_date'] list_filter = ['song','comment_date'] ordering = ['comment_id'] 接下来就是user这个app的一些设置，与上面大同小异 123456789101112131415161718192021222324252627282930313233343536#user的__init__.pyfrom django.apps import AppConfigimport osdefault_app_config = 'user.IndexConfig'#获取当前App的命名def get_current_app_name(_file): return os.path.split(os.path.dirname(_file))[-1]#重写类IndexConfigclass IndexConfig(AppConfig): name = get_current_app_name(__file__) verbose_name = '用户管理'------------------------------------------------------------------------------------------------#user的admin.pyfrom django.contrib import adminfrom .models import MyUserfrom django.contrib.auth.admin import UserAdminfrom django.utils.translation import gettext_lazy as _@admin.register(MyUser)class MyUserAdmin(UserAdmin): list_display = ['username','email','mobile','qq','weChat'] #在用户信息界面添加’mobile‘，'qq','weChat'的信息输入框 #将源码的UserAdmin.filesets转换成列表格式 fieldsets = list(UserAdmin.fieldsets) #重写UserAdmin的fieldsets，添加'mobile','qq','weChat'的信息录入 fieldsets[1] = (_('Personal info'), &#123;'fields':('first_name','last_name','email','mobile','qq','weChat')&#125;) #设置fieldsets 控制管理“添加”和 “更改” 页面的布局. #fieldsets 是一个以二元元组为元素的列表, 每一个二元元组代表一个在管理表单二元元组的格式是 (name, field_options), 其中 name 是一个字符串相当于 fieldset的标题， field_options 是一个关于 fieldset的字典信息,一个字段列表包含在里面。 当网页遇到错误时，往往我们会返回404，这时候我们在网页中也可以设置一下 123456789#music的urls.py#设置404、500错误状态码from index import viewshandler404 = views.page_not_foundhandler500 = views.page_not_found#index的views.pydef page_not_found(request): return render(request, 'error404.html', status = 404) 到这块基本网站的建立就完成了，这时候可以在后台进行对用户设置权限，可以更换音乐和照片素材，也可以进行新的数据库数据添加，但是要考虑到数据改变是否影响到html的设置。这个由个人随机操作。 最后重头戏就是项目上线部署了，一般采用django+nginx+uWSGI这样。我利用虚拟机进行了多次部署….期间废掉了好几个VM…目前还没成功，等我成功之后将继续写博客分享经验。 根据书上的内容进行了操作对django框架有了一个简单的认识，我还是打算在此立个flag，我也会继续学习，建立一个属于自己的电影网站！ 加油吧！！！]]></content>
      <tags>
        <tag>python, django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django建立一个音乐网站(四)]]></title>
    <url>%2F2019%2F03%2F16%2FDjango%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AA%E9%9F%B3%E4%B9%90%E7%BD%91%E7%AB%99-%E5%9B%9B%2F</url>
    <content type="text"><![CDATA[之前将网站一些该有的元素都准备完成了。接下来就是关于用户注册和后台admin设置。 user模块关于一个网站的浏览量是靠用户的数量来决定的。所以每一个用户在网站的操作，要做出限制。这个是可以实现的。接着还有一些个人的账号和数据信息可以完善，让管理员能更好的管理。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126#user的urls模块from django.urls import pathfrom . import viewsurlpatterns = [ #用户的注册和登陆 path('login.html', views.loginView, name='login'), #用户登录中心 path('home/&lt;int:page&gt;.html', views.homeView, name='home'), #退出用户登陆 path('logout.html', views.logoutView, name='logout'),]#两个html文件已经放到之前的文件下载中------------------------------------------------------------------------------------------------#user的models模块from django.db import modelsfrom django.contrib.auth.models import AbstractUserclass MyUser(AbstractUser): qq = models.CharField('QQ号码', max_length=20) weChat = models.CharField('微信账号', max_length=20) mobile = models.CharField('手机账号', max_length=11, unique=True) #设置返回值 def __str__(self): return self.username#这里与之前数据库的建立连接是一个意思，此时需要将之前库内所有表删除(建议先导出数据保存)，在将这个执行#python manage.py makemigrations和python manage.py migrate 两个指令操作------------------------------------------------------------------------------------------------#user的forms模块from django.contrib.auth.forms import UserCreationFormfrom .models import MyUserfrom django import forms#定义MyUser的数据表单，用于用户注册class MyUserCreationForm(UserCreationForm): #重写初始化函数，设置自定义字段password1和password2的样式和属性 def __init__(self, *args, **kwargs): super(MyUserCreationForm, self).__init__(*args, **kwargs) self.fields['password1'].widget = forms.PasswordInput(attrs=&#123;'class':'txt tabInput', 'placeholder':'密码，4-16位数字/字母。特殊符号（空格除外）'&#125;) self.fields['password2'].widget = forms.PasswordInput(attrs=&#123;'class':'txt tabInput', 'placeholder':'重复密码'&#125;) class Meta(UserCreationForm.Meta): model = MyUser #在注册界面添加模型字段：手机号码和密码 fields = UserCreationForm.Meta.fields + ('mobile',) #设置模型字段的样式和属性(widgets) widgets = &#123; 'mobile':forms.widgets.TextInput(attrs=&#123;'class':'txt tabInput','placeholder':'手机号'&#125;), 'username':forms.widgets.TextInput(attrs=&#123;'class':'txt tabInput','placeholder':'用户名'&#125;), &#125; #实现用户的注册和登陆之前，除了自定义用户模型MyUser之外，还需要定义用户注册的表单类。 #这里通过重写Django中的内置表单类UserCreationForm ------------------------------------------------------------------------------------------------#user的views模块from django.shortcuts import render, redirectfrom django.db.models import Qfrom index.models import Dynamicfrom user.models import *from django.contrib.auth import login, logoutfrom django.contrib.auth.hashers import check_passwordfrom .form import MyUserCreationFormfrom django.contrib.auth.decorators import login_requiredfrom django.core.paginator import Paginator, EmptyPage, PageNotAnInteger#用户注册与登录def loginView(request): #表单对象user user = MyUserCreationForm() #表单提交 if request.method == 'POST': #判断表单提交是 用户登陆 还是 用户注册 #用户登陆 if request.POST.get('loginUser', ''):#获取搜索内容如果为loginUser，没有返回空 loginUser = request.POST.get('loginUser', '')#这里是已经获取到用户输入的 password = request.POST.get('password', '') if MyUser.objects.filter(Q(mobile = loginUser) | Q(username=loginUser)): user = MyUser.objects.filter(Q(mobile=loginUser) | Q(username=loginUser)).first()#这里是sql语句在django中的不同表示方法 if check_password(password, user.password): login(request, user) return redirect('/user/home/1.html')#页面跳转 else: tips = '密码错误' else: tips = '用户不存在' #用户注册 else: user = MyUserCreationForm(request.POST) if user.is_valid(): user.save() tips = '注册成功' else: if user.errors.get('username', ''): tips = user.errors.get('username', '注册失败') else: tips = user.errors.get('mobile', '注册失败') return render(request, 'login.html', locals())#用户中心#设置用户登录限制@login_required(login_url='/user/login.html')def homeView(request, page): #热搜歌曲 search_song = Dynamic.objects.select_related('song').order_by('-dynamic_search').all()[:4] #分页功能 song_info = request.session.get('play_list', []) paginator = Paginator(song_info, 3) try:#错误解决方法 contacts = paginator.page(page) except PageNotAnInteger: contacts = paginator.page(1) except EmptyPage: contacts = paginator.page(paginator.num_pages) return render(request, 'home.html', locals())def logoutView(request): logout(request) return redirect('/') 在上面的代码中涉及到了表单类这么一个概念。 在这里要说明以下，表单是搜集用户数据信息的各种表单元素的集合，作用是实现网页上的数据交互，用户在网站输入数据信息，然后提交到网站服务器端进行处理 表单我们学过html的知道，定义一个类似下拉菜单的样式，在这个项目中是先利用了内置表单类，然后重写了两个新功能。 1、添加用户注册的字段，在Meta类对fields属性设置字段即可，添加的字段必须是模型字段并且以元组或列表的形式添加 2、设置字段的CSS格式，设置表单字段mobile、username、password1、password2的attrs属性。其中mobile和username是模型MyUser的字段，所以在Meta类中重写widgets属性。widgets是内置表单类的一个参数，两个密码password是额外定义的表单字段，所以重写初始函数__init__可以实现字段样式设置 这里对表单说的有点多，因为在网站中，用户注册是一个非常重要的环节。而且表单这里还是涉及到了前端的知识…原谅本小白不才….实在能力有限。 至此除了后台系统之外，基本全部完成。上几个截图看看吧 接下来就是后台系统了….]]></content>
      <tags>
        <tag>python, django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django建立一个音乐网站(三)]]></title>
    <url>%2F2019%2F03%2F13%2FDjango%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AA%E9%9F%B3%E4%B9%90%E7%BD%91%E7%AB%99-%E4%B8%89%2F</url>
    <content type="text"><![CDATA[Django+mysql连接成功之后，就是我们对网页设计了。 但我并不擅长html的一些前端，不做多的描述….因此将这些html文件和静态文件，打包提供大家参考。 点击下载 这个是数据文件，静态文件，html文件，可以将其导入进行测试 主要了解对app中各模块的写法 index模块之前将index的models.py为了建立数据库完成了，现在继续写views.py和urls.py 1234567891011121314151617181920212223242526272829303132333435#index的urls.pyfrom django.urls import pathfrom . import viewsurlpatterns = [ path('', views.indexView, name='index'),]#index的views.pyfrom django.shortcuts import renderfrom .models import *def indexView(request): #热搜歌曲 search_song = Dynamic.objects.select_related('song').order_by('-dynamic_search').all()[:8] #select_related的用法可以用于表之间建立联系的查询。 #select_related的参数为'song'，我们可以理解为在这个表中，排序为逆序，显示前八个数据 #等同于SQL：SELECT * FROM index_dynamic INNER JOIN index_song ON (song_id = id) #查询两个模型的全部数据 #音乐分类 label_list = Label.objects.all() #热门歌曲 play_hot_song = Dynamic.objects.select_related('song').order_by('-dynamic_search').all()[:10] #新歌推荐 daily_recommendation = Song.objects.order_by('-song_release').all()[:3] #热门搜索、热门下载 search_ranking = search_song[:6] down_ranking = Dynamic.objects.select_related('song').order_by('-dynamic_down').all()[:6] all_ranking = [search_ranking,down_ranking] #render()结合一个给定的模板和一个给定的上下文字典, 并返回一个渲染后的HttpResponse对象。 #locals()用法：locals()可以直接将函数中所有的变量全部传给模板 return render(request, 'index.html', locals()) 在上面的代码中，我将大部分都用注释标记了出来。 Django使用请求和响应对象来通过系统传递状态。 视图所对应的是在html显示中可以将数据库中的数据进行查询，然后将选择出来的数据放到站点进行浏览。 比如我们在index.html节选文件中可以看到,在view中定义的label_list列表我们在其中使用利用for循环进行调用，最后将数据库建立连接的数据显示在主页上。 这里也涉及到前端中JavaScript，本小白实在是不知语言原理，只能看懂一二…各位见谅！！！ 12345678910111213141516171819202122&lt;div class="nav-box"&gt; &lt;div class="nav-box-inner"&gt; &lt;ul class="nav clearfix"&gt; &lt;li&gt;&lt;a href="/"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="&#123;% url 'ranking' %&#125;" target="_blank"&gt;歌曲排行&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="&#123;% url 'home' 1 %&#125;" target="_blank"&gt;用户中心&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;div class="category-nav"&gt; &lt;div class="category-nav-header"&gt; &lt;strong&gt;&lt;a href="javascript:;" title=""&gt;音乐分类&lt;/a&gt;&lt;/strong&gt; &lt;/div&gt; &lt;div class="category-nav-body"&gt; &lt;div id="J_CategoryItems" class="category-items"&gt; &#123;% for label in label_list %&#125; &lt;div class="item" data-index="1"&gt;&lt;h3&gt; &lt;a href="javascript:;"&gt;&#123;&#123; label.label_name &#125;&#125;&lt;/a&gt;&lt;/h3&gt; &lt;/div&gt; &#123;% endfor %&#125; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 接下来的各个模块的代码，我将根据index.html出现的顺序依次往下罗列。 search模块首先是search的代码，搜索是对网站内的数据进行检索 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#search的urls.psfrom django.urls import pathfrom . import viewsurlpatterns = [ path('&lt;int:page&gt;.html', views.searchView, name='search'),]#views.pyfrom django.shortcuts import render, redirectfrom django.core.paginator import Paginator, EmptyPage, PageNotAnIntegerfrom django.db.models import Qfrom index.models import *def searchView(request, page): if request.method == 'GET': #搜索歌曲 search_song = Dynamic.objects.select_related('song').order_by('-dynamic_search').all()[:6] #获取搜索内容，如果kword为空就查询全部歌曲 kword = request.session.get('kword', '') if kword: #Q是SQL语句里的or语法 song_info = Song.objects.values('song_id', 'song_name','song_singer', 'song_time').filter(Q(song_name__icontains=kword) | Q(song_singer=kword)).order_by('-song_release').all() else: song_info = Song.objects.values('song_id', 'song_name', 'song_singer', 'song_time').order_by('-song_release').all()[:50] #分页功能,是django的一个库函数，叫做分页器，设置每一页显示几条数据 paginator = Paginator(song_info, 5) try: contacts = paginator.page(page) except PageNotAnInteger: contacts = paginator.page(1) except EmptyPage: contacts = paginator.page(paginator.num_pages) #添加歌曲搜索次数 song_exist = Song.objects.filter(song_name=kword) if song_exist: song_id = song_exist[0].song_id dynamic_info = Dynamic.objects.filter(song_id=int(song_id)).first() #判断歌曲动态信息是否存在,存在就在原来的基础上加1 if dynamic_info: dynamic_info.dynamic_search += 1 dynamic_info.save() #若动态信息不存在，则创建新的动态信息 else: dynamic = Dynamic(dynamic_plays=0, dynamic_search=1, dynamic_down=0, song_id=song_id) dynamic.save() return render(request, 'search.html', locals()) else: #处理POST请求，并重定向搜索页面 request.session['kword'] = request.POST.get('kword', '') return redirect('/search/1.html') 大概说明一下，method用于获取用户的请求方式。属性GET和POST用于获取用户的请求参数 GET请求一般做查询（有缓存），POST请求一般做添加/删除/修改（无缓存） session就是用来在服务器端保存用户的会话状态。 Paginator是一个django中自带的分页器，将搜索结果进行每页5条来显示。 根据搜索的内容kword查找完全匹配的歌名，匹配成功，才会判断歌曲的动态信息是否存在。 存在就在数据库的数据中+1，否则创建一条动态信息，并将搜索次数设为1. ranking模块歌曲信息列表，当我们在站点进行搜索时，显示出来的排名。这个排名根据设置的降序进行排序。下面上代码 12345678910111213141516171819202122232425262728#ranking的urls.pyfrom django.urls import pathfrom .import viewsurlpatterns = [ path('',views.rankingView,name='ranking'),]#ranking的views.pyfrom djagno.shortcuts import renderfrom index.models import *def rankingView(request): #热搜歌曲 search_song = Dynamic.objects.select_related('song').order_by('-dynamic_search').all()[:4] #歌曲分类列表 All_list = Song.objects.values('song_type').distinct() #关键词 DISTINCT 用于返回唯一不同的值。 #歌曲列表信息 song_type = request.GET.get('type', '') #寻找名为type的GET参数，而且如果参数没有提交，返回一个空的字符串。 if song_type: song_info = Dynamic.objects.select_related('song').filter(song__song_type=song_type).order_by('-dynamic_plays').all()[:10] else: song_info = Dynamic.objects.select_related('song').order_by('-dynamic_plays').all()[:10] return render(request, 'ranking.html', locals()) web开发一般是一个无聊的过程，尤其在视图编写功能方面。所以在Django中植入了通用视图这一概念，该功能封装了视图开发常用的代码和模式。根据用途划分三大类： TemplateView直接返回HTML模板，但无法将数据库的数据展示出来 ListView能将数据库的数据传递给HTML模板，通常获取某个表的所有数据 DetailView能将数据库的数据传递给HTML模板，通常获取数据表的单条数据 通用模板的代码 1234567891011121314151617181920212223242526272829303132333435#ranking.urlsfrom django.urls import pathfrom . import viewsurlpatterns = [ #通用视图 path('.list', views.RankingList.as_view(), name = 'rankingList'),]#ranking.viewsfrom django.views.generic import ListViewclass RankingList(ListView): #context_object_name 设置HTML模板的某一个变量名称 context_object_name = 'song_info' #设定模板文件 template_name = 'ranking.html' #查询变量song_info的数据 def get_queryset(self): #获取请求参数 song_type = self.request.GET.get('type', '') if song_type: song_info = Dynamic.objects.select_related('song').filter(song__song_type=song_type).order_by('-dynamic_plays').all()[:10] else: song_info = Dynamic.objects.select_related('song').order_by('-dynamic_plays').all()[:10] return song_info #添加其他变量 def get_context_data(self, **kwargs): context = super().get_context_data(**kwargs) #搜索歌曲 context['search_song'] = Dynamic.objects.select_related('song').order_by('-dynamic_search').all()[:4] #所有歌曲分类 context['All_list'] = Song.objects.values('song_type').distinct() return context 我个人觉得通用视图还是比较方便的。首先如果自己构思时，不一定能想出最好的代码块，可能有出错的可能。但是通用视图在模板上进行一定的修改，设定模板文件，将所要查询的数据SQL转换成django中的语法，在之后添加其他变量，设置HTML中的其他变量。 play模块音乐网站那么最重要的就是歌曲的视听效果了。前面提到了，除了HTML在相关的模块templates中，所有静态的文件资源都被保存在一个static文件夹中，那么肯定我们需要读取这个文件，读取了之后在网页播放 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#play的urls.pyfrom django.urls import pathfrom . import viewsurlpatterns = [ #歌曲播放页面 path('&lt;int:song_id&gt;.html', views.playView, name='play'), #歌曲下载 path('download/&lt;int:song_id&gt;.html', views.downloadView, name='download')]#views.pyfrom django.shortcuts import renderfrom index.models import *#歌曲播放页面def playView(request, song_id): #热搜歌曲 search_song = Dynamic.objects.select_related('song').order_by('-dynamic_search').all()[:6] #歌曲信息 song_info = Song.objects.get(song_id=int(song_id)) #歌曲列表 play_list = request.session.get('play_list', []) song_exist = False if play_list: for i in play_list: if int(song_id) == i['song_id']: song_exist = True if song_exist == False: play_list.append(&#123;'song_id': int(song_id), 'song_singer': song_info.song_singer, 'song_name': song_info.song_name, 'song_time': song_info.song_time&#125;) request.session['play_list'] = play_list #歌词 if song_info.song_lyrics != '暂无歌词': f = open('static/songLyric/' +song_info.song_lyrics, 'r', encoding='utf-8') song_lyrics = f.read() f.close() #相关歌曲 song_type = Song.objects.values('song_type').get(song_id = song_id)['song_type'] song_relevant = Dynamic.objects.select_related('song').filter(song__song_type=song_type).order_by('-dynamic_plays').all()[:6] #添加播放次数 #扩展功能:可使用session实现每天只添加一次播放次数 dynamic_info = Dynamic.objects.filter(song_id=int(song_id)).first() #判断歌曲动态信息是否存在, 存在就在原来的基础上+1 if dynamic_info: dynamic_info.dynamic_plays += 1 dynamic_info.save() #若动态信息不存在，则创建新的动态信息 else: dynamic_info = Dynamic(dynamic_plays=1, dynamic_search=0, dynamic_down=0, song_id=song_id) dynamic_info.save() return render(request, 'play.html', locals()) 关于播放列表的部分，这里获取当前Session的play_list的信息，play_list代表用户的播放记录。将用户URL的参数song_id与play_list的song_id进行对比，如果两者匹配的上，说明当前歌曲已加入播放记录。 1234567891011121314151617181920212223242526272829 #歌曲下载def downloadView(request, song_id): #根据song_id查找歌曲信息 song_info = Song.objects.get(song_id=int(song_id)) #添加下载次数 dynamic_info = Dynamic.objects.filter(song_id=int(song_id)).first() if dynamic_info: dynamic_info.dynamic_down += 1 dynamic_info.save() #若动态信息不存在，则创建新的动态信息 else: dynamic_info = Dynamic(dynamic_plays=0, dynamic_search=0, dynamic_down=1, song_id=song_id) dynamic_info.save() #读取文件内容 file = 'static/songFile/' + song_info.song_file def file_iterator(file, chunk_size=512): with open(file, 'rb') as f:#读取静态音乐文件 while True: c = f.read(chunk_size) if c: yield c else: break #将文件内容写入StreamingHttpResponse对象，并以字节流的方式返回给用户，实现文件下载 filename = str(song_id) + '.mp3' response = StreamingHttpResponse(file_iterator(file)) response['Content-Type'] = 'application/octet-stream' response['Content-Disposition'] = 'attachment; filename="%s"'%(filename) return response 在代码中response的使用就是将音频文件在HTML中进行播放的方法。 在各个模块中的代码中，视图更多的还是将数据库中的数据查询出来，存放到一个标量或者列表里，这是在学习过程中更需要我们去了解视图在web中的方法实现。而models文件一般在index文件中，用于数据库时进行类的书写。 comment模块这个模块的使用，也是我对django好感度一个巨大的提升。因为django自己封装了这么一个可以进行评论的函数。这让我们使用起来就非常方便。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#comment的urls.pyfrom django.urls import pathfrom . import viewsurlpatterns = [ path('&lt;int:song_id&gt;.html', views.commentView, name='comment'),]#views.pyfrom django.core.paginator import Paginator, PageNotAnInteger, EmptyPagefrom django.shortcuts import render, redirectfrom django.http import Http404from index.models import *import timedef commentView(request, song_id): #搜索结果 search_song = Dynamic.objects.select_related('song').order_by('-dynamic_search').all()[:6] #点评提交处理 if request.method == 'POST': comment_text = request.POST.get('comment', '') comment_user = request.user.username if request.user.username else '匿名用户' if comment_text: comment = Comment() comment.comment_text = comment_text comment.comment_user = comment_user comment.comment_date = time.strftime('%Y-%m-%d', time.localtime(time.time())) comment.song_id = song_id comment.save() return redirect('/comment/%s.html' %(str(song_id))) else: song_info = Song.objects.filter(song_id = song_id).first() #歌曲不存在，抛出404 if not song_info: raise Http404 comment_all = Comment.objects.filter(song_id = song_id).order_by('comment_date') song_name = song_info.song_name page = int(request.GET.get('page',1))#当请求参数不存在时，默认页数为1，如果存在，将参数值转化为Int类型 #每两条点评信息设置为一页 paginator = Paginator(comment_all, 2)# Paginator分页功能 可以接收列表、元组或其它可迭代的对象。 try: contacts = paginator.page(page) except PageNotAnInteger: contacts = paginator.page(1) except EmptyPage: contacts = paginator.page(paginator.num_pages) return render(request, 'comment.html', locals()) 如果歌曲存在，在歌曲点评表comment中查询当前歌曲的全部点评信息，然后获取到GET请求的请求参数page。参数page点评的分页页数，如果请求参数page不存在，默认页数为1，如果存在，将参数值转换成Int类型。 当用户评论时，浏览器向网站发送POST请求，POST请求由歌曲点评页的URL接收和处理。首先获取到表单里的点评内容，命名为comment_text,然后获取当前用户名，如果当前用户没有登陆网站，用户为匿名用户，用户为comment_user。如果comment不为空，在歌曲点评表comment中新增一条点评信息，分别记录点评内容、用户名、点评日期和当前歌曲在歌曲信息表的主键。 最后在使用分页功能进行对数据的显示。 基本模块就完成了。目前来看，基本不算太难，在有python基本语法的情况下时容易去了解。就是对视图，模块，url这三个进行设计和数据库的连接。]]></content>
      <tags>
        <tag>python, django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django建立一个音乐网站(二)]]></title>
    <url>%2F2019%2F03%2F12%2FDjango%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AA%E9%9F%B3%E4%B9%90%E7%BD%91%E7%AB%99-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[初步模板建立完成之后，就是数据的保存。数据也算是当前互联网中最热门的话题。 数据库的配置是西纳泽项目所使用的数据库的类型，不同的数据库需要设置不同的数据库引擎，Django提供4种数据库引擎。分别是： 1234'django.db.backends.mysql''django.db.backends.postgresql''django.db.backends.sqlite3''django.db.backends.oracle' 在我看来，我觉得数据的连接和使用对程序员也是一个非常大的提升。 项目创建时默认使用Sqlite3数据库，这是一款轻型的数据库，常用于嵌入式系统开发，而且占用的资源非常多。但是django2中不再支持mysqldb作为MySQL的连接模块，而选择了mysqlclient模块 1pip install mysqlclient 但是我在安装完成之后，还是有错误显示，这个时候在安装一个 1pip install PyMySQL 这两个模块安装后，将MySQL开启，进行连接。 书上用5.7作为一个，我也建议使用5.7，因为在8版本的密码加密方式发生了改变。 所以8版本需要在MySQL的可视化工具中运行以下SQL语句： 12ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'newpassword';FLUSH PRIVILEGES; 之后我们下载一个navicat进行数据的管理。 建议下载navicat10版本的，网上有许多的注册码，我先贴一个我自用的，如果不行，在继续寻找 1NAVN-LNXG-XHHX-5NOO 然后将之前DATABASE中设置的用户名和密码填入，连接就成功 首页的歌曲信息应该来自于数据库，除了Django内置的数据表之外，根据项目的数据库设计得知，网站一共定义了4张数据表，将4个数据表所对应的模型都在index的models.py中进行定义 1234567891011121314#index的models.pyfrom django.db import models#歌曲分类表labelclass Label(models.Model): label_id = models.AutoField('序号', primary_key=True) label_name = models.CharField('分类标签', max_length=10) def __str__(self): #设置返回值，若不设置，则默认返回Type对象 return self.label_name class Meta: #设置Admin界面的显示内容 verbose_name = '歌曲分类' verbose_name_plural = '歌曲分类' 上面的就是一个对数据表的定义，表名就是一个类名，并且在label_id定义了主键。跟SQL语句是相似的，只不过用的语言不同而已。接着分别定义了歌曲信息表song，歌曲动态表dynamic，歌曲点评表comment。 12345678910111213141516171819202122232425262728293031323334353637383940414243#歌曲信息表songclass Song(models.Model): song_id = models.AutoField('序号', primary_key=True) song_name = models.CharField('歌名', max_length=50) song_singer = models.CharField('歌手', max_length=50) song_time = models.CharField('时长', max_length=10) song_album = models.CharField('专辑', max_length=50) song_languages = models.CharField('语种', max_length=20) song_type = models.CharField('类型', max_length=20) song_release = models.CharField('发行时间', max_length=20) song_img = models.CharField('歌曲图片', max_length=20) song_lyrics = models.CharField('歌词', max_length=50, default='暂无歌词') song_file = models.CharField('歌曲文件', max_length=50) label = models.ForeignKey(Label, on_delete=models.CASCADE,verbose_name='歌名分类') def __str__(self): return self.song_name class Meta: #设置Admin界面的显示内容 verbose_name = '歌曲信息' verbose_name_plural = '歌曲信息'#歌曲动态表dynamicclass Dynamic(models.Model): dynamic_id = models.AutoField('序号', primary_key=True)#生成默认的id字段 song = models.ForeignKey(Song, on_delete=models.CASCADE, verbose_name='歌名') dynamic_plays = models.IntegerField('播放次数') dynamic_search = models.IntegerField('搜索次数') dynamic_down = models.IntegerField('下载次数') class Meta: #设置admin界面的显示内容 verbose_name = '歌曲动态' verbose_name_plural = '歌曲动态'class Comment(models.Model): comment_id = models.AutoField('序号', primary_key=True) comment_text = models.CharField('内容', max_length=500) comment_user = models.CharField('用户', max_length=20) song = models.ForeignKey(Song, on_delete=models.CASCADE,verbose_name='歌名') #on_delete=models.CASCADE,删除关联数据,与之关联也删除 comment_date = models.CharField('日期', max_length=50) class Meta: verbose_name = '歌曲评论' #verbose_name 在站点管理设置字段的显示名称 verbose_name_plural = '歌曲评论' 一些django定义的说明 AutoField：只是为模型创建一个自增长的字段，所做的仅仅是创建。自增的工作由所使用的数据库完成。 CharField：只是字符串类型 ForeignKey：类似SQL中的外键，在某类名中使用，作为另一类名的外键 只要了解SQL，并且有了一定的SQL语法，这些理解起来比较容易的 定义完成之后，再次到Pycharm中的Terminal输入数据迁移指令： 123456F:\music&gt;python manage.py makemigrationsMigrations for 'index': index\migrations\0001_initial.py ... F:\music&gt;python manage.py migrate 之后打开navicat，可以看到建立了许多表 点开表之后，我们可以进行导入数据等一些列操作。接下来就是对站点进行装饰。]]></content>
      <tags>
        <tag>python, django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django建立一个音乐网站(一)]]></title>
    <url>%2F2019%2F03%2F06%2FDjango%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AA%E9%9F%B3%E4%B9%90%E7%BD%91%E7%AB%99-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[Django是python学习的一个分支。最近跟着书上在学习。关于书上的项目我觉得拿来练手非常合适。而且涉及了数据库，html相关知识，对程序员的学习关联性我觉得还是有很大的提升的。 根据《玩转Django2.0》在此理解记忆关于python在Django中的使用。 Django的安装因为Django也到了2.0的时代，而且2.0之前的版本与现在有了一些很大变化，所以根据书上进行，使用2.0进行的学习。 python的环境不再多说，应该都是准备好了。 但是django与python的版本互搭问题这个请网上自己寻找。django-2.0还是推荐python3.5之上版本 利用pip安装1pip install Django 这个是最简单的方式，但是如果pip版本不高，可能下的django版本也不高。还有另一个方法 下载源码安装https://www.djangoproject.com/download/ 如果是源码包, 比如 django-1.11.8.tar.gz 直接用解压软件解压，然后到命令行（XP/Win7点击开始，在下面的那个输入框中输入 cmd, Win8在开始那里点右键，选择命令行) 比如在D:\django-1.11.8\这个文件夹下 123cd D:cd django-1.11.8python setup.py install 之后检查是否安装成功,从终端进入python环境. 123456&gt;&gt;&gt; import django&gt;&gt;&gt; django.VERSION(1, 11, 8, 'final', 0)&gt;&gt;&gt; &gt;&gt;&gt; django.get_version()'1.11.8' Django项目的创建当基本安装完成后，开始项目的创建。这时候使用Pycharm来进行项目的创建。 选择Pycharm的理由是IDE能更好的帮助我们，工具好，我们才能更好的去理解其他的知识。 在Pycharm直接新建工程。 注意！注意！注意！ 此时不要建立成了python工程，要选择django工程。(如果你没有，说明你下载的可能是社区版，请寻找激活码激活的版本) 如上图所示，建立完成后，开始进行项目的初始配置 建立完成后，我建议直接在pycharm的终端下进行，这样我们在框架之内创建我们的app程序 在terminal中输入，例如我的 123456F:\music&gt;python manage.py startapp indexF:\music&gt;python manage.py startapp commentF:\music&gt;python manage.py startapp playF:\music&gt;python manage.py startapp searchF:\music&gt;python manage.py startapp rankingF:\music&gt;python manage.py startapp user 完成项目的创建之后，在项目music的根目录下创建文件夹templates和music(pycharm下创建成功)，两者分别存放模板文件和静态资源文件。 在templates中放置公用模板title_base.html，在static目录下创建文件夹css，js，font，image，songFile，songLyric，songImg以及在当前目录下放置favicon.ico 接着就是关于setting中的设置。 在setting中有些地方需要我们去添加，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'index', 'ranking', 'user', 'play', 'search', 'comment',]MIDDLEWARE = [ 'django.middleware.security.SecurityMiddleware', 'django.contrib.sessions.middleware.SessionMiddleware', #使用中文 'django.middleware.locale.LocaleMiddleware', 'django.middleware.common.CommonMiddleware', 'django.middleware.csrf.CsrfViewMiddleware', 'django.contrib.auth.middleware.AuthenticationMiddleware', 'django.contrib.messages.middleware.MessageMiddleware', 'django.middleware.clickjacking.XFrameOptionsMiddleware',]TEMPLATES = [ &#123; 'BACKEND': 'django.template.backends.django.DjangoTemplates', 'DIRS': [os.path.join(BASE_DIR, 'templates'), os.path.join(BASE_DIR,'index/templates'), os.path.join(BASE_DIR,'ranking/templates'), os.path.join(BASE_DIR,'user/templates'), os.path.join(BASE_DIR,'play/templates'), os.path.join(BASE_DIR,'comment/templates'), ], 'APP_DIRS': True, 'OPTIONS': &#123; 'context_processors': [ 'django.template.context_processors.debug', 'django.template.context_processors.request', 'django.contrib.auth.context_processors.auth', 'django.contrib.messages.context_processors.messages', ], &#125;, &#125;,]DATABASES = &#123; 'default': &#123; 'ENGINE': 'django.db.backends.mysql', 'NAME': 'music_db', 'USER': 'root', 'PASSWORD': '123456', 'HOST': '127.0.0.1', 'PORT': '3306', &#125;,&#125; 当所有常规设置信息都完成之后，我们接着对项目url进行配置，在项目的urls.py中分别对新建的App设置相应的URL地址 注意！！！ 注意！！！ 注意！！！ 根据书上所描述一开始就将所有的App数据进行了添加。但是在操作过程中，因为其他模板应用并没有完成设计所以，会报错不存在model 此时可以先添加进行，完成一个模板之后，将其注释去掉 123456789urlpatterns = [ path('admin/', admin.site.urls), path('', include('index.urls')), #path('ranking.html', include('ranking.urls')), #path('play/', include('play.urls')), #path('comment/', include('comment.urls')), #path('search/', include('search.urls')), #path('user/', include('user.urls')),] 基本配置就算完成，下一部分先关于数据库的建立写博客]]></content>
      <tags>
        <tag>python, django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用结构体实现一个通讯录]]></title>
    <url>%2F2019%2F02%2F22%2F%E2%80%9C%E5%88%A9%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%80%9A%E8%AE%AF%E5%BD%95%2F</url>
    <content type="text"><![CDATA[实现一个通讯录； 通讯录可以用来存储1000个人的信息，每个人的信息包括： 姓名、性别、年龄、电话、住址 提供方法1.添加联系人信息 2.删除指定联系人信息 3.查找指定联系人信息 4.修改指定联系人信息 5.显示所有联系人信息 6.清空所有联系人 7.以名字排序所有联系人 8. 保存联系人到文件 9. 加载联系人 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;assert.h&gt;#include &lt;string.h&gt;#define PERSON_INFO_MAX_SIZE 1024typedef struct PersonInfo&#123; char name[1024]; char phone[1024];&#125;PersonInfo;typedef struct AddressBook&#123;//结构体数组 PersonInfo infos[PERSON_INFO_MAX_SIZE]; int size;//描述数组中前多少个元素是被使用的，有效元素区间[0,size)&#125;AddressBook;//我们将生活中的常识抽象成计算机中的语言AddressBook g_address_book;void Init(AddressBook* addr_book)&#123; assert(addr_book != NULL); addr_book-&gt; size = 0;&#125;void AddPersonInfo(AddressBook* addr_book)&#123; assert(addr_book != NULL); printf("插入一个联系人！\n"); if(addr_book-&gt;size &gt;= PERSON_INFO_MAX_SIZE)&#123; printf("当前通讯已满,插入失败!\n"); return; &#125; //每次都把新的联系人放到有效数组的最后一个元素上 PersonInfo *p = &amp;addr_book-&gt;infos[addr_book-&gt;size]; printf("请输入新增的联系人姓名:"); scanf("%s",p-&gt;name); printf("请输入新增的联系人的电话:"); scanf("%s",p-&gt;phone); //新增完成后，需要更新size ++addr_book-&gt;size; printf("插入联系人成功！\n");&#125;void DelPersonInfo(AddressBook* addr_book)&#123; assert(addr_book != NULL); printf("删除联系人！\n"); //根据用户输入的下标来删除联系人 printf("请输入要删除的联系人符号："); int id = 0; scanf("%d",&amp;id); if(id &lt; 0 || id &gt;= addr_book-&gt;size)&#123; printf("您输入的序号有误!删除失败!\n"); return; &#125; PersonInfo *p = &amp;addr_book-&gt;infos[id]; printf("您要删除的联系人为[%d] %s,确认请输入Y:",id,p-&gt;name); char cmd[1024] = &#123;0&#125;; scanf("%s",cmd); if(strcmp(cmd, "Y") != 0)&#123; printf("删除操作已经取消!\n"); return; &#125; PersonInfo* from = &amp;aaddr_book-&gt;infos[addr_book-&gt;size - 1]; PersonInfo* to = p; *to = *from; --addr_book-&gt;size; printf("删除成功!\n");&#125;void ModifyPersonInfo(AddressBook* addr_book)&#123; assert(addr_book != NULL); printf("修改联系人\n"); printf("请输入需要修改的联系人序号:"); int id = 0; scanf("%d",&amp;id); if(id &lt; 0 || id &gt;= addr_book-&gt;size)&#123; printf("您输入的序号错误"); return; &#125; PersonInfo *p = &amp;addr_book-&gt;infos[id]; char input[1024] = &#123;0&#125;; printf("请输入要修改的姓名:"); scanf("%s",input); if(strcmp(input,"#") != 0)&#123; strcpy(p-&gt;name,input); &#125; printf("请输入要修改的电话:"); scanf("%s",input); if(strcmp(input,"#") != 0)&#123; strcpy(p-&gt;phone,input); &#125; printf("修改成功!\n");&#125;void FindPersonInfo(AddressBook* addr_book)&#123; assert(addr_book != NULL); printf("开始进行查找！\n"); printf("请输入要查找的姓名："); char name[1024] = &#123;0&#125;; scanf("%s",name); int count = 0; for(int i = 0;i &lt; addr_book-&gt;size;++i)&#123; PersonInfo* p = &amp;addr_book-&gt;infos[i]; if(strcmp(name,p-&gt;name) == 0)&#123; printf("[%d] %s\t%s\n",i,p-&gt;name,p-&gt;phone); ++count; &#125; &#125; printf("查找完毕！共找到 %d 条记录！\n",count);&#125;void SortPersonInfo(AddressBook* addr_book)&#123;//只适用于英文名字的排序 assert(addr_book != NULL); int i = 0; int j = 0; for(i = 0;i &lt; addr_book-&gt;size;++i)&#123; for(j = 0;j &lt; addr_book-&gt;size - 1 - i;j++)&#123; if(strcmp(addr_book-&gt;infos[j].name,addr_book-&gt;infos[j + 1].name) &gt; 0)&#123; PersonInfo tmp; tmp = addr_book-&gt;infos[j]; addr_book-&gt;infos[j] = addr_book-&gt;infos[j + 1]; addr_book-&gt;infos[j + 1] = tmp; &#125; &#125; &#125;&#125;void PrintAllPersonInfo(AddressBook* addr_book)&#123; assert(addr_book != NULL); for(int i = 0;i &lt; addr_book-&gt;size;++i)&#123; PersonInfo* p = &amp;addr_book-&gt;infos[i]; printf("[%d] %s\t%s\n",i ,p-&gt;name,p-phone); &#125;&#125;void ClearPersonInfo(AddressBook* addr_book)&#123; assert(addr_book != NULL); printf("清空所有记录！\n"); printf("您确认要清空所有记录吗？输入 Y 表示确定"); char cmd[1024] = &#123;0&#125;; scanf("%s",&amp;cmd); if(strcmp(cmd,"Y") != 0)&#123; printf("清空操作取消"); return; &#125; addr_book-&gt;size = 0; printf("清空操作成功！\n");&#125;int Menu()&#123; printf("================="); printf("1.新增\n"); printf("2.删除\n"); printf("3.修改\n"); printf("4.查找\n"); printf("5.排序\n"); printf("6.显示全部\n"); printf("7.清空全部\n"); printf("0.退出\n"); printf("================="); int choice = 0; scanf("%d",&amp;choice); return choice;&#125;int main()&#123; //1.对通讯录进行初始化 Init(&amp;g_address_book); typedef void(*pfunc_t)(AddressBook*); pfunc_t table[] = &#123; AddPersonInfo, DelPersonInfo, ModifyPersonInfo, FindPersonInfo, SortPersonInfo, PrintAllPersonInfo, ClearPersonInfo &#125; while(1)&#123; int choice = Menu(); if(choice &lt; 0 || choice &gt; (int)(sizeof(table) / sizeof(table[0])))&#123; printf("您的输入有误!\n") &#125; if(choice == 0)&#123; printf("goodbye!\n"); break; &#125; table[choice - 1](&amp;g_address_book); &#125; return 0;&#125; 这个通讯录只是一个静态的，此时还可以进行一些改版，将其变为动态结合的，这时候可利用到malloc函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;assert.h&gt;#include &lt;string.h&gt;#define PERSON_INFO_MAX_SIZE 1024typedef struct PersonInfo&#123; char name[1024]; char phone[1024];&#125;PersonInfo;typedef struct AddressBook&#123;//结构体数组 PersonInfo* infos; int capacity;//容量，infos指针指向的动态数组的长度（元素个数） int size;//描述数组中前多少个元素是被使用的，有效元素区间[0,size)&#125;AddressBook;//我们将生活中的常识抽象成计算机中的语言AddressBook g_address_book;void Init(AddressBook* addr_book)&#123; assert(addr_book != NULL); addr_book-&gt; size = 0; addr_book-&gt;capacity = 10; addr_book-&gt;infos = (PersonInfo*)malloc(sizeof(PersonInfo) * addr_book-&gt;capacity); &#125;void Realloc(AddressBook* addr_book)&#123; assert(addr_book != NULL); //此处每次扩容多少，这样的策略完全是我们自定制的 //1.扩大capacity的取值 addr_book-&gt;capacity *= 2; //2.申请一个更大的内存 PersonInfo* old_infos = addr_book-&gt;infos; addr_book-&gt;infos = (PersonInfo*)malloc(addr_book-&gt;capacity * sizeof(PersonInfo)); //3.把原有的内存中的数据复制过来 for(int i = 0;i &lt; addr_book-&gt;size;++i)&#123; addr_book-&gt;infos[i] = old_infos[i]; &#125; //4.释放原有的内存 free(old_infos);&#125;void AddPersonInfo(AddressBook* addr_book)&#123; assert(addr_book != NULL); printf("插入一个联系人！\n"); if(addr_book-&gt;size &gt;= addr_book-&gt;capacity)&#123; printf("当前通讯已满,插入失败!进行扩容！\n"); Realloc(addr_book); &#125; //每次都把新的联系人放到有效数组的最后一个元素上 PersonInfo *p = &amp;addr_book-&gt;infos[addr_book-&gt;size]; printf("请输入新增的联系人姓名:"); scanf("%s",p-&gt;name); printf("请输入新增的联系人的电话:"); scanf("%s",p-&gt;phone); //新增完成后，需要更新size ++addr_book-&gt;size; printf("插入联系人成功！\n");&#125;void DelPersonInfo(AddressBook* addr_book)&#123; assert(addr_book != NULL); printf("删除联系人！\n"); //根据用户输入的下标来删除联系人 printf("请输入要删除的联系人符号："); int id = 0; scanf("%d",&amp;id); if(id &lt; 0 || id &gt;= addr_book-&gt;size)&#123; printf("您输入的序号有误!删除失败!\n"); return; &#125; PersonInfo *p = &amp;addr_book-&gt;infos[id]; printf("您要删除的联系人为[%d] %s,确认请输入Y:",id,p-&gt;name); char cmd[1024] = &#123;0&#125;; scanf("%s",cmd); if(strcmp(cmd, "Y") != 0)&#123; printf("删除操作已经取消!\n"); return; &#125; PersonInfo* from = &amp;aaddr_book-&gt;infos[addr_book-&gt;size - 1]; PersonInfo* to = p; *to = *from; --addr_book-&gt;size; printf("删除成功!\n");&#125;void ModifyPersonInfo(AddressBook* addr_book)&#123; assert(addr_book != NULL); printf("修改联系人\n"); printf("请输入需要修改的联系人序号:"); int id = 0; scanf("%d",&amp;id); if(id &lt; 0 || id &gt;= addr_book-&gt;size)&#123; printf("您输入的序号错误"); return; &#125; PersonInfo *p = &amp;addr_book-&gt;infos[id]; char input[1024] = &#123;0&#125;; printf("请输入要修改的姓名:"); scanf("%s",input); if(strcmp(input,"#") != 0)&#123; strcpy(p-&gt;name,input); &#125; printf("请输入要修改的电话:"); scanf("%s",input); if(strcmp(input,"#") != 0)&#123; strcpy(p-&gt;phone,input); &#125; printf("修改成功!\n");&#125;void FindPersonInfo(AddressBook* addr_book)&#123; assert(addr_book != NULL); printf("开始进行查找！\n"); printf("请输入要查找的姓名："); char name[1024] = &#123;0&#125;; scanf("%s",name); int count = 0; for(int i = 0;i &lt; addr_book-&gt;size;++i)&#123; PersonInfo* p = &amp;addr_book-&gt;infos[i]; if(strcmp(name,p-&gt;name) == 0)&#123; printf("[%d] %s\t%s\n",i,p-&gt;name,p-&gt;phone); ++count; &#125; &#125; printf("查找完毕！共找到 %d 条记录！\n",count);&#125;void SortPersonInfo(AddressBook* addr_book)&#123;//只适用于英文名字的排序 assert(addr_book != NULL); int i = 0; int j = 0; for(i = 0;i &lt; addr_book-&gt;size;++i)&#123; for(j = 0;j &lt; addr_book-&gt;size - 1 - i;j++)&#123; if(strcmp(addr_book-&gt;infos[j].name,addr_book-&gt;infos[j + 1].name) &gt; 0)&#123; PersonInfo tmp; tmp = addr_book-&gt;infos[j]; addr_book-&gt;infos[j] = addr_book-&gt;infos[j + 1]; addr_book-&gt;infos[j + 1] = tmp; &#125; &#125; &#125;&#125;void PrintAllPersonInfo(AddressBook* addr_book)&#123; assert(addr_book != NULL); for(int i = 0;i &lt; addr_book-&gt;size;++i)&#123; PersonInfo* p = &amp;addr_book-&gt;infos[i]; printf("[%d] %s\t%s\n",i ,p-&gt;name,p-phone); &#125;&#125;void ClearPersonInfo(AddressBook* addr_book)&#123; assert(addr_book != NULL); printf("清空所有记录！\n"); printf("您确认要清空所有记录吗？输入 Y 表示确定"); char cmd[1024] = &#123;0&#125;; scanf("%s",&amp;cmd); if(strcmp(cmd,"Y") != 0)&#123; printf("清空操作取消"); return; &#125; addr_book-&gt;size = 0; printf("清空操作成功！\n");&#125;int Menu()&#123; printf("================="); printf("1.新增\n"); printf("2.删除\n"); printf("3.修改\n"); printf("4.查找\n"); printf("5.排序\n"); printf("6.显示全部\n"); printf("7.清空全部\n"); printf("0.退出\n"); printf("================="); int choice = 0; scanf("%d",&amp;choice); return choice;&#125;int main()&#123; //1.对通讯录进行初始化 Init(&amp;g_address_book); typedef void(*pfunc_t)(AddressBook*); pfunc_t table[] = &#123; AddPersonInfo, DelPersonInfo, ModifyPersonInfo, FindPersonInfo, SortPersonInfo, PrintAllPersonInfo, ClearPersonInfo &#125; while(1)&#123; int choice = Menu(); if(choice &lt; 0 || choice &gt; (int)(sizeof(table) / sizeof(table[0])))&#123; printf("您的输入有误!\n") &#125; if(choice == 0)&#123; printf("goodbye!\n"); break; &#125; table[choice - 1](&amp;g_address_book); &#125; return 0;&#125; 在扩容过程中，我们经过分析之后，当内存不够时，考虑到只有添加才需要开辟新的空间。 所以在第一个静态的版本之上，又加入了动态开辟，这样当添加不够时，我们的程序会自动开辟新的空间，为了当前能够使用。 在代码中有注释，关于开辟的关键。 内存中原先保存的位置我们也要管理，否则会造成内存泄漏。必须要保证这有一个合适的内存分配。]]></content>
      <tags>
        <tag>进阶C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模拟实现strncpy,strncat,strncmp]]></title>
    <url>%2F2019%2F02%2F21%2F%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0strncpy-strncat-strncmp%2F</url>
    <content type="text"><![CDATA[main()函数中的例子全部取于cplusplus网站 模拟实现strncat 123456789101112131415161718char* Strncat(char* dest,const char* src,size_t num)&#123; assert(dest != NULL); assert(src != NULL); unsigned int i = 0; for(i = 0;i &lt; num; i++); strncpy(&amp;dest[i],src,num); return dest; &#125; int main()&#123; char str1[20]; char str2[20]; strcpy (str1,"To be "); strcpy (str2,"or not to be"); Strncat (str1, str2, 6); puts (str1); return 0; &#125; 模拟实现strncmp 1234567891011121314151617181920212223242526272829int Strncmp(const char *dest, const char*src, int count)&#123; assert(dest != NULL); assert(src != NULL); while (count &amp;&amp; *dest != '\0' &amp;&amp; *src != '\0') &#123; if (*dest &gt; *src)&#123; return 1; &#125; else if (*dest &lt; *src)&#123; return -1; &#125; else&#123; dest++; src++; count--; &#125; &#125;&#125;int main()&#123; char str[][5] = &#123; "R2D2", "C3PO", "R2A6" &#125;; int n; printf("Looking for R2 astromech droids...\n"); for (n = 0; n&lt;3; n++) if (Strncmp(str[n], "R2xx", 2) == 0) &#123; printf("found %s\n", str[n]); &#125; strncpy模拟实现 123456789101112131415161718192021222324252627char* Strncpy(char* dest, const char* src, size_t num)&#123; assert(dest != NULL); assert(src != NULL); int64_t i = 0; for(i = 0;(unsigned)i &lt; num;i++)&#123; dest[i] = src[i]; &#125; dest[num] = '\0'; return dest; &#125; int main()&#123; char str1[]= "To be or not to be"; char str2[40]; char str3[40]; /* copy to sized buffer (overflow safe): */ Strncpy ( str2, str1, sizeof(str2) ); /* partial copy (only 5 chars): */ Strncpy ( str3, str2, 7 ); str3[7] = '\0'; /* null character manually added */ puts (str1); puts (str2); puts (str3); return 0;&#125;]]></content>
      <tags>
        <tag>进阶C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言标准库函数的理解与重写]]></title>
    <url>%2F2019%2F02%2F16%2FC%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86%E5%BA%93%E5%87%BD%E6%95%B0%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E9%87%8D%E5%86%99%2F</url>
    <content type="text"><![CDATA[1.实现strcpy 2.实现strcat 3.实现strstr 4.实现strchr 5.实现strcmp 6.实现memcpy 7.实现memmove 为了更好的去理解这几个函数的用法，自己去实现一下功能，才能更好的学习 123456789#include&lt;assert.h&gt;size_t Strlen(const char* str)&#123; //无符号整型 assert(str != NULL);//首先要进行合法性判断，如果字符串本身都有问题，那么就没必要检验了 size_t count = 0; while(str[count] != '\0')&#123; ++count; &#125; return conunt;&#125; 1234567891011#include&lt;assert.h&gt;char* Strcpy(char* dest,const char* src)&#123; assert(dest != NULL); assert(src != NULL); int64_t i = 0; for(i = 0;src[i] != '\0';i++)&#123; dest[i] = src[i]; &#125; dest[i] = '\0'; return dest;&#125; 123456789#include&lt;assert.h&gt;char* Strcat(char* dest,const char* src)&#123; assert(dest != NULL); assert(src != NULL); int i = 0; for(i = 0; dest[i] != '\0';i++); Strcpy(&amp;dest[i],src); return dest;&#125; 12345678910111213141516171819202122#include&lt;assert.h&gt;const char* Strstr(const char* str1,const char* str2)&#123; assert(str1 != NULL); assert(str2 != NULL); if(*str1 == '\0' || *str2 == '\0')&#123; return NULL; &#125; const char* black_ptr = str1; while(*black_ptr != '\0')&#123; const char* sub_ptr = str2; const char* red_ptr = black_ptr; while(*red_ptr != '\0' &amp;&amp; *sub_ptr != '\0' &amp;&amp;(*red_ptr == *sub_ptr))&#123; ++red_ptr; ++sub_ptr; &#125; if(*sub_ptr == '\0')&#123; return black_ptr; &#125; ++black_ptr; &#125; return NULL;&#125; 1234567891011#include&lt;assert.h&gt;const char* Strchr(const char* str,int chr)&#123; assert(str != NULL); while(*str)&#123;//*str表示字符数组中第一个字符 if(*str == (char)chr)&#123; return (char*)str;//此时返回的是第一个找到所需字符的地址 &#125; ++str; &#125; return NULL;&#125; 1234567891011121314151617181920212223#include&lt;assert.h&gt;int Strcmp(const char* str1, const char* str2)&#123; assert(str1 != NULL); assert(str2 != NULL); while(*str1 != '\0' &amp;&amp; *str2 != '\0')&#123; if(*str1 &gt; *str2)&#123; return 1; &#125;else if(*str1 &lt; *str2)&#123; return -1; &#125;else&#123; ++str1; ++str2; &#125; &#125; //此时如果str1或者str2有一个提前遇到了'\0',那么跳出了while循环，接着判断 if(*str1 &gt; *str2)&#123; return 1; &#125;else if(*str1 &lt; *str2)&#123; return -1; &#125;else&#123; return 0; &#125;&#125; 123456789101112#include&lt;assert.h&gt;void* Memcpy(void* dest,void* src,size_t num)&#123; assert(dest != NULL); assert(src != NULL); char* pdest = (char*)dest;//void*不能解引用，类型改变，只在运算中起作用，是临时的，本身的类型不改变，所以最后还是返回dest char* psrc = (char*)src; size_t i = 0; for(i = 0;i &lt; num;++i)&#123; pdest[i] = psrc[i]; &#125; return dest;&#125; 12345678910111213141516171819#include&lt;assert.h&gt;void* Memmove(void* dest,const void* src,size_t num)&#123; assert(dest != NULL); assert(src != NULL); char* pdest = (char*)dest; char* psrc = (char*)src; if(pdest &gt;= psrc &amp;&amp; pdest &lt; psrc + num)&#123;//这是标准库认为的缓冲区重合 //起始dest指针如果在src缓冲区范围以内，拷贝为缓冲区重合 //以外则不为缓冲区拷贝 int64_t i = 0;//从最后一个元素的下标开始，倒着拷贝 for(i = num - i;i &gt;= 0;i++)&#123; pdest[i] = psrc[i]; &#125; &#125;else&#123; //完全按照原来方法拷贝 Memcpy(dest,src,num); &#125; return dest;&#125;]]></content>
      <tags>
        <tag>进阶C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初阶C-0215]]></title>
    <url>%2F2019%2F02%2F15%2F%E5%88%9D%E9%98%B6C-0215%2F</url>
    <content type="text"><![CDATA[1.实现一个函数，可以左旋字符串中的k个字符。 ABCD左旋一个字符得到BCDA ABCD左旋两个字符得到CDAB 1234567891011void left_rotate(char* str,int k)&#123; while(k--)&#123; char tmp = *str; char* cur = str; while(*(cur + 1))&#123; //判断真假是否到了‘\0’ *cur = *(cur + 1); cur++; &#125; *cur = tmp; &#125;&#125; 这里有一个问题需要我们去注意 当我们左旋的时候，将B C D移动向前之后，之前字符串的\0也被提前了。 但是字符串数组本身最后有一个\0,所以我们要在字符串的前一个位置，把旋转的字符与前面的\0交换 那么这个时候在while循环里，需要将我们的cur向后移动一个位置，也就是字符串之前的最后一个位置。 此时的判断条件为cur + 1 12345678int main()&#123; char str[] = "ABCD"; int k; scanf("%d", &amp;k); printf("%s",str) left_rotate(str, k); printf("%s",str);&#125; 关于右旋，右旋就是左旋的相反，即strlen(str)-k次，直接在右旋中，调用左旋设置k的次数即可 2.判断一个字符串是否为另外一个字符串旋转之后的字符串。 例如：给定s1 =AABCD和s2 = BCDAA，返回1，给定s1=abcd和s2=ACBD，返回0. AABCD左旋一个字符得到ABCDA AABCD左旋两个字符得到BCDAA AABCD右旋一个字符得到DAABC 12345678910111213int is_rotate(char* dest, char* src)&#123; if(strlen(dest) != strlen(src))&#123; return 0; &#125; int len = strlen(src); while(len--)&#123; right_rotate(src, 1);//一次一个判断 if(strcmp(dest, src) == 0)&#123; return 1; &#125; return 0; &#125;&#125; 3.一个数组中只有两个数字是出现一次， 其他所有数字都出现了两次。 找出这两个数字，编程实现。 首先要清楚连续异或的结果，因为单独出现的数字会在最后呈现出来 这样我们就可以找到异或结果中，二进制‘1’在什么位置不同 根据‘1’的位置把所有数分成两组，每一组当中必有一个数单独出现一次 1234567891011121314151617181920212223242526int main()&#123; int a[]=&#123; 1, 2, 3, 4, 6, 6, 2, 3, 4, 1, 9, 10&#125;; int ret = 0; int pos = 0; int sz = sizeof(a)/sizeof(a[0]); int i = 0; for(i = 0;i &lt; sz;i++)&#123; ret ^= a[i]; &#125; for(i = 0;i &lt; 32;i++)&#123; if(((ret &gt;&gt; i) &amp; 1) == 1)&#123; pos = i; break; &#125; &#125; for(i = 0;i &lt; sz;i++)&#123; if(((a[i] &gt;&gt; pos) &amp; 1) == 1)&#123; x ^= a[i]; &#125; else&#123; y ^= a[i]; &#125; &#125; printf("%d %d",x,y); return 0;&#125; 4.喝汽水，1瓶汽水1元，2个空瓶可以换一瓶汽水， 给20元，可以多少汽水。 编程实现。 123456789101112int main()&#123; int empty ; int total ; int money; scanf("%d",&amp;money); total = money; empty = money; while(empty &gt; 1)&#123; total += (empty / 2); empty = (empty % 2) + (empty / 2) &#125;&#125;]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[八皇后问题(C+python)]]></title>
    <url>%2F2019%2F01%2F27%2F%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98-C-python%2F</url>
    <content type="text"><![CDATA[最近继续自学python，看到了八皇后问题，觉得是个有点意思的问题。 八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。 首先得说一下什么是回溯算法，实际是一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。回溯法是一种优选搜索法，按优选条件向前搜索，以达到目标。 该问题是在8x8格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、后一列、或同一斜线上有多少种摆法。 通过C语言解决因为是在python递归、迭代和生成器时碰到的这些问题，看了好久，还是有点懵，所以先用C语言的思想去理解一下。 首先我们得明确我们的思想，在这个8x8的棋盘上，我们如何去部署我们的棋子，我们已y轴为我们定义的数组下标范围，让x轴为数组内表示的元素所在的格子位置。 12345#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;static int board[8] = &#123;&#125;;int board_size = sizeof(board)/sizeof(int); 接着需要去思考如何使用数学的语言来表述斜线上重叠的皇后。对于棋盘上任意的一点，都要在[0，7]这个范围内，那么这个关系就是目标格子(a,b)和当前所在格子(x,y)等价于&#124;a-x&#124;==&#124;b-y&#124; 所以首先进行一个判定 12345678910int check(int *board,int row)&#123; int i = 0; while(i &lt; row)&#123; if(board[i] == board[row] || row - i == board[row] - board[i] || row - i == board[i] - board[row])&#123; return 0; &#125; i++; &#125; return 1;&#125; 我们从第一行开始给每一行的皇后确定一个位置。每来到新的一行时，对本行的所有可能位置（皇后放在这个位置和前面所有已放置的皇后无冲突）分别进行递归地深入；若某一行可能放置地位置为0，那么说明这是一个四路，此时需要返回到上一层去重新选择。若此时八行都结束后，那么说明这是一个可行的方法。 123456789101112131415161718int eight_queen(int *board,int row)&#123; if(row == 8)&#123; printf_board(board); return 1; &#125; board[row] = 0;//每次当row行跳转到下一行时，需要重新初始化一下 while(1)&#123; if(check(board,row) &amp;&amp; eight_queen(board,row + 1))&#123; return 1; &#125; else&#123; if(++board[row] &gt;= 8)&#123;//当上面的判断条件失败之后，将row行的值向后+1看是否满足了全部落完棋子的情况 break; &#125; &#125; &#125; return 0；&#125; 这里需要解释一下这个递归，在第一个if语句中，进行了两个函数的判断。首先是check函数，当第一个棋子部署后，进行第二个部署并且此时还要提前检查是否在第一个棋子的周围。如果不符合，那么board[row]+1，在进行判断，看此时是否符合要求。如果这时已经符合要求了，那么eight_queen函数也返回1，那么此时第二个就可以部署，以此类推，第三个也按照如此去部署。 当数组board[row]知道每个确切的值之后，我们将其数组打印，并且，打印出一个大概的图像 123456789101112131415161718192021void print_board(int *board)&#123; int i; int size = board_size; for(i = 0;i &lt; size; ++i)&#123; printf("%d",board[i]); &#125; printf("\n"); i = 0;//局部变量此时值不相同 while(i &lt; size)&#123; int j; for(j = 0;j &lt; size; ++j)&#123; if(j == board[i])&#123; printf("%s","x"); &#125;else&#123; printf("%s","0"); &#125; &#125; printf("\n"); i++; &#125;&#125; 代码比较不好理解的就是，在递归的过程中，何时board[row]被赋值，知道具体哪个位置可以被部署皇后。所以建议利用调试器去看！ 通过python解决其实早都该写完这篇博客，有点懒了，也是有点小受挫，总觉得python简单。现在不会再轻敌了。 关于问题的本身跟用C语言来分析是大概一样的，那么就是应该怎么样利用去python去想这个问题 还是先定义一个判定的方法，当我们去放置皇后时，判定是否可以去落棋子,这里称为检测冲突 123456def conflict(state, nextX):#这里的state将其定义为元组，它表示皇后落在每一行的第几个位置上 nextY = len(state) for i in range(nextY):#检查每一个已摆放的棋子和当前行摆放的棋子的位置是否冲突 if abs(state[i] - nextX) in (0,nextY - i): return True return False 主函数的思想则是利用python的生成器和递归的思想 将问题拆解，如果一个已经布置好了，那么接下来就是有限制的七皇后问题。那么每一次剩下的皇后没有放好，就遍历所有可能的位置，并放回那些不会引发冲突的位置。 12345678def eight_queen(num=8,state=()):#num为皇后数目，state为元组 for pos in range(num):#pos此时可以看成当前所在的行数 if not conflict(state, pos):#此时是冲突判断，not是与函数内的true和false相反 if len(state) == num - 1#当没有冲突时，元组内记录的皇后数-1，这样就代表继续向下部署 yield(pos,)#yield函数存在，此时已经成为了一个生成器，每次从上次pos结束的位置进行判断 else: for result in queens(num,state + (pos,)):#此时将已得到的数据存入元组 yield(pos,) + result 当主函数没问题了，我们也会想知道总共有多少方法 1len(list(eight_queen(8))) 这样就可以知道有多少方法了。 最后，这个问题让我想了好久好久啊，感觉如果学习一门新的语言出现疑惑时，不妨利用C语言去思考一下，这样有助于更好去发现自己的盲点存在那里。]]></content>
      <tags>
        <tag>算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C进阶-C语言文件操作]]></title>
    <url>%2F2019%2F01%2F22%2F%E8%BF%9B%E9%98%B6C-C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[什么是文件磁盘上的文件是文件。但在程序设计中，我们一般谈的文件有两种：程序文件、数据文件 程序文件：包括源程序文件，目标文件，可执行文件。 数据文件：文件的内容不一定是程序，而是程序运行时读写的数据，比如程序运行需要从中读取数据的文件，或者输出内容的文件。 文件名文件标识常被成为文件名 文件类型根据数据的组织形式，数据文件被称为文本文件或者二进制文件。 数据在内存中以二进制的形式存储，如果不加转换的输出的外存，就是二进制文件]]></content>
      <tags>
        <tag>进阶C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进阶C-动态内存管理]]></title>
    <url>%2F2019%2F01%2F20%2F%E8%BF%9B%E9%98%B6C-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[动态内存分配可以说是C语言中的超级大BOSS，他能使用的地方有许多许多，而且与free搭配使用。很多初学者，经常会忘记这个的使用。 而且它也是数据结构中很关键的一环。在各种的链表，顺序表等等，我们都需要去使用它。所以这是一个非常重要的一节 为什么存在动态内存分配我们以尽掌握的内存开辟方式 12int val = 20;//在栈空间上开辟四个字节char arr[10] = &#123;0&#125;;//在栈空间上开辟10个字节的连续空间 但是上述的开辟方式有两个特点： 1.空间的开辟大小是固定的。 2.数组在申明的时候，必须指定数组的长度，它所需要的内存在编译时分配。 但比如我们在动态顺序表中，我们先开辟了一部分，但是在分配过程中，我们所分配的内存不够了，此时我们就需要malloc函数先临时开辟一个空间，之后再去使用，当使用完成之后在free释放掉。 12345678int main()&#123; int len = 0; printf("请输入长度:"); scanf("%d",&amp;len); //malloc只是动态申请一块连续的内存空间 int* a = (int*)malloc(len * sizeof(int)); return 0;&#125; 123malloc()函数的优点1.申请内存空间的长度能够比较灵活 2.何时释放，完全由用户来掌控 malloc1void* malloc(size_t size); 这个函数向内存申请一块连续可用的空间，并返回指向这块空间的指针。 如果开辟成功，则返回一个指向开辟好空间的指针。 如果开辟失败，则返回一个NULL指针，因此malloc的返回值一定要做检查。 返回值的类型是 void* ，所以malloc函数并不知道开辟空间的类型，具体在使用的时候使用者自己来决定。 如果参数 size 为0，malloc的行为是标准是未定义的，取决于编译器。 free1void free(void* ptr); free函数用来释放动态开辟的内存。 如果参数 ptr 指向的空间不是动态开辟的，那free函数的行为是未定义的。 如果参数 ptr 是NULL指针，则函数什么事都不做。 如果频繁 malloc 但是忘记 free，此时就是内存泄漏 关于一些经典的动态分配1.首先不能malloc()两次，或者free两次。动态分配两次也就是说你释放的时候只能释放一个，另一个并没有释放掉。即使你释放了两次。 2.free必须搭配malloc函数来使用。如果定义一个指针的地址，是不能释放掉的。这是错误的操作。 3.还有特殊规定，C++标准中规定了对 空指针进行 free/delete，都是合法的（无事发生）。所以当free一个内存之后，就把这个指针设为NULL。推荐这样做 1234int * p = (int*)malloc(sizeof(int));free(p);p = NULL;//如果*p = 100；这就是一个未定义行为 calloc 1void* calloc(size_t num,size_t size); 函数的功能是为num个大小为size的元素开辟一块空间，并且把空间的每个字节初始化为0. 与函数malloc的区别只在于calloc会返回地址之前把申请的空间的每个字节初始化为全0. realloc 1void* realloc(void* ptr,size_t size); 当我们发现我们申请的内存空间过大或者过小，我此时就可以使用realloc函数就可以对动态开辟内存大小的调整 ptr是要调整的内存地址 size调整之后新的大小 返回值为调整之后的内存起始位置 这个函数调整原内存空间大小的基础上，还会将原来内存中的数据移动到新的空间上 一些常见的动态内存错误对NULL指针的解引用操作 12345void test()&#123; int *p = (int*)malloc(INT_MAX/4); *p = 20; free(p);&#125; 对动态开辟空间的越界访问 1234567891011void test()&#123; int i = 0; int *p = (int*)malloc(10*sizeof(int)); if(NULL == p)&#123; exit(EXIT_FAILURE);//是个宏，返回1成功，返回0失败 &#125; for(i = 0;i &lt;= 10;i++)&#123; *(p+i) = i;//当i是10的时候越界访问，*(p+i)相当于p[i]，i为10时，数组下标越界 &#125; free(p);&#125; 使用free释放一块动态开辟内存的一部分 12345void test()&#123; int *p = (int*)malloc(100); p++; free(p);//p不再指向动态内存的起始位置&#125; free只能释放开辟的所有空间，这种行为是未定义行为 经典笔试题第一题 123456789void GetMemory(char *p)&#123; p = (char *)malloc(100);&#125;void Test(void)&#123; char *str = NULL; GetMemory(str); strcpy(str, "hello world"); printf(str);&#125; 在Test函数中，*str是实参，当通过GetMemory调用之后的str是形参，当函数结束结束之后，就不存在了，str依旧是一个空指针，将字符拷贝到一个空指针中，这将发生段错误，也就是未定义行为。应该修改为 1234567891011void GetMemory(char **p)&#123; *p = (char *)malloc(100); &#125; void Test(void)&#123; char *str = NULL; GetMemory(&amp;str); strcpy(str, "hello world"); printf("%s\n",str); free(str); &#125; 第二题 1234567891011char *GetMemory(void)&#123; char p[] = "hello world"; return p;//返回的是数组的首元素地址&#125;void Test(void)&#123; char *str = NULL; str = GetMemory(); printf(str);&#125; 但是p[]数组仅仅是一个局部变量，函数结束，内存就释放了。应该修改为 1234567891011const char *GetMemory(void) &#123; const char* p = "hello world"; return p; &#125; void Test(void) &#123; const char *str = NULL; str = GetMemory(); printf("%s\n",str); &#125; 虽然内存可以访问，但是不可以修改 第三题 1234567891011void GetMemory2(char **p, int num)&#123; *p = (char *)malloc(num);&#125;void Test(void)&#123; char *str = NULL; GetMemory(&amp;str, 100); strcpy(str, "hello"); printf(str);&#125; 首先没有释放内存，并且在我们的调用过程中最好进行一个if对str的判断 第四题 123456789void Test(void)&#123; char *str = (char *) malloc(100); strcpy(str, “hello”); free(str); if(str != NULL)&#123; strcpy(str, “world”); printf(str); &#125;&#125; 释放完毕之后就不能在使用了，此时str就相当于一个野指针，虽然有结果打印出来，但是这个打印是非法的。 那么我们什么时候需要malloc内存？ 当申请的内存空间比较大的时候，需要malloc 什么时候血药直接定义临时变量？ 如果对于内存申请的性能要求较高的时候 柔性数组只在C语言中存在 1234567891011121314151617181920212223242526typedef struct Test&#123; int i; int a[0];//a成员就是柔性数组成员&#125;Test;typedef struct Test2&#123; int i; int* a;&#125;Test;int main()&#123; Test* t = (Test*)malloc(sizeof(int)+sizeof(int)*10); t-&gt;i = 10; for(int i = 0;i &lt; 10;i++)&#123; t-&gt;a[i] = i; &#125; free(t); Test2* t2 = (Test2*)malloc(sizeof(int)+sizeof(int)*100); t2-&gt;i = 10; t2-&gt;a = (int*)malloc(sizeof(int) * 10); free(t2-&gt;a); free(t2); return 0;&#125; 柔性数组的特点： 结构中的柔性数组成员前面必须至少一个其他成员。 sizeof 返回的这种结构大小不包括柔性数组的内存。 包含柔性数组成员的结构用malloc ()函数进行内存的动态分配，并且分配的内存应该大于结构的大小，以适应柔性数组的预期大小。]]></content>
      <tags>
        <tag>进阶C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进阶C-结构体,枚举,联合]]></title>
    <url>%2F2019%2F01%2F19%2F%E8%BF%9B%E9%98%B6C-%E7%BB%93%E6%9E%84%E4%BD%93-%E6%9E%9A%E4%B8%BE-%E8%81%94%E5%90%88%2F</url>
    <content type="text"><![CDATA[结构体也是一个很重要的东西。在数据结构中，这个是经常被拿来使用的一部分。 联合类型应该和结构体去比较着学习。 结构体结构体的定义结构是一些值的集合，这些值称为成员变量。结构的每个成员可以是不同的类型 结构的声明1234567struct Stu&#123; char name[20]; int age; char sex; char id[20];&#125;Stu; 特殊的声明1234567//匿名结构体类型 C语言支持struct&#123; int a; char b; float c;&#125;x; 结构在声明的时候省略掉了结构体标签 实际应用中没啥用处，但是匿名函数特别有用，然而C语言不支持 不同的匿名结构体不能相互之间赋值 结构的自引用12345struct Student&#123; char name[1024]; int score; struct Student* s; &#125;; 当将自己作为结构体指针时，可以引用自己 结构体内存对齐结构体成员占用的内存空间的相对位置和代码中结构体变量的定义写法是密切相关的 成员从低地址到高地址依次布置 如何计算？ 1.第一个成员在结构体变量偏移量为0的地址处 2.其他成员变量要对其到某个数字的整数倍的地址处 对其数 = 编译器默认的一个对其数 与 该成员大小的较小值 VS中默认的值为8 Linux中的默认值为4 3.结构体中总大小为最大对齐数(每个成员变量都有一个对齐数)的整数倍。 4.如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有对齐数(含嵌套结构体的对齐数)的整数倍。 修改默认对齐数#pragma pack()还原默认的对齐数 结构体传参12345678910111213141516171819202122struct S&#123; int data[1000]; int num;&#125;;struct S s = &#123;&#123;1,2,3,4&#125;, 1000&#125;;//结构体传参void print1(struct S s)&#123; printf("%d\n", s.num);&#125;//结构体地址传参void print2(struct S* ps)&#123; printf("%d\n", ps-&gt;num);&#125;int main()&#123; print1(s); //传结构体 print2(&amp;s); //传地址 return 0;&#125; 位段位段的声明和结构是类似的，有两个不同 位段成员必须是int，unsigned int 或 signed int。 位段的成员名后边有一个冒号和一个数字 123456struct A&#123; int _a:2; int _b:5; int _c:10; int _d:30;&#125;; 枚举枚举顾名思义就是一一列举。 把可能的取值一一列举。 枚举类型的定义123456789enum Day&#123; Mon, Tues, Wed, Thur, Fri, Sat, Sun&#125;; 枚举的优点1.增加代码的可读性和可维护性 2.和#define定义的标识符比较枚举有类型检查，更加严谨。(核心优点) 3.防止了命名污染（封装） 4.便于调试 5.使用方便，一次可以定义多个常量 联合(共用体)联合也是一种特殊的自定义类型 这种类型定义的变量也包含一系列的成员，特征是这些成员公用同一块空间(所以联合也叫共用体) 12345678910111213union Un&#123; char a; int b;&#125;;int main()&#123; //此时创建了一个联合体类型的变量 u union Un u; u.a = 10; //和结构体的区别 站在内存的角度去分析 printf("%lu\n",sizeof(u)); return 0;&#125; 联合的特点联合的成员是共用同一块内存空间的，这样一个联合变量的大小，至少是最大成员的大小（因为联合至少得有能力保存你最大的那个成员）。 同一块内存空间中的数据可以有不同的理解方式 假设用联合体去表示怎么判断大小端 123456789101112int IslittleEnd()&#123; union Un&#123; char a; int b; &#125;u; u.b = 0x11223344; if(u.a == 0x11)&#123; return 0;//大端 &#125;else&#123; return 1;//小端 &#125;&#125; char a与int b的最低字节放在一起，因为它们是共用一块内存。这样就可以判断是否在一个字节内的地址是否是相同的]]></content>
      <tags>
        <tag>进阶C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进阶C-字符串+内存函数]]></title>
    <url>%2F2019%2F01%2F17%2F%E8%BF%9B%E9%98%B6C-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%86%85%E5%AD%98%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[关于这节学习重点：处理字符和字符串的库函数的使用和注意事项 求字符串长度 strlen 长度不受限制的字符串函数 strcpy strcat strcmp 长度受限制的字符串函数介绍 strncpy strncat strncmp 字符串查找 strstr strtok 错误信息报告 strerror 字符操作 内存操作函数 memcpy memmove memset memcmp 函数介绍strlen 1size_t strlen(const char* str); 我们对这些函数需要掌握的是自己来写一个这样的函数 在我们自己编写一个函数时，我们需要进行一个合法性校验 所以我们要用到assert()这个函数 assert是断言，如果表达式为真，断言通过，无事发生；如果表达式为假，断言失败，程序直接退出 123456789101112size_t Strlen(const char* str)&#123; //1.函数内部进行判定 //if(str == NULL)&#123; // return 0; //&#125; assert(str != NULL); size_t count = 0; while(str[count] != '\0')&#123; ++count; &#125; return count; &#125; strcpy 1char* strcpy(char *destination,const char * source); 源字符串必须以\0结尾。 会将源字符串中的\0拷贝到目标空间 12345678910char* Strcpy(char * dest,const char* src)&#123; assert(dest != NULL); assert(src != NULL); int64_t i = 0; for (i = 0;src[i] != '\0';++i)&#123; dest[i] = src[i]; &#125; dest[i] = '\0'; return dest; &#125; strcat 1cahr* strcat(char * destnation,const char * source); 将两个字符串合并 源字符串必须以&#39;\0&#39;结束。 目标空间必须足够大，能够容纳下源字符串的内容 123456789101112131415char* Strcat(char* dest,const char* src)&#123; assert(dest != NULL); assert(src != NULL); //1.找到dest的末尾在哪里 int i = 0; for (;dest[i] != '\0';++i); //2.拷贝数据 //int j = 0; //for (;src[j] != '\0';++j,++i)&#123; //dest[i] = src[j]; //&#125; //dest[i] = '\0'; Strcpy(&amp;dest[i],src); return dest;&#125; strcmp 1char* strcmp(const char* str1,const char* str2); 1.字符串是使用字符数组来表示的 2.数组名会隐式转换成指针 此处的比较就不再是字符串内容的比较了，而是两个指针保存的地址的比较 如果str1 = str2，返回0 如果str1 &lt; str2，返回负数 如果str1 &gt; str2，返回正数 1234567891011121314151617181920212223int Strcmp(const char* str1,const char* str2)&#123; assert(str1 != NULL); assert(str2 != NULL); while(*str1 != '\0' &amp;&amp; *str2 != '\0')&#123; if(*str1 &lt; *str2)&#123; return -1; &#125;else if(*str1 &gt;*str2)&#123; return 1; &#125;else&#123; //对应字符相等，继续比较下一个字符 ++str1; ++str2; &#125; &#125; //str1 遇到'\0',str2 没遇到,认为str1 &lt; str2 if(*str1 &lt; *str2)&#123; return -1; &#125;else if(*str1 &gt;*str2)&#123; //str1 没遇到，str2遇到'\0',认为 str1 &gt; str2 return 1; &#125;else&#123; //str1和str2同时遇到 str1 = str2 return 0; &#125; &#125; strncpy 1char* strncpy(char* dest,const char* source,size_t num); 拷贝num个字符从源字符串到目标空间。 如果源字符串的长度小于num，则拷贝完源字符串之后，在目标的后边追加0，直到num个。 strncat 1char* strncat(char* dest,const char* src,size_t num); 将src字符串的num个数目合并到dest中。 目标字符串必须足够大 strncmp 1int strncmp(const char* str1,const char* str2,size_t num); 比较到出现另个字符不一样或者一个字符串结束或者num个字符全部比较完 strstr 1char* strstr(const char* str1,const char* str2); 123456789//str2 就是 str1的子字符串(str2是str1 的一部分) char str1[] = "abcdef"; char str2[] = "ccc"; //返回的p的指针就只想str1中第一个c的位置 //strstr就是在判定和查找 str2 是否是 str1的子字符串 //判定str1 是否包含 str2 char* p = strstr(str1,str2); printf("%p\n",p); 123456789101112131415161718192021222324//判定str2是不是str1的子字符串 const char* Strstr(const char* str1,const char* str2)&#123; assert(str1 != NULL); assert(ser2 != NULL); //如果str2是空字符串，就没有比较的必要了 if(*str2 == '\0' || *str1 == '\0')&#123; return NULL; &#125; const char* black_ptr = str1; while(*black_ptr != '\0')&#123; const char* sub_ptr = str2; const char* red_ptr = black_ptr; while(*red_ptr != '\0' &amp;&amp; *sub_ptr != '\0' &amp;&amp;(*red_ptr == *sub_ptr))&#123; ++sub_ptr; ++red_ptr; &#125; if(*sub_ptr == '\0')&#123; //说明找到了子串,需要返回一个指向str1的位置。 return black_ptr; &#125; ++black_ptr; &#125; return NULL; &#125; strtok 1char* strtok(char* str,const char* sep); sep参数是个字符串，定义了用作分隔符的字符集合 第一个参数指定了一个字符串，它包含了0个或者多个由sep字符串中一个或者多个分隔符分割的标记。 strtok函数找到str中的下一个标记，并将其用\0结尾，返回一个指向这个标记的指针， strtok函数的第一个参数不为NULL,函数将找到str中第一个标记，strtok函数将保存它在字符串中的位置 strtok函数的第一个参数为NULL,函数将在同一个字符串中被保存的位置开始，查找下一个标记 如果字符串中不存在更多的标记，则返回NULL指针 123456789101112//基于strtok进行封装，让 strtok 使用起来更简单一些 //返回值的含义相当于切分出来的 token 的个数 int Split(char* input,const char* split_char,char* output[])&#123; int output_index = 0; char* p = strtok(input,split_char); while(p != NULL)&#123; output[output_index] = p; ++output_index; p = strtok(NULL,split_char); &#125; return output_index; &#125; strerror 12#include &lt;errno.h&gt;char* strerror(int errnum); 返回错误码，所对应的错误信息 strerro函数是吧错误码转为错误提示信息 errno中，不同的数值代表不同的错误 与内存相关的函数memcpy 1void* memcpy(void* dest,const void* src,size_t num); 函数memcpy从src的位置开始向后复制num个字节的数据到dest的内存位置。 这个函数在遇到&#39;\0&#39;的时候并不会停下来。 如果src和dest有任何的重叠，复制的结果都是未定义的。 12345678910111213//返回值也是dest void* Memcpy(void* dest,const void* src,size_t num)&#123; assert(dest != NULL ); assert(src != NULL); char* pdest = (char*)dest; char* psrc = (char*)src; size_t i = 0; for(;i &lt; num; ++i)&#123; pdest[i] = psrc[i]; &#125; //不需要设置'\0' return dest;&#125; memmove 1void* memmove(void* dest,const void* src,size_t num); 和memcpy的差别就是memmove函数处理的源内存块和目标内存块是可以重叠的。 如果源空间和目标空间出现重叠，就得使用memmove函数处理。 1234567891011121314151617void* Memmove(void* dest,const void* src,size_t num)&#123; assert(dest != NULL); assert(src != NULL); char* pdest = (char*)dest; char* psrc = (char*)src; if(pdest &gt;= psrc &amp;&amp; pdest &lt; psrc + num)&#123; //这是标准库认为的缓冲区重合 //特殊进行处理 int64_t i = 0; for(i = num - 1;i &gt;= 0;--i)&#123; pdest[i] = psrc[i]; &#125; &#125;else&#123; Memcpy(dest,src,num); &#125; return dest; &#125; memcmp 1int memcmp(const void* ptr1,const void* ptr2,size_t num); 比较从ptr1和ptr2指针开始的num个字节。 使用方法与strncpy非常类似。]]></content>
      <tags>
        <tag>进阶C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进阶C-指针的进阶]]></title>
    <url>%2F2019%2F01%2F16%2F%E8%BF%9B%E9%98%B6C-%E6%8C%87%E9%92%88%E7%9A%84%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[指针之前有个初阶的总结，这次到了进阶。里面有更多的，更坑的地方。并且涉及到了各种指针。 字符指针在指针的类型中我们知道有一种指针类型为字符指针char* 一般使用： 123456int main()&#123; char ch = 'w'; char *pc = &amp;ch; *pc = 'w'; return 0;&#125; 对于某一指针p，指向的是单个字符。并且指向的不是字符串，就不能使用strlen。 强行使用strlen就会内存访问越界，此时就是未定义行为了。 指针数组指针数组是一个存放指针的数组。数组的每一个元素是一个指针 例如：int* arr[5]，这就是个指针数组 数组指针数组指针就是一个指针。指向的元素是整个数组 例如：int (*arr)[5]，这就是个数组指针，这个指针的类型 int(*)[5] &amp;数组名VS数组名arr是数组名，数组名表示数组首元素的地址。int*类型的变量 &amp;arr是数组指针。 ‘房间号’是相同的，但是类型不同 函数指针(第二重要)123456789101112int Func()&#123; printf("hehe\n"); return 10; &#125; //()函数调用操作符 int main()&#123; //Func 也就是函数指针了 printf("%p\n",Func); printf("%d\n",Func()); return 0; &#125; Func打印出来的就是当前函数存放的地址 在指针中，void*不能解引用。但是函数指针可以。 对于函数指针来说，最重要的操作是调用() int (*p)() = Func;，此时定义了一个指针变量p，p的类型 int(*)() 函数指针数组把函数的地址存到一个数组中，那这个数组就叫函数指针数组 123int (*parr1[10]])();int *parr2[10]();int (*)() parr3[10]; 只有第一种写法算比较科学，但是还是推荐用typedef来描述 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;int add(int a, int b)&#123; return a + b;&#125;int sub(int a, int b)&#123; return a - b;&#125;int mul(int a, int b)&#123; return a*b;&#125;int div(int a, int b)&#123; return a / b;&#125;int main()&#123; typedef int(*T)(int,int); T arr[] = &#123; Add, Sub, Mul, Div &#125;; arr[choice - 1](10,20); return 0;&#125; 这是利用函数指针数组来实现 回调函数回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应 123456void Swap(int* x,int* y)&#123; int tmp = *x; *x = *y; *y = tmp; &#125; //is_desc =&gt; 1降序排序 0升序排序 通过调用一个开关进行排序 12345678910111213141516171819202122void BubbleSort(int arr[],int size,int is_desc)&#123; //[0,bound)已排序区间 //[bound,size)待排序区间 int bound = 0; for(bound = 0; bound &lt; size; ++bound)&#123; //反着循环是为了每次找到一个最小的元素并且放&gt; 到合适的位置上 int cur = 0; for(cur = size - 1;cur &gt; bound; --cur)&#123; if(is_desc == 1)&#123; if(arr[cur - 1] &gt; arr[cur])&#123; //这个条件其实就是在描述排序规则 //这两个相邻元素不符合排序规则，需要交换 Swap(&amp;arr[cur - 1],&amp;arr[cur]); &#125;else if(is_desc == 0)&#123; if(arr[cur - 1] &gt; arr[cur])&#123; Swap(&amp;arr[cur - 1],&amp;arr[cur]); &#125; &#125; &#125; &#125; &#125; &#125; 通过回调函数来进行冒泡排序 123456789101112131415161718192021222324252627282930313233343536373839404142typedef int(*T)(int x,int y); //参数中引入一个函数指针，这个函数指针描述了排序&gt; 规则 //排序规则可能会非常复杂，根据实际情况可能要考虑&gt; 很多很多方面 int Less(int x,int y)&#123; return x &lt; y ? 1 : 0; &#125; int Greater(int x,int y)&#123; return x &gt; y ? 1 : 0; &#125; int AbsLess(int x,int y)&#123; return fabs(x) &lt; fabs(y) ? 1 : 0; &#125;void BubbleSort2(int arr[],int size,T cmp)&#123; //[0,bound)已排序区间 //[bound,size)待排序区间 int bound = 0; for(bound = 0; bound &lt; size; ++bound)&#123; //反着循环是为了每次找到一个最小的元素并且放&gt; 到合适的位置上 int cur = 0; for(cur = size - 1;cur &gt; bound; --cur)&#123; if(cmp(arr[cur - 1] ,arr[cur]) == 0)&#123; //这个条件其实就是在描述排序规则 //这两个相邻元素不符合排序规则，需要交换 Swap(&amp;arr[cur - 1],&amp;arr[cur]); &#125; &#125; &#125; &#125;int main()&#123; int arr[5] = &#123;0&#125;; //升序 BubbleSort2(arr,5,Less); //降序 BubbleSort2(arr,5,Greater); //元素的绝对值升序排序 BubbleSort2(arr,5,AbsLess); //回调函数函数调用时机不是由调用者来决定，而是&gt; 由操作系统或者由代码框架来决定。return 0;&#125; 接着就是之前在指针初阶的总结中一部分超坑的打印题 附上链接，拉到底部即可 接着还有一些超坑的指针代码块！ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172int main()&#123; int a[5] = &#123; 1, 2, 3, 4, 5 &#125;; int *ptr = (int *)(&amp;a + 1); printf( "%d,%d", *(a + 1), *(ptr - 1)); //结果为2，5 int a[4] = &#123; 1, 2, 3, 4 &#125;; int *ptr1 = (int *)(&amp;a + 1); int *ptr2 = (int *)((int)a + 1);//需修改 printf( "%x,%x", ptr1[-1], *ptr2); //ptr1是指针数组+1，跳过了这个数组，那么-1就是向前取一位，也就是4 //对于ptr2，假设a对应地址 0x ff ff ff ff 00 00 00 01 64位地址 //0x 00 00 00 01 强转成int 占4个字节 //0x 00 00 00 02 再+1 //0x 00 00 00 00 00 00 00 02 再转为int*，所以再64位机子上，int的高位被截断，转没了，所以改为long，能正常显示 int a[3][2] = &#123; (0, 1), (2, 3), (4, 5) &#125;; int *p; p = a[0]; printf( "%d", p[0]); //这里涉及到了逗号表达式，整个表达式的值为最后一个表达式的值。 //所以数组的初始化应为&#123;1，3，5，0，0，0&#125; int a[5][5]; int(*p)[4]; p = a; printf( "a_ptr=%#p,p_ptr=%#p\n" , &amp;a[4][2], &amp;p[4][2]); printf( "%p,%d\n", &amp;p[4][2] - &amp;a[4][2], &amp;p[4][2] - &amp;a[4][2]); //内存分布见图一 //a与p的内存之间从对其，到逐渐有了差值 int aa[2][5] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &#125;; int *ptr1 = (int *)(&amp;aa + 1); int *ptr2 = (int *)(*(aa + 1));//相当于aa[1]强转成int*，就是指向6的指针 printf( "%d,%d", *(ptr1 - 1), *(ptr2 - 1)); char *a[] = &#123;"work","at","alibaba"&#125;;//数组指针 char** p = a;//将a数组中的首元素地址放在p指针中 p++;//根据数据类型，+4个字节，这时候指针刚好指向了第二个元素 printf("%s\n", *p);//再解引用，此时得到就是 “at” char *c[] = &#123;"ENTER","NEW","POINT","FIRST"&#125;; char**cp[] = &#123;c+3,c+2,c+1,c&#125;; char***cpp = cp; printf("%s\n", **++cpp);//打印point printf("%s\n", *--*++cpp+3); printf("%s\n", *cpp[-2]+3); printf("%s\n", cpp[-1][-1]+1); //内存见图二 //第一个打印 ++ =&gt; cpp &amp;&amp;p3 * =&gt; &amp;p3 * =&gt; p3 //第二个打印 //运算顺序是 ++ * -- * + ++ =&gt; &amp;&amp;p2 * =&gt; &amp;p2 此时相当于重新定义了一个指针指向p2元素的地址 -- =&gt;p2移动，位&amp;p1 * =&gt; p1 +3 =&gt; "ENTER",指向了第三个字符之后的 //第三个打印 //运算顺序 [] * + [-2] =&gt; 先减2在解引用，cpp指针由之前此时指向&amp;p2，-2得到的是&amp;p4 * =&gt; p4 +3 =&gt; ‘ST’ //第四个打印 [-1] =&gt; &amp;p3,相当于有另个指针指向了p3 [-1] =&gt; p3-1，就相当于p2 +1 =&gt; 'EW' return 0;&#125; 图一： 图二：]]></content>
      <tags>
        <tag>进阶C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进阶C-数据的存储]]></title>
    <url>%2F2019%2F01%2F07%2F%E8%BF%9B%E9%98%B6C-%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[就目前来看，C++和JAVA的选择我选择了前者。 大家都说是Hard模式，但是自己不尝试，不努力又怎么知道能否成功呢！ 所以再一次开始了C语言的进阶。这几部分总结完之后，我想就能开始C++的真正学习了！ C语言好学但又不好学。首先是因为C语言的语法比较固定，是可以很快理解的。但是C中有一个关键的地方，就是涉及到内存。因为C++追求的性能的极致。这就有了许多坑。 整型在内存中的存储首先说到内存了，那么第一个需要考虑的还是在当前系统中，数据的存储模式。到底是大端还是小端。这里又要讨论到 大端模式：是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中 如：0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x0a 0a是低位，因为在16进制中表示10，应为00 00 00 0a这个样子。 低地址—————————————————–高地址 我们一般写数据也喜欢00 00 00 0a。 小端模式：是指数据的低位保存在内存低地址中，而数据的低位，保存在内存的高地址中 如：0x0a 0x00 0x00 0x00 0x00 0x00 0x00 0x00 低地址—————————————————–高地址 以上只是一个正整数在内存的表示方式。如果是负数呢？ 这个时候就要考虑原码，补码，反码这三种的转换情况了 原码：直接将二进制按照正负数的形式翻译成二进制就可以。 反码：将原码的符号位不变，其他位依次按位取反就可以得到了。 补码：反码+1就得到补码。正数的原/反/补码都相同 在转换过程中，约定一个整数的最高位为符号位。正数为0，负数为1。 对于整型来说：数据存放内存中其实存放的是补码 但为什么我们需要搞一个补码？对人来说，原码不是更直观吗 这是为了方便计算机的计算来使用。计算机的内部表示都是用二进制来表示，那不管加减乘除都用补码，这样不就转换成了全是加法的运算吗。减法也只不过是加上一个负数 12345678910111213141516171819202122//检验大小端#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;//如果是大端，返回0//如果是小端，返回1//非常重要！！校招总是爱考int IsLittleEnd()&#123; int a = 0x11223344; char* b = (char*)&amp;a; if (*b == 0x11)&#123;//检查低地址的内容是否是数字的高位 return 0; &#125; return 1;&#125;int main()&#123; int a = -10; printf("%d\n",a); //printf("%d\n",IsLittleEnd()); return 0;&#125; 数据在内存中具有一定的存储形式，存储同样的内容，可以按照不同的方式来理解 比如在unsigned char a = -1，这打印出来的即为255。因为-1在内存中表示为0xff，有时无符号此时就不管负号了。这之后0xff表示的就是255，所以打印出来不再是-1，就是255。 如果两个数据在内存中存储的形式是相同的，再按照相同的方式来理解，结果也肯定是相同的 char = 128和char = -128 在printf（“%u”)打印下都是一样的 123int i = -20;unsigned j = 10;printf("%d",i+j); 在这里又要碰到隐式转换。某个操作数属于不同的类型，那么除非其中一个操作数的转换为另一个操作数的类型，否则操作就无法进行。下面的层次体系为寻常算术转换 1234567long doubledoublefloatunsigned long intlong intunsigned intint 如果某个操作数的类型在上面这个列表中排名较低，那么首先要转换为另一个操作数的类型后执行选择。比如int要转换成unsigned int，低类型要向高类型转换。 又因为打印为’%d’，是有符号的打印，所以我们最后为-10。 所以无符号整型在计算减法时很容易溢出。能不用无符号整数，就不用无符号，有符号整数来代替。 浮点型在内存中的存储浮点型在内存中的分配中是根据国际标准IEEE754来定义的。 (-1)^S M 2^E (-1)^s表示符号位，当s=0，V为正数；当s=1，V为负数。 M表示有效数字，大于等于1，小于2。 2^E表示指数位。 举例来说：十进制的5.0，写成二进制是101.0，相当于1.01x2^2 那么，s=1，M=1.01，E=2 不能拿两个浮点数直接比较相等，浮点数的存储是存在误差的。因为在浮点数的存储中，如果是无限循环小数，数字超过了能存储的位数之后就不能在存储进去了。这样计算之后也无法得到准确的值 能不用浮点数，就不用浮点数。]]></content>
      <tags>
        <tag>进阶C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统之进程调度]]></title>
    <url>%2F2019%2F01%2F05%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[这周学校布置了关于操作系统的知识点论文，正好也写篇博客来好好分析一下关于进程调度的知识点。 调度的基本概念在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程。处理机调度，就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行。 调度的三个层次高级调度由于内存空间有限，有时无法将用户的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序。 高级调度（作业调度）。按一定的原则从外存上处于后备队列的作业中挑选一个（或多个）作业，给他们分配内存等必要资源，并建立相应的进程（建立PCB），以使它们获得竞争处理机的权利。高级调度使辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。 中级调度暂时调到外存等待的进程状态为挂起状态。值得注意的是，PCB并不会一起调到外存，而是会常驻内存。PCB中会记录进程数据在外存中存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到的挂起队列中。 中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存。 一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。 低级调度低级调度（进程调度），其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。 进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。 进程调度的频率很高，一般几十毫秒一次。 要做什么 调度发生在.. 发生频率 对进程状态的影响 高级调度 按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程 外存→内存 最低 无→创建态→就绪态 中级调度 按照某种规则，从挂起队列中选择合适的进程将其数据调回内存 外存→内存 中等 挂起态→就绪态 低级调度 按照某种规则，从就绪队列中选择一个进程为其分配处理机 内存→CPU 最高 就绪态→运行态 进程调度的方式非抢占方式只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。 抢占方式当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。 进程调度中的这两种方式决定了调度中时间的改变。 调度算法的评价指标CPU利用率 = 忙碌的时间/总时间 系统吞吐量 = 总共完成了多少道作业/总共花了多少时间 周转时间 = 作业完成时间 - 作业提交时间（到达时间） 平均周转时间 = 各作业周转时间之和 / 作业数 带权周转时间 = 作业周转时间/作业实际运行的时间 平均带权周转时间 = 各作业带权周转时间之和/作业数 这些名词可以衡量一个进程调度过程中，是否能达到一个高效的过程。时间的分配是否合理。但是这些也并不是都是绝对的。因为考虑到有些进程的调度有其他因素的考虑，所以我们只是将其作为一个参考。 调度算法先来先服务（FCFS）先来先服务算法：主要从“公平”的角度考虑（类似于我们生活中排队买东西的例子）。一种非抢占式的算法。 它主要按照作业/进程到达的先后顺序进行服务。等待时间越久的越优先得到服务。用于作业调度时，考虑的是哪个作业先到达后备队列；用于进程调度时，考虑的是哪个进程先到达就绪队列。对长作业有利，对短作业不利 进程 到达时间 运行时间 P1 0 7 P2 2 4 P3 4 1 P4 5 4 调度顺序为：P1→P2→P3→P4 短作业优先（SJF）短作业优先算法：追求最少的平均等待时间，最少的平均周转时间，最少的平均带权周转时间。所谓“最短”就是要求服务时间最短。即可用于作业调度，也可用于进程调度。它具有非抢占式和抢占式。 非抢占式：每次调度时选择已到达且运行时间最短的作业/进程 抢占式(最短剩余时间优先算法)：每当有进程加入就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列，另外，当一个进程完成时也需要调度。 调度顺序为：P1→P3→P2→P4 高响应比优先（HRRN）高响应比优先算法：要综合考虑作业/进程的等待时间和要求服务的时间 在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务。 响应比 = （等待时间 + 要求服务时间）/ 要求服务时间（响应比 &gt;= 1) 即可作业调度也可进程调度。它是一种非抢占式的算法。因此只有当前运行的作业/进程主动放弃处理机（CPU）时，才需要调度，才需要计算响应比。调度时计算所有就绪进程的响应比，玄响应比最高的进程上处理机。看下面例子： 进程 到达时间 运行时间 P1 0 7 P2 2 4 P3 4 1 P4 5 4 0时刻：只有P1到达就绪队列，P1上处理机 7时刻（P1主动放弃CPU）：就绪队列中有P2（响应比=（5+4）/4=2.25）、P3((3 + 1) / 1 =3)、P4((2 + 4)/4 = 1.5），P3的响应比高，所以P3上处理机 8时刻（P3完成）：P2（2.5），p4（1.75）P2高，P2上处理机 12时刻（P2完成）：就绪队列中只剩下P4.这时候P4上处理机 算法 可抢占？ 优点 缺点 考虑到等待时间&amp;运行时间 会导致饥饿？ FCFS 非抢占 实现简单 对短作业不利 1，0 不会 SJF/SPF 默认为非抢占式，但也有抢占式 最短的平均等待/周转时间 对长作业不利，可能导致饥饿；难以做到真正的短作业优先 0，1 会 HRRN 非抢占 上述两种算法的权衡折中，综合考虑的等待时间和运行时间 1，1 不会 注：1为考虑到，0为没有考虑到 以上这三种算法一般适合于早期的批处理系统。下面的算法适合于交互式系统的调度算法。 时间片轮转调度算法时间片轮转算法：公平地、轮流地为各个进程服务，让每个进程在一定时间隔内都可以得到响应。按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms），若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。 只用于进程调度，只有作业放入内存建立了相应的进程后，才能被分配处理机时间片。该算法也属于抢占式算法，由时钟装置发出时钟中断，来通知CPU时间片已到。轮流让就绪队列中的进程依次执行一个时间片（每次选择的都是排在就绪队列队头的进程）。 进程 到达时间 运行时间 P1 0 5 P2 2 4 P3 4 1 P4 5 6 时间片的大小为2。 0时刻(P1(5)):0时刻只有P1到达就绪队列，让P1上处理机运行一个时间片 2时刻(P2(4)→P1(3))：2时刻P2到达就绪队列，P1运行完一个时间片，被剥夺处理机，重新放到队尾。此时P2排在队头，因此让P2上处理机。(注意：2时刻，P1下处理机，同一时刻新进程P2到达，如果在题目中遇到这种情况，默认新到达的进程先进入就绪队列) 4时刻(P1(3)→P3(1)→P2(2)):4时刻，P3到达，先插到就绪队尾，紧接着，P2下处理机也插到队尾 5时刻(P3(1)→P2(2)→P4(6)):5时刻，P4到达插到就绪队尾(注意：由于P1的时间片还没用完，因此P1重新排到就绪队列之后，等到执行) 6时刻(P3(1)→P2(2)→P4(6)→P1(1)):6时刻，P1时间片用完，下处理机，重新放回就绪队尾，发生调度 7时刻(P2(2)→P4(6)→P1(1))：虽然P3的时间片没用完，但是由于P3只需运行1个单位的时间，运行完了会主动放弃处理机，因此也会主动放弃处理机，因此也会发生调度。队头进程P2上处理机。 9时刻(P4(6)→P1(1))：进程P2时间片用完，并刚好运行完，发生调度，P4上处理机 11时刻(P1(1)→P4(4))：P4时间片用完，重新回到就绪队列，P1上处理机 12时刻(P4(4))：P1运行完，主动放弃处理机，此时就绪队列中只剩P4，P4上处理机 14时刻()：就绪队列为空，因此让P4接着运行一个时间片 16时刻：所有进程运行结束 优先级调度算法优先级调度算法：每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程。即可用于作业调度，也可用于进程调度。 非抢占式：只需在进程主动放弃处理机时进行调度即可，每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度 抢占式：需要在就绪队列变化时，检查是否会发生抢占。每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度。另外，当就绪队列改变时也需要检查是否会发生抢占。 0时刻(P1):只有P1到达，P1上处理机 2时刻(P2)：P2到达就绪队列，优先级比P1更高，发生抢占。P1回到就绪队列，P2上处理机 4时刻(P1、P3)：P3到达，优先级比P2更高，P2回到就绪队列，P3抢占处理机 5时刻(P1、P2、P4):P3完成，主动释放处理机，同时，P4也到达，由于P2比P4更先进入就绪队列，因此选择P2上处理机 7时刻(P1、P4):P2完成，就绪队列只剩P1、P4，P4上处理机。 11时刻(P1):P4完成，P1上处理机。 就绪队列未必只有一个，可以按照不同优先级来组织，另外，也可以把优先级高的进程排在更靠近队头的位置。 以上就是关于操作系统进程调度的基本定义和算法。毕竟CPU是计算机的核心，它具有对我们的进程进行分配的一个过程。可以看作是OS中关键的部分。比如我们日常生活中又想听歌又想敲代码。这时候我们的CPU就要对我们的这个行为进行一个分配管理。通过一个学期的学习，OS让我更加对计算机和编程有了更大兴趣。也真的更加看到了自己的不足。想真正成为一个大佬还差得十万八千里呢。所以，从现在脚踏实地的做起吧。]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim操作总结]]></title>
    <url>%2F2019%2F01%2F03%2Fvim%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[之前学了Linux，用了vim之后发现特别强大。这一周又在做串口实验，我又用的Linux做的，再一次感觉到vim的强大。但是在写代码的过程中，因为快捷键没有记住，所以并不流畅。所以这周闲了，赶快来总结一下。 首先通过指令 vimtutor 进入到vim新手教程。 Kana大神说过，对vim的掌握有五个层次： 层次0： 对vim一无所知 层次1： 了解vim的基本使用 层次2： 知道可视模式 层次3： 知道多种移动动作 层次4： 不再需要可视模式 说实话，我目前只能说在层次0.5（哈哈哈哈哈哈哈哈哈）。因为我了解但是基本操作都不记得 文本基本编辑移动光标这个操作比较基础，上下左右的使用，打破了使用方向键的惯性习惯。不是说不能使用方向键，而是编辑器特有的操作方式。 h：代表光标左移 l：代表光标右移 j：代表光标下移 k：代表光标上移 进入与退出输入vimtutor进入教程，退出或者需要其他指令时，先使用ESC键。然后:q!退出。 文本删除将光标移至需要删除的字符处，按下x键 文本插入将光标移至第一个准备插入字符的位置，按下i键 文本添加将光标移至需要插入的位置，按下a键 文本保存并退出按下ESC进入正常模式，然后:wq按键操作，即可退出并保存。 删除命令使用dw可以从光标处删除至一个单词的结尾 使用d$可以从当前光标删除至行末 使用de可以从当前光标删除到单词末尾，包括最后一个字符 计数动作输入2w使光标向前移动两个单词 输入3e使光标向前移动到第三个单词的末尾 输入0移动光标到行首 计数动作删除d+number+motion 例如输入d2w删除光标后面两个单词 输入dd可以直接删除掉整行 输入2dd可以直接删除两行 撤销类命令重要的说三遍 ctrl组合键，按住ctrl不放+操作按键 ctrl组合键，按住ctrl不放+操作按键 ctrl组合键，按住ctrl不放+操作按键 输入x删除字符之后，利用u来撤销最后一次的执行命令（类比于Windows下的ctrl-z） 利用U恢复该行的原始状态 利用CTRL-R撤销掉撤销命令（类比于Windows下的crtl-y） 置入类命令输入p将最后一次删除的内容置入光标之后 将光标移动到需要更改的位置，输入r之后在输入一个我们需要替换的字符，就可以完成更改 如果要改变文本中的一个单词，先将光标移动到错误单词处，按下cw键，然后输入正确的单词 如果要改变文本中的更多单词，先将光标移动到错误单词处，按下c$键，然后输入你想输入的 定位及文件状态定位文件关键位置按下CTRL-g此时我们在vim编辑框最底部，可以查看到一个状态信息行。记住这个行号！！ 按下gg跳至文件最开头，按下G跳至文件最底部 输入你想要返回的 行号+G，可以返回第一次按下ctrl-g时所在的行了 搜索类命令跟：命令相似，输入/,加上你所要查找的关键字符，就可以查找到。 按键n查找同上一个字符，按键N查找同下一个字符（可称为逆向查找） 配对括号查找（好用）输入%可以查找配对的括号)、]、} 替换命令将光标移到需要改变的一行。输入:s/错误字符/修改字符，只替换第一个匹配串 若是:s/错误字符/修改字符/g替换全行的字符串 若是:#,#s/错误字符/修改字符#，#代表的是替换若干行的首尾两行 若是:%s/错误字符/修改字符/g替换整个文件的每个匹配串 若是:%s/错误字符/修改字符/gc替换整个文件的每个匹配串，但是会进行提示，是否进行替换 vim内执行外部指令输入:!+你所需要的外部指令（LINUX具有的）比如:!dir 对文件的改动保存到文件中输入w FILENAME保存到文件中 可视模式（超关键）按 v 键使 Vim 进入可视模式进行选取。您可以四处移动光标使选取区域变大或变小。 接着您可以使用一个操作符对选中文本进行操作。例如，按 d 键会删除选中的文本内容。 提取和合并文件:r FILENAME 可提取磁盘文件 FILENAME 并将其插入到当前文件的光标位置后面。 打开类命令光标移动到想要添加的上一行，按下o键，可以打开新的一行，进行编辑 附加类命令输入 a 将可在光标之后插入文本。 a、i 和 A 都会带您进入插入模式，惟一的区别在于字符插入的位置。 另一个置换类命令的版本移动光标到需要更改的位置，输入按键R，就可以连续更改了，按ESC退出 复制粘贴文本（绝对是最需要的！！！！！！！！）先按键v进入可视模式，对需要复制的部分进行选取。选取完之后，按y进行复制拷贝。 在移动光标到我们需要复制的位置，按p进行粘贴。 设置类的选项设置可使查找或者替换可忽略大小写的选项 输入:set ic可以忽略大小写。输入:set noic禁用大小写 输入:set incsearch,查找短语时显示部分匹配 输入:set hlsearch,高亮显示所有的匹配短语 关于vim获取帮助，输入:help或者按下F1。 创建启动脚本Vim 的功能特性要比 Vi 多得多，但其中大部分都没有缺省启用。为了使用更多的特性，您得创建一个vimrc 文件。 开始编辑 vimrc 文件，具体命令取决于您所使用的操作系统： `:edit ~/.vimrc` 这是 Unix 系统所使用的命令 `:edit $VIM/_vimrc ` 这是 MS-Windows 系统所使用的命令 接着读取 vimrc 示例文件的内容：:r $VIMRUNTIME/vimrc_example.vim 保存文件，命令为：:write 以上就是vim的基本操作。这些掌握了，用起来就特别方便啦。还是那句话，操作不能靠背的。需要多练。换句话说，多敲代码就行啦！！！！！]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初阶C-1201]]></title>
    <url>%2F2019%2F01%2F01%2F%E5%88%9D%E9%98%B6C-1201%2F</url>
    <content type="text"><![CDATA[1.调整数组使奇数全部都位于偶数前面。 题目：输入一个整数数组，实现一个函数，来调整该数组中数字的顺序使得数组中所有的奇数位于数组的前半部分，所有偶数位于数组的后半部分。 123456789101112131415161718192021void reverse_array(int a[],int n)&#123; //数组的两头分别向中间检索 int left = 0; int right = n - 1; while(left&lt;right)&#123; //从左开始查找数是偶数的 while(left &lt; right &amp;&amp; (a[left] % 2) != 0)&#123; left++; &#125; //从右开始查找是奇数的 while(right &lt; left &amp;&amp; (a[right] % 2) == 0)&#123; right++; &#125; while(left &lt; right)&#123; a[left] = a[left] ^ a[right]; a[right] = a[left] ^ a[right]; a[left] = a[left] ^ a[right]; //利用异或的方式进行交换数 &#125; &#125;&#125; 2.杨氏矩阵有一个二维数组. 数组的每行从左到右是递增的,每列从上到下是递增的. 在这样的数组中查找一个数字是否存在. 时间复杂度小于O(N); 数组： 1 2 3 / 1 3 4 / 1 2 3 2 3 4 / 2 4 5 / 4 5 6 3 4 5 / 4 5 6 / 7 8 9 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 //从右上角开始搜索 //key &gt; a[i][j] --&gt; 向左搜索 //key &lt; a[i][j] --&gt; 向下搜索 //从左下角开始搜索 //key &lt; a[i][j] --&gt; 向右搜索 //key &gt; a[i][j] --&gt; 向上搜索int main()&#123; int a[3][3] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9 &#125;; int n; int px, py; scanf("%d", &amp;n); if (find(a, 3, 3, n, &amp;px, &amp;py))&#123; printf("%d,%d", px, py); &#125; else&#123; return 0; &#125;&#125;void find(int a[3][3],int row,int col,int key,int *px,int *py)&#123; //从右上角开始搜索 int x = 0; int y = col - 1; //左下角搜索结束 //x &gt;= row;y &lt; 0; while(x &lt; row &amp;&amp; y &gt;= 0)&#123; if(a[x][y] == key)&#123; *px = x; *py = y; return 1; &#125; else if(a[x][y] &gt; key)&#123; //向左搜索 y--; &#125; else&#123; x++; &#125; &#125; *px = -1; *py = -1; return 0; //如果都没有搜索到，就将其赋予一个不存在的值，直接返回0；&#125;void find_r(int a[3][3],int row,int col,int x,int y,int key,int *px,int *py)&#123; //从左下角开始搜索,利用递归的写法 //因为是递归循环，所以没有循环，我们需要记住此时是在哪个位置 //所以我们定义了参数x，y if(x &lt; 0 || y &gt; col)&#123; return 0; &#125; if(key &gt; a[x][y])&#123; return find_r(a, row, col, x, y + 1, key, px, py); &#125; else if(key &lt; a[x][y])&#123; return find_r(a, row, col, x - 1, y, key, px, py); &#125; else if(key == a[x][y])&#123; *px = x; *py = y; return 1; &#125;&#125; 初阶C已结束！接下来就是进阶了！加油！一定要完成自我的进化！]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-对豆瓣的top250的爬取(利用正则表达式)]]></title>
    <url>%2F2018%2F12%2F10%2Fpython-%E5%AF%B9%E8%B1%86%E7%93%A3%E7%9A%84top250%E7%9A%84%E7%88%AC%E5%8F%96%2F</url>
    <content type="text"><![CDATA[之前写了一个猫眼的爬虫的代码。是利用了request()和beautifulsoup()。但是之前的方法是利用了selector的搜索方法。最近学习了一点正则表达式，用正则表达式对豆瓣的top250进行了尝试。 豆瓣一直都是我比较喜欢的一个app，我也很喜欢看电影，你如果喜欢，在我的博客里有我的豆瓣链接，我们可以互粉一下聊聊电影hhhhhh，看得不多，但坚持再看并且写影评。 这次爬取下来top250的数据也非常高兴。 正则表达式的定义正则表达式，又称规则表达式。（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。 1import re python如果要使用正则表达式，首先需要引用re库 re库是一个python中有关于正则表达式的第三方库。因为我们在匹配过程中，也需要一些函数来剔除我们不需要的冗余字符。 正则表达式常用操作符(1) 操作符 说明 实例 . 表示任何单个字符 比如在非贪婪匹配中(.*?) [ ] 字符集，对单个字符给出取值范围 [abc]表示a/b/c，[a-z]表示a到z的单个字符 [^ ] 非字符集，对单个字符给出排除范围 [^abc]表示非a非b非c的单个字符 * 前一个字符0次或无限次扩展 abc*表示为ab/abc/abccc + 前一个字符1次或无限次扩展 abc+表示abc/abcc/abccc ? 前一个字符0次或1次扩展 abc？表示ab/abc &#124; 左右表达式的任意一个 abc &#124; def表示 abc、def 正则表达式的常用操作符(2) 操作符 说明 实例 {m} 扩展前一个字符m次 ab{2}c表示abbc {m,n} 扩展前一个字符m至n次（含n） ab{1,2}c表示abc、abbc ^ 匹配字符串开头 ^abc表示abc且在一个字符串的开头 $ 匹配字符串结尾 abc$表示abc且在一个字符串的结尾 ( ) 分组标记，内部只能使用 &#124; 操作符 (abc)表示abc,(abc &#124; def)表示abc、def \d 数字，等价于[0-9] \w 单词字符，等价于[A-Za-z0-9_] 常用标记 说明 re.I re.IGNORECASE 忽略正则表达式中的大小写，[A-Z]能够匹配小写字符 re.M re.MULTILINE 正则表达式中的^操作符能够将给定字符串的每行当作匹配开始 re.S re.DOTALL 正则表达式中的.操作符能够匹配所有字符，默认匹配除了换行以外的所有字符 以上这些常用的操作符对于爬虫来说是足够的了，我们还需要的是怎么去使用去让其匹配。 正则表达式的练习我用的是anaconda中的jupyter进行练习。 几种常见的匹配方式首先引用这个库，常规操作 1import re 最常规匹配123456content='Hello 123 4567 World_This is a Regex Demo'print(len(content))result=re.match('^Hello\s\d\d\d\s\d&#123;4&#125;\s\w&#123;10&#125;.*Demo$',content)print(result)print(result.group())#group()表示取全部匹配的字符串或者指定的组，返回结果是一个字符串print(result.span())#span()表示返回一个元组包含匹配 (开始,结束) 的位置 输出结果 1234567841&lt;re.Match object; span=(0, 41), match='Hello 123 4567 World_This is a Regex Demo'&gt;Hello 123 4567 World_This is a Regex Demo(0, 41)#这是最常规的匹配，将每一个字符都用操作符#\s 是一个匹配空格 \d 匹配数字 \d&#123;4&#125; 匹配一串数字#.*Demo$ 点用于匹配之前的 *作为前一个字符的匹配与'点'一起 最后用$作为一个匹配字符串的结尾 泛匹配1234content = 'Hello 123 4567 World_This is a Regex Demo'result = re.match('^Hello.*Demo$',content)print(result)print(result.group()) 输出结果 1234&lt;re.Match object; span=(0, 41), match='Hello 123 4567 World_This is a Regex Demo'&gt;Hello 123 4567 World_This is a Regex Demo#泛匹配就比较省略，有前面和后面的字符就行，中间的不需要也可以 匹配目标12345content = 'Hello 1234567 World_This is a Regex Demo'result = re.match('^Hello\s(\d+)\sWorld.*Demo$',content)print(result)print(result.group(1))#为了看看匹配的分组中是否是我所需要的print(result.span()) 输出结果 12345&lt;re.Match object; span=(0, 40), match='Hello 1234567 World_This is a Regex Demo'&gt;1234567(0, 40)#(\d+) \d表示数字, + 表示一个或多个，括号就是将其作为一个分组 接着是两个比较关键的匹配方法 贪婪匹配1234content = 'Hello 1234567 World_This is a Regex Demo'result = re.match('^He.*(\d+).*Demo$',content)print(result)print(result.group(1)) 输出结果 1234567&lt;re.Match object; span=(0, 40), match='Hello 1234567 World_This is a Regex Demo'&gt;7#Python里数量词默认是贪婪的（在少数语言里也可能是默认非贪婪），总是尝试匹配尽可能多的字符#贪婪模式下字符串查找会直接走到字符串结尾去匹配，如果不相等就向前寻找，这一过程称为回溯。#上面的例子可以看出 .* 这样的前后搭配匹配 可以前后尝试尽可能多的匹配字符 非贪婪匹配1234content = 'Hello 1234567 World_This is a Regex Demo'result = re.match('^He.*?(\d+).*Demo$',content)print(result)print(result.group(1)) 输出结果 12345&lt;re.Match object; span=(0, 40), match='Hello 1234567 World_This is a Regex Demo'&gt;1234567#非贪婪则相反，总是尝试匹配尽可能少的字符。在"*","?","+","&#123;m,n&#125;"后面加上？，使贪婪变成非贪婪。#非贪婪模式下会自左向右查找，一个一个匹配不会出现回溯的情况。 匹配模式12345content = '''Hello 1234567 World_Thisis a Regex Demo'''result = re.match('^He.*?(\d+).*?Demo',content,re.S)print(result.group(1)) 匹配模式主要利用了re库中的re.S参数，这样就可以将字符串作为一个整体，在整体中进行匹配。 以上就是关于正则表达式的基本知识。看一下例子，知道大概就足够了。 豆瓣的正则表达式 首先进入豆瓣的top250排行榜，我们首先能看到的就是关于电影的内容。利用chrome浏览器右击检查打开审查元素，我们来观察一下这个网页的html大概构成。 我们将鼠标放到li标签上，可以看到左侧的一片区域都被标记了。说明这一块都是有关《肖申克的救赎》。 一步一步点开这个标签我们将鼠标放到每一个标签之上能看到，每一个标签都有一个与之对应的区域，这个时候我们就需要使用这些标签来构建正则表达式。 我们从每一个标签自上而下看下来。 依次是名次 片名 职员表 类型 星级 评价人数 热门短评这几个 比如名次去匹配 12'&lt;em class=""&gt;(\d+)&lt;/em&gt;'#因为名次是用数字表示的，先将一个标签内的数字用(\d+)来表示 12'&lt;em class=""&gt;(\d+)&lt;/em&gt;.*?&lt;span class=title"&gt;(.*?)&lt;/span&gt;'#当第一个标签完成之后，根据非贪婪匹配的规则 .*? 这样继续根据HTML标签的镶嵌继续向下搜寻。直到span标签结束。中间括号是我们需要匹配的内容 正则表达式的使用还是很简单的，只要找到我们需要的内容，利用非贪婪匹配进行前后选择就好了 下面的是一个已经匹配好的正则表达式。 1'&lt;em class=""&gt;(\d+)&lt;/em&gt;.*?&lt;span class="title"&gt;(.*?)&lt;/span&gt;.*?&lt;p class=""&gt;(.*?)&lt;/p&gt;.*?&lt;span class="rating_num" property="v:average"&gt;(.*?)&lt;/span&gt;.*?&lt;span&gt;(.*?)&lt;/span&gt;.*?&lt;span class="inq"&gt;(.*?)&lt;/span&gt;' 代码获取内容接下来的步骤就与我之前的一篇博文的内容很相似了 python-对猫眼网的top100的爬取 首先需要定义一个函数去获取页面 1234567891011121314import requestsimport reimport jsonfrom requests.exceptions import RequestExceptionimport time#得到网页源代码def get_one_page(url): try: res=resquest.get(url) if res.status_code==200: return res.text return None except RequestException: return None 得到了网页源代码之后，需要利用正则表达式去匹配出我们需要的内容，并将它们放入到一个字典中。 1234567891011121314151617181920212223242526def pares_one_html(html): regex='&lt;em class=""&gt;(\d+)&lt;/em&gt;.*?&lt;span class="title"&gt;(.*?)&lt;/span&gt;.*?&lt;p class=""&gt;(.*?)&lt;/p&gt;.*?&lt;span class="rating_num" property="v:average"&gt;(.*?)&lt;/span&gt;.*?&lt;span&gt;(.*?)&lt;/span&gt;.*?&lt;span class="inq"&gt;(.*?)&lt;/span&gt;' pattern=re.compile(regex,re.S)#re.compile()编译正则表达式模式 items=re.findall(pattern,html)#返回的是一个list对象 for item in items: content="" for every_list in item[2].split(): #split()通过指定分隔符对字符串进行切片，因为职员表处有些标签需要我们进行处理 content=content+"".join(every_list) content=re.sub('&amp;nbsp;',' ',content) content=re.sub('&lt;br&gt;',' ',content) #删除空格和&lt;br&gt;这些多余的部分 #将获取到的list放到dict字典中 dict=&#123; "index":item[0], "name":item[1], "describe":content, "star":item[3], "evaluate":item[4], "title":item[5] &#125; print(dict) #此时先打印看一下，是否数据是正确的 #将数据写入文本中 with open('doubanMovie.txt','a',encoding='utf-8') as f: f.write(json.dumps(dict,ensure_ascii=False)+'\n') 此时还有两个问题，我们此时只是能将第一个页面的数据爬取下来，这时候我们得分析一下这个url在切换页面时，它是怎么变化的。 https://movie.douban.com/top250这是豆瓣top250的第一页 转到第二页，第三页可以看到网页的变化 https://movie.douban.com/top250?start=25&amp;filter= 第二页 https://movie.douban.com/top250?start=50&amp;filter= 第三页 url中的参数start={} 这个数在不断的变化，而且规律是每次隔25个，说明这就是我们需要的。 123456if __name__ == '__main__': urls=['https://movie.douban.com/top250?start=&#123;&#125;&amp;filter='.format(str(i)) for i in range(0,250,25)] for url in urls: html=get_one_page(url) parse_one_html(html) time.sleep(2) 最后将url放在一个列表中，利用for循环去将所有这些网页循环将数据爬取出来。 最后展示一下 python的学习中，爬虫只要有了基本的知识之后就可以慢慢尝试了，而且我觉得爬虫是最容易有自豪感的。 之前对猫眼的爬取用到了基本的Requests和beautifulsoup，接下来还会在写一篇关于Scrapy的基础知识，这个我认为是爬虫的总统山…但是我也还在摸索中 接着刷电影去了….(●’◡’●)]]></content>
      <tags>
        <tag>python-爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初阶C-1124]]></title>
    <url>%2F2018%2F12%2F06%2F%E5%88%9D%E9%98%B6C-1124%2F</url>
    <content type="text"><![CDATA[1.编写函数： unsigned int reverse_bit(unsigned int value); 这个函数的返回值value的二进制位模式从左到右翻转后的值。 如： 在32位机器上 25这个值包含下列各位： 00000000000000000000000000011001 翻转后：（2550136832） 10011000000000000000000000000000 程序结果返回： 2550136832 12345678910111213141516171819202122232425262728unsigned int reverse_bit(unsigned int value)&#123; //第一种方法 unsigned int sum = 0; int i; for(i = 0;i &lt; 32;i++)&#123; sum = sum + ((value &gt;&gt; i) &amp; 1) * pow(2,31 - i); &#125; return sum; //输入任意一个数，进行移位操作并且移位一次还要和1进行一次与操作，这个时候判断最后一个位是1还是0。 //当判断完之后，进行乘方 //第一个数 ----&gt; 32位 2^31 //第二个数 ----&gt; 32位 2^30 //对每一位的数进行了判断之后(判断是为1还是为0)，乘以它的方就是将其转换放在翻转后的位置 //全部相加之后，就是每个翻转之后的位置 //第二种方法 unsigned int temp = 0; int i; for(i = 0;i &lt; 31;i++)&#123; temp = temp &lt;&lt; 1; temp = temp | ((value &gt;&gt; i) &amp; 1); &#125; return temp; //将每一个最后位都取出来 //放在新建变量的最后一位 //左移新建变量temp //我们可以这样理解，我们取出一个变量。让这个变量每次向左移动。这样每次左移之后它的位数都在增加，但是增加之后，仅仅只是增加了位数，具体值的判断再由下一步 //还是依旧判断最后一位是否为1，判断是否为1之后再去与变量进行 或运算。如果是1，那么与完之后的结果为1.否则与完之后的结果为0.并不冲突。位数再增加，但是每次增加的位数还是要进行判断是0还是1.最后将这个变量返回。即为翻转之后的数。&#125; 2.不使用（a+b）/2这种方式，求两个数的平均值。 123456789101112int avg()&#123; int i,j; int num; printf("enter tow numbers\n"); scanf("%d %d",&amp;i,&amp;j); num = (i &amp; j) + (i ^ j) &gt;&gt; 1; printf("%d",num); //不用最常规的写法，那么就是以二进制的角度来思考。 //二进制去求平均数。那么就是让每一位都进行一个求其平均 //&amp; 用来判断相同位的平均值， ^ 用来判断不同位的平均值(不同位进行^运算之后，得的是不同位的值，这时候将其除以2得到的就是不同位的平均值) //之后将它们相加之后，得到就是二进制下的平均数&#125; 3.编程实现： 一组数据中只有一个数字出现了一次。其他所有数字都是成对出现的。 请找出这个数字。（使用位运算） 12345678910void find_num()&#123; int arr[9] = &#123; 5, 5, 2, 4, 8, 9, 8, 4, 9 &#125;; int len = sizeof(arr)/sizeof(arr[0]); for(int i = 1;i &lt; len;i++)&#123; arr[0] = arr[0] ^ arr[i]; &#125; printf("%d",arr[0]); //连续异或，偶数位的最后异或还是为0，但是奇数位的异或最后为1 //所以最后可能出现的只是单独出现的的位数。&#125; 4.有一个字符数组的内容为:”student a am i”, 请你将数组的内容改为”i am a student”. 要求： 不能使用库函数。 只能开辟有限个空间（空间个数和字符串的长度无关）。 student a am i i ma a tneduts i am a student 12345678910int mystrlen(char* str)&#123; //判断字符串的长度 int count = 0; while(*str++)&#123; count++; &#125; return count;&#125;//字符串判定长度，设置的形参为char类型的指针，一个字符串的长度始终都在变化//在输出时，系统先输出字符指针指向的第一个字符数据，然后使指针加1，使之指向下一个，然后再输出……直至遇到字符'\0‘，结束。所以给while的判断是 *str++，指针一个一个的走判断。 1234567891011//逆转指定范围的字符串void reverse_string(char* start,char* end)&#123; while(start &lt; end)&#123; //比如classmate start的字符为‘c’，end的字符则为‘e’ char temp = *start; *start = *end; *end = temp; start++;//字符串指向的位置，从开始不断向后 end--;//才指定范围的字符串，从结尾不断向前 &#125;&#125; 1234567891011121314151617181920void reverse(char* str)&#123; int len = mystrlen(str); char* start = str; char* end = str + len - 1; // len-1是不包括‘\0’ char* cur = str; //整体逆转一次 reverse_string(start,end); //局部逆转 while(*cur != '\0')&#123; char* st = cur; //寻找子串的尾点 while(*cur != ' ' &amp;&amp; *cur != '\0')&#123; cur++;//cur作为一个尾点，我们去寻找cur具体到哪个位置，当为‘ ’和‘\0’之前的一个位置将它作为end，cur最开始的作为st，这样局部的前后就有了，可以交换一次。 &#125; reverse_string(st,cur-1); while(*cur == ' ')&#123; cur++;//在指针走的过程中，如果遇到了' '，则使其跳过，因为这样将不用再去将' '逆转一次。否则会有多余的步骤。 &#125; &#125;&#125; 感觉初阶到了后期难度一下就上来了。考试周结束后，还是得好好敲代码啊。]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之链表]]></title>
    <url>%2F2018%2F12%2F02%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[链表的定义链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 相比于线性表顺序结构，操作复杂。 （百度） 链表：一种链式存储的线性表，用一组地址任意的存储单元存放线性表的数据元素，称存储单元为一个结点。 链表的形式：结点地址{data，next} 链表的形式基本知道后，链表的使用离不开指针。关于指针 和 指针指向的空间 是有区别的 指针不能看成是一个地址，指针是用来存放地址的。指针指向的空间不是地址，是一个还未使用开辟出来的空间。 ps：这之上是去年写了一个开头，今年复习的时候感觉链表的操作围绕头插，尾插，头删，尾删这几个操作来做。还是理解学会这几个操作更好的去理解链表 链表的初始化12345678910111213#pargma once#include &lt;stdio.h&gt;typedef int SLDatatype;typedef struct Node&#123; SLDatatype value; struct Node *next;&#125;typedef struct SList&#123; Node *first;//定义一个头结点&#125; 初始化我个人觉得难点可能在于一开始比较想不通结构体内定义next。结构体调用自己定义一个next指针变量是为了表示链表下一个的指向。在指针域指向下一个链表的指针域。（自行体会） 链表的两种插入12345678//链表的头插void SListPushFront(SList *s, SLDatatype v)&#123; Node *node = (Node*)malloc(sizeof(Node));//插入肯定要开辟一个新空间 node-&gt;value = v; node-&gt;next = s-&gt;first; s-&gt;first = node;&#125; 12345678910111213141516//链表的尾插void SListPushBack(SList *s, SLDatatype v)&#123; Node *node = (Node*)malloc(sizeof(Node)); node-&gt;value = v; if(s-&gt;first == NULL)&#123; s-&gt;first = node; &#125; else&#123; Node *c = s-&gt;first; while(c-&gt;next != NULL)&#123; c = c-&gt;next; &#125; c-&gt;next = node; &#125;&#125; while循环的意义在于找到最后一个结点，当找到最后一个结点之后，将最后一个结点的next指向node 12345678//链表的任意位置插入void SListInsertAfter(Node *pos, SLDataType v)&#123; Node *node = (Node*)malloc(sizeof(Node)); node-&gt;value = v; node-&gt;next = pos-&gt;next; pos-&gt;next = node;&#125; 从这个图中来看在pos结点与后一个结点之间插入一个新结点。让新结点的指向为pos结点的指向，然后让pos结点的指向为新结点。新的结点就被插入之中了。 链表的删除12345678910//链表的头删void SListPopFront(SList *s)&#123; assert(s-&gt;first != NULL); if(s-&gt;first-&gt;next == NULL)&#123; s-&gt;first = NULL; &#125; Node *second = s-&gt;first-&gt;next; free(s-&gt;first); s-&gt;first = second;&#125; 头删很容易理解，分成两种情况。只有一个结点的情况下，直接让头结点为空。如果不是只有一个结点的情况下将头结点指向的下一个结点先标记一下，释放掉头结点，在将标记的结点设为头结点。 12345678910111213141516//链表的尾删void SListPopBack(SList *s)&#123; assert(s-&gt;first != NULL); if(s-&gt;first-&gt;next == NULL)&#123; free(s-&gt;first); s-&gt;first = NULL; &#125; else&#123; Node *c = s-&gt;first; while(c-&gt;next-&gt;next != NULL)&#123; c = c-&gt;next; &#125; free(c-&gt;next); c-&gt;next = NULL; &#125;&#125; 其实仔细看尾删跟尾插有点相似，只不过尾删需要找到倒数第二个结点。然后释放到第一个结点，再将第一个结点赋为空。 123456//链表的任意位置之后结点删除void SListEarseAfter(Node *pos)&#123; Node *next = pos-&gt;next-&gt;next; free(pos-&gt;next); pos-&gt;next = next;&#125; 假设三个结点，先将最后一个结点标记，之后释放掉中间结点，在让第一个结点指向最后一个结点。 链表的另外两种删除与之前顺序表相似的地方，删除遇到的一个链表中的数据域和删除链表中所有的数据域 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849//删除遇到的第一个数据域void SListRemove(SList *s, SLDataType v)&#123; if(s-&gt;first == NULL)&#123; return; &#125; if(s-&gt;first-&gt;value == v)&#123; Node *second = s-&gt;first-&gt;next; free(s-&gt;first); s-&gt;first = second; &#125; else&#123; Node *c = s-&gt;first; while(c-&gt;next != NULL)&#123; if(c-&gt;next-&gt;value == v)&#123; Node *next = c-&gt;next;//先将头结点的后一个结点设为next c-&gt;next = c-&gt;next-&gt;next;//这时候将头结点的后二个结点next转换为头结点的后一个结点 free(next);//释放掉后一个结点 return; &#125; c = c-&gt;next; &#125; &#125;&#125;------------------------------------------------------------------------------------------------//删除遇到的所有数据域void SListRemoveAll(SList *s, SLDataType v)&#123; if(s-&gt;first == NULL)&#123; return; &#125; if(s-&gt;first-&gt;value == v)&#123; Node *next = s-&gt;first; s-&gt;first = s-&gt;first-&gt;next; free(next); &#125; else&#123; Node *c = s-&gt;first; while(c-&gt;next != NULL)&#123; if(c-&gt;next-&gt;value == v)&#123; Node *next = c-&gt;next; c-&gt;next = c-&gt;next-&gt;next; free(next); &#125; else&#123; c = c-&gt;next;//用到else是如果不等于数据域的话就继续向后走，再到下一个结点去判断数据域 &#125; &#125; &#125;&#125; 上面代码其实很相似，只不过要考虑差距在哪，其实就是调用了几个不同的判断语句。 链表的核心就是这些了。我认为这些如果不能理解一定多画图！！！！画图太有助于理解了！！！！ 而且必须多敲代码！！！！我都敲了好几遍！！！！终于在今天写起来比较顺手了！！！！]]></content>
      <tags>
        <tag>C-数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初阶C-1121]]></title>
    <url>%2F2018%2F11%2F27%2F%E5%88%9D%E9%98%B6C-1121%2F</url>
    <content type="text"><![CDATA[1.写一个函数返回参数二进制中 1 的个数 ，比如：15 —&gt; 0000 1111 中4个1。 12345678910int count_one_bits(unsigned int value)&#123; int count = 0; for (int i = 0; i &lt; 32; i++)&#123; if (((value &gt;&gt; i) &amp; 1) == 1)&#123; count++; &#125; &#125; printf("%d\n", count); // 返回 1的位数 &#125; 2.获取一个数二进制序列中所有的偶数位和奇数位,分别输出二进制序列。 1234567891011121314151617int Print_col(unsigned int value)&#123; //二进制的奇偶数位是从低位0123456开始算起 int odd;//奇数 int even;//偶数 printf("偶数的序列:"); for (int i = 0; i &lt; 32; i += 2)&#123; even = (value &gt;&gt; i) &amp; 1; printf("%d ", even); &#125; printf("\n"); printf("奇数的序列:"); for (int j = 1; j &lt; 32; j += 2)&#123; odd = (value &gt;&gt; j) &amp; 1; printf("%d ", odd); &#125; return 0;&#125; 3.输出一个整数的每一位。 123456789void Print_num()&#123; printf("请输入数:"); int x; scanf("%d", &amp;x); while (x)&#123; printf("%d ", x % 10); x /= 10; &#125;&#125; 4.两个int（32位）整数m和n的二进制表达中,有多少个位(bit)不同? 输入例子: 1999 2299 输出例子:7 123456789101112void diff_bit()&#123; int m, n,num,count = 0; printf("请输入两个数:"); scanf("%d %d", &amp;m, &amp;n); num = m ^ n; for (int i = 0; i &lt; 32; i++)&#123; if (((num &gt;&gt; i) &amp; 1) == 1)&#123; count++; &#125; &#125; printf("%d", count);&#125; 在操作符总结完之后做的一些题。我个人觉得总结完之后，上手是非常容易的。]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-对猫眼网的top100的爬取]]></title>
    <url>%2F2018%2F11%2F26%2Fpython-%E5%AF%B9%E7%8C%AB%E7%9C%BC%E7%BD%91%E7%9A%84top100%E7%9A%84%E7%88%AC%E5%8F%96%2F</url>
    <content type="text"><![CDATA[python我从今年过年开始自学，断断续续的，最近参加了一个爬虫训练营，我发现爬虫对开始学习python是非常合适的，只不过首先得具备一些HTML的知识储备，毕竟爬虫是需要解析网页的。而且爬虫实现后的成就感是非常巨大的。所以，根据上周学习的一些知识，做一个小的总结。 首先需要安装requests库和beautifulsoup库，这两个库是有函数可以对网页进行一个解析操作的。比如request中的get()。beautifulsoup中的Beautifulsoup()的使用。 安装过程首先最简单的安装就是利用cmd通过pip指令安装 12pip install requestspip install beautifulsoup4 //这里需要注意一下，后面必须有个4。 如果安装不上，那就从网上先下载好需要的安装文件，在进入该文件的目录下，进行安装。 request的使用request的请求方式有多种，因为是一个第三方库，有多种使用方法，可以在网上寻找一些使用文档参考 12345requests.get('http://www.xxxxxxxx.com')requests.post('http://www.xxxxxxxx.com')requests.delete('http://www.xxxxxxxx.com')requests.put('http://www.xxxxxxxx.com')requests.head('http://www.xxxxxxxx.com') 列举一些常用的。 get：请求指定的页面信息，并返回一个主体。使用get方式时，请求数据直接放在url中。 post：请求主要是发送一些较长的数据，数据比较安全 。使用post方式时，数据放在data或者body中，不能放在url中，放在url中将被忽略。 delete：请求服务器删除Request-URI所标识的资源。 put：向指定资源位置上传其最新内容 。 head： 向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。 request的实例首先我们要爬取的是猫眼网站的top100榜单。网址为http://maoyan.com/board/4。 这是第一页的情况，此时我们点击一个下一页，就能发现网址发现了变化。 能明显看到网址的变化是http://maoyan.com/board/4?offset={}。 不断去往下翻页，我们就能看到offset=后面这个数在不断的变化，第一页是0，到最后一页是90。 说明offset是偏移量，等于号后面的是偏移量的值 知道了这个url的规律之后，就可以来进行获取网址了。 通过get去获取一个网页信息 12345678def get_url(url): try: wb_data=requests.get(url) wb_data.raise_for_status wb_data.encoding=wb_data.apparent_encoding return wb_data.text except: return "代码段异常" 上面是单个网页去抓取。我们能发现，此时所有的html页面信息都被反馈出来了。 我们利用谷歌浏览器打开该网站，右键点击检查，我们能看到各个标签内的字符串在其中，这个时候我们就需要正则表达式将其提取出来。 1234567891011def parse_one_page(html): pattern=re.compile('&lt;dd&gt;.*?board-index.*?&gt;(.*?)&lt;/i&gt;.*?data-src="(.*?)".*?name.*?a.*?&gt;(.*?)&lt;/a&gt;.*?star.*?&gt;(.*?)&lt;/p&gt;.*?releasetime.*?&gt;(.*?)&lt;/p&gt;.*?integer.*?&gt;(.*?)&lt;/i&gt;.*?fraction.*?&gt;(.*?)&lt;/i&gt;.*?&lt;/dd&gt;',re.S) items=re.findall(pattern,html) for item in items: yield&#123; 'index':item[0], 'img':item[1], '名称':item[2], '主演':item[3].strip()[3:], '上映时间':item[4].strip()[5:] &#125; 关于正则表达式不在这里详细说了，以后我会专门写一篇总结。 yield的用法：如果一个函数包含yield关键字，这个函数就会变为一个生成器。 生成器并不会一次返回所有结果，而是每次遇到yield关键字后返回相应结果，并保留函数当前的运行状态，等待下一次的调用。所以在我们去请求网页的过程中，每寻找一次，找到相对应的标签，就将其内容爬取下来。 接下来需要对offset这个偏移量找到方法将他添加到我们的url中，并且可以循环的使用。 12345def main(offset): url='http://maoyan.com/board/4?offset=&#123;0&#125;'.format(offset) html=get_url(url) for item in get_url(html): print(item) format函数就不需要多说了，就是往其中添加字符串。这里利用一个for循环使用，这样可以循环将网页都在函数get_url中请求一次。 最后将它输出出来 123for i in range(10): main(offset=i*10) time.sleep(2) 在控制台观察，就会发现我们需要的网页信息被一个一个的提取出来了。 这里使用了一个time.sleep(2),它的作用是让请求有一定的间隔，我们都知道各个网站具有反爬虫机制，如果访问太频繁，则会被禁止访问。让2s访问一次，则可以避免这种机制。 这就是一个简单的爬取过程。接下来是更具体的一种。利用了beautifulsoup来使用 BeautifulSoup的用法‘美味汤’，是用Python写的一个HTML/XML的解析器，它可以很好的处理不规范标记并生成剖析树(parse tree)。 它提供简单又常用的导航（navigating），搜索以及修改剖析树的操作。它可以大大节省你的编程时间。 123456789//引用该库的方法不是直接import就可以，而是通过fromform bs4 import beautifulsoupsoup=BeautifulSoup(wb_data.text,'lxml')print（soup.find_all('a')）print（soup.get_text()）//以上是举例它的写法 soup 就是BeautifulSoup处理格式化后的字符串，soup.title 得到的是title标签，soup.p 得到的是文档中的第一个p标签，要想得到所有标签，得用find_all 函数。find_all 函数返回的是一个序列，可以对它进行循环，依次得到想到的东西. get_text() 是返回文本,这个对每一个BeautifulSoup处理后的对象得到的标签都是生效的。 我们在上面看到一个‘lxml’这个东西，这是解析库。在这里说明一下 解析器 使用方法 优势 劣势 python标准库 BeautifulSoup(markup,’parser’) python内置；执行速度适中；文档容错能力强 低版本pyton容错能力差 lxml HTML解析器 BeautifulSoup(markup,’lxml’) 速度快；容错能力强 需要安装lxml lxml XML解析器 BeautifulSoup(markup,’xml’) 速度快；唯一支持XML 需要安装lxml Html5lib BeautifulSoup(markup,’html5lib’) 容错性最好 速度慢；需要安装html5lib 在我们知道解析器之后，我们还要做的就是通过什么去选择标签。这里一般有四种常用选择器 选择器 作用 使用方法 节点选择器 通过节点名称嵌套选取信息 soup.div.next_sibling.ul.li.p 方法选择器 find_all()和find()函数 soup.find(name=’p’,class=’ ‘) css选择器 Select方法 body&gt;div.content&gt;ul&gt;li:nth-child(1)&gt;p Xpath 用于在xml文档中搜索元素的路径语言 /html/body/div[2]/ul/li[1]/p 当我们基本了解之后就可以使用了。 在下面的使用中，就利用select方法 我们能看到黄色的地方就是我们需要的title标签所指向的地方。 右击这个标签，点击copy—-&gt;copy selector就是利用css选择器，这之后复制出来的标签走向最后复制到select()方法中。 12345678910111213141516171819def parse_one_page(html): soup=BeautifulSoup(''.join(html),'lxml')#在这里我们是得到了R.txt的文本，但是我们不能输出，所以我们得利用print来输出 titles=soup.select('#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; div &gt; div &gt; div.movie-item-info &gt; p.name &gt; a') pics=soup.select('#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; a &gt; img.board-img') actors=soup.select('#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; div &gt; div &gt; div.movie-item-info &gt; p.star') days=soup.select('#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; div &gt; div &gt; div.movie-item-info &gt; p.releasetime') scores1=soup.select('#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; div &gt; div &gt; div.movie-item-number.score-num &gt; p &gt; i.integer') scores2=soup.select('#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; div &gt; div &gt; div.movie-item-number.score-num &gt; p &gt; i.fraction') for title,pic,actor,day,scores,scoress in zip(titles,pics,actors,days,scores1,scores2): info=&#123; 'title':title.get_text(), 'pic':pic.get('alt'), 'actor':actor.get_text(), 'day':day.get_text(), 'scores':scores.get_text()+scoress.get_text(), &#125; write_to_file(info) print(info) 在上面有一个自己定义的wirte_to_file()函数。爬取完数据后，一直放在控制台显示只能证明我们爬取成功了。所以定义函数将我们所请求到的数据放入一个文件中，可以供我们需要的时候看看。 123def write_to_file(content): with open('maoyan.text','a',encoding='utf-8') as f: f.write(json.dumps(content,ensure_ascii=False)+'\n') with open()这个函数的使用时，有四种文本可以保存，分别是text，json，csv，excel。后两种还可以利用pandas来处理统计。 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445import jsonimport requestsimport timefrom bs4 import BeautifulSoupdef get_one_page(url): headers=&#123;'user-agent':'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.104 Safari/537.36 Core/1.53.2263.400 QQBrowser/9.5.10429.400'&#125; response=requests.get(url,headers=headers) if response.status_code==200: return response.text else: return Nonedata=[]def parse_one_page(html): soup=BeautifulSoup(''.join(html),'lxml')#在这里我们是得到了R.txt的文本，但是我们不能输出，所以我们得利用print来输出 titles=soup.select('#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; div &gt; div &gt; div.movie-item-info &gt; p.name &gt; a') pics=soup.select('#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; a &gt; img.board-img') actors=soup.select('#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; div &gt; div &gt; div.movie-item-info &gt; p.star') days=soup.select('#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; div &gt; div &gt; div.movie-item-info &gt; p.releasetime') scores1=soup.select('#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; div &gt; div &gt; div.movie-item-number.score-num &gt; p &gt; i.integer') scores2=soup.select('#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; div &gt; div &gt; div.movie-item-number.score-num &gt; p &gt; i.fraction') for title,pic,actor,day,scores,scoress in zip(titles,pics,actors,days,scores1,scores2): info=&#123; 'title':title.get_text(), 'pic':pic.get('alt'), 'actor':actor.get_text(), 'day':day.get_text(), 'scores':scores.get_text()+scoress.get_text(), &#125; write_to_file(info) print(info)def write_to_file(content): with open('maoyan.excel','a',encoding='utf-8') as f: f.write(json.dumps(content,ensure_ascii=False)+'\n')def main(offset): url='https://maoyan.com/board/4?offset='+str(offset) html=get_one_page(url) parse_one_page(html)for i in range(10): main(offset=i*10) time.sleep(1) 以上就是我们的爬取过程，并不算复杂，而且是比较容易爬取的！可以让你瞬间有成就感的那种！ 爬取出来的是放在字典内的，一条一条在文本文件中，观看是非常醒目的。动手试试吧！]]></content>
      <tags>
        <tag>python-爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初阶C-指针总结与坑]]></title>
    <url>%2F2018%2F11%2F25%2F%E5%88%9D%E9%98%B6C-%E6%8C%87%E9%92%88%E6%80%BB%E7%BB%93%E4%B8%8E%E5%9D%91%2F</url>
    <content type="text"><![CDATA[指针的定义在计算机科学中，指针（Pointer）是编程语言中的一个对象，利用地址，它的值直接指向（points to）存在电脑存储器中另一个地方的值。由于通过地址能找到所需的变量单元，可以说，地址指向该变量单元。因此，将地址形象化的称为“指针”。意思是通过它能找到以它为地址的内存单元。 总的来说，指针就是变量，用来存放地址的变量。（存放在指针中的值都被当成地址处理） 指针的大小在32位平台上是4个字节，在64位平台上是8个字节。 指针是存放地址才出现的，地址是为了标示一块地址空间的。 指针让地址有地方存放，指针让内存的访问更加方便。 指针和指针类型有这么一个代码 12int num = 10;p = &amp;num; 要将&amp;num保存到p中，p就是一个指针变量，它的类型是有相对应的。 123456char *pc = NULL;int *pi = NULL;short *ps = NULL;long *pl = NULL;float *pf = NULL;double *pd = NULL; 由上面的代码段可以看到，指针的定义方式就是 type + 。 也就是char\的指针存放char类型变量的地址。short*的指针存放short类型变量的地址。int*的指针存放int类型的变量的地址。 普通的指针变量，指针类型，表示指针指向的变量的类型。一个普通的指针，知道对应这个变量的房间号，以及房间的大小。 void*的使用：只知道房间号，但是不关注房间大小。 void*类型不能解引用 void*类型的指针不能和整数进行相加减 void*类型的两个指针也不能相减 然而这样一个代码 123int a = 10;char* p = &amp;a;printf("%d\n",*p); 打印的结果是多少？打印的结果还是10。但是int*和char*类型是不兼容的，但是我们在存放数据时，要考虑到大端和小端的情况，低位在低地址 p的解引用 对于char\得看它是怎么放置的。 通俗来说，int*本身有4个字节，但是非要让它char*去表示，那么只能去考虑一个字节。打印出它的第一个地址存储的数据。但这第一个地址是怎么存放数据的，我们要考虑大端与小端的情况。因为就一个 0a，可能在4个字节中，最末尾的位置，也可能是第一个位置。这都是根据机器设定的字节序来得出结果的。 这里说一下机器的字节序： 大端：低位在高地址上 小端：低位在低地址上 指针 +/- 整数首先站在上帝视角，对指针进行运算是一件非常危险的事情，这也是一个埋下大坑的开始！！ 指针的加减与普通的数字加减不太一样。 123456789101112char* p = NULL;p = p + 1;//结果为1short* p = NULL;p = p + 1;//结果为2int* p = NULL;p = p + 1;//结果为4double* p = NULL；p = p + 1;//结果为8 指针和整数+1并不是地址+1，而是跳过当前指向的元素。-1是往低地址跳过一个元素（可以说是往前跳） 指针-指针1234int arr[] = &#123;1, 2, 3, 4&#125;;int* p1 = arr;int* p2 = arr + 3;printf("%d\n",p2 - p1); 指针相减，就是指针加减整数的逆运算。指针相减就是看指针之间隔了多少个元素。 语法是允许，但是很多情况下是没有意义的。比如两个不同类型的去相减，没有什么实际的意义。除非两个指针指向了同一个连续的内存空间，此时才是有意义的。 指针的解引用解引用：”*”的作用是引用指针指向的变量值，引用其实就是引用该变量的地址，“解”就是把该地址对应的东西解开，解出来，就像打开一个包裹一样，那就是该变量的值了，所以称为“解引用”。 也就是说，解引用是返回内存地址中保存的值。 指针的类型决定了对指针解引用的时候有多大的权限。 比如：char*的指针解引用就只能访问一个字节，而int*的指针的解引用就能访问四个字节 这里补充一个const的使用。 const int* p =&gt; p 指向的内容不能修改 int const *p =&gt; p指向的内容不能修改 int* p const p =&gt; p 的指向不能修改 二级指针二级指针并没有很难理解，就是将一直指针看成一个常量，在引用一个指针。 可以类比于二维数组，它其实还是一个一维数组，只是每个元素是一个一维数组。 当我们觉得不太好理解时，可以这样 1234typedef int* int_ptrint a = 10;int_ptr p = &amp;a;int_ptr* pp = &amp;p; 将int*定义成一个变量来代替，这样我们看着就比较方便了。 指针和数组名指针和数组名往往是可以相互转化的。 12int arr[] = &#123;1,2,3,4&#125;int* p = arr + 1; 此时的含义是，数组的首地址元素+1，跳过这个当前指向的元素，此时*p为2。 &amp;arr =&gt; 数组指针：是一个指针，指向一个数组的指针。 指针数组 vs 数组指针 123456int a[] = &#123; 1, 2, 3, 4&#125;;printf("%p\n",a);//指向的intprintf("%p\n",&amp;a);//得出的地址是一样的，改变一下printf("%p\n",&amp;a + 1);//这直接跳过了整个数组，指向了整个数组 1int* a[] = &#123; 0 &#125;;//每个元素是一个指针 指针的大坑第一组 12345678910int a[] = &#123; 1, 2, 3, 4&#125;;printf("%d\n",sizeof(a));//数组的大小，16printf("%d\n",sizeof(a + 0));//a此时变成了指针，4（32位系统下）printf("%d\n",sizeof(*a));//a变成首元素的指针，得到了一个整数，4printf("%d\n",sizeof(a + 1));//a此时变成了指针，4printf("%d\n",sizeof(a[1]));//第二个元素的大小，4printf("%d\n",sizeof(&amp;a));//此时是数组指针，指针就一定占4个字节！printf("%d\n",sizeof(*&amp;a));//此时先位数组指针，指向整个数组，每个数组内元素解引用，还原数组，16printf("%d\n",sizeof(&amp;a + 1));//数组指针+1还是数组指针，还是为4printf("%d\n",sizeof(&amp;a[0]));//a[0]取元素，整数，取完地址为int*，还是为4 第二组 12345678910111213141516char a[] = &#123; 'a', 'b', 'c', 'd', 'e', 'f'&#125;;printf("%d\n",sizeof(a));//类型为char型，占1个字节，共6个printf("%d\n",sizeof(a + 0));//变成指针，4printf("%d\n",sizeof(*a));//转成指针，解引用，得到是字符a，1printf("%d\n",sizeof(a[1]));//1printf("%d\n",sizeof(&amp;a));//数组指针，4printf("%d\n",sizeof(&amp;a + 1));//还是4，数组指针+1还是指针printf("%d\n",sizeof(&amp;a[0] + 1));//char* 还是一个指针printf("%d\n",strlen(a));// strlen从当前位置找到\0，如果找不到则越界，那么就是未定义行为printf("%d\n",strlen(a + 0));//strlen()函数都当成char*指针来处理，数组中没有\0，依然是未定义行为printf("%d\n",strlen(*a));//得到一个字符，不能放到char*里，间接级别不同，所以依然是未定义行为printf("%d\n",strlen(a[1]));//得到一个字符，都是未定义i行为printf("%d\n",strlen(&amp;a));//依然是个未定义行为printf("%d\n",strlen(&amp;a + 1));//未定义行为printf("%d\n",strlen(&amp;a[0] + 1));//未定义行为 第三组 12345678910111213141516char* p = 'abcdef';printf("%d\n",sizeof(p));//只要是指针，4个字节printf("%d\n",sizeof(p + 1));//还是指针，4个字节printf("%d\n",sizeof(*p));//解引用，char类型，得到a，1个字节printf("%d\n",sizeof(p[0]));//等价于*p，1printf("%d\n",sizeof(&amp;p));//指针取地址，就是二级指针，4printf("%d\n",sizeof(&amp;p + 1));//二级指针，4printf("%d\n",sizeof(&amp;p[0]));//a取地址，就是指向a的指针，+1就是指向b的指针，还是4printf("%d\n",strlen(p));//6，‘\0’不取，strlen()不算在其长度中printf("%d\n",strlen(p + 1));//5,p指向a，p+1指向b，从b开始到结束，只占了5个printf("%d\n",strlen(*p));//得到是一个字符，不能用strlen(),未定义行为printf("%d\n",strlen(p[0]));//未定义行为printf("%d\n",strlen(&amp;p));//二级指针不能进行，还是未定义行为printf("%d\n",strlen(&amp;p + 1));//未定义行为printf("%d\n",strlen(&amp;p[0] + 1));//a的指针，+1为b的指针，此时从b到结束，5 第四组12345678910111213141516char a[] = "abcdef";printf("%d\n",sizeof(a));//7,还有'\0'得算上，strlen()到\0结束，不计算入内printf("%d\n",sizeof(a + 0));//此时变为了指针，4printf("%d\n",sizeof(*a));//解引用得到字符a，1printf("%d\n",sizeof(a[1]));//1printf("%d\n",sizeof(&amp;a));//还是4，数组指针printf("%d\n",sizeof(&amp;a + 1));//4，还是数组指针printf("%d\n",sizeof(&amp;a[0] + 1));//是一个char*指针，4printf("%d\n",strlen(a));//6，不计算\0printf("%d\n",strlen(a + 0));//还是指向首元素的地址，6printf("%d\n",strlen(*a));//解引用得到字符，未定义printf("%d\n",strlen(a[1]));//未定义行为printf("%d\n",strlen(&amp;a));//数组名取地址，变为数组指针，得到的是首元素地址，依次往后去找。得到的还是6printf("%d\n",strlen(&amp;a + 1));//数组指针+1跳出整个数组了，找不到\0了，未定义行为printf("%d\n",strlen(&amp;a[0] + 1));//指向b，直到\0，为5 第五组123456789101112int a[3][4] = &#123; 0 &#125;;printf("%d\n",sizeof(a));//3*4*4=48printf("%d\n",sizeof(a[0][0]));//4printf("%d\n",sizeof(a[0]));//16,第一行printf("%d\n",sizeof(a[0] + 1));//4，数组指针，指针就是4printf("%d\n",sizeof(*(a[0] + 1)));//*(p + 1) =&gt; p[1],还是指针，即a[0][1] + 1,解引用，为4printf("%d\n",sizeof(a + 1));//变为指针，还是为4printf("%d\n",sizeof(*(a + 1));//*(a + 1) =&gt; a[1],所以数组为第二行,16printf("%d\n",sizeof(&amp;a[0] + 1));//得到为数组指针，+1还是数组指针，4printf("%d\n",sizeof(*(&amp;a[0] + 1)));//数组a[0]，&amp;为数组指针，在+1跳到第二个元素，在解引用为a[1]，16printf("%d\n",sizeof(*a));//*a =&gt; a[0] ,16printf("%d\n",sizeof(a[3]));//下标越界，sizeof在编译过程中得到类型，长度为4个元素的数组。 这些大坑多种形式，真的需要没事就看看，指针在C中是一个很重要的工具，在之前的静态顺序表中已经出现过，在链表中还出现了二级指针，所以需要多理解，多思考！]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初阶C-1117]]></title>
    <url>%2F2018%2F11%2F23%2F%E5%88%9D%E9%98%B6C-1117%2F</url>
    <content type="text"><![CDATA[1、有5位运动员参加了10米台跳水比赛，有人让他们预测比赛结果 A选手说：B第二，我第三； B选手说：我第二，E第四； C选手说：我第一，D第二； D选手说：C最后，我第三； E选手说：我第四，A第一； 比赛结束后，每位选手都说对了一半，请编程确定比赛的名次。 这道题我们一般的思维是直接根据一个条件的真假性，然后去依次判断下去。但是在C语言中不可以那么想。你不能去想当然的去判断。所以我们得设置条件，去不断的循环，然后判断出结果。 1234567891011121314151617181920212223242526void Guess()&#123; for(int a = 1;a &lt;= 5;a++)&#123; for(int b = 1;b &lt;= 5;b++)&#123; for(int c = 1;c &lt;= 5;c++)&#123; for(int d = 1;d &lt;= 5;d++)&#123; for(int e = 1;e &lt;= 5;e++)&#123; //排名无非就是12345，全部走一遍，当满足条件时，就判断下一个条件，直到满足时 if ((2 == b &amp;&amp; 3 != a) || (2 != b &amp;&amp; 3 == a) == 1)&#123; if ((2 == b &amp;&amp; 4 != e) || (2 != b &amp;&amp; 4 == e) == 1)&#123; if ((1 == c &amp;&amp; 2 != d) || (1 != c &amp;&amp; 2 == d) == 1)&#123; if ((5 == c &amp;&amp; 3 != d) || (5 != c &amp;&amp; 3 == d) == 1)&#123; if ((4 == e &amp;&amp; 1 != a) || (4 != e &amp;&amp; 1 == a) == 1)&#123; if (a*b*c*d*e == 120)&#123; printf("a=%d b=%d c=%d d=%d e=%d\n", a, b, c, d, e); &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125; 2、日本某地发生了一件谋杀案，警察通过排查确定杀人凶手必为4个嫌疑犯的一个。以下为4个嫌疑犯的供词 A说：不是我。 B说：是C。 C说：是D。 D说：C在胡说 已知3个人说了真话，1个人说的是假话。 现在请根据这些信息，写一个程序来确定到底谁是凶手。 这个与上面的思想是一样的，我们需要设置一个常量，将它作为凶手的标志。 我在里面设置2为凶手的标志 123456789101112131415161718192021void Guesspeople()&#123; for (int a = 1; a &lt;= 4; a++)&#123; for (int b = 1; b &lt;= 4; b++)&#123; for (int c = 1; c &lt;= 4; c++)&#123; for (int d = 1; d &lt;= 4; d++)&#123; if ((a != 2 &amp;&amp; c == 2 &amp;&amp; d == 2) || (d != 2) == 1)&#123; if ((a != 2 &amp;&amp; c == 2 &amp;&amp; d != 2) || (d == 2) == 1)&#123; if ((a != 2 &amp;&amp; c != 2 &amp;&amp; d == 2) || (d != 2) == 1)&#123; if ((a == 2 &amp;&amp; c == 2 &amp;&amp; d == 2) || (d != 2) == 1)&#123; if (a != b&amp;&amp;a != c&amp;&amp;a != d&amp;&amp;b != c&amp;&amp;b != d&amp;&amp;c != d)&#123; printf("a=%d,b=%d,c=%d,d=%d\n", a, b, c, d); &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125; 打印输出之后可以发现，C的值全部为2，那么说明C一定就是凶手。 3、在屏幕上打印杨辉三角 杨辉三角的规律有很多，其中有一个，每个数等于上方两数之和。 12345678910111213141516171819#define N 10 //定义一个二维数组void triangle()&#123; int arr[N][N]=&#123;0&#125;;//先全部初始化为0 int i, j, k; for(i = 0;i &lt; N;i++)&#123; for(j = 0;j &lt; N-i;j++)&#123; printf(" "); for(k = 0;k &lt;= i;k++)&#123; if(k == 0||k == i)&#123; arr[i][k] = 1; &#125;else&#123; arr[i][k] = arr[i-1][k] + arr[i-1][k-1]; &#125; &#125; printf("%4d",arr[i][k]); &#125; printf("\n"); &#125;&#125;]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初阶C-操作符总结]]></title>
    <url>%2F2018%2F11%2F21%2F%E5%88%9D%E9%98%B6C-%E6%93%8D%E4%BD%9C%E7%AC%A6%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[C语言操作符是构成C语言表达式的工具，是说明特别操作的符号。 操作符的类型算术操作符1+ - * / % 除了%操作符之外，其他均可以作用于整数和浮点数。 对于/操作符，如果是整数，执行整数除法，如果是浮点数，则执行浮点数除法 %操作符的两个操作符必须是整数，返回的是整除之后的余数。 移位操作符1&lt;&lt;左移操作符 &gt;&gt;右移操作符 左移位规则：左边抛弃，右边补0 右移位规则：这又分为两种，分别是逻辑移位和算术移位 逻辑移位 是左边用0填充，右边丢弃 算术移位 是左边用原该值的符号位填充，右边丢弃 例如：求一个整数存储在内存中的二进制中1的个数 1234567891011#include&lt;stdio.h&gt;void erjinzhi(int num)&#123; int count = 0; while (num)&#123; if (num % 2 == 1) count++; num = num / 2; &#125; printf("二进制中1的个数 = %d ", count); return 0;&#125; 从这个程序里中，我们就可以测出，每个数在二进制中1的个数。但是我们，如果输入负数，我们会发现，我们的程序，是有问题的。如果输入了-10，那么-10之前的所有0都要取反，这个时候我们将出来许多的1。 所以我们进行一个改正 12345678910#include&lt;stdio&gt;void erjingzhi(int num)&#123; int i = 0; int count = 0; for (i = 0; i &lt; 32; i++)&#123; if (((num &gt;&gt; i) &amp; 1) == 1) count++; &#125; printf("二进制中1的个数 = %d\n", count);&#125; 我们利用移位的方法去一个一个来计算。 这里添加一个二进制负数的转化过程，可以更好的理解。 Ps:注意我们的移位不要移动负数位，这个是标准未定义的。 位操作符位操作符有三种分别是：按位与，按位或，按位异或 1&amp; | ^ 它们的操作数必须是整数。 按位与：对两个数进行操作，然后返回一个新的数，这个数的每个位都需要两个输入数的同一位都为1时才为1. 按位或：比较两个数，然后返回一个新的数，这个数的每一位设置1的条件是两个输入数的同一位都不为0。即任意一个为1，或者都为1。否则为0。 按位异或：比较两个数，然后返回一个数，这个数的每个位设为1的条件是两个输入数的同一位不同，如果相同就设为0。即相同为0，不同为1。 赋值操作符赋值操作符是一个很好用的操作符，你可以将你的变量设置成你需要的值。用 “=” 即可。 复合赋值操作符 += 加等 -= 减等 *= 乘等 /= 除等 %= 取模等 &gt;&gt;= 右移位等于 &lt;&lt;= 左移位等于 &amp;= 按位与等于 &#124; = 按位或等于 ^= 按位取反等于 单目操作符 ！ 逻辑反操作 - 取负数 + 取正数 &amp; 取地址 sizeof 操作数的类型长度 ~ 对一个数的二进制按位取反 – 减减，类似累减 ++ 加加，类似累加 * 间接访问操作符 逻辑操作符逻辑操作符有 12&amp;&amp; 逻辑与|| 逻辑或 它们与按位与和按位或之间的区别 1&amp;2 —–&gt;0 1&amp;&amp;2 ——-&gt;1 1|2 ——&gt;3 1||2 —–&gt;1 逻辑与还有逻辑或，此时是判断它的真假性。要记住，非0为真。这是一个关键。 1234567#include&lt;stdio.h&gt;int main()&#123; int i= 0,a=0,b=2,c=3,d=4; i= a++&amp;&amp;++b&amp;&amp;d++; printf("a= %d\n b=%d\n c=%d\n d=%d\n",a,b,c,d); return 0;&#125; 输出后，abcd分别位1234。根据我们的猜测，这里可能是为135这样。但是这里有个坑。 这里存在一个短路求值的知识点。a=0这就代表了假。那么 a++——&gt;0。也就是说在这里是先返回，后++ 短路求值：如果是&amp;&amp;左侧表达式为假的时候，右侧表达式不会求值 ​ 如果是||左侧表达式为真的时候，右侧表达式不会求值 条件操作符1exp1 ? exp2 : exp3 这是C语言中唯一的一个二目运算符，运算级非常低。 逗号表达式1exp1,exp2,exp3....expN 就是用逗号隔开的多个表达式。从左向右依次执行。 表达式求值隐式类型转换C的整型算术运算总是至少以缺省整型类型的精度来进行的。为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转化为普通类型，这种转换称为——整形提升。 123char a,b,c;...a = b + c; b和c的值被提升为普通整型，然后再执行加法运算。 加法运算完成之后，结果将被截断，然后再存储于a中。 算法运算中，a隐式转换为int。 凡是针对char/short，此时都隐式转换成int。 操作符的属性复杂表达式的求值有三个影响的因素： ​ 1.操作符的优先级 ​ 2.操作符的结合性 ​ 3.是否控制求值的顺序 以上就是操作符的基本了，目前是我能知道并且掌握的，当以后有了其他的之后，再慢慢的添加进去。]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初阶C-扫雷]]></title>
    <url>%2F2018%2F11%2F18%2F%E5%88%9D%E9%98%B6C-%E6%89%AB%E9%9B%B7%2F</url>
    <content type="text"><![CDATA[上次完成了三子棋的做法，利用了二维数组。扫雷也是一样，需要我们利用二维数组去完成。扫雷有所不同的地方在于，我们需要两个二维数组。一个用来展示棋盘，另外一个用于展示我们的下雷过程，因为每一个点击有可能是雷或者不是雷。 关于扫雷的编程思想我们与三子棋相比是有一些不同的地方。但归途同属，我们只需要想清楚每一个步骤就可以。 还是先创建一个工程，并且我还是习惯于一个头文件定义函数，一个源文件测试。 我们首先设置一个选择功能，让我们在看的时候，比较美观。毕竟好看的事务会给别人留下的印象也比较深。 123456789101112131415161718192021222324#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;void Start()&#123; int choice == Menu(); while(1)&#123; if(choice == 0)&#123; break; &#125; Game(); &#125;&#125;int Menu()&#123; printf("====================\n"); printf(" 1.开始游戏\n"); printf(" 2.退出游戏\n"); printf("====================\n"); int choice = 0; scanf("%d",&amp;choice); return choice;&#125; 基本开始样式就ok了。之后我们开始需要对每个关键步骤写代码了。 我们先想象一下扫雷的规则与步骤。 1.我们首先得有一个地图的样式，然后初始化它最初的样子 2.打印这个棋盘。（这两步与三子棋的思路比较像） 3.进行点击，之后判断点击的情况。 4.判定是否踩雷，如果踩雷，GG。 5.如果没踩雷，判定是否掀开了所有格子。 6.如果没有掀开所有格子。那么更新周围有几个雷。显示到地图上。 3-6这是一个循环的过程，所以我们将用while来判断什么时候胜利或者失败。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#define MAX_ROW 10#define MAX_COL 10#define DEFAULT_LEIZI_COUNT 10void Game()&#123; char show_map[MAX_ROW + 2][MAX_COL + 2]; char mine_map[MAX_ROW + 2][MAX_COL + 2]; Init_map(); Print_map(); while(1)&#123; int count = 0; int row,col; printf("请输入坐标，例如1 2\n")； scanf("%d",&amp;row,&amp;col); if(row &lt;= 0 || row &gt; MAX_ROW || col &lt;= 0 || col &gt; MAX_COL)&#123; printf("请重新输入坐标\n"); continue; &#125; if(mine_map[row][col] == '1')&#123; printf("游戏结束，此处有雷\n"); Print_map(); break; &#125; if (count==DEFAULT_LEIZI_COUNT + 1)&#123; printf("扫雷成功\n"); Print_map(mine_map); break; &#125; for (int i = 1; i &lt;= MAX_ROW; i++)&#123; for (int j = 1; j &lt;= MAX_COL; j++)&#123; if (show_map[i][j] == '*')&#123; count++; &#125; &#125; &#125; if (count == DEFAULT_LEIZI_COUNT)&#123; printf("扫雷成功\n"); Print_map(mine_map); break; &#125; Updateshowmap(); Showaround(); Print_map(); &#125;&#125; 这就是上面描述的一个基本的流程。也就是扫雷对输赢的判断规则。接着对每一个函数去完善。函数内参数我是没有直接添加进去的。我是都定义完成之后，才慢慢添加进去的。 首先是对我们地图的一个初始化 1234567891011121314151617181920212223242526void Init_map(char show_map[MAX_ROW + 2][MAX_COL + 2]; char mine_map[MAX_ROW + 2][MAX_COL + 2])&#123; //在这里就要解释一下，我们为什么要加上一个2了。因为我们要保证我们需要一个边框 //大多数人的潜意识中喜欢输入都是1 1，这样我们定义一个边框，我们就可以将其上下包围这些地图 //那么这个地图将是从1 1到 10 10的所有点了。 for(int row = 0;row &lt; MAX_ROW;row++)&#123; for(int col = 0;col &lt;MAX_COL;col++)&#123; show_map[row][col] = '*'; &#125; &#125; for(int row = 0;row &lt; MAX_ROW;row++)&#123; for(int col = 0;col &lt;MAX_COL;col++)&#123; mine_map[row][col] = '*'; &#125; &#125; int mine_count = DEFAULT_LEIZI_COUNT; while(mine_count &gt; 0)&#123; int row = rand() % 10 + 1; int col = rand() % 10 + 1; if(mine[row][col] == '1')&#123; continue; &#125; mine[row][col] = '1'; mine_count--; &#125;&#125; 初始化完成之后，我们开始打印地图 123456789101112131415161718void Print_map((char map[MAX_ROW + 2][MAX_COL + 2],int row,int col)&#123; printf(" "); for(int i = 1;i &lt; MAX_ROW + 2;i++)&#123; printf("%d ",row); &#125; printf("\n"); for(int i = 1;i &lt; MAX_ROW +2 ;i++)&#123; printf("---\n"); &#125; for(int row = 1;row &lt; MAX_ROW + 2;row++)&#123; printf("%02d |\n",row); for(int col = 1;col &lt; MAX_COL + 2;col++)&#123; printf("%c ",map[row][col]); &#125; printf("\n"); &#125; &#125; 打印完地图之后，就是扫雷中最关键的一个部分了。判断周围雷的个数，然后将它打印到地图中。 12345678910111213void Updateshowmap(char show_map[MAX_ROW + 2][MAX_COL + 2]; char mine_map[MAX_ROW + 2][MAX_COL + 2],int row,int col)&#123; int leizi_num = (mine_map[row][col + 1] - '0')+ (mine_map[row][col - 1] - '0')+ (mine_map[row + 1][col + 1] - '0')+ (mine_map[row + 1][col] - '0')+ (mine_map[row + 1][col - 1] - '0')+ (mine_map[row - 1][col + 1] - '0')+ (mine_map[row - 1][col] - '0')+ (mine_map[row - 1][col - 1] - '0'); show_map[row][col] = leizi_num + '0'; return show_map[row][col];&#125; 在这里我是将周围八个格子是否有雷的情况统计下来，然后将其赋给中间的格子，这样我们就可以知道周围有几个雷了。 我们都知道扫雷的规则，当你点开一部分后，如果周围没雷的话，我们就将会点开空白区域。所以我们要写一个递归来去不断的调用。 123456789101112131415161718192021222324252627282930313233void Showaround(char show_map[MAX_ROW + 2][MAX_COL + 2], char mine_map[MAX_ROW + 2][MAX_COL + 2], int row, int col)&#123; if (mine_map[row][col] == '0' &amp;&amp; show_map[row][col] == '*')&#123; show_map[row][col] = Updateshowmap(show_map, mine_map, row, col); &#125; if (mine_map[row][col - 1] == '0' &amp;&amp; show_map[row][col - 1]=='*')&#123; show_map[row][col - 1] = Updateshowmap(show_map, mine_map, row, col - 1); if (Updateshowmap(show_map, mine_map, row, col) == '0')&#123; Showaround(show_map, mine_map, row, col - 1); &#125; &#125; if (mine_map[row + 1][col] == '0' &amp;&amp; show_map[row + 1][col] == '*')&#123; show_map[row + 1][col] = Updateshowmap(show_map, mine_map, row + 1, col); if (Updateshowmap(show_map, mine_map, row + 1, col) == '0')&#123; Showaround(show_map, mine_map, row + 1, col); &#125; &#125; if (mine_map[row - 1][col] == '0' &amp;&amp; show_map[row - 1][col] == '*')&#123; show_map[row - 1][col] = Updateshowmap(show_map, mine_map, row - 1, col); if (Updateshowmap(show_map, mine_map, row - 1, col) == '0')&#123; Showaround(show_map, mine_map, row - 1, col); &#125; &#125; if (mine_map[row][col + 1] == '0' &amp;&amp; show_map[row][col + 1] == '*')&#123; show_map[row][col + 1] = Updateshowmap(show_map, mine_map, row, col + 1); if (Updateshowmap(show_map, mine_map, row, col + 1) == '0')&#123; Showaround(show_map, mine_map, row, col + 1); &#125; &#125;&#125; 我觉得扫雷对周围的判断是根据上下左右来进行的。如果周围没雷，那么它就是相当于空白的。当分成八个方向去判断时，那么就将产生一键排雷的这种奇葩操作。 最后就是一个源文件了。将Start（）放入测试即可。但是不要忘了随机种子，否则扫雷的布置雷数是没有变化的。]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之动态顺序表]]></title>
    <url>%2F2018%2F11%2F15%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[动态顺序表动态顺序表是跟静态顺序表大体相似，有些地方是不同的，动态顺序表是在动态变化中，当我们的所需的内存不够时，它会自动开辟一个我们需要的空间，来供我们使用。 动态顺序表与静态顺序表的不同在于初始化/销毁/所有插入，其他和静态顺序表完全一样。 定义一个结构体先将我们需要的都定义好 12345678910111213141516#pragma once#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;assert.h&gt;#include&lt;string.h&gt;//为了观看方便先写在开头，正常应该需要什么去使用什么typedef int DataType;#define INIT_CAPACITY(3)//定义一个动态的初始化空间容量为3typedef struct SeqListD&#123; DataType* parray; int capacity; int size;&#125; 在结构体的定义中，静态与动态的定义是不同的。静态的是直接定义了一个空间是有范围确定的数组。但是动态不同，动态定义的是一个指针，在这里面存储的范围是不确定的，当我们定义了一个当前我们认为足够大的空间时，它是在一个计算机给我们的随机地址中。当我们需要更大的空间时，我们将申请新空间，这个时候我们将数据转移，先将所有数据转移到新的空间，之后我们将旧的空间释放掉。这个时候空间是新开辟的一段空间，但是我们的地址是计算机重新分配的一段新地址。 初始化12345678void SeqListInit(SeqListD *pSeq)&#123; pSeq-&gt;capacity = INIT_CAPACITY;//当前容量我们都先设置为3，每当我们不够时， //我们就调用其他函数去扩充它 pSeq-&gt;parray = (DataType *)malloc(sizeof(DataType)*pSeq-&gt;capacity);//我们的数组利用malloc函数 //类型 //4*3 assert(pSeq-&gt;parray);//判断我的指针是否正常 pSeq-&gt;size = 0;&#125; malloc(): malloc的全称是memory allocation，中文叫动态内存分配，用于申请一块连续的指定大小的内存块区域以void*类型返回分配的内存区域地址，当无法知道内存具体位置的时候，想要绑定真正的内存空间，就需要用到动态的分配内存。 一般需和free函数配对使用。 销毁12345678void SeqListDestory(SeqListD *pSeq)&#123; free(pSeq-&gt;parray); //将它释放掉 pSeq-&gt;capacity = 0; pSeq-&gt;size = 0; pSeq-&gt;parry = NULL; //所有一切还原&#125; 插入1234567void SeqListPushBack(SeqListD *pSeq,DataType data)&#123; //静态：如果满了，不处理/报错 //动态：加入扩容机制 ExpandIfRequired(pSeq);//每次都需要去判断是否达到条件可以实现 pSeq-&gt;parray[pSeq-&gt;size] = data;// pSeq-&gt;size++;&#125; 判断是否需要扩大1234567891011121314151617static void ExpandIfRequired(SeqListD *pSeq)&#123; if(pSeq-&gt;size &lt; pSeq-&gt;capacity)&#123; return;//还没满 &#125; //扩容 pSeq-&gt;capacity *= 2; //开辟新空间 DataType *newArray = (DataType *)malloc(sizeof(DataType)*pSeq-&gt;capacity); assert(newArray); //数据搬移 for(int i = 0;i &lt; pSeq-&gt;size；i++)&#123; newArray[i] = pSeq-&gt;parray[i]; &#125; //释放老空间，申请的新空间与动态顺序表关联起来 free(pSeq-&gt;parray); pSeq-&gt;parray = newArray;&#125; 同理，所有插入都需要加入扩容机制 其他的操作与静态顺序表的操作是相近的。可以参考我之前的对照着看。 数据结构重新在学！如有不对，请cue我！]]></content>
      <tags>
        <tag>C-数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初阶C-三子棋]]></title>
    <url>%2F2018%2F11%2F12%2F%E5%88%9D%E9%98%B6C-%E4%B8%89%E5%AD%90%E6%A3%8B%2F</url>
    <content type="text"><![CDATA[今天试着独自完成三子棋，经过一个小时多…才完成。真的太菜了！！！ 但是一个简单的三子棋确实能建立一些基本的编程思想。其中让我迷糊的是和棋那里。接下来我来代码分析说明。 首先我们编程一个项目时，我们要明白我们的基本构想是什么。那么三子棋的思想有这么几点。 三子棋的规则三子棋是在一个3x3的表格之中，如果在行列斜只要有三个相同的棋子，那么就将获胜。如果棋盘满了之后，但没有相同的，则算和棋。先手是具有一定的优势的。 三子棋的编程思想我们要将我们的操作步骤与实际相比较起来 1.初始化棋盘 2.展示棋盘的过程。我们得时刻了解到，此时的下子情况 3.玩家落子，进行判断，是否赢得了胜利 4.电脑落子，进行判断，是否赢得了胜利，如果没有分出，重复第2步 5.还未判断是否分出胜负，对其判断是否和棋。 三子棋的代码过程首先我用的是VS2013，只定义了一个头文件和一个源文件。 头文件的初定义12345678#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;#define ROWS 3#define COLS 3char qipan[ROWS][COLS]; 首先我们定义头文件，不过在此处我觉得并不需要一上来就定义，我们最后需要什么，我们去定义它。 但是宏最开始我们需要定义好，因为是二维数组。棋盘的大小我们要先设定好，并对其声明。 数组初始化1234567void Init(char qipan[ROWS][COLS],int row,int col)&#123; for (int row = 0; row &lt; ROWS; ++row)&#123; for (int col = 0; col &lt; COLS; ++col)&#123; qipan[row][col] = ' '; &#125; &#125;&#125; 展示棋盘123456789void Show_qipan(char qipan[ROWS][COLS], int row, int col)&#123; for (int i = 0; i &lt; row; ++i)&#123; printf("| %c | %c | %c |\n", qipan[i][0], qipan[i][1], qipan[i][2]); if (i != row - 1)&#123; printf("|---|---|---|\n"); &#125; &#125;&#125; 玩家落子1234567891011121314151617void Playmove(char qipan[ROWS][COLS], int row, int col)&#123; printf("请玩家下子\n"); while (1)&#123; printf("例如输入的格式为0,0\n"); scanf("%d,%d", &amp;row, &amp;col); if (row &lt; 0 || row &gt;= ROWS || col &lt; 0 || col &gt;= COLS)&#123; printf("输入有误，请重新输入\n"); continue; &#125; else if (qipan[row][col] != ' ')&#123; printf("该处已经下过子了，请重新输入\n"); continue; &#125; qipan[row][col] = 'x'; break; &#125;&#125; 电脑落子12345678910111213void Computermove(char qipan[ROWS][COLS], int row, int col)&#123; printf("请电脑下子\n"); while (1)&#123; row = rand() % ROWS; col = rand() % COLS; if (qipan[row][col] != ' ')&#123; printf("该处已有棋子，请重新填入\n"); continue; &#125; qipan[row][col] = 'O'; break; &#125;&#125; 和棋判断条件1234567891011static int Show_full(char qipan[ROWS][COLS], int row, int col)&#123; int i, j; for (i = 0; i &lt; row; i++)&#123; for (j = 0; j &lt; col; j++)&#123; if (qipan[i][j] == ' ')&#123; return 0; &#125; &#125; &#125; return 1;&#125; 判断胜负123456789101112131415161718192021222324252627282930char CheckWinner(char qipan[ROWS][COLS], int row, int col)&#123; //判断行 for (int col = 0; col &lt; COLS; col++)&#123; if (qipan[0][col] == qipan[1][col] &amp;&amp; qipan[0][col] == qipan[2][col] &amp;&amp; qipan[0][col] != ' ')&#123; return qipan[0][col]; &#125; &#125; //判断列 for (int row = 0; row &lt; ROWS; row++)&#123; if (qipan[row][0] == qipan[row][1] &amp;&amp; qipan[row][0] == qipan[row][2] &amp;&amp; qipan[row][0] != ' ')&#123; return qipan[row][0]; &#125; &#125; //判断斜 if (qipan[0][0] == qipan[1][1] &amp;&amp; qipan[0][0] == qipan[2][2] &amp;&amp; qipan[0][0] != ' ')&#123; return qipan[0][0]; &#125; else if (qipan[2][0] == qipan[1][1] &amp;&amp; qipan[2][0] == qipan[0][2] &amp;&amp; qipan[2][0] != ' ')&#123; return qipan[2][0]; &#125; //判断和棋 else if (Show_full(qipan,row,col))&#123; return 'q'; &#125; return ' ';&#125; 代码比较容易理解，但是我们也有几个必须注意的地方。 首先，定义的每个函数中，参数不能忘，对其中添加数组，行，列三个。因为我们对输入值后，要把每个值传入函数中，让其进行判断。所以这是一个关键。 其次是和棋的判断，在返回值为0与1的意思是假与真（估计大家都知道），但是关键在于CheckWinner()中，我们要知道判断结束后要有返回值。我们之前设置初始化的数组值是‘ ’。接着我们可以在源文件中进行判断。 源文件的代码12345678910111213141516171819202122232425262728293031323334353637#include"chess.h"int main()&#123; srand((unsigned int)time(NULL)); Init(qipan, ROWS, COLS); Choice(); char winner; int a; scanf("%d", &amp;a); switch (a)&#123; case 1: while (1)&#123; Show_qipan(qipan, ROWS, COLS); Playmove(qipan, ROWS, COLS); Show_qipan(qipan, ROWS, COLS); winner = CheckWinner(qipan, ROWS, COLS); if (winner != ' ')&#123; break; &#125; Computermove(qipan, ROWS, COLS); winner = CheckWinner(qipan, ROWS, COLS); &#125; if (winner == 'x')&#123; printf("你赢了！\n"); &#125; else if (winner == 'o')&#123; printf("电脑赢了！\n"); &#125; else if (winner == 'q')&#123; printf("五五开！真厉害！\n"); &#125; case 2: system("exit"); &#125; system("pause"); return 0;&#125; 看了winner的值你就可以看出来，如果之前返回的不是‘ ’，那么winner将直接跳出循环。 在其中我还添加了一个switch语句增加一些选择来让程序更生动点。下图实例： 大家如果有什么想法，还可以自己往里面添加！ 加油！会越来越强的！]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之静态顺序表]]></title>
    <url>%2F2018%2F11%2F09%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%9D%99%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[静态顺序表属于数据结构开始的一种基本结构首先我们要知道数据结构的概念 数据结构 数据的组织关系 算法 为了达到特定的目的的一系列过程。在这个过程中又分为两种角度1） 逻辑角度：线性结构，树形结构，图形结构2） 存储角度：顺序存储，链式存储 在线性结构中顺序存储的方式，在本次中为顺序表，分为静态和动态而静态顺序表的理解可以分为1） 结构体定义（定义、背后的内存布局模型）2） 顺序表的基本操作：插/删/查/改。重点需要去掌握的是插和删。插（头插/尾插/插入），删（头删/尾删/删除）接下来开始对于整个代码进行一个分析。 123456789101112#pragma once#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt; //一般不着急于先定义一堆，你需要什么在去定义什么。typedef int DataType; //为现有类型创建别名。用DataType来代替int。#define MAX_SIZE(100) //开出一块空间，占用内存的最大位置。typedef struct SeqList&#123; //定义结构体的别名 DataType array[MAX_SIZE]; int size;&#125;SeqList; //变量名 当把结构体都定义好了之后，我们开始先进行两个基本操作，对数组进行初始化和销毁此时我们要用到assert()。在开头首先要定义这个宏#include&lt;assert.h&gt;,他的功能就是测试一个条件可能使程序终止。用法void assert(int test) assert(), 断言,如果表达式为真，断言通过，无事发生；如果表达式为假，断言失败，程序直接退出。 在初始过程中，可能需要把内存清空一下，所以我们可能需要memset()这个函数。这个函数的用法void memset(void s, int ch, size_t n);将s所指向的某一块内存中的后n个 字节的内容全部设置为ch指定的ASCII值，第一个值为指定的内存地址，块的大小由第三个参数指定，这个函数通常为新申请的内存做初始化工作，其返回值为s。 123456789101112//初始化void SeqListInit(Seqlist *pSeq)&#123; //初始化size assert(pSeq != NULL); pSep-&gt;size = 0; memset(pSep-&gt;array,0,SIZE_MAX * sizeof(DataType));&#125;//销毁void SeqListDestory(SeqList *pSeq)&#123; assert(pSeq); pSeq-&gt;size = 0;&#125; 我们还需要部署一个测试函数，先暂时定义一下，当增删改查部署完后，可以往其中添加增删改查的函数来进行实验。 插入：有头插，尾插，插入头插的使用PS：考虑完了普通情况后，我们要考虑的是特殊情况，当size超过了定义的最大尺寸情况，我们需要进行一个判断， 123456789101112131415161718void SeqListPushTop(SeqList *pSeq,DataType data)&#123; assert(pSeq); if(pSeq-&gt;size &gt;= MAX_SIZE)&#123; printf("满了\n"); assert(0); return; &#125; //从最后开始向每一个后面开始搬运，如果不这么做，将会将每一次的值覆盖掉 for(int i = pSeq-&gt;szie;i &gt; 0; i--)&#123; // i此时是定义的为位置,位置为[size,0],从后往前搬 pSeq-&gt;array[i] = pSeq-&gt;array[i - 1]; &#125; //将i定位为数据,位置size[0,size),将整体的位置向后移 for(int i = size - 1；i &gt; 0;i++)&#123; pSeq-&gt;array[i + 1] = pSeq-&gt;array[i]; &#125; pSeq-&gt;array[0]=data; pSeq-&gt;size++;&#125; 这是一个自我思考的图示，仅供参考 尾插的使用尾插就相当于正常插入了，这个是比较简单的一种插入 1234567891011void SeqListPushBack(SeqList *pSeq,DataType data)&#123; //还是要先考虑特殊情况 assert(pSeq); if(pSeq-&gt;size &gt;= MAX_SIZE)&#123; printf("满了\n"); assert(0); return; &#125; pSeq-&gt;array[pSeq-&gt;size] = data; pSeq-&gt;size++;&#125; 中间插入的使用中间插入根据下标来使用，此时这么想，我们先将要插入的地方定义一个pos下标，此时将此下标之后的（包括此下标的）所有数据向后移动。 123456789101112131415161718void SeqListInsert(SeqList *pSeq,int pos, DataType data)&#123; //考虑特殊情况 assert(pSeq); if(pSeq-&gt;size &gt;= MAX_SIZE)&#123; printf("满了\n"); assert(0); return; //此时i作为位置 for(int i = pSeq-&gt;size; i &gt;= pos; i--)&#123; pSeq-&gt;array[i] = pSeq-&gt;array[i - 1]; &#125; //此时i作为数据 for(int i = pSeq-&gt;size - 1;i &gt;= pos; i--)&#123; pSeq-&gt;array[i + 1] = pSeq-&gt;array[i]; &#125; pSeq-&gt;array[pos] = data; pSeq-&gt;szie++;&#125; 自我图示，仅供参考 删除：头删，尾删，删除头删的使用最开始的数删除后，其他的数据向前补进。当然，也别忘了特殊情况！ 123456789101112131415161718void SeqListPushFont(SeqList *pSeq)&#123; //特殊情况 assert(pSeq) if(pSeq-&gt;size &lt;= 0)&#123; printf("空了\n"); assert(0); return; &#125; //i此时为位置时 for(int i = 0; i &lt; pSeq-&gt;size - 1;i++)&#123; pSeq-&gt;array[i] = pSeq-&gt;array[i + 1]; &#125; //i此时为数据时 for(int i = 1;i &lt; pSeq-&gt;size;i++)&#123; pSeq-&gt;array[i - 1] = pSeq-&gt;array[i]; &#125; pSeq-&gt;size--;&#125; 尾删的使用尾删比较简单，也就是直接将最后一个删除 123456789void SeqListPushPop(SeqList *pSeq)&#123; assert(pSeq) if(pSeq-&gt;size &lt;= 0)&#123; printf("空了\n"); assert(0); return; &#125; pSeq-&gt;size--;//直接将空间减小&#125; 删除的使用删除从中间删除，还是定义一个pos下标，删除之后，在将所有数据向前移动 1234567891011void SeqListPushErase(SeqList *pSeq,int pos)&#123; assert(pSeq) if(pSeq-&gt;size &lt;= 0)&#123; printf("空了\n"); assert(0); return; &#125; for(int i = pos;i &lt;= pSeq-&gt;size ;i--)&#123; pSeq-&gt;array[i - 1] = pSeq-&gt;array[i]; &#125;&#125; 当我们基本的这些操作编写完之后，我们需要输出这些数组，来观察。 1234567void SeqListPrint(const SeqList *pSeq)&#123; assert(pSeq != NULL); for(int i = 0;i &lt; pSeq-&gt;size;i++)&#123; printf("%d",pSeq-&gt;array[i]); &#125; printf("\n");&#125; 删除的第二种形态用接口的方式来实现删除。 接口可以理解为封装一个函数来对其使用。这样我们就可以有一些其他的删除方式 删除第一个遇到的数据的形式12345678void SeqListRemove(SeqList *pSeq, DataType data)&#123; int pos = SeqListFind(pSeq,data); if(pos == -1)&#123; //找不到删除 return; &#125; SeqListPushErase(pSeq, pos);&#125; 删除遇到的所有数据的形式123456void SeqListRemoveALL(SeqList *pSeq,DataType data)&#123; //第一种方式 while(pos = SeqListFind(pSeq,data) != -1)&#123; SeqListPushErase(pSeq,data); &#125;&#125; 12345678910111213141516171819202122void SeqListRemovALL(SeqList *pSeq,DataType data)&#123; //第二种方式 //一次遍历空间，时间快，但是开辟了新空间，空间大小和size有关系 //开辟一个新空间，遍历原来的数组 //if arr[i] != data //new [j+1]= arr[j+1] //else i++ //把数据在搬回来，还剩的数据个数为i个 DataType *newArray = (DataType *)malloc(sizeof(DataType)*pSeq-&gt;size); int i, j; for(i = 0,j = 0;i &lt; pSeq-&gt;size;i++)&#123; if(data != pSeq-&gt;array[i])&#123; newArray[j] = pSeq-&gt;array[i]; j++ &#125; &#125; for(i = 0;i &lt; j; i++)&#123; pSeq-&gt;array[i] = newArray[i]; &#125; pSeq-&gt;size = j; free(newArray);&#125; 1234567891011void SeqListRemoveALL(SeqList *pSeq,DataType data)&#123; //第三种方法 //这个方法没有开辟新的空间，直接对其每个所对应的新区域赋值 //这样我们最后将数组size直接改为新开辟的大小 int i, j; for(i = 0,j = 0;i &lt; pSeq-&gt;size, i++)&#123; pSeq-&gt;array[j] = pSeq-&gt;array[i]; j++; &#125; pSeq-&gt;size = j;&#125; 查找的使用查找也是一个关键的选择，因为，在查找到我们需要的下标之后，我们可以对此进行各种增删改操作 查找也有很多方式，这里先仅做一种顺序遍历查找。查找也有二分查找(前提有序) 12345678int SeqListFind(SeqList *pSeq,DataType data)&#123; for(int i = 0;i &lt; pSeq-&gt;size;i++)&#123; if(data = pSeq-&gt;size[i])&#123; return 1; &#125; return -1; &#125;&#125; 一些其他的使用操作对于顺序表的操作我们还有一些其他的操作 1234int SeqListSize(SeqList *pSeq)&#123; //查看当前size的大小 return pSeq-&gt;size;&#125; 1234int SeqListEmpty(SeqList *pSeq)&#123; //清空当前数组 return pSeq-&gt;size == 0;&#125; 1234int SeqListFull(SeqList *pSeq)&#123; //将数组的size放到最大 return pSeq-&gt;size == MAX_SIZE;&#125; 123456void Swap(DataType *a,DataType *b)&#123; //交换两个数据 DataType t = *a; *a = *b; *b = t;&#125; 改的使用我们可以理解为，我们将要怎么让这个数组去改变，那么我们可以使用排序的方式将数组发生变化。这是一种改法。在静态顺序表中。通过举冒泡排序的例子来使用。 12345678910111213141516void SeqListBubbleSort(SeqList *pSeq)&#123; int i,j; int isSort; for(i = 0;i &lt; pSeq-&gt;size - 1;i++)&#123; isSort = 1; for(j = 0;j &lt;= pSeq-&gt;size - 1 - i; j++)&#123; if(pSeq-&gt;array[i] &gt; pSeq-&gt;array[i + j])&#123; Swap(pSeq-&gt;array + j, pSeq-&gt;array + j + i); &#125; isSort = 0; &#125; if(isSort)&#123; break; &#125; &#125;&#125; 在这里调用冒泡排序的方法是可以进行数组的改变。 以上就是关于静态顺序数组的基本组成。总的来说，数据结构的难点在于思想过程。怎么把在纸上我们通过绘画的东西，利用代码的形式去表达出来，这是一个很关键的思考过程。]]></content>
      <tags>
        <tag>C-数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初阶C-1107]]></title>
    <url>%2F2018%2F11%2F08%2F%E5%88%9D%E9%98%B6C-1107%2F</url>
    <content type="text"><![CDATA[这次的初阶都是跟C语言中的递归有关的。可以说递归是一个不好理解的，比较抽象的东西。 递归（Recursion），指在函数的定义中使用函数自身的方法，即程序的自身调用。 递归就是方法里调用自身。 但是递归的缺陷也是非常大的。在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储。递归次数过多容易造成栈溢出等，所以一般不提倡用递归算法设计程序。 1.递归和非递归分别实现求第n个斐波那契数。 12345678910111213141516171819202122232425262728//利用了递归int Fibonacci(int n)&#123; if (n == 1 || n == 2)&#123; return 1; &#125; return Fibonacci(n - 1) + Fibonacci(n - 2);&#125;//不使用递归void Fib(int n)&#123; int j = 1, k = 1, sum = 0; if (n == 1 || n == 2)&#123; return 1; &#125; if (n % 2 == 0)&#123; for (int i = 1; i &lt; n / 2; i++)&#123; j += k; k += j; &#125; printf("%d", k); &#125; else if(n % 2 == 1)&#123; for (int i = 1; i &lt;= n / 2; i++)&#123; j += k; k += j; &#125; printf("%d", j); &#125;&#125; 2.编写一个函数实现n^k，使用递归实现. 12345678//n^k 如果调用递归，我们先拆分这个算式// n^k=1,k=0;n^k=n*n^(k-1),k&gt;0double index(double n,double k)&#123; if (k == 0)&#123; return 1; &#125; return n*index(n, k - 1);&#125; 3.写一个递归函数DigitSum(n),输入一个非负整数,返回组成它的数字之和,例如,调用DigitSum(1729)，则应该返回1+7+2+9,它的和是19. 12345678910int DigitSum(int n)&#123; int m = 0; int sum = 0; if (n != 0)&#123; m = n % 10; n = n / 10; sum = m + DigitSum(n); &#125; return sum;&#125; 4.递归和非递归分别实现strlen. 123456789101112131415int Strlen(const char*str)&#123; if ('\0' == *str)&#123; return 0; &#125; return 1+Strlen(str + 1);//这里的+1可以理解成每次进行拆分去算 //比如“abcd” 先为“a”+“bcd”，第二次在为“b”+“cd”，以此类推&#125;int Strlen2(char str[])&#123; int size = 0; while (str[size] != '\0')&#123; size++; &#125; return size;&#125; 5.递归和非递归分别实现求n的阶乘 . 1234567891011121314151617void Fac(int n)&#123; int j = 1; if (n == 1)&#123; return 1; &#125; for (int i = 1; i &lt;= n; i++)&#123; j *= i; &#125; printf("%d", j);&#125;int Fac1(int a)&#123; if (a == 1)&#123; return 1; &#125; return a*Fac1(a-1);&#125; 6.递归方式实现打印一个整数的每一位. 1234567891011121314int PrintfNum(int n)&#123; if (n &gt; 9)&#123; printf("%d",PrintfNum(n / 10); &#125; printf("%d", n % 10); //逆序实现,非递归 //while (n)&#123; // m = n % 10; // n = n / 10; // printf("%d", m); //&#125; &#125; 本次就结束了，还有一个利用递归进行逆序的题，我觉得这道题很不好理解。我将专门写一篇关于这道题目的文章。 递归的思想是很重要的。我们可以想象成电影《盗梦空间》，一层接着一层的梦境，就好比我们的递归不断的往下进行，只有上一层完成后，才可到下一层。多加练习，多思考，一定会掌握的。]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初阶C-1103]]></title>
    <url>%2F2018%2F11%2F05%2F%E5%88%9D%E9%98%B6C-1103%2F</url>
    <content type="text"><![CDATA[1.实现一个函数，打印乘法口诀表，口诀表的行数和列数自己指定，输入9，输出99口诀表，输入12，输出1212的乘法口诀表。12345678910111213#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;void MultiplicationTable(int a)&#123; for (int i = 1; i &lt;= a; i++)&#123; for (int j = 1; j &lt;= i; j++)&#123; int k = 0; k = j*i; printf("%d*%d=%d ", j,i,k); &#125; printf("\n"); &#125;&#125; 2.使用函数实现两个数的交换。1234567void ChangeNum(int a, int b)&#123; int temp = 0; temp = b; b = a; a = temp; printf("%d,%d", a, b);&#125; 3.实现一个函数判断year是不是润年。1234567891011void LeapYear(int a)&#123; if (a % 100 == 0 &amp;&amp; a % 400 == 0)&#123; printf("%d is LeapYear", a); &#125; else if (a % 4 == 0 &amp;&amp; a % 100 != 0)&#123; printf("%d is LeapYear", a); &#125; else&#123; printf("Not LeapYear"); &#125;&#125; 4.实现一个函数，判断一个数是不是素数。1234567891011121314void prime(int a)&#123; if (a == 2)&#123; printf("It's a prime"); &#125; else &#123; for (int i = 3; i &lt;= a; i++)&#123; if (a%i == 0)&#123; break; &#125; printf("It's a prime"); &#125; printf("It's not a prime"); &#125;&#125; 5.创建一个数组,实现函数init()初始化数组、实现empty()清空数组、实现reverse()函数完成数组元素的逆置。 要求：自己设计函数的参数，返回值。12345678910111213141516171819202122232425262728293031#define size 5//数组初始化 就是定义数组变量的同时给其中的数组元素赋值，由于是给多个元素同时赋值void init()&#123; int arr[size] = &#123; 20, 16, 23, 75, 95, &#125;; for (int i = 0; i &lt; size; i++)&#123; printf("arr[%d]=%2d \n", i, arr[i]); &#125; printf("\n");&#125;void empty()&#123; int arr[5] = &#123; 20, 16, 23, 75, 95, &#125;; for (int i = 0; i &lt; (sizeof(arr) / sizeof(arr[0])); i++)&#123; arr[i] = '\0'; printf("arr[%d]=%2d \n", i, arr[i]); &#125; printf("\n");&#125;void reverse()&#123; int temp = 0; int i = 0; int arr[5] = &#123; 20, 16, 23, 75, 95, &#125;; for (i = 0; i &lt; 3; i++)&#123; temp = arr[i]; arr[i] = arr[4 - i]; arr[4 - i] = temp; &#125; for (i = 0; i &lt; 5; i++)&#123; printf("arr[%d]=%2d \n",i, arr[i]); &#125;&#125; 前4题很简单，并没有特别大的难度，只要掌握了计算公式，就可以算出。第五题的思路有很多种，这是我目前想出来的一种，初始化和清空比较容易想到。关于逆置，我的方法是比较繁琐的，要根据数组内个数的多少来判断i的取值范围，当然i是可以通过sizeof()来取代的，在此我就不更换了。还有memset()这个函数可以使用，以后我将找机会将其写出。 欢迎大家留言！我们可以一起讨论]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初阶C-1101]]></title>
    <url>%2F2018%2F11%2F04%2F%E5%88%9D%E9%98%B6C-1101%2F</url>
    <content type="text"><![CDATA[1.完成猜数字游戏。 源文件内需执行的1234567891011121314151617181920int main()&#123; while (1)&#123; printf("输入1，开始游戏\n"); printf("输入0，退出游戏\n"); int i = 0; scanf("%d", &amp;i); if (i == 1)&#123; Game(); &#125; else if(i == 0)&#123; printf("goodbye!\n"); break; &#125; else&#123; printf("请重新输入！\n"); &#125; &#125; system("pause"); return 0;&#125; 头文件.h1234567891011121314151617181920212223#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;#include&lt;time.h&gt;#include&lt;windows.h&gt;void Game()&#123; int num = 0; int result = 0; srand((unsigned int)time(NULL)); result = rand() % 100 + 1; do&#123; printf("请输入一个数:"); scanf("%d", &amp;num); if (num &lt; result)&#123; printf("lower\n"); &#125; else if(num &gt; result)&#123; printf("higher\n"); &#125; &#125; while (num != result); printf("congratulations!\n");&#125; 2.写代码可以在整型有序数组中查找想要的数字，找到了返回下标，找不到返回-1.（折半查找）123456789101112131415161718192021222324252627void find()&#123; int arr[] = &#123; 11, 12, 13, 14, 15, 16, 17, 18, 19 &#125;; int left = 0; int right = sizeof(arr) / sizeof(arr[0]) - 1;//减一是因为数组下标规则 int i = 0; int mid = (left + right) / 2; printf("输入一个数字进行查找："); scanf("%d", &amp;i); while (left &lt;= right)&#123;//在左边数小于右边数的情况下 mid = (left + right) / 2; if (arr[mid] &lt; i)&#123; left =mid + 1; &#125; else if(arr[mid] &gt; i)&#123; right = mid - 1; &#125; else&#123; break; &#125; &#125; if (arr[mid] == i)&#123; printf("%d", mid); &#125; else&#123; printf("-1"); &#125;&#125; 3.编写代码模拟三次密码输入的场景。 最多能输入三次密码，密码正确，提示“登录成功”,密码错误，可以重新输入，最多输入三次。三次均错，则提示退出程序。123456789101112void login()&#123; char pass[1024] = &#123;&#125;; char password[] = "123456"; for (int i = 0; i &lt; 3; i++)&#123; printf("Please enter you password:\n"); scanf("%s", &amp;pass); if (strcmp(password, pass) == 0)&#123; printf("Welcome to system!\n"); break; &#125; &#125;printf("sorry,exiting");&#125; 4.编写一个程序，可以一直接收键盘字符，如果是小写字符就输出对应的大写字符，如果接收的是大写字符，就输出对应的小写字符，如果是数字不输出。123456789101112void receive()&#123; printf("please enter successively\n"); while(1)//永真情况下。永远进行循环。在字符数c为数字时跳出循环。 &#123; char c; c = getchar();//从控制台读取一个字符，但不显示在屏幕上。 if (c &gt;= 48 &amp;&amp; c &lt;= 57)&#123; break; &#125; putchar(c); &#125;&#125; 本次作业都是一些关于for和while循环的一些用法。第二题是需要好好思考一下的，难点在于中间值在比较过后，向右还是向左的问题。最后一定要break退出，否则会无法跳出循环。]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初阶C_1030]]></title>
    <url>%2F2018%2F10%2F31%2F%E5%88%9D%E9%98%B6C-1030%2F</url>
    <content type="text"><![CDATA[1.在屏幕上输出一个上下倒三角星形的图案123456789101112131415161718192021222324252627void star()&#123;//将代码分为上三角和下三角来输出 int i, j, n = 7; for (i = 1; i &lt;= n; i++) &#123; for (j = 1; j &lt;= n - i; j++) &#123; printf(" "); &#125; for (j = 0; j &lt; 2 * i - 1; j++) &#123; printf("*"); &#125; printf("\n"); &#125; for (i = 6; i &gt; 0 ; i--) &#123; for (j = 1; j &lt;= n-i; j++) &#123; printf(" "); &#125; for (j = 1; j &lt; 2 * i ; j++) &#123; printf("*"); &#125; printf("\n"); &#125;&#125; 2.求出0～999之间的所有“水仙花数”并输出。例如： 153 = 1^3 + 5^3 + 3^3。 370 = 3^3 + 7^3 + 0^3。 371 = 3^3 + 7^3 + 1^3。 407 = 4^3 + 0^3 + 7^3。12345678910111213void narcissus()&#123; int i; int j, k, l; for (i = 0; i &lt; 1000; i++) &#123; j = i % 10; k = (i / 10) % 10; l = i / 100; if (i == j * j * j + k * k * k + l * l * l )&#123;//老铁！注意是"=="!! printf("%d\n", i); &#125; &#125;&#125; 3.求Sn=a+aa+aaa+aaaa+aaaaa的前5项之和，其中a是一个数字，例如：2+22+222+2222+22222 123456789void he(int a)&#123; //j每次都是j*10，之后在加上a。 int Sn = 0, i, j; j = a; //j=a，定义在循环之外，a的赋值只在第一次填写参数时。 for (i = 0; i &lt; 5; i++)&#123; Sn = j+ Sn; j = j * 10 + a; &#125; printf("%d", Sn);&#125;]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初阶C_1027]]></title>
    <url>%2F2018%2F10%2F31%2F%E5%88%9D%E9%98%B6C-1027%2F</url>
    <content type="text"><![CDATA[将数组A中的内容和数组B中的内容进行交换。（数组一样大） 12345678910111213141516171819void change_num()&#123; int a[5] = &#123; 12, 52, 36, 45, 62 &#125;; int b[5] = &#123; 21, 34, 13, 24, 72 &#125;; int i = 0; int tmp = 0; int sz = sizeof(a) / sizeof(a[0]);//所有数据的字节数除以一个数据的字节数等于数组的长度 for (i = 0; i &lt; sz; i++)&#123; tmp = a[i]; a[i] = b[i]; b[i] = tmp; &#125; for (i = 0; i &lt; sz; i++)&#123; printf("%d,", a[i]); &#125; printf("\n"); for (i = 0; i &lt; sz; i++)&#123; printf("%d,", a[i]); &#125;&#125; 计算1/1-1/2+1/3-1/4+1/5 …… + 1/99 - 1/100 的值。 12345678910111213void jisuan()&#123; double i;//最好改为double类型，因为1/i和1.0/i这两种写法，如果i的类型不同那么得出的答案也不同 double sum=0,sum1=0,sum2=0; for (i = 1; i &lt; 100; i += 2)&#123; sum1 = sum1 + 1 / i; &#125; for (i = 2; i &lt; 101; i += 2)&#123; sum2 = sum2 - 1 / i; &#125; sum=sum1+sum2; printf("%lf", sum);//%f和%lf分别是float类型和double类型用于格式化输入输出时对应的格式符号。 //%lf为双精度浮点&#125; 编写程序数一下 1到 100 的所有整数中出现多少次数字9。 12345678910void js9()&#123; int i; int count = 0; for (i = 0; i &lt; 101; i++)&#123; if ((i - 9) % 10 == 0||i / 9 == 10 )&#123; count++; &#125; &#125; printf("%d", count);//计算出来为19，这是因为99中有两个9存在，所以计算两次。刚开始总以为应该是18...&#125; 类型与计算公式别混淆，否则很容易代码出问题。]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初阶C_1025]]></title>
    <url>%2F2018%2F10%2F31%2F%E5%88%9D%E9%98%B6C-1025%2F</url>
    <content type="text"><![CDATA[#C常见的几种比较我用的VS2013，头文件与源文件分开，在此只贴出函数。 1.给定两个整形变量的值，将两个值的内容进行交换。 123456789void compare()&#123; int a = 10; int b = 20; int tmp = 0; tmp = a; a = b; b = tmp; printf("a=%d,b=%d", a, b);&#125; 2.不允许创建临时变量，交换两个数的内容 12345678void compare2()&#123; int a = 20; int b = 10; a = a - b; b = a + b; a = b - a; printf("a=%d,b=%d", a, b);&#125; 3.求10 个整数中最大值。 1234567891011void compare3()&#123; int a[10] = &#123; 12, 23, 51, 5, 24, 35, 62, 25, 19, 60 &#125;; int i; int max = a[0]; for (i = 0; i &lt; 11; i++)&#123; if (max &lt; a[i])&#123; max = a[i]; &#125; &#125; printf("最大数为%d", max);&#125; 4.将三个数按从大到小输出。 12345678910111213141516171819void compare4(int a,int b,int c)&#123; int tmp = 0; if (a &gt; b)&#123; tmp = a; a = b; b = tmp; &#125; if (b &gt; c)&#123; tmp = b; b = c; c = tmp; &#125; if (a &gt; b)&#123; tmp = a; a = b; b = tmp; &#125; printf("这三个数的排序为：%d,%d,%d", a, b, c);&#125; 在这里特别说一下，求最大公约数这用的是相减法，在while语句中，有个特别注意的。a-b的数需要考虑大小的问题，因为一直用大数减小数直到为0.5.求两个数的最大公约数。 12345678910111213141516171819void compare5(int a,int b)&#123; int tmp = 0; if (a &lt; b)&#123; tmp = a; a = b; b = tmp; &#125; while (a-b!=0)&#123; tmp = a - b; a = b; b = tmp; if (a &lt; b)&#123; tmp = a; a = b; b = tmp; &#125; &#125; printf("最大公约数为：%d", b);&#125;]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新的开始]]></title>
    <url>%2F2018%2F10%2F29%2F%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B%2F</url>
    <content type="text"><![CDATA[博客今日搭建初步完成，Markdown形式还不知道具体操作，会陆陆续续的进行完善。 说实话，一直就想搭建一个属于自己的博客。就为了能有个属于自己的小天地。 国内也有CSDN，博客园之类的。 但我觉得自己动手的会更好。 当我觉得自己足够强大时，会去尝试WordPress来搭建另外一种博客。 加油！程序程！]]></content>
      <tags>
        <tag>程序人生</tag>
      </tags>
  </entry>
</search>
