<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C进阶-数据的存储]]></title>
    <url>%2F2019%2F01%2F07%2FC%E8%BF%9B%E9%98%B6-%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8%2F</url>
    <content type="text"><![CDATA[就目前来看，C++和JAVA的选择我选择了前者。 大家都说是Hard模式，但是自己不尝试，不努力又怎么知道能否成功呢！ 所以再一次开始了C语言的进阶。这几部分总结完之后，我想就能开始C++的真正学习了！]]></content>
      <tags>
        <tag>进阶C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统之进程调度]]></title>
    <url>%2F2019%2F01%2F05%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[这周学校布置了关于操作系统的知识点论文，正好也写篇博客来好好分析一下关于进程调度的知识点。 调度的基本概念在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程。处理机调度，就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行。 调度的三个层次高级调度由于内存空间有限，有时无法将用户的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序。 高级调度（作业调度）。按一定的原则从外存上处于后备队列的作业中挑选一个（或多个）作业，给他们分配内存等必要资源，并建立相应的进程（建立PCB），以使它们获得竞争处理机的权利。高级调度使辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。作业调入时会建立相应的PCB，作业调出时才撤销PCB。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。 中级调度暂时调到外存等待的进程状态为挂起状态。值得注意的是，PCB并不会一起调到外存，而是会常驻内存。PCB中会记录进程数据在外存中存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到的挂起队列中。 中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存。 一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。 低级调度低级调度（进程调度），其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。 进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。 进程调度的频率很高，一般几十毫秒一次。 要做什么 调度发生在.. 发生频率 对进程状态的影响 高级调度 按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程 外存→内存 最低 无→创建态→就绪态 中级调度 按照某种规则，从挂起队列中选择合适的进程将其数据调回内存 外存→内存 中等 挂起态→就绪态 低级调度 按照某种规则，从就绪队列中选择一个进程为其分配处理机 内存→CPU 最高 就绪态→运行态 进程调度的方式非抢占方式只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。 抢占方式当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。 进程调度中的这两种方式决定了调度中时间的改变。 调度算法的评价指标CPU利用率 = 忙碌的时间/总时间 系统吞吐量 = 总共完成了多少道作业/总共花了多少时间 周转时间 = 作业完成时间 - 作业提交时间（到达时间） 平均周转时间 = 各作业周转时间之和 / 作业数 带权周转时间 = 作业周转时间/作业实际运行的时间 平均带权周转时间 = 各作业带权周转时间之和/作业数 这些名词可以衡量一个进程调度过程中，是否能达到一个高效的过程。时间的分配是否合理。但是这些也并不是都是绝对的。因为考虑到有些进程的调度有其他因素的考虑，所以我们只是将其作为一个参考。 调度算法先来先服务（FCFS）先来先服务算法：主要从“公平”的角度考虑（类似于我们生活中排队买东西的例子）。一种非抢占式的算法。 它主要按照作业/进程到达的先后顺序进行服务。等待时间越久的越优先得到服务。用于作业调度时，考虑的是哪个作业先到达后备队列；用于进程调度时，考虑的是哪个进程先到达就绪队列。对长作业有利，对短作业不利 进程 到达时间 运行时间 P1 0 7 P2 2 4 P3 4 1 P4 5 4 调度顺序为：P1→P2→P3→P4 短作业优先（SJF）短作业优先算法：追求最少的平均等待时间，最少的平均周转时间，最少的平均带权周转时间。所谓“最短”就是要求服务时间最短。即可用于作业调度，也可用于进程调度。它具有非抢占式和抢占式。 非抢占式：每次调度时选择已到达且运行时间最短的作业/进程 抢占式(最短剩余时间优先算法)：每当有进程加入就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列，另外，当一个进程完成时也需要调度。 调度顺序为：P1→P3→P2→P4 高响应比优先（HRRN）高响应比优先算法：要综合考虑作业/进程的等待时间和要求服务的时间 在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务。 响应比 = （等待时间 + 要求服务时间）/ 要求服务时间（响应比 &gt;= 1) 即可作业调度也可进程调度。它是一种非抢占式的算法。因此只有当前运行的作业/进程主动放弃处理机（CPU）时，才需要调度，才需要计算响应比。调度时计算所有就绪进程的响应比，玄响应比最高的进程上处理机。看下面例子： 进程 到达时间 运行时间 P1 0 7 P2 2 4 P3 4 1 P4 5 4 0时刻：只有P1到达就绪队列，P1上处理机 7时刻（P1主动放弃CPU）：就绪队列中有P2（响应比=（5+4）/4=2.25）、P3((3 + 1) / 1 =3)、P4((2 + 4)/4 = 1.5），P3的响应比高，所以P3上处理机 8时刻（P3完成）：P2（2.5），p4（1.75）P2高，P2上处理机 12时刻（P2完成）：就绪队列中只剩下P4.这时候P4上处理机 算法 可抢占？ 优点 缺点 考虑到等待时间&amp;运行时间 会导致饥饿？ FCFS 非抢占 实现简单 对短作业不利 1，0 不会 SJF/SPF 默认为非抢占式，但也有抢占式 最短的平均等待/周转时间 对长作业不利，可能导致饥饿；难以做到真正的短作业优先 0，1 会 HRRN 非抢占 上述两种算法的权衡折中，综合考虑的等待时间和运行时间 1，1 不会 注：1为考虑到，0为没有考虑到 以上这三种算法一般适合于早期的批处理系统。下面的算法适合于交互式系统的调度算法。 时间片轮转调度算法时间片轮转算法：公平地、轮流地为各个进程服务，让每个进程在一定时间隔内都可以得到响应。按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms），若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。 只用于进程调度，只有作业放入内存建立了相应的进程后，才能被分配处理机时间片。该算法也属于抢占式算法，由时钟装置发出时钟中断，来通知CPU时间片已到。轮流让就绪队列中的进程依次执行一个时间片（每次选择的都是排在就绪队列队头的进程）。 进程 到达时间 运行时间 P1 0 5 P2 2 4 P3 4 1 P4 5 6 时间片的大小为2。 0时刻(P1(5)):0时刻只有P1到达就绪队列，让P1上处理机运行一个时间片 2时刻(P2(4)→P1(3))：2时刻P2到达就绪队列，P1运行完一个时间片，被剥夺处理机，重新放到队尾。此时P2排在队头，因此让P2上处理机。(注意：2时刻，P1下处理机，同一时刻新进程P2到达，如果在题目中遇到这种情况，默认新到达的进程先进入就绪队列) 4时刻(P1(3)→P3(1)→P2(2)):4时刻，P3到达，先插到就绪队尾，紧接着，P2下处理机也插到队尾 5时刻(P3(1)→P2(2)→P4(6)):5时刻，P4到达插到就绪队尾(注意：由于P1的时间片还没用完，因此P1重新排到就绪队列之后，等到执行) 6时刻(P3(1)→P2(2)→P4(6)→P1(1)):6时刻，P1时间片用完，下处理机，重新放回就绪队尾，发生调度 7时刻(P2(2)→P4(6)→P1(1))：虽然P3的时间片没用完，但是由于P3只需运行1个单位的时间，运行完了会主动放弃处理机，因此也会主动放弃处理机，因此也会发生调度。队头进程P2上处理机。 9时刻(P4(6)→P1(1))：进程P2时间片用完，并刚好运行完，发生调度，P4上处理机 11时刻(P1(1)→P4(4))：P4时间片用完，重新回到就绪队列，P1上处理机 12时刻(P4(4))：P1运行完，主动放弃处理机，此时就绪队列中只剩P4，P4上处理机 14时刻()：就绪队列为空，因此让P4接着运行一个时间片 16时刻：所有进程运行结束 优先级调度算法优先级调度算法：每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程。即可用于作业调度，也可用于进程调度。 非抢占式：只需在进程主动放弃处理机时进行调度即可，每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度 抢占式：需要在就绪队列变化时，检查是否会发生抢占。每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度。另外，当就绪队列改变时也需要检查是否会发生抢占。 0时刻(P1):只有P1到达，P1上处理机 2时刻(P2)：P2到达就绪队列，优先级比P1更高，发生抢占。P1回到就绪队列，P2上处理机 4时刻(P1、P3)：P3到达，优先级比P2更高，P2回到就绪队列，P3抢占处理机 5时刻(P1、P2、P4):P3完成，主动释放处理机，同时，P4也到达，由于P2比P4更先进入就绪队列，因此选择P2上处理机 7时刻(P1、P4):P2完成，就绪队列只剩P1、P4，P4上处理机。 11时刻(P1):P4完成，P1上处理机。 就绪队列未必只有一个，可以按照不同优先级来组织，另外，也可以把优先级高的进程排在更靠近队头的位置。 以上就是关于操作系统进程调度的基本定义和算法。毕竟CPU是计算机的核心，它具有对我们的进程进行分配的一个过程。可以看作是OS中关键的部分。比如我们日常生活中又想听歌又想敲代码。这时候我们的CPU就要对我们的这个行为进行一个分配管理。通过一个学期的学习，OS让我更加对计算机和编程有了更大兴趣。也真的更加看到了自己的不足。想真正成为一个大佬还差得十万八千里呢。所以，从现在脚踏实地的做起吧。]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim操作总结]]></title>
    <url>%2F2019%2F01%2F03%2Fvim%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[之前学了Linux，用了vim之后发现特别强大。这一周又在做串口实验，我又用的Linux做的，再一次感觉到vim的强大。但是在写代码的过程中，因为快捷键没有记住，所以并不流畅。所以这周闲了，赶快来总结一下。 首先通过指令 vimtutor 进入到vim新手教程。 Kana大神说过，对vim的掌握有五个层次： 层次0： 对vim一无所知 层次1： 了解vim的基本使用 层次2： 知道可视模式 层次3： 知道多种移动动作 层次4： 不再需要可视模式 说实话，我目前只能说在层次0.5（哈哈哈哈哈哈哈哈哈）。因为我了解但是基本操作都不记得 文本基本编辑移动光标这个操作比较基础，上下左右的使用，打破了使用方向键的惯性习惯。不是说不能使用方向键，而是编辑器特有的操作方式。 h：代表光标左移 l：代表光标右移 j：代表光标下移 k：代表光标上移 进入与退出输入vimtutor进入教程，退出或者需要其他指令时，先使用ESC键。然后:q!退出。 文本删除将光标移至需要删除的字符处，按下x键 文本插入将光标移至第一个准备插入字符的位置，按下i键 文本添加将光标移至需要插入的位置，按下a键 文本保存并退出按下ESC进入正常模式，然后:wq按键操作，即可退出并保存。 删除命令使用dw可以从光标处删除至一个单词的结尾 使用d$可以从当前光标删除至行末 使用de可以从当前光标删除到单词末尾，包括最后一个字符 计数动作输入2w使光标向前移动两个单词 输入3e使光标向前移动到第三个单词的末尾 输入0移动光标到行首 计数动作删除d+number+motion 例如输入d2w删除光标后面两个单词 输入dd可以直接删除掉整行 输入2dd可以直接删除两行 撤销类命令重要的说三遍 ctrl组合键，按住ctrl不放+操作按键 ctrl组合键，按住ctrl不放+操作按键 ctrl组合键，按住ctrl不放+操作按键 输入x删除字符之后，利用u来撤销最后一次的执行命令（类比于Windows下的ctrl-z） 利用U恢复该行的原始状态 利用CTRL-R撤销掉撤销命令（类比于Windows下的crtl-y） 置入类命令输入p将最后一次删除的内容置入光标之后 将光标移动到需要更改的位置，输入r之后在输入一个我们需要替换的字符，就可以完成更改 如果要改变文本中的一个单词，先将光标移动到错误单词处，按下cw键，然后输入正确的单词 如果要改变文本中的更多单词，先将光标移动到错误单词处，按下c$键，然后输入你想输入的 定位及文件状态定位文件关键位置按下CTRL-g此时我们在vim编辑框最底部，可以查看到一个状态信息行。记住这个行号！！ 按下gg跳至文件最开头，按下G跳至文件最底部 输入你想要返回的 行号+G，可以返回第一次按下ctrl-g时所在的行了 搜索类命令跟：命令相似，输入/,加上你所要查找的关键字符，就可以查找到。 按键n查找同上一个字符，按键N查找同下一个字符（可称为逆向查找） 配对括号查找（好用）输入%可以查找配对的括号)、]、} 替换命令将光标移到需要改变的一行。输入:s/错误字符/修改字符，只替换第一个匹配串 若是:s/错误字符/修改字符/g替换全行的字符串 若是:#,#s/错误字符/修改字符#，#代表的是替换若干行的首尾两行 若是:%s/错误字符/修改字符/g替换整个文件的每个匹配串 若是:%s/错误字符/修改字符/gc替换整个文件的每个匹配串，但是会进行提示，是否进行替换 vim内执行外部指令输入:!+你所需要的外部指令（LINUX具有的）比如:!dir 对文件的改动保存到文件中输入w FILENAME保存到文件中 可视模式（超关键）按 v 键使 Vim 进入可视模式进行选取。您可以四处移动光标使选取区域变大或变小。 接着您可以使用一个操作符对选中文本进行操作。例如，按 d 键会删除选中的文本内容。 提取和合并文件:r FILENAME 可提取磁盘文件 FILENAME 并将其插入到当前文件的光标位置后面。 打开类命令光标移动到想要添加的上一行，按下o键，可以打开新的一行，进行编辑 附加类命令输入 a 将可在光标之后插入文本。 a、i 和 A 都会带您进入插入模式，惟一的区别在于字符插入的位置。 另一个置换类命令的版本移动光标到需要更改的位置，输入按键R，就可以连续更改了，按ESC退出 复制粘贴文本（绝对是最需要的！！！！！！！！）先按键v进入可视模式，对需要复制的部分进行选取。选取完之后，按y进行复制拷贝。 在移动光标到我们需要复制的位置，按p进行粘贴。 设置类的选项设置可使查找或者替换可忽略大小写的选项 输入:set ic可以忽略大小写。输入:set noic禁用大小写 输入:set incsearch,查找短语时显示部分匹配 输入:set hlsearch,高亮显示所有的匹配短语 关于vim获取帮助，输入:help或者按下F1。 创建启动脚本Vim 的功能特性要比 Vi 多得多，但其中大部分都没有缺省启用。为了使用更多的特性，您得创建一个vimrc 文件。 开始编辑 vimrc 文件，具体命令取决于您所使用的操作系统： `:edit ~/.vimrc` 这是 Unix 系统所使用的命令 `:edit $VIM/_vimrc ` 这是 MS-Windows 系统所使用的命令 接着读取 vimrc 示例文件的内容：:r $VIMRUNTIME/vimrc_example.vim 保存文件，命令为：:write 以上就是vim的基本操作。这些掌握了，用起来就特别方便啦。还是那句话，操作不能靠背的。需要多练。换句话说，多敲代码就行啦！！！！！]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初阶C-1201]]></title>
    <url>%2F2019%2F01%2F01%2F%E5%88%9D%E9%98%B6C-1201%2F</url>
    <content type="text"><![CDATA[1.调整数组使奇数全部都位于偶数前面。 题目：输入一个整数数组，实现一个函数，来调整该数组中数字的顺序使得数组中所有的奇数位于数组的前半部分，所有偶数位于数组的后半部分。 123456789101112131415161718192021void reverse_array(int a[],int n)&#123; //数组的两头分别向中间检索 int left = 0; int right = n - 1; while(left&lt;right)&#123; //从左开始查找数是偶数的 while(left &lt; right &amp;&amp; (a[left] % 2) != 0)&#123; left++; &#125; //从右开始查找是奇数的 while(right &lt; left &amp;&amp; (a[right] % 2) == 0)&#123; right++; &#125; while(left &lt; right)&#123; a[left] = a[left] ^ a[right]; a[right] = a[left] ^ a[right]; a[left] = a[left] ^ a[right]; //利用异或的方式进行交换数 &#125; &#125;&#125; 2.杨氏矩阵有一个二维数组. 数组的每行从左到右是递增的,每列从上到下是递增的. 在这样的数组中查找一个数字是否存在. 时间复杂度小于O(N); 数组： 1 2 3 / 1 3 4 / 1 2 3 2 3 4 / 2 4 5 / 4 5 6 3 4 5 / 4 5 6 / 7 8 9 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 //从右上角开始搜索 //key &gt; a[i][j] --&gt; 向左搜索 //key &lt; a[i][j] --&gt; 向下搜索 //从左下角开始搜索 //key &lt; a[i][j] --&gt; 向右搜索 //key &gt; a[i][j] --&gt; 向上搜索int main()&#123; int a[3][3] = &#123; 1, 2, 3, 4, 5, 6, 7, 8, 9 &#125;; int n; int px, py; scanf("%d", &amp;n); if (find(a, 3, 3, n, &amp;px, &amp;py))&#123; printf("%d,%d", px, py); &#125; else&#123; return 0; &#125;&#125;void find(int a[3][3],int row,int col,int key,int *px,int *py)&#123; //从右上角开始搜索 int x = 0; int y = col - 1; //左下角搜索结束 //x &gt;= row;y &lt; 0; while(x &lt; row &amp;&amp; y &gt;= 0)&#123; if(a[x][y] == key)&#123; *px = x; *py = y; return 1; &#125; else if(a[x][y] &gt; key)&#123; //向左搜索 y--; &#125; else&#123; x++; &#125; &#125; *px = -1; *py = -1; return 0; //如果都没有搜索到，就将其赋予一个不存在的值，直接返回0；&#125;void find_r(int a[3][3],int row,int col,int x,int y,int key,int *px,int *py)&#123; //从左下角开始搜索,利用递归的写法 //因为是递归循环，所以没有循环，我们需要记住此时是在哪个位置 //所以我们定义了参数x，y if(x &lt; 0 || y &gt; col)&#123; return 0; &#125; if(key &gt; a[x][y])&#123; return find_r(a, row, col, x, y + 1, key, px, py); &#125; else if(key &lt; a[x][y])&#123; return find_r(a, row, col, x - 1, y, key, px, py); &#125; else if(key == a[x][y])&#123; *px = x; *py = y; return 1; &#125;&#125; 初阶C已结束！接下来就是进阶了！加油！一定要完成自我的进化！]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-对豆瓣的top250的爬取(利用正则表达式)]]></title>
    <url>%2F2018%2F12%2F10%2Fpython-%E5%AF%B9%E8%B1%86%E7%93%A3%E7%9A%84top250%E7%9A%84%E7%88%AC%E5%8F%96%2F</url>
    <content type="text"><![CDATA[之前写了一个猫眼的爬虫的代码。是利用了request()和beautifulsoup()。但是之前的方法是利用了selector的搜索方法。最近学习了一点正则表达式，用正则表达式对豆瓣的top250进行了尝试。 豆瓣一直都是我比较喜欢的一个app，我也很喜欢看电影，你如果喜欢，在我的博客里有我的豆瓣链接，我们可以互粉一下聊聊电影hhhhhh，看得不多，但坚持再看并且写影评。 这次爬取下来top250的数据也非常高兴。 正则表达式的定义正则表达式，又称规则表达式。（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。 1import re python如果要使用正则表达式，首先需要引用re库 re库是一个python中有关于正则表达式的第三方库。因为我们在匹配过程中，也需要一些函数来剔除我们不需要的冗余字符。 正则表达式常用操作符(1) 操作符 说明 实例 . 表示任何单个字符 比如在非贪婪匹配中(.*?) [ ] 字符集，对单个字符给出取值范围 [abc]表示a/b/c，[a-z]表示a到z的单个字符 [^ ] 非字符集，对单个字符给出排除范围 [^abc]表示非a非b非c的单个字符 * 前一个字符0次或无限次扩展 abc*表示为ab/abc/abccc + 前一个字符1次或无限次扩展 abc+表示abc/abcc/abccc ? 前一个字符0次或1次扩展 abc？表示ab/abc &#124; 左右表达式的任意一个 abc &#124; def表示 abc、def 正则表达式的常用操作符(2) 操作符 说明 实例 {m} 扩展前一个字符m次 ab{2}c表示abbc {m,n} 扩展前一个字符m至n次（含n） ab{1,2}c表示abc、abbc ^ 匹配字符串开头 ^abc表示abc且在一个字符串的开头 $ 匹配字符串结尾 abc$表示abc且在一个字符串的结尾 ( ) 分组标记，内部只能使用 &#124; 操作符 (abc)表示abc,(abc &#124; def)表示abc、def \d 数字，等价于[0-9] \w 单词字符，等价于[A-Za-z0-9_] 常用标记 说明 re.I re.IGNORECASE 忽略正则表达式中的大小写，[A-Z]能够匹配小写字符 re.M re.MULTILINE 正则表达式中的^操作符能够将给定字符串的每行当作匹配开始 re.S re.DOTALL 正则表达式中的.操作符能够匹配所有字符，默认匹配除了换行以外的所有字符 以上这些常用的操作符对于爬虫来说是足够的了，我们还需要的是怎么去使用去让其匹配。 正则表达式的练习我用的是anaconda中的jupyter进行练习。 几种常见的匹配方式首先引用这个库，常规操作 1import re 最常规匹配123456content='Hello 123 4567 World_This is a Regex Demo'print(len(content))result=re.match('^Hello\s\d\d\d\s\d&#123;4&#125;\s\w&#123;10&#125;.*Demo$',content)print(result)print(result.group())#group()表示取全部匹配的字符串或者指定的组，返回结果是一个字符串print(result.span())#span()表示返回一个元组包含匹配 (开始,结束) 的位置 输出结果 1234567841&lt;re.Match object; span=(0, 41), match='Hello 123 4567 World_This is a Regex Demo'&gt;Hello 123 4567 World_This is a Regex Demo(0, 41)#这是最常规的匹配，将每一个字符都用操作符#\s 是一个匹配空格 \d 匹配数字 \d&#123;4&#125; 匹配一串数字#.*Demo$ 点用于匹配之前的 *作为前一个字符的匹配与'点'一起 最后用$作为一个匹配字符串的结尾 泛匹配1234content = 'Hello 123 4567 World_This is a Regex Demo'result = re.match('^Hello.*Demo$',content)print(result)print(result.group()) 输出结果 1234&lt;re.Match object; span=(0, 41), match='Hello 123 4567 World_This is a Regex Demo'&gt;Hello 123 4567 World_This is a Regex Demo#泛匹配就比较省略，有前面和后面的字符就行，中间的不需要也可以 匹配目标12345content = 'Hello 1234567 World_This is a Regex Demo'result = re.match('^Hello\s(\d+)\sWorld.*Demo$',content)print(result)print(result.group(1))#为了看看匹配的分组中是否是我所需要的print(result.span()) 输出结果 12345&lt;re.Match object; span=(0, 40), match='Hello 1234567 World_This is a Regex Demo'&gt;1234567(0, 40)#(\d+) \d表示数字, + 表示一个或多个，括号就是将其作为一个分组 接着是两个比较关键的匹配方法 贪婪匹配1234content = 'Hello 1234567 World_This is a Regex Demo'result = re.match('^He.*(\d+).*Demo$',content)print(result)print(result.group(1)) 输出结果 1234567&lt;re.Match object; span=(0, 40), match='Hello 1234567 World_This is a Regex Demo'&gt;7#Python里数量词默认是贪婪的（在少数语言里也可能是默认非贪婪），总是尝试匹配尽可能多的字符#贪婪模式下字符串查找会直接走到字符串结尾去匹配，如果不相等就向前寻找，这一过程称为回溯。#上面的例子可以看出 .* 这样的前后搭配匹配 可以前后尝试尽可能多的匹配字符 非贪婪匹配1234content = 'Hello 1234567 World_This is a Regex Demo'result = re.match('^He.*?(\d+).*Demo$',content)print(result)print(result.group(1)) 输出结果 12345&lt;re.Match object; span=(0, 40), match='Hello 1234567 World_This is a Regex Demo'&gt;1234567#非贪婪则相反，总是尝试匹配尽可能少的字符。在"*","?","+","&#123;m,n&#125;"后面加上？，使贪婪变成非贪婪。#非贪婪模式下会自左向右查找，一个一个匹配不会出现回溯的情况。 匹配模式12345content = '''Hello 1234567 World_Thisis a Regex Demo'''result = re.match('^He.*?(\d+).*?Demo',content,re.S)print(result.group(1)) 匹配模式主要利用了re库中的re.S参数，这样就可以将字符串作为一个整体，在整体中进行匹配。 以上就是关于正则表达式的基本知识。看一下例子，知道大概就足够了。 豆瓣的正则表达式 首先进入豆瓣的top250排行榜，我们首先能看到的就是关于电影的内容。利用chrome浏览器右击检查打开审查元素，我们来观察一下这个网页的html大概构成。 我们将鼠标放到li标签上，可以看到左侧的一片区域都被标记了。说明这一块都是有关《肖申克的救赎》。 一步一步点开这个标签我们将鼠标放到每一个标签之上能看到，每一个标签都有一个与之对应的区域，这个时候我们就需要使用这些标签来构建正则表达式。 我们从每一个标签自上而下看下来。 依次是名次 片名 职员表 类型 星级 评价人数 热门短评这几个 比如名次去匹配 12'&lt;em class=""&gt;(\d+)&lt;/em&gt;'#因为名次是用数字表示的，先将一个标签内的数字用(\d+)来表示 12'&lt;em class=""&gt;(\d+)&lt;/em&gt;.*?&lt;span class=title"&gt;(.*?)&lt;/span&gt;'#当第一个标签完成之后，根据非贪婪匹配的规则 .*? 这样继续根据HTML标签的镶嵌继续向下搜寻。直到span标签结束。中间括号是我们需要匹配的内容 正则表达式的使用还是很简单的，只要找到我们需要的内容，利用非贪婪匹配进行前后选择就好了 下面的是一个已经匹配好的正则表达式。 1'&lt;em class=""&gt;(\d+)&lt;/em&gt;.*?&lt;span class="title"&gt;(.*?)&lt;/span&gt;.*?&lt;p class=""&gt;(.*?)&lt;/p&gt;.*?&lt;span class="rating_num" property="v:average"&gt;(.*?)&lt;/span&gt;.*?&lt;span&gt;(.*?)&lt;/span&gt;.*?&lt;span class="inq"&gt;(.*?)&lt;/span&gt;' 代码获取内容接下来的步骤就与我之前的一篇博文的内容很相似了 python-对猫眼网的top100的爬取 首先需要定义一个函数去获取页面 1234567891011121314import requestsimport reimport jsonfrom requests.exceptions import RequestExceptionimport time#得到网页源代码def get_one_page(url): try: res=resquest.get(url) if res.status_code==200: return res.text return None except RequestException: return None 得到了网页源代码之后，需要利用正则表达式去匹配出我们需要的内容，并将它们放入到一个字典中。 1234567891011121314151617181920212223242526def pares_one_html(html): regex='&lt;em class=""&gt;(\d+)&lt;/em&gt;.*?&lt;span class="title"&gt;(.*?)&lt;/span&gt;.*?&lt;p class=""&gt;(.*?)&lt;/p&gt;.*?&lt;span class="rating_num" property="v:average"&gt;(.*?)&lt;/span&gt;.*?&lt;span&gt;(.*?)&lt;/span&gt;.*?&lt;span class="inq"&gt;(.*?)&lt;/span&gt;' pattern=re.compile(regex,re.S)#re.compile()编译正则表达式模式 items=re.findall(pattern,html)#返回的是一个list对象 for item in items: content="" for every_list in item[2].split(): #split()通过指定分隔符对字符串进行切片，因为职员表处有些标签需要我们进行处理 content=content+"".join(every_list) content=re.sub('&amp;nbsp;',' ',content) content=re.sub('&lt;br&gt;',' ',content) #删除空格和&lt;br&gt;这些多余的部分 #将获取到的list放到dict字典中 dict=&#123; "index":item[0], "name":item[1], "describe":content, "star":item[3], "evaluate":item[4], "title":item[5] &#125; print(dict) #此时先打印看一下，是否数据是正确的 #将数据写入文本中 with open('doubanMovie.txt','a',encoding='utf-8') as f: f.write(json.dumps(dict,ensure_ascii=False)+'\n') 此时还有两个问题，我们此时只是能将第一个页面的数据爬取下来，这时候我们得分析一下这个url在切换页面时，它是怎么变化的。 https://movie.douban.com/top250这是豆瓣top250的第一页 转到第二页，第三页可以看到网页的变化 https://movie.douban.com/top250?start=25&amp;filter= 第二页 https://movie.douban.com/top250?start=50&amp;filter= 第三页 url中的参数start={} 这个数在不断的变化，而且规律是每次隔25个，说明这就是我们需要的。 123456if __name__ == '__main__': urls=['https://movie.douban.com/top250?start=&#123;&#125;&amp;filter='.format(str(i)) for i in range(0,250,25)] for url in urls: html=get_one_page(url) parse_one_html(html) time.sleep(2) 最后将url放在一个列表中，利用for循环去将所有这些网页循环将数据爬取出来。 最后展示一下 python的学习中，爬虫只要有了基本的知识之后就可以慢慢尝试了，而且我觉得爬虫是最容易有自豪感的。 之前对猫眼的爬取用到了基本的Requests和beautifulsoup，接下来还会在写一篇关于Scrapy的基础知识，这个我认为是爬虫的总统山…但是我也还在摸索中 接着刷电影去了….(●’◡’●)]]></content>
      <tags>
        <tag>python-爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初阶C-1124]]></title>
    <url>%2F2018%2F12%2F06%2F%E5%88%9D%E9%98%B6C-1124%2F</url>
    <content type="text"><![CDATA[1.编写函数： unsigned int reverse_bit(unsigned int value); 这个函数的返回值value的二进制位模式从左到右翻转后的值。 如： 在32位机器上 25这个值包含下列各位： 00000000000000000000000000011001 翻转后：（2550136832） 10011000000000000000000000000000 程序结果返回： 2550136832 12345678910111213141516171819202122232425262728unsigned int reverse_bit(unsigned int value)&#123; //第一种方法 unsigned int sum = 0; int i; for(i = 0;i &lt; 32;i++)&#123; sum = sum + ((value &gt;&gt; i) &amp; 1) * pow(2,31 - i); &#125; return sum; //输入任意一个数，进行移位操作并且移位一次还要和1进行一次与操作，这个时候判断最后一个位是1还是0。 //当判断完之后，进行乘方 //第一个数 ----&gt; 32位 2^31 //第二个数 ----&gt; 32位 2^30 //对每一位的数进行了判断之后(判断是为1还是为0)，乘以它的方就是将其转换放在翻转后的位置 //全部相加之后，就是每个翻转之后的位置 //第二种方法 unsigned int temp = 0; int i; for(i = 0;i &lt; 31;i++)&#123; temp = temp &lt;&lt; 1; temp = temp | ((value &gt;&gt; i) &amp; 1); &#125; return temp; //将每一个最后位都取出来 //放在新建变量的最后一位 //左移新建变量temp //我们可以这样理解，我们取出一个变量。让这个变量每次向左移动。这样每次左移之后它的位数都在增加，但是增加之后，仅仅只是增加了位数，具体值的判断再由下一步 //还是依旧判断最后一位是否为1，判断是否为1之后再去与变量进行 或运算。如果是1，那么与完之后的结果为1.否则与完之后的结果为0.并不冲突。位数再增加，但是每次增加的位数还是要进行判断是0还是1.最后将这个变量返回。即为翻转之后的数。&#125; 2.不使用（a+b）/2这种方式，求两个数的平均值。 123456789101112int avg()&#123; int i,j; int num; printf("enter tow numbers\n"); scanf("%d %d",&amp;i,&amp;j); num = (i &amp; j) + (i ^ j) &gt;&gt; 1; printf("%d",num); //不用最常规的写法，那么就是以二进制的角度来思考。 //二进制去求平均数。那么就是让每一位都进行一个求其平均 //&amp; 用来判断相同位的平均值， ^ 用来判断不同位的平均值(不同位进行^运算之后，得的是不同位的值，这时候将其除以2得到的就是不同位的平均值) //之后将它们相加之后，得到就是二进制下的平均数&#125; 3.编程实现： 一组数据中只有一个数字出现了一次。其他所有数字都是成对出现的。 请找出这个数字。（使用位运算） 12345678910void find_num()&#123; int arr[9] = &#123; 5, 5, 2, 4, 8, 9, 8, 4, 9 &#125;; int len = sizeof(arr)/sizeof(arr[0]); for(int i = 1;i &lt; len;i++)&#123; arr[0] = arr[0] ^ arr[i]; &#125; printf("%d",arr[0]); //连续异或，偶数位的最后异或还是为0，但是奇数位的异或最后为1 //所以最后可能出现的只是单独出现的的位数。&#125; 4.有一个字符数组的内容为:”student a am i”, 请你将数组的内容改为”i am a student”. 要求： 不能使用库函数。 只能开辟有限个空间（空间个数和字符串的长度无关）。 student a am i i ma a tneduts i am a student 12345678910int mystrlen(char* str)&#123; //判断字符串的长度 int count = 0; while(*str++)&#123; count++; &#125; return count;&#125;//字符串判定长度，设置的形参为char类型的指针，一个字符串的长度始终都在变化//在输出时，系统先输出字符指针指向的第一个字符数据，然后使指针加1，使之指向下一个，然后再输出……直至遇到字符'\0‘，结束。所以给while的判断是 *str++，指针一个一个的走判断。 1234567891011//逆转指定范围的字符串void reverse_string(char* start,char* end)&#123; while(start &lt; end)&#123; //比如classmate start的字符为‘c’，end的字符则为‘e’ char temp = *start; *start = *end; *end = temp; start++;//字符串指向的位置，从开始不断向后 end--;//才指定范围的字符串，从结尾不断向前 &#125;&#125; 1234567891011121314151617181920void reverse(char* str)&#123; int len = mystrlen(str); char* start = str; char* end = str + len - 1; // len-1是不包括‘\0’ char* cur = str; //整体逆转一次 reverse_string(start,end); //局部逆转 while(*cur != '\0')&#123; char* st = cur; //寻找子串的尾点 while(*cur != ' ' &amp;&amp; *cur != '\0')&#123; cur++;//cur作为一个尾点，我们去寻找cur具体到哪个位置，当为‘ ’和‘\0’之前的一个位置将它作为end，cur最开始的作为st，这样局部的前后就有了，可以交换一次。 &#125; reverse_string(st,cur-1); while(*cur == ' ')&#123; cur++;//在指针走的过程中，如果遇到了' '，则使其跳过，因为这样将不用再去将' '逆转一次。否则会有多余的步骤。 &#125; &#125;&#125; 感觉初阶到了后期难度一下就上来了。考试周结束后，还是得好好敲代码啊。]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之链表]]></title>
    <url>%2F2018%2F12%2F02%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[链表的定义链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 相比于线性表顺序结构，操作复杂。 （百度） 链表：一种链式存储的线性表，用一组地址任意的存储单元存放线性表的数据元素，称存储单元为一个结点。 链表的形式：结点地址{data，next} 链表的形式基本知道后，链表的使用离不开指针。关于指针 和 指针指向的空间 是有区别的 指针不能看成是一个地址，指针是用来存放地址的。指针指向的空间不是地址，是一个还未使用开辟出来的空间。 链表里的结构体与顺序表的结构体]]></content>
      <tags>
        <tag>C-数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初阶C-1121]]></title>
    <url>%2F2018%2F11%2F27%2F%E5%88%9D%E9%98%B6C-1121%2F</url>
    <content type="text"><![CDATA[1.写一个函数返回参数二进制中 1 的个数 ，比如：15 —&gt; 0000 1111 中4个1。 12345678910int count_one_bits(unsigned int value)&#123; int count = 0; for (int i = 0; i &lt; 32; i++)&#123; if (((value &gt;&gt; i) &amp; 1) == 1)&#123; count++; &#125; &#125; printf("%d\n", count); // 返回 1的位数 &#125; 2.获取一个数二进制序列中所有的偶数位和奇数位,分别输出二进制序列。 1234567891011121314151617int Print_col(unsigned int value)&#123; //二进制的奇偶数位是从低位0123456开始算起 int odd;//奇数 int even;//偶数 printf("偶数的序列:"); for (int i = 0; i &lt; 32; i += 2)&#123; even = (value &gt;&gt; i) &amp; 1; printf("%d ", even); &#125; printf("\n"); printf("奇数的序列:"); for (int j = 1; j &lt; 32; j += 2)&#123; odd = (value &gt;&gt; j) &amp; 1; printf("%d ", odd); &#125; return 0;&#125; 3.输出一个整数的每一位。 123456789void Print_num()&#123; printf("请输入数:"); int x; scanf("%d", &amp;x); while (x)&#123; printf("%d ", x % 10); x /= 10; &#125;&#125; 4.两个int（32位）整数m和n的二进制表达中,有多少个位(bit)不同? 输入例子: 1999 2299 输出例子:7 123456789101112void diff_bit()&#123; int m, n,num,count = 0; printf("请输入两个数:"); scanf("%d %d", &amp;m, &amp;n); num = m ^ n; for (int i = 0; i &lt; 32; i++)&#123; if (((num &gt;&gt; i) &amp; 1) == 1)&#123; count++; &#125; &#125; printf("%d", count);&#125; 在操作符总结完之后做的一些题。我个人觉得总结完之后，上手是非常容易的。]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-对猫眼网的top100的爬取]]></title>
    <url>%2F2018%2F11%2F26%2Fpython-%E5%AF%B9%E7%8C%AB%E7%9C%BC%E7%BD%91%E7%9A%84top100%E7%9A%84%E7%88%AC%E5%8F%96%2F</url>
    <content type="text"><![CDATA[python我从今年过年开始自学，断断续续的，最近参加了一个爬虫训练营，我发现爬虫对开始学习python是非常合适的，只不过首先得具备一些HTML的知识储备，毕竟爬虫是需要解析网页的。而且爬虫实现后的成就感是非常巨大的。所以，根据上周学习的一些知识，做一个小的总结。 首先需要安装requests库和beautifulsoup库，这两个库是有函数可以对网页进行一个解析操作的。比如request中的get()。beautifulsoup中的Beautifulsoup()的使用。 安装过程首先最简单的安装就是利用cmd通过pip指令安装 12pip install requestspip install beautifulsoup4 //这里需要注意一下，后面必须有个4。 如果安装不上，那就从网上先下载好需要的安装文件，在进入该文件的目录下，进行安装。 request的使用request的请求方式有多种，因为是一个第三方库，有多种使用方法，可以在网上寻找一些使用文档参考 12345requests.get('http://www.xxxxxxxx.com')requests.post('http://www.xxxxxxxx.com')requests.delete('http://www.xxxxxxxx.com')requests.put('http://www.xxxxxxxx.com')requests.head('http://www.xxxxxxxx.com') 列举一些常用的。 get：请求指定的页面信息，并返回一个主体。使用get方式时，请求数据直接放在url中。 post：请求主要是发送一些较长的数据，数据比较安全 。使用post方式时，数据放在data或者body中，不能放在url中，放在url中将被忽略。 delete：请求服务器删除Request-URI所标识的资源。 put：向指定资源位置上传其最新内容 。 head： 向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。 request的实例首先我们要爬取的是猫眼网站的top100榜单。网址为http://maoyan.com/board/4。 这是第一页的情况，此时我们点击一个下一页，就能发现网址发现了变化。 能明显看到网址的变化是http://maoyan.com/board/4?offset={}。 不断去往下翻页，我们就能看到offset=后面这个数在不断的变化，第一页是0，到最后一页是90。 说明offset是偏移量，等于号后面的是偏移量的值 知道了这个url的规律之后，就可以来进行获取网址了。 通过get去获取一个网页信息 12345678def get_url(url): try: wb_data=requests.get(url) wb_data.raise_for_status wb_data.encoding=wb_data.apparent_encoding return wb_data.text except: return "代码段异常" 上面是单个网页去抓取。我们能发现，此时所有的html页面信息都被反馈出来了。 我们利用谷歌浏览器打开该网站，右键点击检查，我们能看到各个标签内的字符串在其中，这个时候我们就需要正则表达式将其提取出来。 1234567891011def parse_one_page(html): pattern=re.compile('&lt;dd&gt;.*?board-index.*?&gt;(.*?)&lt;/i&gt;.*?data-src="(.*?)".*?name.*?a.*?&gt;(.*?)&lt;/a&gt;.*?star.*?&gt;(.*?)&lt;/p&gt;.*?releasetime.*?&gt;(.*?)&lt;/p&gt;.*?integer.*?&gt;(.*?)&lt;/i&gt;.*?fraction.*?&gt;(.*?)&lt;/i&gt;.*?&lt;/dd&gt;',re.S) items=re.findall(pattern,html) for item in items: yield&#123; 'index':item[0], 'img':item[1], '名称':item[2], '主演':item[3].strip()[3:], '上映时间':item[4].strip()[5:] &#125; 关于正则表达式不在这里详细说了，以后我会专门写一篇总结。 yield的用法：如果一个函数包含yield关键字，这个函数就会变为一个生成器。 生成器并不会一次返回所有结果，而是每次遇到yield关键字后返回相应结果，并保留函数当前的运行状态，等待下一次的调用。所以在我们去请求网页的过程中，每寻找一次，找到相对应的标签，就将其内容爬取下来。 接下来需要对offset这个偏移量找到方法将他添加到我们的url中，并且可以循环的使用。 12345def main(offset): url='http://maoyan.com/board/4?offset=&#123;0&#125;'.format(offset) html=get_url(url) for item in get_url(html): print(item) format函数就不需要多说了，就是往其中添加字符串。这里利用一个for循环使用，这样可以循环将网页都在函数get_url中请求一次。 最后将它输出出来 123for i in range(10): main(offset=i*10) time.sleep(2) 在控制台观察，就会发现我们需要的网页信息被一个一个的提取出来了。 这里使用了一个time.sleep(2),它的作用是让请求有一定的间隔，我们都知道各个网站具有反爬虫机制，如果访问太频繁，则会被禁止访问。让2s访问一次，则可以避免这种机制。 这就是一个简单的爬取过程。接下来是更具体的一种。利用了beautifulsoup来使用 BeautifulSoup的用法‘美味汤’，是用Python写的一个HTML/XML的解析器，它可以很好的处理不规范标记并生成剖析树(parse tree)。 它提供简单又常用的导航（navigating），搜索以及修改剖析树的操作。它可以大大节省你的编程时间。 123456789//引用该库的方法不是直接import就可以，而是通过fromform bs4 import beautifulsoupsoup=BeautifulSoup(wb_data.text,'lxml')print（soup.find_all('a')）print（soup.get_text()）//以上是举例它的写法 soup 就是BeautifulSoup处理格式化后的字符串，soup.title 得到的是title标签，soup.p 得到的是文档中的第一个p标签，要想得到所有标签，得用find_all 函数。find_all 函数返回的是一个序列，可以对它进行循环，依次得到想到的东西. get_text() 是返回文本,这个对每一个BeautifulSoup处理后的对象得到的标签都是生效的。 我们在上面看到一个‘lxml’这个东西，这是解析库。在这里说明一下 解析器 使用方法 优势 劣势 python标准库 BeautifulSoup(markup,’parser’) python内置；执行速度适中；文档容错能力强 低版本pyton容错能力差 lxml HTML解析器 BeautifulSoup(markup,’lxml’) 速度快；容错能力强 需要安装lxml lxml XML解析器 BeautifulSoup(markup,’xml’) 速度快；唯一支持XML 需要安装lxml Html5lib BeautifulSoup(markup,’html5lib’) 容错性最好 速度慢；需要安装html5lib 在我们知道解析器之后，我们还要做的就是通过什么去选择标签。这里一般有四种常用选择器 选择器 作用 使用方法 节点选择器 通过节点名称嵌套选取信息 soup.div.next_sibling.ul.li.p 方法选择器 find_all()和find()函数 soup.find(name=’p’,class=’ ‘) css选择器 Select方法 body&gt;div.content&gt;ul&gt;li:nth-child(1)&gt;p Xpath 用于在xml文档中搜索元素的路径语言 /html/body/div[2]/ul/li[1]/p 当我们基本了解之后就可以使用了。 在下面的使用中，就利用select方法 我们能看到黄色的地方就是我们需要的title标签所指向的地方。 右击这个标签，点击copy—-&gt;copy selector就是利用css选择器，这之后复制出来的标签走向最后复制到select()方法中。 12345678910111213141516171819def parse_one_page(html): soup=BeautifulSoup(''.join(html),'lxml')#在这里我们是得到了R.txt的文本，但是我们不能输出，所以我们得利用print来输出 titles=soup.select('#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; div &gt; div &gt; div.movie-item-info &gt; p.name &gt; a') pics=soup.select('#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; a &gt; img.board-img') actors=soup.select('#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; div &gt; div &gt; div.movie-item-info &gt; p.star') days=soup.select('#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; div &gt; div &gt; div.movie-item-info &gt; p.releasetime') scores1=soup.select('#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; div &gt; div &gt; div.movie-item-number.score-num &gt; p &gt; i.integer') scores2=soup.select('#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; div &gt; div &gt; div.movie-item-number.score-num &gt; p &gt; i.fraction') for title,pic,actor,day,scores,scoress in zip(titles,pics,actors,days,scores1,scores2): info=&#123; 'title':title.get_text(), 'pic':pic.get('alt'), 'actor':actor.get_text(), 'day':day.get_text(), 'scores':scores.get_text()+scoress.get_text(), &#125; write_to_file(info) print(info) 在上面有一个自己定义的wirte_to_file()函数。爬取完数据后，一直放在控制台显示只能证明我们爬取成功了。所以定义函数将我们所请求到的数据放入一个文件中，可以供我们需要的时候看看。 123def write_to_file(content): with open('maoyan.text','a',encoding='utf-8') as f: f.write(json.dumps(content,ensure_ascii=False)+'\n') with open()这个函数的使用时，有四种文本可以保存，分别是text，json，csv，excel。后两种还可以利用pandas来处理统计。 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445import jsonimport requestsimport timefrom bs4 import BeautifulSoupdef get_one_page(url): headers=&#123;'user-agent':'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.104 Safari/537.36 Core/1.53.2263.400 QQBrowser/9.5.10429.400'&#125; response=requests.get(url,headers=headers) if response.status_code==200: return response.text else: return Nonedata=[]def parse_one_page(html): soup=BeautifulSoup(''.join(html),'lxml')#在这里我们是得到了R.txt的文本，但是我们不能输出，所以我们得利用print来输出 titles=soup.select('#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; div &gt; div &gt; div.movie-item-info &gt; p.name &gt; a') pics=soup.select('#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; a &gt; img.board-img') actors=soup.select('#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; div &gt; div &gt; div.movie-item-info &gt; p.star') days=soup.select('#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; div &gt; div &gt; div.movie-item-info &gt; p.releasetime') scores1=soup.select('#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; div &gt; div &gt; div.movie-item-number.score-num &gt; p &gt; i.integer') scores2=soup.select('#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; div &gt; div &gt; div.movie-item-number.score-num &gt; p &gt; i.fraction') for title,pic,actor,day,scores,scoress in zip(titles,pics,actors,days,scores1,scores2): info=&#123; 'title':title.get_text(), 'pic':pic.get('alt'), 'actor':actor.get_text(), 'day':day.get_text(), 'scores':scores.get_text()+scoress.get_text(), &#125; write_to_file(info) print(info)def write_to_file(content): with open('maoyan.excel','a',encoding='utf-8') as f: f.write(json.dumps(content,ensure_ascii=False)+'\n')def main(offset): url='https://maoyan.com/board/4?offset='+str(offset) html=get_one_page(url) parse_one_page(html)for i in range(10): main(offset=i*10) time.sleep(1) 以上就是我们的爬取过程，并不算复杂，而且是比较容易爬取的！可以让你瞬间有成就感的那种！ 爬取出来的是放在字典内的，一条一条在文本文件中，观看是非常醒目的。动手试试吧！]]></content>
      <tags>
        <tag>python-爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初阶C-指针总结与坑]]></title>
    <url>%2F2018%2F11%2F25%2F%E5%88%9D%E9%98%B6C-%E6%8C%87%E9%92%88%E6%80%BB%E7%BB%93%E4%B8%8E%E5%9D%91%2F</url>
    <content type="text"><![CDATA[指针的定义在计算机科学中，指针（Pointer）是编程语言中的一个对象，利用地址，它的值直接指向（points to）存在电脑存储器中另一个地方的值。由于通过地址能找到所需的变量单元，可以说，地址指向该变量单元。因此，将地址形象化的称为“指针”。意思是通过它能找到以它为地址的内存单元。 总的来说，指针就是变量，用来存放地址的变量。（存放在指针中的值都被当成地址处理） 指针的大小在32位平台上是4个字节，在64位平台上是8个字节。 指针是存放地址才出现的，地址是为了标示一块地址空间的。 指针让地址有地方存放，指针让内存的访问更加方便。 指针和指针类型有这么一个代码 12int num = 10;p = &amp;num; 要将&amp;num保存到p中，p就是一个指针变量，它的类型是有相对应的。 123456char *pc = NULL;int *pi = NULL;short *ps = NULL;long *pl = NULL;float *pf = NULL;double *pd = NULL; 由上面的代码段可以看到，指针的定义方式就是 type + 。 也就是char\的指针存放char类型变量的地址。short*的指针存放short类型变量的地址。int*的指针存放int类型的变量的地址。 普通的指针变量，指针类型，表示指针指向的变量的类型。一个普通的指针，知道对应这个变量的房间号，以及房间的大小。 void*的使用：只知道房间号，但是不关注房间大小。 void*类型不能解引用 void*类型的指针不能和整数进行相加减 void*类型的两个指针也不能相减 然而这样一个代码 123int a = 10;char* p = &amp;a;printf("%d\n",*p); 打印的结果是多少？打印的结果还是10。但是int*和char*类型是不兼容的，但是我们在存放数据时，要考虑到大端和小端的情况，低位在低地址 p的解引用 对于char\得看它是怎么放置的。 通俗来说，int*本身有4个字节，但是非要让它char*去表示，那么只能去考虑一个字节。打印出它的第一个地址存储的数据。但这第一个地址是怎么存放数据的，我们要考虑大端与小端的情况。因为就一个 0a，可能在4个字节中，最末尾的位置，也可能是第一个位置。这都是根据机器设定的字节序来得出结果的。 这里说一下机器的字节序： 大端：低位在高地址上 小端：低位在低地址上 指针 +/- 整数首先站在上帝视角，对指针进行运算是一件非常危险的事情，这也是一个埋下大坑的开始！！ 指针的加减与普通的数字加减不太一样。 123456789101112char* p = NULL;p = p + 1;//结果为1short* p = NULL;p = p + 1;//结果为2int* p = NULL;p = p + 1;//结果为4double* p = NULL；p = p + 1;//结果为8 指针和整数+1并不是地址+1，而是跳过当前指向的元素。-1是往低地址跳过一个元素（可以说是往前跳） 指针-指针1234int arr[] = &#123;1, 2, 3, 4&#125;;int* p1 = arr;int* p2 = arr + 3;printf("%d\n",p2 - p1); 指针相减，就是指针加减整数的逆运算。指针相减就是看指针之间隔了多少个元素。 语法是允许，但是很多情况下是没有意义的。比如两个不同类型的去相减，没有什么实际的意义。除非两个指针指向了同一个连续的内存空间，此时才是有意义的。 指针的解引用解引用：”*”的作用是引用指针指向的变量值，引用其实就是引用该变量的地址，“解”就是把该地址对应的东西解开，解出来，就像打开一个包裹一样，那就是该变量的值了，所以称为“解引用”。 也就是说，解引用是返回内存地址中保存的值。 指针的类型决定了对指针解引用的时候有多大的权限。 比如：char*的指针解引用就只能访问一个字节，而int*的指针的解引用就能访问四个字节 这里补充一个const的使用。 const int* p =&gt; p 指向的内容不能修改 int const *p =&gt; p指向的内容不能修改 int* p const p =&gt; p 的指向不能修改 二级指针二级指针并没有很难理解，就是将一直指针看成一个常量，在引用一个指针。 可以类比于二维数组，它其实还是一个一维数组，只是每个元素是一个一维数组。 当我们觉得不太好理解时，可以这样 1234typedef int* int_ptrint a = 10;int_ptr p = &amp;a;int_ptr* pp = &amp;p; 将int*定义成一个变量来代替，这样我们看着就比较方便了。 指针和数组名指针和数组名往往是可以相互转化的。 12int arr[] = &#123;1,2,3,4&#125;int* p = arr + 1; 此时的含义是，数组的首地址元素+1，跳过这个当前指向的元素，此时*p为2。 &amp;arr =&gt; 数组指针：是一个指针，指向一个数组的指针。 指针数组 vs 数组指针 123456int a[] = &#123; 1, 2, 3, 4&#125;;printf("%p\n",a);//指向的intprintf("%p\n",&amp;a);//得出的地址是一样的，改变一下printf("%p\n",&amp;a + 1);//这直接跳过了整个数组，指向了整个数组 1int* a[] = &#123; 0 &#125;;//每个元素是一个指针 指针的大坑第一组 12345678910int a[] = &#123; 1, 2, 3, 4&#125;;printf("%d\n",sizeof(a));//数组的大小，16printf("%d\n",sizeof(a + 0));//a此时变成了指针，4（32位系统下）printf("%d\n",sizeof(*a));//a变成首元素的指针，得到了一个整数，4printf("%d\n",sizeof(a + 1));//a此时变成了指针，4printf("%d\n",sizeof(a[1]));//第二个元素的大小，4printf("%d\n",sizeof(&amp;a));//此时是数组指针，指针就一定占4个字节！printf("%d\n",sizeof(*&amp;a));//此时先位数组指针，指向整个数组，每个数组内元素解引用，还原数组，16printf("%d\n",sizeof(&amp;a + 1));//数组指针+1还是数组指针，还是为4printf("%d\n",sizeof(&amp;a[0]));//a[0]取元素，整数，取完地址为int*，还是为4 第二组 12345678910111213141516char a[] = &#123; 'a', 'b', 'c', 'd', 'e', 'f'&#125;;printf("%d\n",sizeof(a));//类型为char型，占1个字节，共6个printf("%d\n",sizeof(a + 0));//变成指针，4printf("%d\n",sizeof(*a));//转成指针，解引用，得到是字符a，1printf("%d\n",sizeof(a[1]));//1printf("%d\n",sizeof(&amp;a));//数组指针，4printf("%d\n",sizeof(&amp;a + 1));//还是4，数组指针+1还是指针printf("%d\n",sizeof(&amp;a[0] + 1));//char* 还是一个指针printf("%d\n",strlen(a));// strlen从当前位置找到\0，如果找不到则越界，那么就是未定义行为printf("%d\n",strlen(a + 0));//strlen()函数都当成char*指针来处理，数组中没有\0，依然是未定义行为printf("%d\n",strlen(*a));//得到一个字符，不能放到char*里，间接级别不同，所以依然是未定义行为printf("%d\n",strlen(a[1]));//得到一个字符，都是未定义i行为printf("%d\n",strlen(&amp;a));//依然是个未定义行为printf("%d\n",strlen(&amp;a + 1));//未定义行为printf("%d\n",strlen(&amp;a[0] + 1));//未定义行为 第三组 12345678910111213141516char* p = 'abcdef';printf("%d\n",sizeof(p));//只要是指针，4个字节printf("%d\n",sizeof(p + 1));//还是指针，4个字节printf("%d\n",sizeof(*p));//解引用，char类型，得到a，1个字节printf("%d\n",sizeof(p[0]));//等价于*p，1printf("%d\n",sizeof(&amp;p));//指针取地址，就是二级指针，4printf("%d\n",sizeof(&amp;p + 1));//二级指针，4printf("%d\n",sizeof(&amp;p[0]));//a取地址，就是指向a的指针，+1就是指向b的指针，还是4printf("%d\n",strlen(p));//6，‘\0’不取，strlen()不算在其长度中printf("%d\n",strlen(p + 1));//5,p指向a，p+1指向b，从b开始到结束，只占了5个printf("%d\n",strlen(*p));//得到是一个字符，不能用strlen(),未定义行为printf("%d\n",strlen(p[0]));//未定义行为printf("%d\n",strlen(&amp;p));//二级指针不能进行，还是未定义行为printf("%d\n",strlen(&amp;p + 1));//未定义行为printf("%d\n",strlen(&amp;p[0] + 1));//a的指针，+1为b的指针，此时从b到结束，5 第四组12345678910111213141516char a[] = "abcdef";printf("%d\n",sizeof(a));//7,还有'\0'得算上，strlen()到\0结束，不计算入内printf("%d\n",sizeof(a + 0));//此时变为了指针，4printf("%d\n",sizeof(*a));//解引用得到字符a，1printf("%d\n",sizeof(a[1]));//1printf("%d\n",sizeof(&amp;a));//还是4，数组指针printf("%d\n",sizeof(&amp;a + 1));//4，还是数组指针printf("%d\n",sizeof(&amp;a[0] + 1));//是一个char*指针，4printf("%d\n",strlen(a));//6，不计算\0printf("%d\n",strlen(a + 0));//还是指向首元素的地址，6printf("%d\n",strlen(*a));//解引用得到字符，未定义printf("%d\n",strlen(a[1]));//未定义行为printf("%d\n",strlen(&amp;a));//数组名取地址，变为数组指针，得到的是首元素地址，依次往后去找。得到的还是6printf("%d\n",strlen(&amp;a + 1));//数组指针+1跳出整个数组了，找不到\0了，未定义行为printf("%d\n",strlen(&amp;a[0] + 1));//指向b，直到\0，为5 第五组123456789101112int a[3][4] = &#123; 0 &#125;;printf("%d\n",sizeof(a));//3*4*4=48printf("%d\n",sizeof(a[0][0]));//4printf("%d\n",sizeof(a[0]));//16,第一行printf("%d\n",sizeof(a[0] + 1));//4，数组指针，指针就是4printf("%d\n",sizeof(*(a[0] + 1)));//*(p + 1) =&gt; p[1],还是指针，即a[0][1] + 1,解引用，为4printf("%d\n",sizeof(a + 1));//变为指针，还是为4printf("%d\n",sizeof(*(a + 1));//*(a + 1) =&gt; a[1],所以数组为第二行,16printf("%d\n",sizeof(&amp;a[0] + 1));//得到为数组指针，+1还是数组指针，4printf("%d\n",sizeof(*(&amp;a[0] + 1)));//数组a[0]，&amp;为数组指针，在+1跳到第二个元素，在解引用为a[1]，16printf("%d\n",sizeof(*a));//*a =&gt; a[0] ,16printf("%d\n",sizeof(a[3]));//下标越界，sizeof在编译过程中得到类型，长度为4个元素的数组。 这些大坑多种形式，真的需要没事就看看，指针在C中是一个很重要的工具，在之前的静态顺序表中已经出现过，在链表中还出现了二级指针，所以需要多理解，多思考！]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初阶C-1117]]></title>
    <url>%2F2018%2F11%2F23%2F%E5%88%9D%E9%98%B6C-1117%2F</url>
    <content type="text"><![CDATA[1、有5位运动员参加了10米台跳水比赛，有人让他们预测比赛结果 A选手说：B第二，我第三； B选手说：我第二，E第四； C选手说：我第一，D第二； D选手说：C最后，我第三； E选手说：我第四，A第一； 比赛结束后，每位选手都说对了一半，请编程确定比赛的名次。 这道题我们一般的思维是直接根据一个条件的真假性，然后去依次判断下去。但是在C语言中不可以那么想。你不能去想当然的去判断。所以我们得设置条件，去不断的循环，然后判断出结果。 1234567891011121314151617181920212223242526void Guess()&#123; for(int a = 1;a &lt;= 5;a++)&#123; for(int b = 1;b &lt;= 5;b++)&#123; for(int c = 1;c &lt;= 5;c++)&#123; for(int d = 1;d &lt;= 5;d++)&#123; for(int e = 1;e &lt;= 5;e++)&#123; //排名无非就是12345，全部走一遍，当满足条件时，就判断下一个条件，直到满足时 if ((2 == b &amp;&amp; 3 != a) || (2 != b &amp;&amp; 3 == a) == 1)&#123; if ((2 == b &amp;&amp; 4 != e) || (2 != b &amp;&amp; 4 == e) == 1)&#123; if ((1 == c &amp;&amp; 2 != d) || (1 != c &amp;&amp; 2 == d) == 1)&#123; if ((5 == c &amp;&amp; 3 != d) || (5 != c &amp;&amp; 3 == d) == 1)&#123; if ((4 == e &amp;&amp; 1 != a) || (4 != e &amp;&amp; 1 == a) == 1)&#123; if (a*b*c*d*e == 120)&#123; printf("a=%d b=%d c=%d d=%d e=%d\n", a, b, c, d, e); &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125; 2、日本某地发生了一件谋杀案，警察通过排查确定杀人凶手必为4个嫌疑犯的一个。以下为4个嫌疑犯的供词 A说：不是我。 B说：是C。 C说：是D。 D说：C在胡说 已知3个人说了真话，1个人说的是假话。 现在请根据这些信息，写一个程序来确定到底谁是凶手。 这个与上面的思想是一样的，我们需要设置一个常量，将它作为凶手的标志。 我在里面设置2为凶手的标志 123456789101112131415161718192021void Guesspeople()&#123; for (int a = 1; a &lt;= 4; a++)&#123; for (int b = 1; b &lt;= 4; b++)&#123; for (int c = 1; c &lt;= 4; c++)&#123; for (int d = 1; d &lt;= 4; d++)&#123; if ((a != 2 &amp;&amp; c == 2 &amp;&amp; d == 2) || (d != 2) == 1)&#123; if ((a != 2 &amp;&amp; c == 2 &amp;&amp; d != 2) || (d == 2) == 1)&#123; if ((a != 2 &amp;&amp; c != 2 &amp;&amp; d == 2) || (d != 2) == 1)&#123; if ((a == 2 &amp;&amp; c == 2 &amp;&amp; d == 2) || (d != 2) == 1)&#123; if (a != b&amp;&amp;a != c&amp;&amp;a != d&amp;&amp;b != c&amp;&amp;b != d&amp;&amp;c != d)&#123; printf("a=%d,b=%d,c=%d,d=%d\n", a, b, c, d); &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125; 打印输出之后可以发现，C的值全部为2，那么说明C一定就是凶手。 3、在屏幕上打印杨辉三角 杨辉三角的规律有很多，其中有一个，每个数等于上方两数之和。 12345678910111213141516171819#define N 10 //定义一个二维数组void triangle()&#123; int arr[N][N]=&#123;0&#125;;//先全部初始化为0 int i, j, k; for(i = 0;i &lt; N;i++)&#123; for(j = 0;j &lt; N-i;j++)&#123; printf(" "); for(k = 0;k &lt;= i;k++)&#123; if(k == 0||k == i)&#123; arr[i][k] = 1; &#125;else&#123; arr[i][k] = arr[i-1][k] + arr[i-1][k-1]; &#125; &#125; printf("%4d",arr[i][k]); &#125; printf("\n"); &#125;&#125;]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初阶C-操作符总结]]></title>
    <url>%2F2018%2F11%2F21%2F%E5%88%9D%E9%98%B6C-%E6%93%8D%E4%BD%9C%E7%AC%A6%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[C语言操作符是构成C语言表达式的工具，是说明特别操作的符号。 操作符的类型算术操作符1+ - * / % 除了%操作符之外，其他均可以作用于整数和浮点数。 对于/操作符，如果是整数，执行整数除法，如果是浮点数，则执行浮点数除法 %操作符的两个操作符必须是整数，返回的是整除之后的余数。 移位操作符1&lt;&lt;左移操作符 &gt;&gt;右移操作符 左移位规则：左边抛弃，右边补0 右移位规则：这又分为两种，分别是逻辑移位和算术移位 逻辑移位 是左边用0填充，右边丢弃 算术移位 是左边用原该值的符号位填充，右边丢弃 例如：求一个整数存储在内存中的二进制中1的个数 1234567891011#include&lt;stdio.h&gt;void erjinzhi(int num)&#123; int count = 0; while (num)&#123; if (num % 2 == 1) count++; num = num / 2; &#125; printf("二进制中1的个数 = %d ", count); return 0;&#125; 从这个程序里中，我们就可以测出，每个数在二进制中1的个数。但是我们，如果输入负数，我们会发现，我们的程序，是有问题的。如果输入了-10，那么-10之前的所有0都要取反，这个时候我们将出来许多的1。 所以我们进行一个改正 12345678910#include&lt;stdio&gt;void erjingzhi(int num)&#123; int i = 0; int count = 0; for (i = 0; i &lt; 32; i++)&#123; if (((num &gt;&gt; i) &amp; 1) == 1) count++; &#125; printf("二进制中1的个数 = %d\n", count);&#125; 我们利用移位的方法去一个一个来计算。 这里添加一个二进制负数的转化过程，可以更好的理解。 Ps:注意我们的移位不要移动负数位，这个是标准未定义的。 位操作符位操作符有三种分别是：按位与，按位或，按位异或 1&amp; | ^ 它们的操作数必须是整数。 按位与：对两个数进行操作，然后返回一个新的数，这个数的每个位都需要两个输入数的同一位都为1时才为1. 按位或：比较两个数，然后返回一个新的数，这个数的每一位设置1的条件是两个输入数的同一位都不为0。即任意一个为1，或者都为1。否则为0。 按位异或：比较两个数，然后返回一个数，这个数的每个位设为1的条件是两个输入数的同一位不同，如果相同就设为0。即相同为0，不同为1。 赋值操作符赋值操作符是一个很好用的操作符，你可以将你的变量设置成你需要的值。用 “=” 即可。 复合赋值操作符 += 加等 -= 减等 *= 乘等 /= 除等 %= 取模等 &gt;&gt;= 右移位等于 &lt;&lt;= 左移位等于 &amp;= 按位与等于 &#124; = 按位或等于 ^= 按位取反等于 单目操作符 ！ 逻辑反操作 - 取负数 + 取正数 &amp; 取地址 sizeof 操作数的类型长度 ~ 对一个数的二进制按位取反 – 减减，类似累减 ++ 加加，类似累加 * 间接访问操作符 逻辑操作符逻辑操作符有 12&amp;&amp; 逻辑与|| 逻辑或 它们与按位与和按位或之间的区别 1&amp;2 —–&gt;0 1&amp;&amp;2 ——-&gt;1 1|2 ——&gt;3 1||2 —–&gt;1 逻辑与还有逻辑或，此时是判断它的真假性。要记住，非0为真。这是一个关键。 1234567#include&lt;stdio.h&gt;int main()&#123; int i= 0,a=0,b=2,c=3,d=4; i= a++&amp;&amp;++b&amp;&amp;d++; printf("a= %d\n b=%d\n c=%d\n d=%d\n",a,b,c,d); return 0;&#125; 输出后，abcd分别位1234。根据我们的猜测，这里可能是为135这样。但是这里有个坑。 这里存在一个短路求值的知识点。a=0这就代表了假。那么 a++——&gt;0。也就是说在这里是先返回，后++ 短路求值：如果是&amp;&amp;左侧表达式为假的时候，右侧表达式不会求值 ​ 如果是||左侧表达式为真的时候，右侧表达式不会求值 条件操作符1exp1 ? exp2 : exp3 这是C语言中唯一的一个二目运算符，运算级非常低。 逗号表达式1exp1,exp2,exp3....expN 就是用逗号隔开的多个表达式。从左向右依次执行。 表达式求值隐式类型转换C的整型算术运算总是至少以缺省整型类型的精度来进行的。为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转化为普通类型，这种转换称为——整形提升。 123char a,b,c;...a = b + c; b和c的值被提升为普通整型，然后再执行加法运算。 加法运算完成之后，结果将被截断，然后再存储于a中。 算法运算中，a隐式转换为int。 凡是针对char/short，此时都隐式转换成int。 操作符的属性复杂表达式的求值有三个影响的因素： ​ 1.操作符的优先级 ​ 2.操作符的结合性 ​ 3.是否控制求值的顺序 以上就是操作符的基本了，目前是我能知道并且掌握的，当以后有了其他的之后，再慢慢的添加进去。]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C初阶-扫雷]]></title>
    <url>%2F2018%2F11%2F18%2FC%E5%88%9D%E9%98%B6-%E6%89%AB%E9%9B%B7%2F</url>
    <content type="text"><![CDATA[上次完成了三子棋的做法，利用了二维数组。扫雷也是一样，需要我们利用二维数组去完成。扫雷有所不同的地方在于，我们需要两个二维数组。一个用来展示棋盘，另外一个用于展示我们的下雷过程，因为每一个点击有可能是雷或者不是雷。 关于扫雷的编程思想我们与三子棋相比是有一些不同的地方。但归途同属，我们只需要想清楚每一个步骤就可以。 还是先创建一个工程，并且我还是习惯于一个头文件定义函数，一个源文件测试。 我们首先设置一个选择功能，让我们在看的时候，比较美观。毕竟好看的事务会给别人留下的印象也比较深。 123456789101112131415161718192021222324#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;void Start()&#123; int choice == Menu(); while(1)&#123; if(choice == 0)&#123; break; &#125; Game(); &#125;&#125;int Menu()&#123; printf("====================\n"); printf(" 1.开始游戏\n"); printf(" 2.退出游戏\n"); printf("====================\n"); int choice = 0; scanf("%d",&amp;choice); return choice;&#125; 基本开始样式就ok了。之后我们开始需要对每个关键步骤写代码了。 我们先想象一下扫雷的规则与步骤。 1.我们首先得有一个地图的样式，然后初始化它最初的样子 2.打印这个棋盘。（这两步与三子棋的思路比较像） 3.进行点击，之后判断点击的情况。 4.判定是否踩雷，如果踩雷，GG。 5.如果没踩雷，判定是否掀开了所有格子。 6.如果没有掀开所有格子。那么更新周围有几个雷。显示到地图上。 3-6这是一个循环的过程，所以我们将用while来判断什么时候胜利或者失败。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#define MAX_ROW 10#define MAX_COL 10#define DEFAULT_LEIZI_COUNT 10void Game()&#123; char show_map[MAX_ROW + 2][MAX_COL + 2]; char mine_map[MAX_ROW + 2][MAX_COL + 2]; Init_map(); Print_map(); while(1)&#123; int count = 0; int row,col; printf("请输入坐标，例如1 2\n")； scanf("%d",&amp;row,&amp;col); if(row &lt;= 0 || row &gt; MAX_ROW || col &lt;= 0 || col &gt; MAX_COL)&#123; printf("请重新输入坐标\n"); continue; &#125; if(mine_map[row][col] == '1')&#123; printf("游戏结束，此处有雷\n"); Print_map(); break; &#125; if (count==DEFAULT_LEIZI_COUNT + 1)&#123; printf("扫雷成功\n"); Print_map(mine_map); break; &#125; for (int i = 1; i &lt;= MAX_ROW; i++)&#123; for (int j = 1; j &lt;= MAX_COL; j++)&#123; if (show_map[i][j] == '*')&#123; count++; &#125; &#125; &#125; if (count == DEFAULT_LEIZI_COUNT)&#123; printf("扫雷成功\n"); Print_map(mine_map); break; &#125; Updateshowmap(); Showaround(); Print_map(); &#125;&#125; 这就是上面描述的一个基本的流程。也就是扫雷对输赢的判断规则。接着对每一个函数去完善。函数内参数我是没有直接添加进去的。我是都定义完成之后，才慢慢添加进去的。 首先是对我们地图的一个初始化 1234567891011121314151617181920212223242526void Init_map(char show_map[MAX_ROW + 2][MAX_COL + 2]; char mine_map[MAX_ROW + 2][MAX_COL + 2])&#123; //在这里就要解释一下，我们为什么要加上一个2了。因为我们要保证我们需要一个边框 //大多数人的潜意识中喜欢输入都是1 1，这样我们定义一个边框，我们就可以将其上下包围这些地图 //那么这个地图将是从1 1到 10 10的所有点了。 for(int row = 0;row &lt; MAX_ROW;row++)&#123; for(int col = 0;col &lt;MAX_COL;col++)&#123; show_map[row][col] = '*'; &#125; &#125; for(int row = 0;row &lt; MAX_ROW;row++)&#123; for(int col = 0;col &lt;MAX_COL;col++)&#123; mine_map[row][col] = '*'; &#125; &#125; int mine_count = DEFAULT_LEIZI_COUNT; while(mine_count &gt; 0)&#123; int row = rand() % 10 + 1; int col = rand() % 10 + 1; if(mine[row][col] == '1')&#123; continue; &#125; mine[row][col] = '1'; mine_count--; &#125;&#125; 初始化完成之后，我们开始打印地图 123456789101112131415161718void Print_map((char map[MAX_ROW + 2][MAX_COL + 2],int row,int col)&#123; printf(" "); for(int i = 1;i &lt; MAX_ROW + 2;i++)&#123; printf("%d ",row); &#125; printf("\n"); for(int i = 1;i &lt; MAX_ROW +2 ;i++)&#123; printf("---\n"); &#125; for(int row = 1;row &lt; MAX_ROW + 2;row++)&#123; printf("%02d |\n",row); for(int col = 1;col &lt; MAX_COL + 2;col++)&#123; printf("%c ",map[row][col]); &#125; printf("\n"); &#125; &#125; 打印完地图之后，就是扫雷中最关键的一个部分了。判断周围雷的个数，然后将它打印到地图中。 12345678910111213void Updateshowmap(char show_map[MAX_ROW + 2][MAX_COL + 2]; char mine_map[MAX_ROW + 2][MAX_COL + 2],int row,int col)&#123; int leizi_num = (mine_map[row][col + 1] - '0')+ (mine_map[row][col - 1] - '0')+ (mine_map[row + 1][col + 1] - '0')+ (mine_map[row + 1][col] - '0')+ (mine_map[row + 1][col - 1] - '0')+ (mine_map[row - 1][col + 1] - '0')+ (mine_map[row - 1][col] - '0')+ (mine_map[row - 1][col - 1] - '0'); show_map[row][col] = leizi_num + '0'; return show_map[row][col];&#125; 在这里我是将周围八个格子是否有雷的情况统计下来，然后将其赋给中间的格子，这样我们就可以知道周围有几个雷了。 我们都知道扫雷的规则，当你点开一部分后，如果周围没雷的话，我们就将会点开空白区域。所以我们要写一个递归来去不断的调用。 123456789101112131415161718192021222324252627282930313233void Showaround(char show_map[MAX_ROW + 2][MAX_COL + 2], char mine_map[MAX_ROW + 2][MAX_COL + 2], int row, int col)&#123; if (mine_map[row][col] == '0' &amp;&amp; show_map[row][col] == '*')&#123; show_map[row][col] = Updateshowmap(show_map, mine_map, row, col); &#125; if (mine_map[row][col - 1] == '0' &amp;&amp; show_map[row][col - 1]=='*')&#123; show_map[row][col - 1] = Updateshowmap(show_map, mine_map, row, col - 1); if (Updateshowmap(show_map, mine_map, row, col) == '0')&#123; Showaround(show_map, mine_map, row, col - 1); &#125; &#125; if (mine_map[row + 1][col] == '0' &amp;&amp; show_map[row + 1][col] == '*')&#123; show_map[row + 1][col] = Updateshowmap(show_map, mine_map, row + 1, col); if (Updateshowmap(show_map, mine_map, row + 1, col) == '0')&#123; Showaround(show_map, mine_map, row + 1, col); &#125; &#125; if (mine_map[row - 1][col] == '0' &amp;&amp; show_map[row - 1][col] == '*')&#123; show_map[row - 1][col] = Updateshowmap(show_map, mine_map, row - 1, col); if (Updateshowmap(show_map, mine_map, row - 1, col) == '0')&#123; Showaround(show_map, mine_map, row - 1, col); &#125; &#125; if (mine_map[row][col + 1] == '0' &amp;&amp; show_map[row][col + 1] == '*')&#123; show_map[row][col + 1] = Updateshowmap(show_map, mine_map, row, col + 1); if (Updateshowmap(show_map, mine_map, row, col + 1) == '0')&#123; Showaround(show_map, mine_map, row, col + 1); &#125; &#125;&#125; 我觉得扫雷对周围的判断是根据上下左右来进行的。如果周围没雷，那么它就是相当于空白的。当分成八个方向去判断时，那么就将产生一键排雷的这种奇葩操作。 最后就是一个源文件了。将Start（）放入测试即可。但是不要忘了随机种子，否则扫雷的布置雷数是没有变化的。]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之动态顺序表]]></title>
    <url>%2F2018%2F11%2F15%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[动态顺序表动态顺序表是跟静态顺序表大体相似，有些地方是不同的，动态顺序表是在动态变化中，当我们的所需的内存不够时，它会自动开辟一个我们需要的空间，来供我们使用。 动态顺序表与静态顺序表的不同在于初始化/销毁/所有插入，其他和静态顺序表完全一样。 定义一个结构体先将我们需要的都定义好 12345678910111213141516#pragma once#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;assert.h&gt;#include&lt;string.h&gt;//为了观看方便先写在开头，正常应该需要什么去使用什么typedef int DataType;#define INIT_CAPACITY(3)//定义一个动态的初始化空间容量为3typedef struct SeqListD&#123; DataType* parray; int capacity; int size;&#125; 在结构体的定义中，静态与动态的定义是不同的。静态的是直接定义了一个空间是有范围确定的数组。但是动态不同，动态定义的是一个指针，在这里面存储的范围是不确定的，当我们定义了一个当前我们认为足够大的空间时，它是在一个计算机给我们的随机地址中。当我们需要更大的空间时，我们将申请新空间，这个时候我们将数据转移，先将所有数据转移到新的空间，之后我们将旧的空间释放掉。这个时候空间是新开辟的一段空间，但是我们的地址是计算机重新分配的一段新地址。 初始化12345678void SeqListInit(SeqListD *pSeq)&#123; pSeq-&gt;capacity = INIT_CAPACITY;//当前容量我们都先设置为3，每当我们不够时， //我们就调用其他函数去扩充它 pSeq-&gt;parray = (DataType *)malloc(sizeof(DataType)*pSeq-&gt;capacity);//我们的数组利用malloc函数 //类型 //4*3 assert(pSeq-&gt;parray);//判断我的指针是否正常 pSeq-&gt;size = 0;&#125; malloc(): malloc的全称是memory allocation，中文叫动态内存分配，用于申请一块连续的指定大小的内存块区域以void*类型返回分配的内存区域地址，当无法知道内存具体位置的时候，想要绑定真正的内存空间，就需要用到动态的分配内存。 一般需和free函数配对使用。 销毁12345678void SeqListDestory(SeqListD *pSeq)&#123; free(pSeq-&gt;parray); //将它释放掉 pSeq-&gt;capacity = 0; pSeq-&gt;size = 0; pSeq-&gt;parry = NULL; //所有一切还原&#125; 插入1234567void SeqListPushBack(SeqListD *pSeq,DataType data)&#123; //静态：如果满了，不处理/报错 //动态：加入扩容机制 ExpandIfRequired(pSeq);//每次都需要去判断是否达到条件可以实现 pSeq-&gt;parray[pSeq-&gt;size] = data;// pSeq-&gt;size++;&#125; 判断是否需要扩大1234567891011121314151617static void ExpandIfRequired(SeqListD *pSeq)&#123; if(pSeq-&gt;size &lt; pSeq-&gt;capacity)&#123; return;//还没满 &#125; //扩容 pSeq-&gt;capacity *= 2; //开辟新空间 DataType *newArray = (DataType *)malloc(sizeof(DataType)*pSeq-&gt;capacity); assert(newArray); //数据搬移 for(int i = 0;i &lt; pSeq-&gt;size；i++)&#123; newArray[i] = pSeq-&gt;parray[i]; &#125; //释放老空间，申请的新空间与动态顺序表关联起来 free(pSeq-&gt;parray); pSeq-&gt;parray = newArray;&#125; 同理，所有插入都需要加入扩容机制 其他的操作与静态顺序表的操作是相近的。可以参考我之前的对照着看。 数据结构重新在学！如有不对，请cue我！]]></content>
      <tags>
        <tag>C-数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C初阶-三子棋]]></title>
    <url>%2F2018%2F11%2F12%2FC%E5%88%9D%E9%98%B6-%E4%B8%89%E5%AD%90%E6%A3%8B%2F</url>
    <content type="text"><![CDATA[今天试着独自完成三子棋，经过一个小时多…才完成。真的太菜了！！！ 但是一个简单的三子棋确实能建立一些基本的编程思想。其中让我迷糊的是和棋那里。接下来我来代码分析说明。 首先我们编程一个项目时，我们要明白我们的基本构想是什么。那么三子棋的思想有这么几点。 三子棋的规则三子棋是在一个3x3的表格之中，如果在行列斜只要有三个相同的棋子，那么就将获胜。如果棋盘满了之后，但没有相同的，则算和棋。先手是具有一定的优势的。 三子棋的编程思想我们要将我们的操作步骤与实际相比较起来 1.初始化棋盘 2.展示棋盘的过程。我们得时刻了解到，此时的下子情况 3.玩家落子，进行判断，是否赢得了胜利 4.电脑落子，进行判断，是否赢得了胜利，如果没有分出，重复第2步 5.还未判断是否分出胜负，对其判断是否和棋。 三子棋的代码过程首先我用的是VS2013，只定义了一个头文件和一个源文件。 头文件的初定义12345678#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;#define ROWS 3#define COLS 3char qipan[ROWS][COLS]; 首先我们定义头文件，不过在此处我觉得并不需要一上来就定义，我们最后需要什么，我们去定义它。 但是宏最开始我们需要定义好，因为是二维数组。棋盘的大小我们要先设定好，并对其声明。 数组初始化1234567void Init(char qipan[ROWS][COLS],int row,int col)&#123; for (int row = 0; row &lt; ROWS; ++row)&#123; for (int col = 0; col &lt; COLS; ++col)&#123; qipan[row][col] = ' '; &#125; &#125;&#125; 展示棋盘123456789void Show_qipan(char qipan[ROWS][COLS], int row, int col)&#123; for (int i = 0; i &lt; row; ++i)&#123; printf("| %c | %c | %c |\n", qipan[i][0], qipan[i][1], qipan[i][2]); if (i != row - 1)&#123; printf("|---|---|---|\n"); &#125; &#125;&#125; 玩家落子1234567891011121314151617void Playmove(char qipan[ROWS][COLS], int row, int col)&#123; printf("请玩家下子\n"); while (1)&#123; printf("例如输入的格式为0,0\n"); scanf("%d,%d", &amp;row, &amp;col); if (row &lt; 0 || row &gt;= ROWS || col &lt; 0 || col &gt;= COLS)&#123; printf("输入有误，请重新输入\n"); continue; &#125; else if (qipan[row][col] != ' ')&#123; printf("该处已经下过子了，请重新输入\n"); continue; &#125; qipan[row][col] = 'x'; break; &#125;&#125; 电脑落子12345678910111213void Computermove(char qipan[ROWS][COLS], int row, int col)&#123; printf("请电脑下子\n"); while (1)&#123; row = rand() % ROWS; col = rand() % COLS; if (qipan[row][col] != ' ')&#123; printf("该处已有棋子，请重新填入\n"); continue; &#125; qipan[row][col] = 'O'; break; &#125;&#125; 和棋判断条件1234567891011static int Show_full(char qipan[ROWS][COLS], int row, int col)&#123; int i, j; for (i = 0; i &lt; row; i++)&#123; for (j = 0; j &lt; col; j++)&#123; if (qipan[i][j] == ' ')&#123; return 0; &#125; &#125; &#125; return 1;&#125; 判断胜负123456789101112131415161718192021222324252627282930char CheckWinner(char qipan[ROWS][COLS], int row, int col)&#123; //判断行 for (int col = 0; col &lt; COLS; col++)&#123; if (qipan[0][col] == qipan[1][col] &amp;&amp; qipan[0][col] == qipan[2][col] &amp;&amp; qipan[0][col] != ' ')&#123; return qipan[0][col]; &#125; &#125; //判断列 for (int row = 0; row &lt; ROWS; row++)&#123; if (qipan[row][0] == qipan[row][1] &amp;&amp; qipan[row][0] == qipan[row][2] &amp;&amp; qipan[row][0] != ' ')&#123; return qipan[row][0]; &#125; &#125; //判断斜 if (qipan[0][0] == qipan[1][1] &amp;&amp; qipan[0][0] == qipan[2][2] &amp;&amp; qipan[0][0] != ' ')&#123; return qipan[0][0]; &#125; else if (qipan[2][0] == qipan[1][1] &amp;&amp; qipan[2][0] == qipan[0][2] &amp;&amp; qipan[2][0] != ' ')&#123; return qipan[2][0]; &#125; //判断和棋 else if (Show_full(qipan,row,col))&#123; return 'q'; &#125; return ' ';&#125; 代码比较容易理解，但是我们也有几个必须注意的地方。 首先，定义的每个函数中，参数不能忘，对其中添加数组，行，列三个。因为我们对输入值后，要把每个值传入函数中，让其进行判断。所以这是一个关键。 其次是和棋的判断，在返回值为0与1的意思是假与真（估计大家都知道），但是关键在于CheckWinner()中，我们要知道判断结束后要有返回值。我们之前设置初始化的数组值是‘ ’。接着我们可以在源文件中进行判断。 源文件的代码12345678910111213141516171819202122232425262728293031323334353637#include"chess.h"int main()&#123; srand((unsigned int)time(NULL)); Init(qipan, ROWS, COLS); Choice(); char winner; int a; scanf("%d", &amp;a); switch (a)&#123; case 1: while (1)&#123; Show_qipan(qipan, ROWS, COLS); Playmove(qipan, ROWS, COLS); Show_qipan(qipan, ROWS, COLS); winner = CheckWinner(qipan, ROWS, COLS); if (winner != ' ')&#123; break; &#125; Computermove(qipan, ROWS, COLS); winner = CheckWinner(qipan, ROWS, COLS); &#125; if (winner == 'x')&#123; printf("你赢了！\n"); &#125; else if (winner == 'o')&#123; printf("电脑赢了！\n"); &#125; else if (winner == 'q')&#123; printf("五五开！真厉害！\n"); &#125; case 2: system("exit"); &#125; system("pause"); return 0;&#125; 看了winner的值你就可以看出来，如果之前返回的不是‘ ’，那么winner将直接跳出循环。 在其中我还添加了一个switch语句增加一些选择来让程序更生动点。下图实例： 大家如果有什么想法，还可以自己往里面添加！ 加油！会越来越强的！]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之静态顺序表]]></title>
    <url>%2F2018%2F11%2F09%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%9D%99%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[静态顺序表属于数据结构开始的一种基本结构首先我们要知道数据结构的概念 数据结构 数据的组织关系 算法 为了达到特定的目的的一系列过程。在这个过程中又分为两种角度1） 逻辑角度：线性结构，树形结构，图形结构2） 存储角度：顺序存储，链式存储 在线性结构中顺序存储的方式，在本次中为顺序表，分为静态和动态而静态顺序表的理解可以分为1） 结构体定义（定义、背后的内存布局模型）2） 顺序表的基本操作：插/删/查/改。重点需要去掌握的是插和删。插（头插/尾插/插入），删（头删/尾删/删除）接下来开始对于整个代码进行一个分析。 123456789101112#pragma once#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt; //一般不着急于先定义一堆，你需要什么在去定义什么。typedef int DataType; //为现有类型创建别名。用DataType来代替int。#define MAX_SIZE(100) //开出一块空间，占用内存的最大位置。typedef struct SeqList&#123; //定义结构体的别名 DataType array[MAX_SIZE]; int size;&#125;SeqList; //变量名 当把结构体都定义好了之后，我们开始先进行两个基本操作，对数组进行初始化和销毁此时我们要用到assert()。在开头首先要定义这个宏#include&lt;assert.h&gt;,他的功能就是测试一个条件可能使程序终止。用法void assert(int test) assert(), 断言,如果表达式为真，断言通过，无事发生；如果表达式为假，断言失败，程序直接退出。 在初始过程中，可能需要把内存清空一下，所以我们可能需要memset()这个函数。这个函数的用法void memset(void s, int ch, size_t n);将s所指向的某一块内存中的后n个 字节的内容全部设置为ch指定的ASCII值，第一个值为指定的内存地址，块的大小由第三个参数指定，这个函数通常为新申请的内存做初始化工作，其返回值为s。 123456789101112//初始化void SeqListInit(Seqlist *pSeq)&#123; //初始化size assert(pSeq != NULL); pSep-&gt;size = 0; memset(pSep-&gt;array,0,SIZE_MAX * sizeof(DataType));&#125;//销毁void SeqListDestory(SeqList *pSeq)&#123; assert(pSeq); pSeq-&gt;size = 0;&#125; 我们还需要部署一个测试函数，先暂时定义一下，当增删改查部署完后，可以往其中添加增删改查的函数来进行实验。 插入：有头插，尾插，插入头插的使用PS：考虑完了普通情况后，我们要考虑的是特殊情况，当size超过了定义的最大尺寸情况，我们需要进行一个判断， 123456789101112131415161718void SeqListPushTop(SeqList *pSeq,DataType data)&#123; assert(pSeq); if(pSeq-&gt;size &gt;= MAX_SIZE)&#123; printf("满了\n"); assert(0); return; &#125; //从最后开始向每一个后面开始搬运，如果不这么做，将会将每一次的值覆盖掉 for(int i = pSeq-&gt;szie;i &gt; 0; i--)&#123; // i此时是定义的为位置,位置为[size,0],从后往前搬 pSeq-&gt;array[i] = pSeq-&gt;array[i - 1]; &#125; //将i定位为数据,位置size[0,size),将整体的位置向后移 for(int i = size - 1；i &gt; 0;i++)&#123; pSeq-&gt;array[i + 1] = pSeq-&gt;array[i]; &#125; pSeq-&gt;array[0]=data; pSeq-&gt;size++;&#125; 这是一个自我思考的图示，仅供参考 尾插的使用尾插就相当于正常插入了，这个是比较简单的一种插入 1234567891011void SeqListPushBack(SeqList *pSeq,DataType data)&#123; //还是要先考虑特殊情况 assert(pSeq); if(pSeq-&gt;size &gt;= MAX_SIZE)&#123; printf("满了\n"); assert(0); return; &#125; pSeq-&gt;array[pSeq-&gt;size] = data; pSeq-&gt;size++;&#125; 中间插入的使用中间插入根据下标来使用，此时这么想，我们先将要插入的地方定义一个pos下标，此时将此下标之后的（包括此下标的）所有数据向后移动。 123456789101112131415161718void SeqListInsert(SeqList *pSeq,int pos, DataType data)&#123; //考虑特殊情况 assert(pSeq); if(pSeq-&gt;size &gt;= MAX_SIZE)&#123; printf("满了\n"); assert(0); return; //此时i作为位置 for(int i = pSeq-&gt;size; i &gt;= pos; i--)&#123; pSeq-&gt;array[i] = pSeq-&gt;array[i - 1]; &#125; //此时i作为数据 for(int i = pSeq-&gt;size - 1;i &gt;= pos; i--)&#123; pSeq-&gt;array[i + 1] = pSeq-&gt;array[i]; &#125; pSeq-&gt;array[pos] = data; pSeq-&gt;szie++;&#125; 自我图示，仅供参考 删除：头删，尾删，删除头删的使用最开始的数删除后，其他的数据向前补进。当然，也别忘了特殊情况！ 123456789101112131415161718void SeqListPushFont(SeqList *pSeq)&#123; //特殊情况 assert(pSeq) if(pSeq-&gt;size &lt;= 0)&#123; printf("空了\n"); assert(0); return; &#125; //i此时为位置时 for(int i = 0; i &lt; pSeq-&gt;size - 1;i++)&#123; pSeq-&gt;array[i] = pSeq-&gt;array[i + 1]; &#125; //i此时为数据时 for(int i = 1;i &lt; pSeq-&gt;size;i++)&#123; pSeq-&gt;array[i - 1] = pSeq-&gt;array[i]; &#125; pSeq-&gt;size--;&#125; 尾删的使用尾删比较简单，也就是直接将最后一个删除 123456789void SeqListPushPop(SeqList *pSeq)&#123; assert(pSeq) if(pSeq-&gt;size &lt;= 0)&#123; printf("空了\n"); assert(0); return; &#125; pSeq-&gt;size--;//直接将空间减小&#125; 删除的使用删除从中间删除，还是定义一个pos下标，删除之后，在将所有数据向前移动 1234567891011void SeqListPushErase(SeqList *pSeq,int pos)&#123; assert(pSeq) if(pSeq-&gt;size &lt;= 0)&#123; printf("空了\n"); assert(0); return; &#125; for(int i = pos;i &lt;= pSeq-&gt;size ;i--)&#123; pSeq-&gt;array[i - 1] = pSeq-&gt;array[i]; &#125;&#125; 当我们基本的这些操作编写完之后，我们需要输出这些数组，来观察。 1234567void SeqListPrint(const SeqList *pSeq)&#123; assert(pSeq != NULL); for(int i = 0;i &lt; pSeq-&gt;size;i++)&#123; printf("%d",pSeq-&gt;array[i]); &#125; printf("\n");&#125; 删除的第二种形态用接口的方式来实现删除。 接口可以理解为封装一个函数来对其使用。这样我们就可以有一些其他的删除方式 删除第一个遇到的数据的形式12345678void SeqListRemove(SeqList *pSeq, DataType data)&#123; int pos = SeqListFind(pSeq,data); if(pos == -1)&#123; //找不到删除 return; &#125; SeqListPushErase(pSeq, pos);&#125; 删除遇到的所有数据的形式123456void SeqListRemoveALL(SeqList *pSeq,DataType data)&#123; //第一种方式 while(pos = SeqListFind(pSeq,data) != -1)&#123; SeqListPushErase(pSeq,data); &#125;&#125; 12345678910111213141516171819202122void SeqListRemovALL(SeqList *pSeq,DataType data)&#123; //第二种方式 //一次遍历空间，时间快，但是开辟了新空间，空间大小和size有关系 //开辟一个新空间，遍历原来的数组 //if arr[i] != data //new [j+1]= arr[j+1] //else i++ //把数据在搬回来，还剩的数据个数为i个 DataType *newArray = (DataType *)malloc(sizeof(DataType)*pSeq-&gt;size); int i, j; for(i = 0,j = 0;i &lt; pSeq-&gt;size;i++)&#123; if(data != pSeq-&gt;array[i])&#123; newArray[j] = pSeq-&gt;array[i]; j++ &#125; &#125; for(i = 0;i &lt; j; i++)&#123; pSeq-&gt;array[i] = newArray[i]; &#125; pSeq-&gt;size = j; free(newArray);&#125; 1234567891011void SeqListRemoveALL(SeqList *pSeq,DataType data)&#123; //第三种方法 //这个方法没有开辟新的空间，直接对其每个所对应的新区域赋值 //这样我们最后将数组size直接改为新开辟的大小 int i, j; for(i = 0,j = 0;i &lt; pSeq-&gt;size, i++)&#123; pSeq-&gt;array[j] = pSeq-&gt;array[i]; j++; &#125; pSeq-&gt;size = j;&#125; 查找的使用查找也是一个关键的选择，因为，在查找到我们需要的下标之后，我们可以对此进行各种增删改操作 查找也有很多方式，这里先仅做一种顺序遍历查找。查找也有二分查找(前提有序) 12345678int SeqListFind(SeqList *pSeq,DataType data)&#123; for(int i = 0;i &lt; pSeq-&gt;size;i++)&#123; if(data = pSeq-&gt;size[i])&#123; return 1; &#125; return -1; &#125;&#125; 一些其他的使用操作对于顺序表的操作我们还有一些其他的操作 1234int SeqListSize(SeqList *pSeq)&#123; //查看当前size的大小 return pSeq-&gt;size;&#125; 1234int SeqListEmpty(SeqList *pSeq)&#123; //清空当前数组 return pSeq-&gt;size == 0;&#125; 1234int SeqListFull(SeqList *pSeq)&#123; //将数组的size放到最大 return pSeq-&gt;size == MAX_SIZE;&#125; 123456void Swap(DataType *a,DataType *b)&#123; //交换两个数据 DataType t = *a; *a = *b; *b = t;&#125; 改的使用我们可以理解为，我们将要怎么让这个数组去改变，那么我们可以使用排序的方式将数组发生变化。这是一种改法。在静态顺序表中。通过举冒泡排序的例子来使用。 12345678910111213141516void SeqListBubbleSort(SeqList *pSeq)&#123; int i,j; int isSort; for(i = 0;i &lt; pSeq-&gt;size - 1;i++)&#123; isSort = 1; for(j = 0;j &lt; pSeq-&gt;size - 1 - i; j++)&#123; if(pSeq-&gt;array[i] &gt; pSeq-&gt;array[i + j])&#123; Swap(pSeq-&gt;array + j, pSeq-&gt;array + j + 1) &#125; isSort = 0; &#125; if(isSort)&#123; break; &#125; &#125;&#125; 在这里调用冒泡排序的方法是可以进行数组的改变。 以上就是关于静态顺序数组的基本组成。总的来说，数据结构的难点在于思想过程。怎么把在纸上我们通过绘画的东西，利用代码的形式去表达出来，这是一个很关键的思考过程。]]></content>
      <tags>
        <tag>C-数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初阶C-1107]]></title>
    <url>%2F2018%2F11%2F08%2F%E5%88%9D%E9%98%B6C-1107%2F</url>
    <content type="text"><![CDATA[这次的初阶都是跟C语言中的递归有关的。可以说递归是一个不好理解的，比较抽象的东西。 递归（Recursion），指在函数的定义中使用函数自身的方法，即程序的自身调用。 递归就是方法里调用自身。 但是递归的缺陷也是非常大的。在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储。递归次数过多容易造成栈溢出等，所以一般不提倡用递归算法设计程序。 1.递归和非递归分别实现求第n个斐波那契数。 12345678910111213141516171819202122232425262728//利用了递归int Fibonacci(int n)&#123; if (n == 1 || n == 2)&#123; return 1; &#125; return Fibonacci(n - 1) + Fibonacci(n - 2);&#125;//不使用递归void Fib(int n)&#123; int j = 1, k = 1, sum = 0; if (n == 1 || n == 2)&#123; return 1; &#125; if (n % 2 == 0)&#123; for (int i = 1; i &lt; n / 2; i++)&#123; j += k; k += j; &#125; printf("%d", k); &#125; else if(n % 2 == 1)&#123; for (int i = 1; i &lt;= n / 2; i++)&#123; j += k; k += j; &#125; printf("%d", j); &#125;&#125; 2.编写一个函数实现n^k，使用递归实现. 12345678//n^k 如果调用递归，我们先拆分这个算式// n^k=1,k=0;n^k=n*n^(k-1),k&gt;0double index(double n,double k)&#123; if (k == 0)&#123; return 1; &#125; return n*index(n, k - 1);&#125; 3.写一个递归函数DigitSum(n),输入一个非负整数,返回组成它的数字之和,例如,调用DigitSum(1729)，则应该返回1+7+2+9,它的和是19. 12345678910int DigitSum(int n)&#123; int m = 0; int sum = 0; if (n != 0)&#123; m = n % 10; n = n / 10; sum = m + DigitSum(n); &#125; return sum;&#125; 4.递归和非递归分别实现strlen. 123456789101112131415int Strlen(const char*str)&#123; if ('\0' == *str)&#123; return 0; &#125; return 1+Strlen(str + 1);//这里的+1可以理解成每次进行拆分去算 //比如“abcd” 先为“a”+“bcd”，第二次在为“b”+“cd”，以此类推&#125;int Strlen2(char str[])&#123; int size = 0; while (str[size] != '\0')&#123; size++; &#125; return size;&#125; 5.递归和非递归分别实现求n的阶乘 . 1234567891011121314151617void Fac(int n)&#123; int j = 1; if (n == 1)&#123; return 1; &#125; for (int i = 1; i &lt;= n; i++)&#123; j *= i; &#125; printf("%d", j);&#125;int Fac1(int a)&#123; if (a == 1)&#123; return 1; &#125; return a*Fac1(a-1);&#125; 6.递归方式实现打印一个整数的每一位. 1234567891011121314int PrintfNum(int n)&#123; if (n &lt; 9)&#123; printf("%d",PrintfNum(n) / 10); &#125; printf("%d", n); //逆序实现,非递归 //while (n)&#123; // m = n % 10; // n = n / 10; // printf("%d", m); //&#125; &#125; 本次就结束了，还有一个利用递归进行逆序的题，我觉得这道题很不好理解。我将专门写一篇关于这道题目的文章。 递归的思想是很重要的。我们可以想象成电影《盗梦空间》，一层接着一层的梦境，就好比我们的递归不断的往下进行，只有上一层完成后，才可到下一层。多加练习，多思考，一定会掌握的。]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初阶C-1103]]></title>
    <url>%2F2018%2F11%2F05%2F%E5%88%9D%E9%98%B6C-1103%2F</url>
    <content type="text"><![CDATA[1.实现一个函数，打印乘法口诀表，口诀表的行数和列数自己指定，输入9，输出99口诀表，输入12，输出1212的乘法口诀表。12345678910111213#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;void MultiplicationTable(int a)&#123; for (int i = 1; i &lt;= a; i++)&#123; for (int j = 1; j &lt;= i; j++)&#123; int k = 0; k = j*i; printf("%d*%d=%d ", j,i,k); &#125; printf("\n"); &#125;&#125; 2.使用函数实现两个数的交换。1234567void ChangeNum(int a, int b)&#123; int temp = 0; temp = b; b = a; a = temp; printf("%d,%d", a, b);&#125; 3.实现一个函数判断year是不是润年。1234567891011void LeapYear(int a)&#123; if (a % 100 == 0 &amp;&amp; a % 400 == 0)&#123; printf("%d is LeapYear", a); &#125; else if (a % 4 == 0 &amp;&amp; a % 100 != 0)&#123; printf("%d is LeapYear", a); &#125; else&#123; printf("Not LeapYear"); &#125;&#125; 4.实现一个函数，判断一个数是不是素数。1234567891011121314void prime(int a)&#123; if (a == 2)&#123; printf("It's a prime"); &#125; else &#123; for (int i = 3; i &lt;= a; i++)&#123; if (a%i == 0)&#123; break; &#125; printf("It's a prime"); &#125; printf("It's not a prime"); &#125;&#125; 5.创建一个数组,实现函数init()初始化数组、实现empty()清空数组、实现reverse()函数完成数组元素的逆置。 要求：自己设计函数的参数，返回值。12345678910111213141516171819202122232425262728293031#define size 5//数组初始化 就是定义数组变量的同时给其中的数组元素赋值，由于是给多个元素同时赋值void init()&#123; int arr[size] = &#123; 20, 16, 23, 75, 95, &#125;; for (int i = 0; i &lt; size; i++)&#123; printf("arr[%d]=%2d \n", i, arr[i]); &#125; printf("\n");&#125;void empty()&#123; int arr[5] = &#123; 20, 16, 23, 75, 95, &#125;; for (int i = 0; i &lt; (sizeof(arr) / sizeof(arr[0])); i++)&#123; arr[i] = '\0'; printf("arr[%d]=%2d \n", i, arr[i]); &#125; printf("\n");&#125;void reverse()&#123; int temp = 0; int i = 0; int arr[5] = &#123; 20, 16, 23, 75, 95, &#125;; for (i = 0; i &lt; 3; i++)&#123; temp = arr[i]; arr[i] = arr[4 - i]; arr[4 - i] = temp; &#125; for (i = 0; i &lt; 5; i++)&#123; printf("arr[%d]=%2d \n",i, arr[i]); &#125;&#125; 前4题很简单，并没有特别大的难度，只要掌握了计算公式，就可以算出。第五题的思路有很多种，这是我目前想出来的一种，初始化和清空比较容易想到。关于逆置，我的方法是比较繁琐的，要根据数组内个数的多少来判断i的取值范围，当然i是可以通过sizeof()来取代的，在此我就不更换了。还有memset()这个函数可以使用，以后我将找机会将其写出。 欢迎大家留言！我们可以一起讨论]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初阶C-1101]]></title>
    <url>%2F2018%2F11%2F04%2F%E5%88%9D%E9%98%B6C-1101%2F</url>
    <content type="text"><![CDATA[1.完成猜数字游戏。 源文件内需执行的1234567891011121314151617181920int main()&#123; while (1)&#123; printf("输入1，开始游戏\n"); printf("输入0，退出游戏\n"); int i = 0; scanf("%d", &amp;i); if (i == 1)&#123; Game(); &#125; else if(i == 0)&#123; printf("goodbye!\n"); break; &#125; else&#123; printf("请重新输入！\n"); &#125; &#125; system("pause"); return 0;&#125; 头文件.h1234567891011121314151617181920212223#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;#include&lt;time.h&gt;#include&lt;windows.h&gt;void Game()&#123; int num = 0; int result = 0; srand((unsigned int)time(NULL)); result = rand() % 100 + 1; do&#123; printf("请输入一个数:"); scanf("%d", &amp;num); if (num &lt; result)&#123; printf("lower\n"); &#125; else if(num &gt; result)&#123; printf("higher\n"); &#125; &#125; while (num != result); printf("congratulations!\n");&#125; 2.写代码可以在整型有序数组中查找想要的数字，找到了返回下标，找不到返回-1.（折半查找）123456789101112131415161718192021222324252627void find()&#123; int arr[] = &#123; 11, 12, 13, 14, 15, 16, 17, 18, 19 &#125;; int left = 0; int right = sizeof(arr) / sizeof(arr[0]) - 1;//减一是因为数组下标规则 int i = 0; int mid = (left + right) / 2; printf("输入一个数字进行查找："); scanf("%d", &amp;i); while (left &lt;= right)&#123;//在左边数小于右边数的情况下 mid = (left + right) / 2; if (arr[mid] &lt; i)&#123; left =mid + 1; &#125; else if(arr[mid] &gt; i)&#123; right = mid - 1; &#125; else&#123; break; &#125; &#125; if (arr[mid] == i)&#123; printf("%d", mid); &#125; else&#123; printf("-1"); &#125;&#125; 3.编写代码模拟三次密码输入的场景。 最多能输入三次密码，密码正确，提示“登录成功”,密码错误，可以重新输入，最多输入三次。三次均错，则提示退出程序。123456789101112void login()&#123; char pass[1024] = &#123;&#125;; char password[] = "123456"; for (int i = 0; i &lt; 3; i++)&#123; printf("Please enter you password:\n"); scanf("%s", &amp;pass); if (strcmp(password, pass) == 0)&#123; printf("Welcome to system!\n"); break; &#125; &#125;printf("sorry,exiting");&#125; 4.编写一个程序，可以一直接收键盘字符，如果是小写字符就输出对应的大写字符，如果接收的是大写字符，就输出对应的小写字符，如果是数字不输出。123456789101112void receive()&#123; printf("please enter successively\n"); while(1)//永真情况下。永远进行循环。在字符数c为数字时跳出循环。 &#123; char c; c = getchar();//从控制台读取一个字符，但不显示在屏幕上。 if (c &gt;= 48 &amp;&amp; c &lt;= 57)&#123; break; &#125; putchar(c); &#125;&#125; 本次作业都是一些关于for和while循环的一些用法。第二题是需要好好思考一下的，难点在于中间值在比较过后，向右还是向左的问题。最后一定要break退出，否则会无法跳出循环。]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初阶C_1030]]></title>
    <url>%2F2018%2F10%2F31%2F%E5%88%9D%E9%98%B6C-1030%2F</url>
    <content type="text"><![CDATA[1.在屏幕上输出一个上下倒三角星形的图案123456789101112131415161718192021222324252627void star()&#123;//将代码分为上三角和下三角来输出 int i, j, n = 7; for (i = 1; i &lt;= n; i++) &#123; for (j = 1; j &lt;= n - i; j++) &#123; printf(" "); &#125; for (j = 0; j &lt; 2 * i - 1; j++) &#123; printf("*"); &#125; printf("\n"); &#125; for (i = 6; i &gt; 0 ; i--) &#123; for (j = 1; j &lt;= n-i; j++) &#123; printf(" "); &#125; for (j = 1; j &lt; 2 * i ; j++) &#123; printf("*"); &#125; printf("\n"); &#125;&#125; 2.求出0～999之间的所有“水仙花数”并输出。例如： 153 = 1^3 + 5^3 + 3^3。 370 = 3^3 + 7^3 + 0^3。 371 = 3^3 + 7^3 + 1^3。 407 = 4^3 + 0^3 + 7^3。12345678910111213void narcissus()&#123; int i; int j, k, l; for (i = 0; i &lt; 1000; i++) &#123; j = i % 10; k = (i / 10) % 10; l = i / 100; if (i == j * j * j + k * k * k + l * l * l )&#123;//老铁！注意是"=="!! printf("%d\n", i); &#125; &#125;&#125; 3.求Sn=a+aa+aaa+aaaa+aaaaa的前5项之和，其中a是一个数字，例如：2+22+222+2222+22222 123456789void he(int a)&#123; //j每次都是j*10，之后在加上a。 int Sn = 0, i, j; j = a; //j=a，定义在循环之外，a的赋值只在第一次填写参数时。 for (i = 0; i &lt; 5; i++)&#123; Sn = j+ Sn; j = j * 10 + a; &#125; printf("%d", Sn);&#125;]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初阶C_1027]]></title>
    <url>%2F2018%2F10%2F31%2F%E5%88%9D%E9%98%B6C-1027%2F</url>
    <content type="text"><![CDATA[将数组A中的内容和数组B中的内容进行交换。（数组一样大） 12345678910111213141516171819void change_num()&#123; int a[5] = &#123; 12, 52, 36, 45, 62 &#125;; int b[5] = &#123; 21, 34, 13, 24, 72 &#125;; int i = 0; int tmp = 0; int sz = sizeof(a) / sizeof(a[0]);//所有数据的字节数除以一个数据的字节数等于数组的长度 for (i = 0; i &lt; sz; i++)&#123; tmp = a[i]; a[i] = b[i]; b[i] = tmp; &#125; for (i = 0; i &lt; sz; i++)&#123; printf("%d,", a[i]); &#125; printf("\n"); for (i = 0; i &lt; sz; i++)&#123; printf("%d,", a[i]); &#125;&#125; 计算1/1-1/2+1/3-1/4+1/5 …… + 1/99 - 1/100 的值。 12345678910111213void jisuan()&#123; double i;//最好改为double类型，因为1/i和1.0/i这两种写法，如果i的类型不同那么得出的答案也不同 double sum=0,sum1=0,sum2=0; for (i = 1; i &lt; 100; i += 2)&#123; sum1 = sum1 + 1 / i; &#125; for (i = 2; i &lt; 101; i += 2)&#123; sum2 = sum2 - 1 / i; &#125; sum=sum1+sum2; printf("%lf", sum);//%f和%lf分别是float类型和double类型用于格式化输入输出时对应的格式符号。 //%lf为双精度浮点&#125; 编写程序数一下 1到 100 的所有整数中出现多少次数字9。 12345678910void js9()&#123; int i; int count = 0; for (i = 0; i &lt; 101; i++)&#123; if ((i - 9) % 10 == 0||i / 9 == 10 )&#123; count++; &#125; &#125; printf("%d", count);//计算出来为19，这是因为99中有两个9存在，所以计算两次。刚开始总以为应该是18...&#125; 类型与计算公式别混淆，否则很容易代码出问题。]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初阶C_1025]]></title>
    <url>%2F2018%2F10%2F31%2F%E5%88%9D%E9%98%B6%E9%98%B6C-1025%2F</url>
    <content type="text"><![CDATA[#C常见的几种比较我用的VS2013，头文件与源文件分开，在此只贴出函数。 1.给定两个整形变量的值，将两个值的内容进行交换。 123456789void compare()&#123; int a = 10; int b = 20; int tmp = 0; tmp = a; a = b; b = tmp; printf("a=%d,b=%d", a, b);&#125; 2.不允许创建临时变量，交换两个数的内容 12345678void compare2()&#123; int a = 20; int b = 10; a = a - b; b = a + b; a = b - a; printf("a=%d,b=%d", a, b);&#125; 3.求10 个整数中最大值。 1234567891011void compare3()&#123; int a[10] = &#123; 12, 23, 51, 5, 24, 35, 62, 25, 19, 60 &#125;; int i; int max = a[0]; for (i = 0; i &lt; 11; i++)&#123; if (max &lt; a[i])&#123; max = a[i]; &#125; &#125; printf("最大数为%d", max);&#125; 4.将三个数按从大到小输出。 12345678910111213141516171819void compare4(int a,int b,int c)&#123; int tmp = 0; if (a &gt; b)&#123; tmp = a; a = b; b = tmp; &#125; if (b &gt; c)&#123; tmp = b; b = c; c = tmp; &#125; if (a &gt; b)&#123; tmp = a; a = b; b = tmp; &#125; printf("这三个数的排序为：%d,%d,%d", a, b, c);&#125; 在这里特别说一下，求最大公约数这用的是相减法，在while语句中，有个特别注意的。a-b的数需要考虑大小的问题，因为一直用大数减小数直到为0.5.求两个数的最大公约数。 12345678910111213141516171819void compare5(int a,int b)&#123; int tmp = 0; if (a &lt; b)&#123; tmp = a; a = b; b = tmp; &#125; while (a-b!=0)&#123; tmp = a - b; a = b; b = tmp; if (a &lt; b)&#123; tmp = a; a = b; b = tmp; &#125; &#125; printf("最大公约数为：%d", b);&#125;]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新的开始]]></title>
    <url>%2F2018%2F10%2F29%2F%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B%2F</url>
    <content type="text"><![CDATA[博客今日搭建初步完成，Markdown形式还不知道具体操作，会陆陆续续的进行完善。 说实话，一直就想搭建一个属于自己的博客。就为了能有个属于自己的小天地。 国内也有CSDN，博客园之类的。 但我觉得自己动手的会更好。 当我觉得自己足够强大时，会去尝试WordPress来搭建另外一种博客。 加油！程序程！]]></content>
      <tags>
        <tag>程序人生</tag>
      </tags>
  </entry>
</search>
