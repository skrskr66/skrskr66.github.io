<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[初阶C-1107]]></title>
    <url>%2F2018%2F11%2F08%2F%E5%88%9D%E9%98%B6C-1107%2F</url>
    <content type="text"><![CDATA[这次的初阶都是跟C语言中的递归有关的。可以说递归是一个不好理解的，比较抽象的东西。 递归（Recursion），指在函数的定义中使用函数自身的方法，即程序的自身调用。 递归就是方法里调用自身。 但是递归的缺陷也是非常大的。在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储。递归次数过多容易造成栈溢出等，所以一般不提倡用递归算法设计程序。 1.递归和非递归分别实现求第n个斐波那契数。 12345678910111213141516171819202122232425262728//利用了递归int Fibonacci(int n)&#123; if (n == 1 || n == 2)&#123; return 1; &#125; return Fibonacci(n - 1) + Fibonacci(n - 2);&#125;//不使用递归void Fib(int n)&#123; int j = 1, k = 1, sum = 0; if (n == 1 || n == 2)&#123; return 1; &#125; if (n % 2 == 0)&#123; for (int i = 1; i &lt; n / 2; i++)&#123; j += k; k += j; &#125; printf("%d", k); &#125; else if(n % 2 == 1)&#123; for (int i = 1; i &lt;= n / 2; i++)&#123; j += k; k += j; &#125; printf("%d", j); &#125;&#125; 2.编写一个函数实现n^k，使用递归实现. 12345678//n^k 如果调用递归，我们先拆分这个算式// n^k=1,k=0;n^k=n*n^(k-1),k&gt;0double index(double n,double k)&#123; if (k == 0)&#123; return 1; &#125; return n*index(n, k - 1);&#125; 3.写一个递归函数DigitSum(n),输入一个非负整数,返回组成它的数字之和,例如,调用DigitSum(1729)，则应该返回1+7+2+9,它的和是19. 12345678910int DigitSum(int n)&#123; int m = 0; int sum = 0; if (n != 0)&#123; m = n % 10; n = n / 10; sum = m + DigitSum(n); &#125; return sum;&#125; 4.递归和非递归分别实现strlen. 1234567891011121314151617void Fac(int n)&#123; int j = 1; if (n == 1)&#123; return 1; &#125; for (int i = 1; i &lt;= n; i++)&#123; j *= i; &#125; printf("%d", j);&#125;int Fac1(int a)&#123; if (a == 1)&#123; return 1; &#125; return a*Fac1(a-1);&#125; 5.递归和非递归分别实现求n的阶乘 . 1234567891011121314int PrintfNum(int n)&#123; if (n &lt; 9)&#123; printf("%d",PrintfNum(n) / 10); &#125; printf("%d", n); //逆序实现,非递归 //while (n)&#123; // m = n % 10; // n = n / 10; // printf("%d", m); //&#125; &#125; 6.递归方式实现打印一个整数的每一位. 123456789101112131415int Strlen(const char*str)&#123; if ('\0' == *str)&#123; return 0; &#125; return 1+Strlen(str + 1);//这里的+1可以理解成每次进行拆分去算 //比如“abcd” 先为“a”+“bcd”，第二次在为“b”+“cd”，以此类推&#125;int Strlen2(char str[])&#123; int size = 0; while (str[size] != '\0')&#123; size++; &#125; return size;&#125; 本次就结束了，还有一个利用递归进行逆序的题，我觉得这道题很不好理解。我将专门写一篇关于这道题目的文章。 递归的思想是很重要的。我们可以想象成电影《盗梦空间》，一层接着一层的梦境，就好比我们的递归不断的往下进行，只有上一层完成后，才可到下一层。多加练习，多思考，一定会掌握的。]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[静态顺序表的方法]]></title>
    <url>%2F2018%2F11%2F06%2F%E9%9D%99%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[静态顺序表属于数据结构开始的一种基本结构首先我们要知道数据结构的概念 数据结构 数据的组织关系 算法 为了达到特定的目的的一系列过程。在这个过程中又分为两种角度1） 逻辑角度：线性结构，树形结构，图形结构2） 存储角度：顺序存储，链式存储 在线性结构中顺序存储的方式，在本次中为顺序表，分为静态和动态而静态顺序表的理解可以分为1） 结构体定义（定义、背后的内存布局模型）2） 顺序表的基本操作：插/删/查/改。重点需要去掌握的是插和删。插（头插/尾插/插入），删（头删/尾删/删除）接下来开始对于整个代码进行一个分析。123456789101112#pragma once#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt; //一般不着急于先定义一堆，你需要什么在去定义什么。typedef int DataType; //为现有类型创建别名。用DataType来代替int。#define MAX_SIZE(100) //开出一块空间，占用内存的最大位置。typedef struct SeqList&#123; //定义结构体的别名 DataType array[MAX_SIZE]; int size;&#125;SeqList; //变量名 当把结构体都定义好了之后，我们开始先进行两个基本操作，对数组进行初始化和销毁此时我们要用到assert()。在开头首先要定义这个宏#include&lt;assert.h&gt;,他的功能就是测试一个条件可能使程序终止。用法void assert(int test)在初始过程中，可能需要把内存清空一下，所以我们可能需要memset()这个函数。这个函数的用法void memset(void s, int ch, size_t n);将s所指向的某一块内存中的后n个 字节的内容全部设置为ch指定的ASCII值，第一个值为指定的内存地址，块的大小由第三个参数指定，这个函数通常为新申请的内存做初始化工作，其返回值为s。 123456789101112//初始化void SeqListInit(Seqlist *pSeq)&#123; //初始化size assert(pSeq != NULL); pSep-&gt;size = 0; memset(pSep-&gt;array,0,SIZE_MAX * sizeof(DataType));&#125;//销毁void SeqListDestory(SeqList *pSeq)&#123; assert(pSeq); pSeq-&gt;size = 0;&#125; 我们还需要部署一个测试函数，先暂时定义一下，当增删改查部署完后，可以往其中添加增删改查的函数来进行实验。 插入：有头插，尾插，插入头插的使用PS：考虑完了普通情况后，我们要考虑的是特殊情况，当size超过了定义的最大尺寸情况，我们需要进行一个判断， 123456789101112131415161718void SeqListPushTop(SeqList *pSeq,DataType data)&#123; assert(pSeq); if(pSeq-&gt;size &gt;= MAX_SIZE)&#123; printf("满了\n"); assert(0); return; &#125; //从最后开始向每一个后面开始搬运，如果不这么做，将会将每一次的值覆盖掉 for(int i = pSeq-&gt;szie;i &gt; 0; i--)&#123; // i此时是定义的为位置,位置为[size,0],从后往前搬 pSeq-&gt;array[i] = pSeq-&gt;array[i - 1]; &#125; //将i定位为数据,位置size[0,size),将整体的位置向后移 for(int i = size - 1；i &gt; 0;i++)&#123; pSeq-&gt;array[i + 1] = pSeq-&gt;array[i]; &#125; pSeq-&gt;array[0]=data; pSeq-&gt;size++;&#125; 这是一个自我思考的图示，仅供参考 尾插的使用尾插就相当于正常插入了，这个是比较简单的一种插入 1234567891011void SeqListPushBack(SeqList *pSeq,DataType data)&#123; //还是要先考虑特殊情况 assert(pSeq); if(pSeq-&gt;size &gt;= MAX_SIZE)&#123; printf("满了\n"); assert(0); return; &#125; pSeq-&gt;array[pSeq-&gt;size] = data; pSeq-&gt;size++;&#125; 中间插入的使用中间插入根据下标来使用，此时这么想，我们先将要插入的地方定义一个pos下标，此时将此下标之后的（包括此下标的）所有数据向后移动。 123456789101112131415161718void SeqListInsert(SeqList *pSeq,int pos, DataType data)&#123; //考虑特殊情况 assert(pSeq); if(pSeq-&gt;size &gt;= MAX_SIZE)&#123; printf("满了\n"); assert(0); return; //此时i作为位置 for(int i = pSeq-&gt;size; i &gt;= pos; i--)&#123; pSeq-&gt;array[i] = pSeq-&gt;array[i - 1]; &#125; //此时i作为数据 for(int i = pSeq-&gt;size - 1;i &gt;= pos; i--)&#123; pSeq-&gt;array[i + 1] = pSeq-&gt;array[i]; &#125; pSeq-&gt;array[pos] = data; pSeq-&gt;szie++;&#125; 自我图示，仅供参考 删除：头删，尾删，删除头删的使用最开始的数删除后，其他的数据向前补进。当然，也别忘了特殊情况！ 123456789101112131415161718void SeqListPushFont(SeqList *pSeq)&#123; //特殊情况 assert(pSeq) if(pSeq-&gt;size &lt;= 0)&#123; printf("空了\n"); assert(0); return; &#125; //i此时为位置时 for(int i = 0; i &lt; pSeq-&gt;size - 1;i++)&#123; pSeq-&gt;array[i] = pSeq-&gt;array[i + 1]; &#125; //i此时为数据时 for(int i = 1;i &lt; pSeq-&gt;size;i++)&#123; pSeq-&gt;array[i - 1] = pSeq-&gt;array[i]; &#125; pSeq-&gt;size--;&#125; 尾删的使用尾删比较简单，也就是直接将最后一个删除 123456789void SeqListPushPop(SeqList *pSeq)&#123; assert(pSeq) if(pSeq-&gt;size &lt;= 0)&#123; printf("空了\n"); assert(0); return; &#125; pSeq-&gt;size--;//直接将空间减小&#125; 删除的使用删除从中间删除，还是定义一个pos下标，删除之后，在将所有数据向前移动1234567891011void SeqListPushErase(SeqList *pSeq,int pos)&#123; assert(pSeq) if(pSeq-&gt;size &lt;= 0)&#123; printf("空了\n"); assert(0); return; &#125; for(int i = pos;i &lt;= pSeq-&gt;size ;i--)&#123; pSeq-&gt;array[i - 1] = pSeq-&gt;array[i]; &#125;&#125; 当我们基本的这些操作编写完之后，我们需要输出这些数组，来观察。 1234567void SeqListPrint(const SeqList *pSeq)&#123; assert(pSeq != NULL); for(int i = 0;i &lt; pSeq-&gt;size;i++)&#123; printf("%d",pSeq-&gt;array[i]); &#125; printf("\n");&#125;]]></content>
      <tags>
        <tag>C-数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初阶C-1103]]></title>
    <url>%2F2018%2F11%2F05%2F%E5%88%9D%E9%98%B6C-1103%2F</url>
    <content type="text"><![CDATA[1.实现一个函数，打印乘法口诀表，口诀表的行数和列数自己指定，输入9，输出99口诀表，输入12，输出1212的乘法口诀表。12345678910111213#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;void MultiplicationTable(int a)&#123; for (int i = 1; i &lt;= a; i++)&#123; for (int j = 1; j &lt;= i; j++)&#123; int k = 0; k = j*i; printf("%d*%d=%d ", j,i,k); &#125; printf("\n"); &#125;&#125; 2.使用函数实现两个数的交换。1234567void ChangeNum(int a, int b)&#123; int temp = 0; temp = b; b = a; a = temp; printf("%d,%d", a, b);&#125; 3.实现一个函数判断year是不是润年。1234567891011void LeapYear(int a)&#123; if (a % 100 == 0 &amp;&amp; a % 400 == 0)&#123; printf("%d is LeapYear", a); &#125; else if (a % 4 == 0 &amp;&amp; a % 100 != 0)&#123; printf("%d is LeapYear", a); &#125; else&#123; printf("Not LeapYear"); &#125;&#125; 4.实现一个函数，判断一个数是不是素数。1234567891011121314void prime(int a)&#123; if (a == 2)&#123; printf("It's a prime"); &#125; else &#123; for (int i = 3; i &lt;= a; i++)&#123; if (a%i == 0)&#123; break; &#125; printf("It's a prime"); &#125; printf("It's not a prime"); &#125;&#125; 5.创建一个数组,实现函数init()初始化数组、实现empty()清空数组、实现reverse()函数完成数组元素的逆置。 要求：自己设计函数的参数，返回值。12345678910111213141516171819202122232425262728293031#define size 5//数组初始化 就是定义数组变量的同时给其中的数组元素赋值，由于是给多个元素同时赋值void init()&#123; int arr[size] = &#123; 20, 16, 23, 75, 95, &#125;; for (int i = 0; i &lt; size; i++)&#123; printf("arr[%d]=%2d \n", i, arr[i]); &#125; printf("\n");&#125;void empty()&#123; int arr[5] = &#123; 20, 16, 23, 75, 95, &#125;; for (int i = 0; i &lt; (sizeof(arr) / sizeof(arr[0])); i++)&#123; arr[i] = '\0'; printf("arr[%d]=%2d \n", i, arr[i]); &#125; printf("\n");&#125;void reverse()&#123; int temp = 0; int i = 0; int arr[5] = &#123; 20, 16, 23, 75, 95, &#125;; for (i = 0; i &lt; 3; i++)&#123; temp = arr[i]; arr[i] = arr[4 - i]; arr[4 - i] = temp; &#125; for (i = 0; i &lt; 5; i++)&#123; printf("arr[%d]=%2d \n",i, arr[i]); &#125;&#125; 前4题很简单，并没有特别大的难度，只要掌握了计算公式，就可以算出。第五题的思路有很多种，这是我目前想出来的一种，初始化和清空比较容易想到。关于逆置，我的方法是比较繁琐的，要根据数组内个数的多少来判断i的取值范围，当然i是可以通过sizeof()来取代的，在此我就不更换了。还有memset()这个函数可以使用，以后我将找机会将其写出。 欢迎大家留言！我们可以一起讨论]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初阶C-1101]]></title>
    <url>%2F2018%2F11%2F04%2F%E5%88%9D%E9%98%B6C-1101%2F</url>
    <content type="text"><![CDATA[1.完成猜数字游戏。 源文件内需执行的1234567891011121314151617181920int main()&#123; while (1)&#123; printf("输入1，开始游戏\n"); printf("输入0，退出游戏\n"); int i = 0; scanf("%d", &amp;i); if (i == 1)&#123; Game(); &#125; else if(i == 0)&#123; printf("goodbye!\n"); break; &#125; else&#123; printf("请重新输入！\n"); &#125; &#125; system("pause"); return 0;&#125; 头文件.h1234567891011121314151617181920212223#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;#include&lt;time.h&gt;#include&lt;windows.h&gt;void Game()&#123; int num = 0; int result = 0; srand((unsigned int)time(NULL)); result = rand() % 100 + 1; do&#123; printf("请输入一个数:"); scanf("%d", &amp;num); if (num &lt; result)&#123; printf("lower\n"); &#125; else if(num &gt; result)&#123; printf("higher\n"); &#125; &#125; while (num != result); printf("congratulations!\n");&#125; 2.写代码可以在整型有序数组中查找想要的数字，找到了返回下标，找不到返回-1.（折半查找）123456789101112131415161718192021222324252627void find()&#123; int arr[] = &#123; 11, 12, 13, 14, 15, 16, 17, 18, 19 &#125;; int left = 0; int right = sizeof(arr) / sizeof(arr[0]) - 1;//减一是因为数组下标规则 int i = 0; int mid = (left + right) / 2; printf("输入一个数字进行查找："); scanf("%d", &amp;i); while (left &lt;= right)&#123;//在左边数小于右边数的情况下 mid = (left + right) / 2; if (arr[mid] &lt; i)&#123; left =mid + 1; &#125; else if(arr[mid] &gt; i)&#123; right = mid - 1; &#125; else&#123; break; &#125; &#125; if (arr[mid] == i)&#123; printf("%d", mid); &#125; else&#123; printf("-1"); &#125;&#125; 3.编写代码模拟三次密码输入的场景。 最多能输入三次密码，密码正确，提示“登录成功”,密码错误，可以重新输入，最多输入三次。三次均错，则提示退出程序。123456789101112void login()&#123; char pass[1024] = &#123;&#125;; char password[] = "123456"; for (int i = 0; i &lt; 3; i++)&#123; printf("Please enter you password:\n"); scanf("%s", &amp;pass); if (strcmp(password, pass) == 0)&#123; printf("Welcome to system!\n"); break; &#125; &#125;printf("sorry,exiting");&#125; 4.编写一个程序，可以一直接收键盘字符，如果是小写字符就输出对应的大写字符，如果接收的是大写字符，就输出对应的小写字符，如果是数字不输出。123456789101112void receive()&#123; printf("please enter successively\n"); while(1)//永真情况下。永远进行循环。在字符数c为数字时跳出循环。 &#123; char c; c = getchar();//从控制台读取一个字符，但不显示在屏幕上。 if (c &gt;= 48 &amp;&amp; c &lt;= 57)&#123; break; &#125; putchar(c); &#125;&#125; 本次作业都是一些关于for和while循环的一些用法。第二题是需要好好思考一下的，难点在于中间值在比较过后，向右还是向左的问题。最后一定要break退出，否则会无法跳出循环。]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初阶C_1030]]></title>
    <url>%2F2018%2F10%2F31%2F%E5%88%9D%E9%98%B6C-1030%2F</url>
    <content type="text"><![CDATA[1.在屏幕上输出一个上下倒三角星形的图案123456789101112131415161718192021222324252627void star()&#123;//将代码分为上三角和下三角来输出 int i, j, n = 7; for (i = 1; i &lt;= n; i++) &#123; for (j = 1; j &lt;= n - i; j++) &#123; printf(" "); &#125; for (j = 0; j &lt; 2 * i - 1; j++) &#123; printf("*"); &#125; printf("\n"); &#125; for (i = 6; i &gt; 0 ; i--) &#123; for (j = 1; j &lt;= n-i; j++) &#123; printf(" "); &#125; for (j = 1; j &lt; 2 * i ; j++) &#123; printf("*"); &#125; printf("\n"); &#125;&#125; 2.求出0～999之间的所有“水仙花数”并输出。例如： 153 = 1^3 + 5^3 + 3^3。 370 = 3^3 + 7^3 + 0^3。 371 = 3^3 + 7^3 + 1^3。 407 = 4^3 + 0^3 + 7^3。12345678910111213void narcissus()&#123; int i; int j, k, l; for (i = 0; i &lt; 1000; i++) &#123; j = i % 10; k = (i / 10) % 10; l = i / 100; if (i == j * j * j + k * k * k + l * l * l )&#123;//老铁！注意是"=="!! printf("%d\n", i); &#125; &#125;&#125; 3.求Sn=a+aa+aaa+aaaa+aaaaa的前5项之和，其中a是一个数字，例如：2+22+222+2222+22222 123456789void he(int a)&#123; //j每次都是j*10，之后在加上a。 int Sn = 0, i, j; j = a; //j=a，定义在循环之外，a的赋值只在第一次填写参数时。 for (i = 0; i &lt; 5; i++)&#123; Sn = j+ Sn; j = j * 10 + a; &#125; printf("%d", Sn);&#125;]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初阶C_1027]]></title>
    <url>%2F2018%2F10%2F31%2F%E5%88%9D%E9%98%B6C-1027%2F</url>
    <content type="text"><![CDATA[将数组A中的内容和数组B中的内容进行交换。（数组一样大） 12345678910111213141516171819void change_num()&#123; int a[5] = &#123; 12, 52, 36, 45, 62 &#125;; int b[5] = &#123; 21, 34, 13, 24, 72 &#125;; int i = 0; int tmp = 0; int sz = sizeof(a) / sizeof(a[0]);//所有数据的字节数除以一个数据的字节数等于数组的长度 for (i = 0; i &lt; sz; i++)&#123; tmp = a[i]; a[i] = b[i]; b[i] = tmp; &#125; for (i = 0; i &lt; sz; i++)&#123; printf("%d,", a[i]); &#125; printf("\n"); for (i = 0; i &lt; sz; i++)&#123; printf("%d,", a[i]); &#125;&#125; 计算1/1-1/2+1/3-1/4+1/5 …… + 1/99 - 1/100 的值。 12345678910111213void jisuan()&#123; double i;//最好改为double类型，因为1/i和1.0/i这两种写法，如果i的类型不同那么得出的答案也不同 double sum=0,sum1=0,sum2=0; for (i = 1; i &lt; 100; i += 2)&#123; sum1 = sum1 + 1 / i; &#125; for (i = 2; i &lt; 101; i += 2)&#123; sum2 = sum2 - 1 / i; &#125; sum=sum1+sum2; printf("%lf", sum);//%f和%lf分别是float类型和double类型用于格式化输入输出时对应的格式符号。 //%lf为双精度浮点&#125; 编写程序数一下 1到 100 的所有整数中出现多少次数字9。 12345678910void js9()&#123; int i; int count = 0; for (i = 0; i &lt; 101; i++)&#123; if ((i - 9) % 10 == 0||i / 9 == 10 )&#123; count++; &#125; &#125; printf("%d", count);//计算出来为19，这是因为99中有两个9存在，所以计算两次。刚开始总以为应该是18...&#125; 类型与计算公式别混淆，否则很容易代码出问题。]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初阶C_1025]]></title>
    <url>%2F2018%2F10%2F31%2F%E5%88%9D%E9%98%B6%E9%98%B6C-1025%2F</url>
    <content type="text"><![CDATA[#C常见的几种比较我用的VS2013，头文件与源文件分开，在此只贴出函数。 1.给定两个整形变量的值，将两个值的内容进行交换。 123456789void compare()&#123; int a = 10; int b = 20; int tmp = 0; tmp = a; a = b; b = tmp; printf("a=%d,b=%d", a, b);&#125; 2.不允许创建临时变量，交换两个数的内容 12345678void compare2()&#123; int a = 20; int b = 10; a = a - b; b = a + b; a = b - a; printf("a=%d,b=%d", a, b);&#125; 3.求10 个整数中最大值。 1234567891011void compare3()&#123; int a[10] = &#123; 12, 23, 51, 5, 24, 35, 62, 25, 19, 60 &#125;; int i; int max = a[0]; for (i = 0; i &lt; 11; i++)&#123; if (max &lt; a[i])&#123; max = a[i]; &#125; &#125; printf("最大数为%d", max);&#125; 4.将三个数按从大到小输出。 12345678910111213141516171819void compare4(int a,int b,int c)&#123; int tmp = 0; if (a &gt; b)&#123; tmp = a; a = b; b = tmp; &#125; if (b &gt; c)&#123; tmp = b; b = c; c = tmp; &#125; if (a &gt; b)&#123; tmp = a; a = b; b = tmp; &#125; printf("这三个数的排序为：%d,%d,%d", a, b, c);&#125; 在这里特别说一下，求最大公约数这用的是相减法，在while语句中，有个特别注意的。a-b的数需要考虑大小的问题，因为一直用大数减小数直到为0.5.求两个数的最大公约数。 12345678910111213141516171819void compare5(int a,int b)&#123; int tmp = 0; if (a &lt; b)&#123; tmp = a; a = b; b = tmp; &#125; while (a-b!=0)&#123; tmp = a - b; a = b; b = tmp; if (a &lt; b)&#123; tmp = a; a = b; b = tmp; &#125; &#125; printf("最大公约数为：%d", b);&#125;]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新的开始]]></title>
    <url>%2F2018%2F10%2F29%2F%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B%2F</url>
    <content type="text"><![CDATA[博客今日搭建初步完成，Markdown形式还不知道具体操作，会陆陆续续的进行完善。 说实话，一直就想搭建一个属于自己的博客。就为了能有个属于自己的小天地。 国内也有CSDN，博客园之类的。 但我觉得自己动手的会更好。 当我觉得自己足够强大时，会去尝试WordPress来搭建另外一种博客。 加油！程序程！]]></content>
      <tags>
        <tag>程序人生</tag>
      </tags>
  </entry>
</search>
