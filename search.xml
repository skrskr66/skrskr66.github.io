<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python-对豆瓣的top250的爬取]]></title>
    <url>%2F2018%2F12%2F10%2Fpython-%E5%AF%B9%E8%B1%86%E7%93%A3%E7%9A%84top250%E7%9A%84%E7%88%AC%E5%8F%96%2F</url>
    <content type="text"><![CDATA[之前写了一个猫眼的爬虫的代码。是利用了request()和beautifulsoup()。但是之前的方法是利用了selector的搜索方法。最近学习了一点正则表达式，用正则表达式对豆瓣的top250进行了尝试。 豆瓣一直都是我比较喜欢的一个app，我也很喜欢看电影，你如果喜欢，在我的博客里有我的豆瓣链接，我们可以互粉一下聊聊电影hhhhhh，看得不多，但坚持再看并且写影评。 这次爬取下来top250的数据也非常高兴。 正则表达式的定义正则表达式，又称规则表达式。（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。 1import re python如果要使用正则表达式，首先需要引用re库 re库是一个python中有关于正则表达式的第三方库。因为我们在匹配过程中，也需要一些函数来剔除我们不需要的冗余字符。 正则表达式常用操作符(1) 操作符 说明 实例 . 表示任何单个字符 比如在非贪婪匹配中(.*?) [ ] 字符集，对单个字符给出取值范围 [abc]表示a/b/c，[a-z]表示a到z的单个字符 [^ ] 非字符集，对单个字符给出排除范围 [^abc]表示非a非b非c的单个字符 * 前一个字符0次或无限次扩展 abc*表示为ab/abc/abccc + 前一个字符1次或无限次扩展 abc+表示abc/abcc/abccc ? 前一个字符0次或1次扩展 abc？表示ab/abc \ 左右表达式的任意一个 abc\ def表示 abc、def 正则表达式的常用操作符(2) 操作符 说明 实例 {m} 扩展前一个字符m次 ab{2}c表示abbc {m,n} 扩展前一个字符m至n次（含n） ab{1,2}c表示abc、abbc ^ 匹配字符串开头 ^abc表示abc且在一个字符串的开头 $ 匹配字符串结尾 abc$表示abc且在一个字符串的结尾 ( ) 分组标记，内部只能使用\ 操作符 (abc)表示abc,(abc\ def)表示abc、def \d 数字，等价于[0-9] \w 单词字符，等价于[A-Za-z0-9_] 常用标记 说明 re.I re.IGNORECASE 忽略正则表达式中的大小写，[A-Z]能够匹配小写字符 re.M re.MULTILINE 正则表达式中的^操作符能够将给定字符串的每行当作匹配开始 re.S re.DOTALL 正则表达式中的.操作符能够匹配所有字符，默认匹配除了换行以外的所有字符 以上这些常用的操作符对于爬虫来说是足够的了，我们还需要的是怎么去使用去让其匹配。 正则表达式的练习我用的是anaconda中的jupyter进行练习。 几种常见的匹配方式首先引用这个库，常规操作 1import re 最常规匹配123456content='Hello 123 4567 World_This is a Regex Demo'print(len(content))result=re.match('^Hello\s\d\d\d\s\d&#123;4&#125;\s\w&#123;10&#125;.*Demo$',content)print(result)print(result.group())#group()表示取全部匹配的字符串或者指定的组，返回结果是一个字符串print(result.span())#span()表示返回一个元组包含匹配 (开始,结束) 的位置 输出结果 1234567841&lt;re.Match object; span=(0, 41), match='Hello 123 4567 World_This is a Regex Demo'&gt;Hello 123 4567 World_This is a Regex Demo(0, 41)#这是最常规的匹配，将每一个字符都用操作符#\s 是一个匹配空格 \d 匹配数字 \d&#123;4&#125; 匹配一串数字#.*Demo$ 点用于匹配之前的 *作为前一个字符的匹配与'点'一起 最后用$作为一个匹配字符串的结尾 泛匹配1234content = 'Hello 123 4567 World_This is a Regex Demo'result = re.match('^Hello.*Demo$',content)print(result)print(result.group()) 输出结果 1234&lt;re.Match object; span=(0, 41), match='Hello 123 4567 World_This is a Regex Demo'&gt;Hello 123 4567 World_This is a Regex Demo#泛匹配就比较省略，有前面和后面的字符就行，中间的不需要也可以 匹配目标12345content = 'Hello 1234567 World_This is a Regex Demo'result = re.match('^Hello\s(\d+)\sWorld.*Demo$',content)print(result)print(result.group(1))#为了看看匹配的分组中是否是我所需要的print(result.span()) 输出结果 12345&lt;re.Match object; span=(0, 40), match='Hello 1234567 World_This is a Regex Demo'&gt;1234567(0, 40)#(\d+) \d表示数字, + 表示一个或多个，括号就是将其最为一个分组 接着是两个比较关键的匹配方法 贪婪匹配1234content = 'Hello 1234567 World_This is a Regex Demo'result = re.match('^He.*(\d+).*Demo$',content)print(result)print(result.group(1)) 输出结果 1234567&lt;re.Match object; span=(0, 40), match='Hello 1234567 World_This is a Regex Demo'&gt;7#Python里数量词默认是贪婪的（在少数语言里也可能是默认非贪婪），总是尝试匹配尽可能多的字符#贪婪模式下字符串查找会直接走到字符串结尾去匹配，如果不相等就向前寻找，这一过程称为回溯。#上面的例子可以看出 .* 这样的前后搭配匹配 可以前后尝试尽可能多的匹配字符 非贪婪匹配1234content = 'Hello 1234567 World_This is a Regex Demo'result = re.match('^He.*?(\d+).*Demo$',content)print(result)print(result.group(1)) 输出结果 12345&lt;re.Match object; span=(0, 40), match='Hello 1234567 World_This is a Regex Demo'&gt;1234567#非贪婪则相反，总是尝试匹配尽可能少的字符。在"*","?","+","&#123;m,n&#125;"后面加上？，使贪婪变成非贪婪。#非贪婪模式下会自左向右查找，一个一个匹配不会出现回溯的情况。 匹配模式12345content = '''Hello 1234567 World_Thisis a Regex Demo'''result = re.match('^He.*?(\d+).*?Demo',content,re.S)print(result.group(1)) 匹配模式主要利用了re库中的re.S参数，这样就可以将字符串作为一个整体，在整体中进行匹配。 以上就是关于正则表达式的基本知识。看一下例子，知道大概就足够了。 豆瓣内容爬取 首先进入豆瓣的top250排行榜，我们首先能看到的就是关于电影的内容。利用chrome浏览器右击检查打开审查元素，我们来观察一下这个网页的html大概构成。 我们将鼠标放到li标签上，可以看到左侧的一片区域都被标记了。说明这一块都是有关《肖申克的救赎》。 一步一步点开这个标签我们将鼠标放到每一个标签之上能看到，每一个标签都有一个与之对应的区域，这个时候我们就需要使用这些标签来构建正则表达式。 1'&lt;em class=""&gt;(\d+)&lt;/em&gt;.*?&lt;span class="title"&gt;(.*?)&lt;/span&gt;.*?&lt;p class=""&gt;(.*?)&lt;/p&gt;.*?&lt;span class="rating_num" property="v:average"&gt;(.*?)&lt;/span&gt;.*?&lt;span&gt;(.*?)&lt;/span&gt;.*?&lt;span class="inq"&gt;(.*?)&lt;/span&gt;']]></content>
      <tags>
        <tag>python-爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初阶C-1124]]></title>
    <url>%2F2018%2F12%2F06%2F%E5%88%9D%E9%98%B6C-1124%2F</url>
    <content type="text"><![CDATA[1.编写函数： unsigned int reverse_bit(unsigned int value); 这个函数的返回值value的二进制位模式从左到右翻转后的值。 如： 在32位机器上 25这个值包含下列各位： 00000000000000000000000000011001 翻转后：（2550136832） 10011000000000000000000000000000 程序结果返回： 2550136832 12345678910111213141516171819202122232425262728unsigned int reverse_bit(unsigned int value)&#123; //第一种方法 unsigned int sum = 0; int i; for(i = 0;i &lt; 32;i++)&#123; sum = sum + ((value &gt;&gt; i) &amp; 1) * pow(2,31 - i); &#125; return sum; //输入任意一个数，进行移位操作并且移位一次还要和1进行一次与操作，这个时候判断最后一个位是1还是0。 //当判断完之后，进行乘方 //第一个数 ----&gt; 32位 2^31 //第二个数 ----&gt; 32位 2^30 //对每一位的数进行了判断之后(判断是为1还是为0)，乘以它的方就是将其转换放在翻转后的位置 //全部相加之后，就是每个翻转之后的位置 //第二种方法 unsigned int temp = 0; int i; for(i = 0;i &lt; 31;i++)&#123; temp = temp &lt;&lt; 1; temp = temp | ((value &gt;&gt; i) &amp; 1); &#125; return temp; //将每一个最后位都取出来 //放在新建变量的最后一位 //左移新建变量temp //我们可以这样理解，我们取出一个变量。让这个变量每次向左移动。这样每次左移之后它的位数都在增加，但是增加之后，仅仅只是增加了位数，具体值的判断再由下一步 //还是依旧判断最后一位是否为1，判断是否为1之后再去与变量进行 或运算。如果是1，那么与完之后的结果为1.否则与完之后的结果为0.并不冲突。位数再增加，但是每次增加的位数还是要进行判断是0还是1.最后将这个变量返回。即为翻转之后的数。&#125; 2.不使用（a+b）/2这种方式，求两个数的平均值。 123456789101112int avg()&#123; int i,j; int num; printf("enter tow numbers\n"); scanf("%d %d",&amp;i,&amp;j); num = (i &amp; j) + (i ^ j) &gt;&gt; 1; printf("%d",num); //不用最常规的写法，那么就是以二进制的角度来思考。 //二进制去求平均数。那么就是让每一位都进行一个求其平均 //&amp; 用来判断相同位的平均值， ^ 用来判断不同位的平均值(不同位进行^运算之后，得的是不同位的值，这时候将其除以2得到的就是不同位的平均值) //之后将它们相加之后，得到就是二进制下的平均数&#125; 3.编程实现： 一组数据中只有一个数字出现了一次。其他所有数字都是成对出现的。 请找出这个数字。（使用位运算） 12345678910void find_num()&#123; int arr[9] = &#123; 5, 5, 2, 4, 8, 9, 8, 4, 9 &#125;; int len = sizeof(arr)/sizeof(arr[0]); for(int i = 1;i &lt; len;i++)&#123; arr[0] = arr[0] ^ arr[i]; &#125; printf("%d",arr[0]); //连续异或，偶数位的最后异或还是为0，但是奇数位的异或最后为1 //所以最后可能出现的只是单独出现的的位数。&#125; 4.有一个字符数组的内容为:”student a am i”, 请你将数组的内容改为”i am a student”. 要求： 不能使用库函数。 只能开辟有限个空间（空间个数和字符串的长度无关）。 student a am i i ma a tneduts i am a student 12345678910int mystrlen(char* str)&#123; //判断字符串的长度 int count = 0; while(*str++)&#123; count++; &#125; return count;&#125;//字符串判定长度，设置的形参为char类型的指针，一个字符串的长度始终都在变化//在输出时，系统先输出字符指针指向的第一个字符数据，然后使指针加1，使之指向下一个，然后再输出……直至遇到字符'\0‘，结束。所以给while的判断是 *str++，指针一个一个的走判断。 1234567891011//逆转指定范围的字符串void reverse_string(char* start,char* end)&#123; while(start &lt; end)&#123; //比如classmate start的字符为‘c’，end的字符则为‘e’ char temp = *start; *start = *end; *end = temp; start++;//字符串指向的位置，从开始不断向后 end--;//才指定范围的字符串，从结尾不断向前 &#125;&#125; 1234567891011121314151617181920void reverse(char* str)&#123; int len = mystrlen(str); char* start = str; char* end = str + len - 1; // len-1是不包括‘\0’ char* cur = str; //整体逆转一次 reverse_string(start,end); //局部逆转 while(*cur != '\0')&#123; char* st = cur; //寻找子串的尾点 while(*cur != ' ' &amp;&amp; *cur != '\0')&#123; cur++;//cur作为一个尾点，我们去寻找cur具体到哪个位置，当为‘ ’和‘\0’之前的一个位置将它作为end，cur最开始的作为st，这样局部的前后就有了，可以交换一次。 &#125; reverse_string(st,cur-1); while(*cur == ' ')&#123; cur++;//在指针走的过程中，如果遇到了' '，则使其跳过，因为这样将不用再去将' '逆转一次。否则会有多余的步骤。 &#125; &#125;&#125; 感觉初阶到了后期难度一下就上来了。考试周结束后，还是得好好敲代码啊。]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之链表]]></title>
    <url>%2F2018%2F12%2F02%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[链表的定义链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 相比于线性表顺序结构，操作复杂。 （百度） 链表：一种链式存储的线性表，用一组地址任意的存储单元存放线性表的数据元素，称存储单元为一个结点。 链表的形式：结点地址{data，next} 链表的形式基本知道后，链表的使用离不开指针。关于指针 和 指针指向的空间 是有区别的 指针不能看成是一个地址，指针是用来存放地址的。指针指向的空间不是地址，是一个还未使用开辟出来的空间。 链表里的结构体与顺序表的结构体]]></content>
      <tags>
        <tag>C-数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初阶C-1121]]></title>
    <url>%2F2018%2F11%2F27%2F%E5%88%9D%E9%98%B6C-1121%2F</url>
    <content type="text"><![CDATA[1.写一个函数返回参数二进制中 1 的个数 ，比如：15 —&gt; 0000 1111 中4个1。 12345678910int count_one_bits(unsigned int value)&#123; int count = 0; for (int i = 0; i &lt; 32; i++)&#123; if (((value &gt;&gt; i) &amp; 1) == 1)&#123; count++; &#125; &#125; printf("%d\n", count); // 返回 1的位数 &#125; 2.获取一个数二进制序列中所有的偶数位和奇数位,分别输出二进制序列。 1234567891011121314151617int Print_col(unsigned int value)&#123; //二进制的奇偶数位是从低位0123456开始算起 int odd;//奇数 int even;//偶数 printf("偶数的序列:"); for (int i = 0; i &lt; 32; i += 2)&#123; even = (value &gt;&gt; i) &amp; 1; printf("%d ", even); &#125; printf("\n"); printf("奇数的序列:"); for (int j = 1; j &lt; 32; j += 2)&#123; odd = (value &gt;&gt; j) &amp; 1; printf("%d ", odd); &#125; return 0;&#125; 3.输出一个整数的每一位。 123456789void Print_num()&#123; printf("请输入数:"); int x; scanf("%d", &amp;x); while (x)&#123; printf("%d ", x % 10); x /= 10; &#125;&#125; 4.两个int（32位）整数m和n的二进制表达中,有多少个位(bit)不同? 输入例子: 1999 2299 输出例子:7 123456789101112void diff_bit()&#123; int m, n,num,count = 0; printf("请输入两个数:"); scanf("%d %d", &amp;m, &amp;n); num = m ^ n; for (int i = 0; i &lt; 32; i++)&#123; if (((num &gt;&gt; i) &amp; 1) == 1)&#123; count++; &#125; &#125; printf("%d", count);&#125; 在操作符总结完之后做的一些题。我个人觉得总结完之后，上手是非常容易的。]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python-对猫眼网的top100的爬取]]></title>
    <url>%2F2018%2F11%2F26%2Fpython-%E5%AF%B9%E7%8C%AB%E7%9C%BC%E7%BD%91%E7%9A%84top100%E7%9A%84%E7%88%AC%E5%8F%96%2F</url>
    <content type="text"><![CDATA[python我从今年过年开始自学，断断续续的，最近参加了一个爬虫训练营，我发现爬虫对开始学习python是非常合适的，只不过首先得具备一些HTML的知识储备，毕竟爬虫是需要解析网页的。而且爬虫实现后的成就感是非常巨大的。所以，根据上周学习的一些知识，做一个小的总结。 首先需要安装requests库和beautifulsoup库，这两个库是有函数可以对网页进行一个解析操作的。比如request中的get()。beautifulsoup中的Beautifulsoup()的使用。 安装过程首先最简单的安装就是利用cmd通过pip指令安装 12pip install requestspip install beautifulsoup4 //这里需要注意一下，后面必须有个4。 如果安装不上，那就从网上先下载好需要的安装文件，在进入该文件的目录下，进行安装。 request的使用request的请求方式有多种，因为是一个第三方库，有多种使用方法，可以在网上寻找一些使用文档参考 12345requests.get('http://www.xxxxxxxx.com')requests.post('http://www.xxxxxxxx.com')requests.delete('http://www.xxxxxxxx.com')requests.put('http://www.xxxxxxxx.com')requests.head('http://www.xxxxxxxx.com') 列举一些常用的。 get：请求指定的页面信息，并返回一个主体。使用get方式时，请求数据直接放在url中。 post：请求主要是发送一些较长的数据，数据比较安全 。使用post方式时，数据放在data或者body中，不能放在url中，放在url中将被忽略。 delete：请求服务器删除Request-URI所标识的资源。 put：向指定资源位置上传其最新内容 。 head： 向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。 request的实例首先我们要爬取的是猫眼网站的top100榜单。网址为http://maoyan.com/board/4。 这是第一页的情况，此时我们点击一个下一页，就能发现网址发现了变化。 能明显看到网址的变化是http://maoyan.com/board/4?offset={}。 不断去往下翻页，我们就能看到offset=后面这个数在不断的变化，第一页是0，到最后一页是90。 说明offset是偏移量，等于号后面的是偏移量的值 知道了这个url的规律之后，就可以来进行获取网址了。 通过get去获取一个网页信息 12345678def get_url(url): try: wb_data=requests.get(url) wb_data.raise_for_status wb_data.encoding=wb_data.apparent_encoding return wb_data.text except: return "代码段异常" 上面是单个网页去抓取。我们能发现，此时所有的html页面信息都被反馈出来了。 我们利用谷歌浏览器打开该网站，右键点击检查，我们能看到各个标签内的字符串在其中，这个时候我们就需要正则表达式将其提取出来。 1234567891011def parse_one_page(html): pattern=re.compile('&lt;dd&gt;.*?board-index.*?&gt;(.*?)&lt;/i&gt;.*?data-src="(.*?)".*?name.*?a.*?&gt;(.*?)&lt;/a&gt;.*?star.*?&gt;(.*?)&lt;/p&gt;.*?releasetime.*?&gt;(.*?)&lt;/p&gt;.*?integer.*?&gt;(.*?)&lt;/i&gt;.*?fraction.*?&gt;(.*?)&lt;/i&gt;.*?&lt;/dd&gt;',re.S) items=re.findall(pattern,html) for item in items: yield&#123; 'index':item[0], 'img':item[1], '名称':item[2], '主演':item[3].strip()[3:], '上映时间':item[4].strip()[5:] &#125; 关于正则表达式不在这里详细说了，以后我会专门写一篇总结。 yield的用法：如果一个函数包含yield关键字，这个函数就会变为一个生成器。 生成器并不会一次返回所有结果，而是每次遇到yield关键字后返回相应结果，并保留函数当前的运行状态，等待下一次的调用。所以在我们去请求网页的过程中，每寻找一次，找到相对应的标签，就将其内容爬取下来。 接下来需要对offset这个偏移量找到方法将他添加到我们的url中，并且可以循环的使用。 12345def main(offset): url='http://maoyan.com/board/4?offset=&#123;0&#125;'.format(offset) html=get_url(url) for item in get_url(html): print(item) format函数就不需要多说了，就是往其中添加字符串。这里利用一个for循环使用，这样可以循环将网页都在函数get_url中请求一次。 最后将它输出出来 123for i in range(10): main(offset=i*10) time.sleep(2) 在控制台观察，就会发现我们需要的网页信息被一个一个的提取出来了。 这里使用了一个time.sleep(2),它的作用是让请求有一定的间隔，我们都知道各个网站具有反爬虫机制，如果访问太频繁，则会被禁止访问。让2s访问一次，则可以避免这种机制。 这就是一个简单的爬取过程。接下来是更具体的一种。利用了beautifulsoup来使用 BeautifulSoup的用法‘美味汤’，是用Python写的一个HTML/XML的解析器，它可以很好的处理不规范标记并生成剖析树(parse tree)。 它提供简单又常用的导航（navigating），搜索以及修改剖析树的操作。它可以大大节省你的编程时间。 123456789//引用该库的方法不是直接import就可以，而是通过fromform bs4 import beautifulsoupsoup=BeautifulSoup(wb_data.text,'lxml')print（soup.find_all('a')）print（soup.get_text()）//以上是举例它的写法 soup 就是BeautifulSoup处理格式化后的字符串，soup.title 得到的是title标签，soup.p 得到的是文档中的第一个p标签，要想得到所有标签，得用find_all 函数。find_all 函数返回的是一个序列，可以对它进行循环，依次得到想到的东西. get_text() 是返回文本,这个对每一个BeautifulSoup处理后的对象得到的标签都是生效的。 我们在上面看到一个‘lxml’这个东西，这是解析库。在这里说明一下 解析器 使用方法 优势 劣势 python标准库 BeautifulSoup(markup,’parser’) python内置；执行速度适中；文档容错能力强 低版本pyton容错能力差 lxml HTML解析器 BeautifulSoup(markup,’lxml’) 速度快；容错能力强 需要安装lxml lxml XML解析器 BeautifulSoup(markup,’xml’) 速度快；唯一支持XML 需要安装lxml Html5lib BeautifulSoup(markup,’html5lib’) 容错性最好 速度慢；需要安装html5lib 在我们知道解析器之后，我们还要做的就是通过什么去选择标签。这里一般有四种常用选择器 选择器 作用 使用方法 节点选择器 通过节点名称嵌套选取信息 soup.div.next_sibling.ul.li.p 方法选择器 find_all()和find()函数 soup.find(name=’p’,class=’ ‘) css选择器 Select方法 body&gt;div.content&gt;ul&gt;li:nth-child(1)&gt;p Xpath 用于在xml文档中搜索元素的路径语言 /html/body/div[2]/ul/li[1]/p 当我们基本了解之后就可以使用了。 在下面的使用中，就利用select方法 我们能看到黄色的地方就是我们需要的title标签所指向的地方。 右击这个标签，点击copy—-&gt;copy selector就是利用css选择器，这之后复制出来的标签走向最后复制到select()方法中。 12345678910111213141516171819def parse_one_page(html): soup=BeautifulSoup(''.join(html),'lxml')#在这里我们是得到了R.txt的文本，但是我们不能输出，所以我们得利用print来输出 titles=soup.select('#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; div &gt; div &gt; div.movie-item-info &gt; p.name &gt; a') pics=soup.select('#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; a &gt; img.board-img') actors=soup.select('#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; div &gt; div &gt; div.movie-item-info &gt; p.star') days=soup.select('#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; div &gt; div &gt; div.movie-item-info &gt; p.releasetime') scores1=soup.select('#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; div &gt; div &gt; div.movie-item-number.score-num &gt; p &gt; i.integer') scores2=soup.select('#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; div &gt; div &gt; div.movie-item-number.score-num &gt; p &gt; i.fraction') for title,pic,actor,day,scores,scoress in zip(titles,pics,actors,days,scores1,scores2): info=&#123; 'title':title.get_text(), 'pic':pic.get('alt'), 'actor':actor.get_text(), 'day':day.get_text(), 'scores':scores.get_text()+scoress.get_text(), &#125; write_to_file(info) print(info) 在上面有一个自己定义的wirte_to_file()函数。爬取完数据后，一直放在控制台显示只能证明我们爬取成功了。所以定义函数将我们所请求到的数据放入一个文件中，可以供我们需要的时候看看。 123def write_to_file(content): with open('maoyan.text','a',encoding='utf-8') as f: f.write(json.dumps(content,ensure_ascii=False)+'\n') with open()这个函数的使用时，有四种文本可以保存，分别是text，json，csv，excel。后两种还可以利用pandas来处理统计。 完整代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445import jsonimport requestsimport timefrom bs4 import BeautifulSoupdef get_one_page(url): headers=&#123;'user-agent':'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.104 Safari/537.36 Core/1.53.2263.400 QQBrowser/9.5.10429.400'&#125; response=requests.get(url,headers=headers) if response.status_code==200: return response.text else: return Nonedata=[]def parse_one_page(html): soup=BeautifulSoup(''.join(html),'lxml')#在这里我们是得到了R.txt的文本，但是我们不能输出，所以我们得利用print来输出 titles=soup.select('#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; div &gt; div &gt; div.movie-item-info &gt; p.name &gt; a') pics=soup.select('#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; a &gt; img.board-img') actors=soup.select('#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; div &gt; div &gt; div.movie-item-info &gt; p.star') days=soup.select('#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; div &gt; div &gt; div.movie-item-info &gt; p.releasetime') scores1=soup.select('#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; div &gt; div &gt; div.movie-item-number.score-num &gt; p &gt; i.integer') scores2=soup.select('#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; div &gt; div &gt; div.movie-item-number.score-num &gt; p &gt; i.fraction') for title,pic,actor,day,scores,scoress in zip(titles,pics,actors,days,scores1,scores2): info=&#123; 'title':title.get_text(), 'pic':pic.get('alt'), 'actor':actor.get_text(), 'day':day.get_text(), 'scores':scores.get_text()+scoress.get_text(), &#125; write_to_file(info) print(info)def write_to_file(content): with open('maoyan.excel','a',encoding='utf-8') as f: f.write(json.dumps(content,ensure_ascii=False)+'\n')def main(offset): url='https://maoyan.com/board/4?offset='+str(offset) html=get_one_page(url) parse_one_page(html)for i in range(10): main(offset=i*10) time.sleep(1) 以上就是我们的爬取过程，并不算复杂，而且是比较容易爬取的！可以让你瞬间有成就感的那种！ 爬取出来的是放在字典内的，一条一条在文本文件中，观看是非常醒目的。动手试试吧！]]></content>
      <tags>
        <tag>python-爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初阶C-指针总结与坑]]></title>
    <url>%2F2018%2F11%2F25%2F%E5%88%9D%E9%98%B6C-%E6%8C%87%E9%92%88%E6%80%BB%E7%BB%93%E4%B8%8E%E5%9D%91%2F</url>
    <content type="text"><![CDATA[指针的定义在计算机科学中，指针（Pointer）是编程语言中的一个对象，利用地址，它的值直接指向（points to）存在电脑存储器中另一个地方的值。由于通过地址能找到所需的变量单元，可以说，地址指向该变量单元。因此，将地址形象化的称为“指针”。意思是通过它能找到以它为地址的内存单元。 总的来说，指针就是变量，用来存放地址的变量。（存放在指针中的值都被当成地址处理） 指针的大小在32位平台上是4个字节，在64位平台上是8个字节。 指针是存放地址才出现的，地址是为了标示一块地址空间的。 指针让地址有地方存放，指针让内存的访问更加方便。 指针和指针类型有这么一个代码 12int num = 10;p = &amp;num; 要将&amp;num保存到p中，p就是一个指针变量，它的类型是有相对应的。 123456char *pc = NULL;int *pi = NULL;short *ps = NULL;long *pl = NULL;float *pf = NULL;double *pd = NULL; 由上面的代码段可以看到，指针的定义方式就是 type + 。 也就是char\的指针存放char类型变量的地址。short*的指针存放short类型变量的地址。int*的指针存放int类型的变量的地址。 普通的指针变量，指针类型，表示指针指向的变量的类型。一个普通的指针，知道对应这个变量的房间号，以及房间的大小。 void*的使用：只知道房间号，但是不关注房间大小。 void*类型不能解引用 void*类型的指针不能和整数进行相加减 void*类型的两个指针也不能相减 然而这样一个代码 123int a = 10;char* p = &amp;a;printf("%d\n",*p); 打印的结果是多少？打印的结果还是10。但是int*和char*类型是不兼容的，但是我们在存放数据时，要考虑到大端和小端的情况，低位在低地址 p的解引用 对于char\得看它是怎么放置的。 通俗来说，int*本身有4个字节，但是非要让它char*去表示，那么只能去考虑一个字节。打印出它的第一个地址存储的数据。但这第一个地址是怎么存放数据的，我们要考虑大端与小端的情况。因为就一个 0a，可能在4个字节中，最末尾的位置，也可能是第一个位置。这都是根据机器设定的字节序来得出结果的。 这里说一下机器的字节序： 大端：低位在高地址上 小端：低位在低地址上 指针 +/- 整数首先站在上帝视角，对指针进行运算是一件非常危险的事情，这也是一个埋下大坑的开始！！ 指针的加减与普通的数字加减不太一样。 123456789101112char* p = NULL;p = p + 1;//结果为1short* p = NULL;p = p + 1;//结果为2int* p = NULL;p = p + 1;//结果为4double* p = NULL；p = p + 1;//结果为8 指针和整数+1并不是地址+1，而是跳过当前指向的元素。-1是往低地址跳过一个元素（可以说是往前跳） 指针-指针1234int arr[] = &#123;1, 2, 3, 4&#125;;int* p1 = arr;int* p2 = arr + 3;printf("%d\n",p2 - p1); 指针相减，就是指针加减整数的逆运算。指针相减就是看指针之间隔了多少个元素。 语法是允许，但是很多情况下是没有意义的。比如两个不同类型的去相减，没有什么实际的意义。除非两个指针指向了同一个连续的内存空间，此时才是有意义的。 指针的解引用解引用：”*”的作用是引用指针指向的变量值，引用其实就是引用该变量的地址，“解”就是把该地址对应的东西解开，解出来，就像打开一个包裹一样，那就是该变量的值了，所以称为“解引用”。 也就是说，解引用是返回内存地址中保存的值。 指针的类型决定了对指针解引用的时候有多大的权限。 比如：char*的指针解引用就只能访问一个字节，而int*的指针的解引用就能访问四个字节 这里补充一个const的使用。 const int* p =&gt; p 指向的内容不能修改 int const *p =&gt; p指向的内容不能修改 int* p const p =&gt; p 的指向不能修改 二级指针二级指针并没有很难理解，就是将一直指针看成一个常量，在引用一个指针。 可以类比于二维数组，它其实还是一个一维数组，只是每个元素是一个一维数组。 当我们觉得不太好理解时，可以这样 1234typedef int* int_ptrint a = 10;int_ptr p = &amp;a;int_ptr* pp = &amp;p; 将int*定义成一个变量来代替，这样我们看着就比较方便了。 指针和数组名指针和数组名往往是可以相互转化的。 12int arr[] = &#123;1,2,3,4&#125;int* p = arr + 1; 此时的含义是，数组的首地址元素+1，跳过这个当前指向的元素，此时*p为2。 &amp;arr =&gt; 数组指针：是一个指针，指向一个数组的指针。 指针数组 vs 数组指针 123456int a[] = &#123; 1, 2, 3, 4&#125;;printf("%p\n",a);//指向的intprintf("%p\n",&amp;a);//得出的地址是一样的，改变一下printf("%p\n",&amp;a + 1);//这直接跳过了整个数组，指向了整个数组 1int* a[] = &#123; 0 &#125;;//每个元素是一个指针 指针的大坑第一组 12345678910int a[] = &#123; 1, 2, 3, 4&#125;;printf("%d\n",sizeof(a));//数组的大小，16printf("%d\n",sizeof(a + 0));//a此时变成了指针，4（32位系统下）printf("%d\n",sizeof(*a));//a变成首元素的指针，得到了一个整数，4printf("%d\n",sizeof(a + 1));//a此时变成了指针，4printf("%d\n",sizeof(a[1]));//第二个元素的大小，4printf("%d\n",sizeof(&amp;a));//此时是数组指针，指针就一定占4个字节！printf("%d\n",sizeof(*&amp;a));//此时先位数组指针，指向整个数组，每个数组内元素解引用，还原数组，16printf("%d\n",sizeof(&amp;a + 1));//数组指针+1还是数组指针，还是为4printf("%d\n",sizeof(&amp;a[0]));//a[0]取元素，整数，取完地址为int*，还是为4 第二组 12345678910111213141516char a[] = &#123; 'a', 'b', 'c', 'd', 'e', 'f'&#125;;printf("%d\n",sizeof(a));//类型为char型，占1个字节，共6个printf("%d\n",sizeof(a + 0));//变成指针，4printf("%d\n",sizeof(*a));//转成指针，解引用，得到是字符a，1printf("%d\n",sizeof(a[1]));//1printf("%d\n",sizeof(&amp;a));//数组指针，4printf("%d\n",sizeof(&amp;a + 1));//还是4，数组指针+1还是指针printf("%d\n",sizeof(&amp;a[0] + 1));//char* 还是一个指针printf("%d\n",strlen(a));// strlen从当前位置找到\0，如果找不到则越界，那么就是未定义行为printf("%d\n",strlen(a + 0));//strlen()函数都当成char*指针来处理，数组中没有\0，依然是未定义行为printf("%d\n",strlen(*a));//得到一个字符，不能放到char*里，间接级别不同，所以依然是未定义行为printf("%d\n",strlen(a[1]));//得到一个字符，都是未定义i行为printf("%d\n",strlen(&amp;a));//依然是个未定义行为printf("%d\n",strlen(&amp;a + 1));//未定义行为printf("%d\n",strlen(&amp;a[0] + 1));//未定义行为 第三组 12345678910111213141516char* p = 'abcdef';printf("%d\n",sizeof(p));//只要是指针，4个字节printf("%d\n",sizeof(p + 1));//还是指针，4个字节printf("%d\n",sizeof(*p));//解引用，char类型，得到a，1个字节printf("%d\n",sizeof(p[0]));//等价与*p，1printf("%d\n",sizeof(&amp;p));//指针取地址，就是二级指针，4printf("%d\n",sizeof(&amp;p + 1));//二级指针，4printf("%d\n",sizeof(&amp;p[0]));//a取地址，就是指向a的指针，+1就是指向b的指针，还是4printf("%d\n",strlen(p));//6，‘\0’不取，strlen()不算在其长度中printf("%d\n",strlen(p + 1));//5,p指向a，p+1指向b，从b开始到结束，只占了5个printf("%d\n",strlen(*p));//得到是一个字符，不能用strlen(),未定义行为printf("%d\n",strlen(p[0]));//未定义行为printf("%d\n",strlen(&amp;p));//二级指针不能进行，还是未定义行为printf("%d\n",strlen(&amp;p + 1));//未定义行为printf("%d\n",strlen(&amp;p[0] + 1));//a的指针，+1为b的指针，此时从b到结束，5 第四组12345678910111213141516char a[] = "abcdef";printf("%d\n",sizeof(a));//7,还有'\0'得算上，strlen()到\0结束，不计算入内printf("%d\n",sizeof(a + 0));//此时变为了指针，4printf("%d\n",sizeof(*a));//解引用得到字符a，1printf("%d\n",sizeof(a[1]));//1printf("%d\n",sizeof(&amp;a));//还是4，数组指针printf("%d\n",sizeof(&amp;a + 1));//4，还是数组指针printf("%d\n",sizeof(&amp;a[0] + 1));//是一个char*指针，4printf("%d\n",strlen(a));//6，不计算\0printf("%d\n",strlen(a + 0));//还是指向首元素的地址，6printf("%d\n",strlen(*a));//解引用得到字符，未定义printf("%d\n",strlen(a[1]));//未定义行为printf("%d\n",strlen(&amp;a));//数组名取地址，变为数组指针，得到的是首元素地址，依次往后去找。得到的还是6printf("%d\n",strlen(&amp;a + 1));//数组指针+1跳出整个数组了，找不到\0了，未定义行为printf("%d\n",strlen(&amp;a[0] + 1));//指向b，直到\0，为5 第五组123456789101112int a[3][4] = &#123; 0 &#125;;printf("%d\n",sizeof(a));//3*4*4=48printf("%d\n",sizeof(a[0][0]));//4printf("%d\n",sizeof(a[0]));//16,第一行printf("%d\n",sizeof(a[0] + 1));//4，数组指针，指针就是4printf("%d\n",sizeof(*(a[0] + 1)));//*(p + 1) =&gt; p[1],还是指针，即a[0][1] + 1,解引用，为4printf("%d\n",sizeof(a + 1));//变为指针，还是为4printf("%d\n",sizeof(*(a + 1));//*(a + 1) =&gt; a[1],所以数组为第二行,16printf("%d\n",sizeof(&amp;a[0] + 1));//得到为数组指针，+1还是数组指针，4printf("%d\n",sizeof(*(&amp;a[0] + 1)));//数组a[0]，&amp;为数组指针，在+1跳到第二个元素，在解引用为a[1]，16printf("%d\n",sizeof(*a));//*a =&gt; a[0] ,16printf("%d\n",sizeof(a[3]));//下标越界，sizeof在编译过程中得到类型，长度为4个元素的数组。 这些大坑多种形式，真的需要没事就看看，指针在C中是一个很重要的工具，在之前的静态顺序表中已经出现过，在链表中还出现了二级指针，所以需要多理解，多思考！]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初阶C-1117]]></title>
    <url>%2F2018%2F11%2F23%2F%E5%88%9D%E9%98%B6C-1117%2F</url>
    <content type="text"><![CDATA[1、有5位运动员参加了10米台跳水比赛，有人让他们预测比赛结果 A选手说：B第二，我第三； B选手说：我第二，E第四； C选手说：我第一，D第二； D选手说：C最后，我第三； E选手说：我第四，A第一； 比赛结束后，每位选手都说对了一半，请编程确定比赛的名次。 这道题我们一般的思维是直接根据一个条件的真假性，然后去依次判断下去。但是在C语言中不可以那么想。你不能去想当然的去判断。所以我们得设置条件，去不断的循环，然后判断出结果。 1234567891011121314151617181920212223242526void Guess()&#123; for(int a = 1;a &lt;= 5;a++)&#123; for(int b = 1;b &lt;= 5;b++)&#123; for(int c = 1;c &lt;= 5;c++)&#123; for(int d = 1;d &lt;= 5;d++)&#123; for(int e = 1;e &lt;= 5;e++)&#123; //排名无非就是12345，全部走一遍，当满足条件时，就判断下一个条件，直到满足时 if ((2 == b &amp;&amp; 3 != a) || (2 != b &amp;&amp; 3 == a) == 1)&#123; if ((2 == b &amp;&amp; 4 != e) || (2 != b &amp;&amp; 4 == e) == 1)&#123; if ((1 == c &amp;&amp; 2 != d) || (1 != c &amp;&amp; 2 == d) == 1)&#123; if ((5 == c &amp;&amp; 3 != d) || (5 != c &amp;&amp; 3 == d) == 1)&#123; if ((4 == e &amp;&amp; 1 != a) || (4 != e &amp;&amp; 1 == a) == 1)&#123; if (a*b*c*d*e == 120)&#123; printf("a=%d b=%d c=%d d=%d e=%d\n", a, b, c, d, e); &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125; 2、日本某地发生了一件谋杀案，警察通过排查确定杀人凶手必为4个嫌疑犯的一个。以下为4个嫌疑犯的供词 A说：不是我。 B说：是C。 C说：是D。 D说：C在胡说 已知3个人说了真话，1个人说的是假话。 现在请根据这些信息，写一个程序来确定到底谁是凶手。 这个与上面的思想是一样的，我们需要设置一个常量，将它作为凶手的标志。 我在里面设置2为凶手的标志 123456789101112131415161718192021void Guesspeople()&#123; for (int a = 1; a &lt;= 4; a++)&#123; for (int b = 1; b &lt;= 4; b++)&#123; for (int c = 1; c &lt;= 4; c++)&#123; for (int d = 1; d &lt;= 4; d++)&#123; if ((a != 2 &amp;&amp; c == 2 &amp;&amp; d == 2) || (d != 2) == 1)&#123; if ((a != 2 &amp;&amp; c == 2 &amp;&amp; d != 2) || (d == 2) == 1)&#123; if ((a != 2 &amp;&amp; c != 2 &amp;&amp; d == 2) || (d != 2) == 1)&#123; if ((a == 2 &amp;&amp; c == 2 &amp;&amp; d == 2) || (d != 2) == 1)&#123; if (a != b&amp;&amp;a != c&amp;&amp;a != d&amp;&amp;b != c&amp;&amp;b != d&amp;&amp;c != d)&#123; printf("a=%d,b=%d,c=%d,d=%d\n", a, b, c, d); &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125; &#125;&#125; 打印输出之后可以发现，C的值全部为2，那么说明C一定就是凶手。 3、在屏幕上打印杨辉三角 杨辉三角的规律有很多，其中有一个，每个数等于上方两数之和。 12345678910111213141516171819#define N 10 //定义一个二维数组void triangle()&#123; int arr[N][N]=&#123;0&#125;;//先全部初始化为0 int i, j, k; for(i = 0;i &lt; N;i++)&#123; for(j = 0;j &lt; N-i;j++)&#123; printf(" "); for(k = 0;k &lt;= i;k++)&#123; if(k == 0||k == i)&#123; arr[i][k] = 1; &#125;else&#123; arr[i][k] = arr[i-1][k] + arr[i-1][k-1]; &#125; &#125; printf("%4d",arr[i][k]); &#125; printf("\n"); &#125;&#125;]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初阶C-操作符总结]]></title>
    <url>%2F2018%2F11%2F21%2F%E5%88%9D%E9%98%B6C-%E6%93%8D%E4%BD%9C%E7%AC%A6%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[C语言操作符是构成C语言表达式的工具，是说明特别操作的符号。 操作符的类型算术操作符1+ - * / % 除了%操作符之外，其他均可以作用于整数和浮点数。 对于/操作符，如果是整数，执行整数除法，如果是浮点数，则执行浮点数除法 %操作符的两个操作符必须是整数，返回的是整除之后的余数。 移位操作符1&lt;&lt;左移操作符 &gt;&gt;右移操作符 左移位规则：左边抛弃，右边补0 右移位规则：这又分为两种，分别是逻辑移位和算术移位 逻辑移位 是左边用0填充，右边丢弃 算术移位 是左边用原该值的符号位填充，右边丢弃 例如：求一个整数存储在内存中的二进制中1的个数 1234567891011#include&lt;stdio.h&gt;void erjinzhi(int num)&#123; int count = 0; while (num)&#123; if (num % 2 == 1) count++; num = num / 2; &#125; printf("二进制中1的个数 = %d ", count); return 0;&#125; 从这个程序里中，我们就可以测出，每个数在二进制中1的个数。但是我们，如果输入负数，我们会发现，我们的程序，是有问题的。如果输入了-10，那么-10之前的所有0都要取反，这个时候我们将出来许多的1。 所以我们进行一个改正 12345678910#include&lt;stdio&gt;void erjingzhi(int num)&#123; int i = 0; int count = 0; for (i = 0; i &lt; 32; i++)&#123; if (((num &gt;&gt; i) &amp; 1) == 1) count++; &#125; printf("二进制中1的个数 = %d\n", count);&#125; 我们利用移位的方法去一个一个来计算。 这里添加一个二进制负数的转化过程，可以更好的理解。 Ps:注意我们的移位不要移动负数位，这个是标准未定义的。 位操作符位操作符有三种分别是：按位与，按位或，按位异或 1&amp; | ^ 它们的操作数必须是整数。 按位与：对两个数进行操作，然后返回一个新的数，这个数的每个位都需要两个输入数的同一位都为1时才为1. 按位或：比较两个数，然后返回一个新的数，这个数的每一位设置1的条件是两个输入数的同一位都不为0。即任意一个为1，或者都为1。否则为0。 按位异或：比较两个数，然后返回一个数，这个数的每个位设为1的条件是两个输入数的同一位不同，如果相同就设为0。即相同为0，不同为1。 赋值操作符赋值操作符是一个很好用的操作符，你可以将你的变量设置成你需要的值。用 “=” 即可。 复合赋值操作符 += 加等 -= 减等 *= 乘等 /= 除等 %= 取模等 &gt;&gt;= 右移位等于 &lt;&lt;= 左移位等于 &amp;= 按位与等于 \ = 按位或等于 ^= 按位取反等于 单目操作符 ！ 逻辑反操作 - 取负数 + 取正数 &amp; 取地址 sizeof 操作数的类型长度 ~ 对一个数的二进制按位取反 – 减减，类似累减 ++ 加加，类似累加 * 间接访问操作符 逻辑操作符逻辑操作符有 12&amp;&amp; 逻辑与|| 逻辑或 它们与按位与和按位或之间的区别 1&amp;2 —–&gt;0 1&amp;&amp;2 ——-&gt;1 1|2 ——&gt;3 1||2 —–&gt;1 逻辑与还有逻辑或，此时是判断它的真假性。要记住，非0为真。这是一个关键。 1234567#include&lt;stdio.h&gt;int main()&#123; int i= 0,a=0,b=2,c=3,d=4; i= a++&amp;&amp;++b&amp;&amp;d++; printf("a= %d\n b=%d\n c=%d\n d=%d\n",a,b,c,d); return 0;&#125; 输出后，abcd分别位1234。根据我们的猜测，这里可能是为135这样。但是这里有个坑。 这里存在一个短路求值的知识点。a=0这就代表了假。那么 a++——&gt;0。也就是说在这里是先返回，后++ 短路求值：如果是&amp;&amp;左侧表达式为假的时候，右侧表达式不会求值 ​ 如果是||左侧表达式为真的时候，右侧表达式不会求值 条件操作符1exp1 ? exp2 : exp3 这是C语言中唯一的一个二目运算符，运算级非常低。 逗号表达式1exp1,exp2,exp3....expN 就是用逗号隔开的多个表达式。从左向右依次执行。 表达式求值隐式类型转换C的整型算术运算总是至少以缺省整型类型的精度来进行的。为了获得这个精度，表达式中的字符和短整型操作数在使用之前被转化为普通类型，这种转换称为——整形提升。 123char a,b,c;...a = b + c; b和c的值被提升为普通整型，然后再执行加法运算。 加法运算完成之后，结果将被截断，然后再存储于a中。 算法运算中，a隐式转换为int。 凡是针对char/short，此时都隐式转换成int。 操作符的属性复杂表达式的求值有三个影响的因素： ​ 1.操作符的优先级 ​ 2.操作符的结合性 ​ 3.是否控制求值的顺序 以上就是操作符的基本了，目前是我能知道并且掌握的，当以后有了其他的之后，再慢慢的添加进去。]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C初阶-扫雷]]></title>
    <url>%2F2018%2F11%2F18%2FC%E5%88%9D%E9%98%B6-%E6%89%AB%E9%9B%B7%2F</url>
    <content type="text"><![CDATA[上次完成了三子棋的做法，利用了二维数组。扫雷也是一样，需要我们利用二维数组去完成。扫雷有所不同的地方在于，我们需要两个二维数组。一个用来展示棋盘，另外一个用于展示我们的下雷过程，因为每一个点击有可能是雷或者不是雷。 关于扫雷的编程思想我们与三子棋相比是有一些不同的地方。但归途同属，我们只需要想清楚每一个步骤就可以。 还是先创建一个工程，并且我还是习惯于一个头文件定义函数，一个源文件测试。 我们首先设置一个选择功能，让我们在看的时候，比较美观。毕竟好看的事务会给别人留下的印象也比较深。 123456789101112131415161718192021222324#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;void Start()&#123; int choice == Menu(); while(1)&#123; if(choice == 0)&#123; break; &#125; Game(); &#125;&#125;int Menu()&#123; printf("====================\n"); printf(" 1.开始游戏\n"); printf(" 2.退出游戏\n"); printf("====================\n"); int choice = 0; scanf("%d",&amp;choice); return choice;&#125; 基本开始样式就ok了。之后我们开始需要对每个关键步骤写代码了。 我们先想象一下扫雷的规则与步骤。 1.我们首先得有一个地图的样式，然后初始化它最初的样子 2.打印这个棋盘。（这两步与三子棋的思路比较像） 3.进行点击，之后判断点击的情况。 4.判定是否踩雷，如果踩雷，GG。 5.如果没踩雷，判定是否掀开了所有格子。 6.如果没有掀开所有格子。那么更新周围有几个雷。显示到地图上。 3-6这是一个循环的过程，所以我们将用while来判断什么时候胜利或者失败。 1234567891011121314151617181920212223242526272829303132333435363738394041424344#define MAX_ROW 10#define MAX_COL 10#define DEFAULT_LEIZI_COUNT 10void Game()&#123; char show_map[MAX_ROW + 2][MAX_COL + 2]; char mine_map[MAX_ROW + 2][MAX_COL + 2]; Init_map(); Print_map(); while(1)&#123; int count = 0; int row,col; printf("请输入坐标，例如1 2\n")； scanf("%d",&amp;row,&amp;col); if(row &lt;= 0 || row &gt; MAX_ROW || col &lt;= 0 || col &gt; MAX_COL)&#123; printf("请重新输入坐标\n"); continue; &#125; if(mine_map[row][col] == '1')&#123; printf("游戏结束，此处有雷\n"); Print_map(); break; &#125; if (count==DEFAULT_LEIZI_COUNT + 1)&#123; printf("扫雷成功\n"); Print_map(mine_map); break; &#125; for (int i = 1; i &lt;= MAX_ROW; i++)&#123; for (int j = 1; j &lt;= MAX_COL; j++)&#123; if (show_map[i][j] == '*')&#123; count++; &#125; &#125; &#125; if (count == DEFAULT_LEIZI_COUNT)&#123; printf("扫雷成功\n"); Print_map(mine_map); break; &#125; Updateshowmap(); Showaround(); Print_map(); &#125;&#125; 这就是上面描述的一个基本的流程。也就是扫雷对输赢的判断规则。接着对每一个函数去完善。函数内参数我是没有直接添加进去的。我是都定义完成之后，才慢慢添加进去的。 首先是对我们地图的一个初始化 1234567891011121314151617181920212223242526void Init_map(char show_map[MAX_ROW + 2][MAX_COL + 2]; char mine_map[MAX_ROW + 2][MAX_COL + 2])&#123; //在这里就要解释一下，我们为什么要加上一个2了。因为我们要保证我们需要一个边框 //大多数人的潜意识中喜欢输入都是1 1，这样我们定义一个边框，我们就可以将其上下包围这些地图 //那么这个地图将是从1 1到 10 10的所有点了。 for(int row = 0;row &lt; MAX_ROW;row++)&#123; for(int col = 0;col &lt;MAX_COL;col++)&#123; show_map[row][col] = '*'; &#125; &#125; for(int row = 0;row &lt; MAX_ROW;row++)&#123; for(int col = 0;col &lt;MAX_COL;col++)&#123; mine_map[row][col] = '*'; &#125; &#125; int mine_count = DEFAULT_LEIZI_COUNT; while(mine_count &gt; 0)&#123; int row = rand() % 10 + 1; int col = rand() % 10 + 1; if(mine[row][col] == '1')&#123; continue; &#125; mine[row][col] = '1'; mine_count--; &#125;&#125; 初始化完成之后，我们开始打印地图 123456789101112131415161718void Print_map((char map[MAX_ROW + 2][MAX_COL + 2],int row,int col)&#123; printf(" "); for(int i = 1;i &lt; MAX_ROW + 2;i++)&#123; printf("%d ",row); &#125; printf("\n"); for(int i = 1;i &lt; MAX_ROW +2 ;i++)&#123; printf("---\n"); &#125; for(int row = 1;row &lt; MAX_ROW + 2;row++)&#123; printf("%02d |\n",row); for(int col = 1;col &lt; MAX_COL + 2;col++)&#123; printf("%c ",map[row][col]); &#125; printf("\n"); &#125; &#125; 打印完地图之后，就是扫雷中最关键的一个部分了。判断周围雷的个数，然后将它打印到地图中。 12345678910111213void Updateshowmap(char show_map[MAX_ROW + 2][MAX_COL + 2]; char mine_map[MAX_ROW + 2][MAX_COL + 2],int row,int col)&#123; int leizi_num = (mine_map[row][col + 1] - '0')+ (mine_map[row][col - 1] - '0')+ (mine_map[row + 1][col + 1] - '0')+ (mine_map[row + 1][col] - '0')+ (mine_map[row + 1][col - 1] - '0')+ (mine_map[row - 1][col + 1] - '0')+ (mine_map[row - 1][col] - '0')+ (mine_map[row - 1][col - 1] - '0'); show_map[row][col] = leizi_num + '0'; return show_map[row][col];&#125; 在这里我是将周围八个格子是否有雷的情况统计下来，然后将其赋给中间的格子，这样我们就可以知道周围有几个雷了。 我们都知道扫雷的规则，当你点开一部分后，如果周围没雷的话，我们就将会点开空白区域。所以我们要写一个递归来去不断的调用。 123456789101112131415161718192021222324252627282930313233void Showaround(char show_map[MAX_ROW + 2][MAX_COL + 2], char mine_map[MAX_ROW + 2][MAX_COL + 2], int row, int col)&#123; if (mine_map[row][col] == '0' &amp;&amp; show_map[row][col] == '*')&#123; show_map[row][col] = Updateshowmap(show_map, mine_map, row, col); &#125; if (mine_map[row][col - 1] == '0' &amp;&amp; show_map[row][col - 1]=='*')&#123; show_map[row][col - 1] = Updateshowmap(show_map, mine_map, row, col - 1); if (Updateshowmap(show_map, mine_map, row, col) == '0')&#123; Showaround(show_map, mine_map, row, col - 1); &#125; &#125; if (mine_map[row + 1][col] == '0' &amp;&amp; show_map[row + 1][col] == '*')&#123; show_map[row + 1][col] = Updateshowmap(show_map, mine_map, row + 1, col); if (Updateshowmap(show_map, mine_map, row + 1, col) == '0')&#123; Showaround(show_map, mine_map, row + 1, col); &#125; &#125; if (mine_map[row - 1][col] == '0' &amp;&amp; show_map[row - 1][col] == '*')&#123; show_map[row - 1][col] = Updateshowmap(show_map, mine_map, row - 1, col); if (Updateshowmap(show_map, mine_map, row - 1, col) == '0')&#123; Showaround(show_map, mine_map, row - 1, col); &#125; &#125; if (mine_map[row][col + 1] == '0' &amp;&amp; show_map[row][col + 1] == '*')&#123; show_map[row][col + 1] = Updateshowmap(show_map, mine_map, row, col + 1); if (Updateshowmap(show_map, mine_map, row, col + 1) == '0')&#123; Showaround(show_map, mine_map, row, col + 1); &#125; &#125;&#125; 我觉得扫雷对周围的判断是根据上下左右来进行的。如果周围没雷，那么它就是相当于空白的。当分成八个方向去判断时，那么就将产生一键排雷的这种奇葩操作。 最后就是一个源文件了。将Start（）放入测试即可。但是不要忘了随机种子，否则扫雷的布置雷数是没有变化的。]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之动态顺序表]]></title>
    <url>%2F2018%2F11%2F15%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%8A%A8%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[动态顺序表动态顺序表是跟静态顺序表大体相似，有些地方是不同的，动态顺序表是在动态变化中，当我们的所需的内存不够时，它会自动开辟一个我们需要的空间，来供我们使用。 动态顺序表与静态顺序表的不同在于初始化/销毁/所有插入，其他和静态顺序表完全一样。 定义一个结构体先将我们需要的都定义好 12345678910111213141516#pragma once#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;assert.h&gt;#include&lt;string.h&gt;//为了观看方便先写在开头，正常应该需要什么去使用什么typedef int DataType;#define INIT_CAPACITY(3)//定义一个动态的初始化空间容量为3typedef struct SeqListD&#123; DataType* parray; int capacity; int size;&#125; 在结构体的定义中，静态与动态的定义是不同的。静态的是直接定义了一个空间是有范围确定的数组。但是动态不同，动态定义的是一个指针，在这里面存储的范围是不确定的，当我们定义了一个当前我们认为足够大的空间时，它是在一个计算机给我们的随机地址中。当我们需要更大的空间时，我们将申请新空间，这个时候我们将数据转移，先将所有数据转移到新的空间，之后我们将旧的空间释放掉。这个时候空间是新开辟的一段空间，但是我们的地址是计算机重新分配的一段新地址。 初始化12345678void SeqListInit(SeqListD *pSeq)&#123; pSeq-&gt;capacity = INIT_CAPACITY;//当前容量我们都先设置为3，每当我们不够时， //我们就调用其他函数去扩充它 pSeq-&gt;parray = (DataType *)malloc(sizeof(DataType)*pSeq-&gt;capacity);//我们的数组利用malloc函数 //类型 //4*3 assert(pSeq-&gt;parray);//判断我的指针是否正常 pSeq-&gt;size = 0;&#125; malloc(): malloc的全称是memory allocation，中文叫动态内存分配，用于申请一块连续的指定大小的内存块区域以void*类型返回分配的内存区域地址，当无法知道内存具体位置的时候，想要绑定真正的内存空间，就需要用到动态的分配内存。 一般需和free函数配对使用。 销毁12345678void SeqListDestory(SeqListD *pSeq)&#123; free(pSeq-&gt;parray); //将它释放掉 pSeq-&gt;capacity = 0; pSeq-&gt;size = 0; pSeq-&gt;parry = NULL; //所有一切还原&#125; 插入1234567void SeqListPushBack(SeqListD *pSeq,DataType data)&#123; //静态：如果满了，不处理/报错 //动态：加入扩容机制 ExpandIfRequired(pSeq);//每次都需要去判断是否达到条件可以实现 pSeq-&gt;parray[pSeq-&gt;size] = data;// pSeq-&gt;size++;&#125; 判断是否需要扩大1234567891011121314151617static void ExpandIfRequired(SeqListD *pSeq)&#123; if(pSeq-&gt;size &lt; pSeq-&gt;capacity)&#123; return;//还没满 &#125; //扩容 pSeq-&gt;capacity *= 2; //开辟新空间 DataType *newArray = (DataType *)malloc(sizeof(DataType)*pSeq-&gt;capacity); assert(newArray); //数据搬移 for(int i = 0;i &lt; pSeq-&gt;size；i++)&#123; newArray[i] = pSeq-&gt;parray[i]; &#125; //释放老空间，申请的新空间与动态顺序表关联起来 free(pSeq-&gt;parray); pSeq-&gt;parray = newArray;&#125; 同理，所有插入都需要加入扩容机制 其他的操作与静态顺序表的操作是相近的。可以参考我之前的对照着看。 数据结构重新在学！如有不对，请cue我！]]></content>
      <tags>
        <tag>C-数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C初阶-三子棋]]></title>
    <url>%2F2018%2F11%2F12%2FC%E5%88%9D%E9%98%B6-%E4%B8%89%E5%AD%90%E6%A3%8B%2F</url>
    <content type="text"><![CDATA[今天试着独自完成三子棋，经过一个小时多…才完成。真的太菜了！！！ 但是一个简单的三子棋确实能建立一些基本的编程思想。其中让我迷糊的是和棋那里。接下来我来代码分析说明。 首先我们编程一个项目时，我们要明白我们的基本构想是什么。那么三子棋的思想有这么几点。 三子棋的规则三子棋是在一个3x3的表格之中，如果在行列斜只要有三个相同的棋子，那么就将获胜。如果棋盘满了之后，但没有相同的，则算和棋。先手是具有一定的优势的。 三子棋的编程思想我们要将我们的操作步骤与实际相比较起来 1.初始化棋盘 2.展示棋盘的过程。我们得时刻了解到，此时的下子情况 3.玩家落子，进行判断，是否赢得了胜利 4.电脑落子，进行判断，是否赢得了胜利，如果没有分出，重复第2步 5.还未判断是否分出胜负，对其判断是否和棋。 三子棋的代码过程首先我用的是VS2013，只定义了一个头文件和一个源文件。 头文件的初定义12345678#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;time.h&gt;#define ROWS 3#define COLS 3char qipan[ROWS][COLS]; 首先我们定义头文件，不过在此处我觉得并不需要一上来就定义，我们最后需要什么，我们去定义它。 但是宏最开始我们需要定义好，因为是二维数组。棋盘的大小我们要先设定好，并对其声明。 数组初始化1234567void Init(char qipan[ROWS][COLS],int row,int col)&#123; for (int row = 0; row &lt; ROWS; ++row)&#123; for (int col = 0; col &lt; COLS; ++col)&#123; qipan[row][col] = ' '; &#125; &#125;&#125; 展示棋盘123456789void Show_qipan(char qipan[ROWS][COLS], int row, int col)&#123; for (int i = 0; i &lt; row; ++i)&#123; printf("| %c | %c | %c |\n", qipan[i][0], qipan[i][1], qipan[i][2]); if (i != row - 1)&#123; printf("|---|---|---|\n"); &#125; &#125;&#125; 玩家落子1234567891011121314151617void Playmove(char qipan[ROWS][COLS], int row, int col)&#123; printf("请玩家下子\n"); while (1)&#123; printf("例如输入的格式为0,0\n"); scanf("%d,%d", &amp;row, &amp;col); if (row &lt; 0 || row &gt;= ROWS || col &lt; 0 || col &gt;= COLS)&#123; printf("输入有误，请重新输入\n"); continue; &#125; else if (qipan[row][col] != ' ')&#123; printf("该处已经下过子了，请重新输入\n"); continue; &#125; qipan[row][col] = 'x'; break; &#125;&#125; 电脑落子12345678910111213void Computermove(char qipan[ROWS][COLS], int row, int col)&#123; printf("请电脑下子\n"); while (1)&#123; row = rand() % ROWS; col = rand() % COLS; if (qipan[row][col] != ' ')&#123; printf("该处已有棋子，请重新填入\n"); continue; &#125; qipan[row][col] = 'O'; break; &#125;&#125; 和棋判断条件1234567891011static int Show_full(char qipan[ROWS][COLS], int row, int col)&#123; int i, j; for (i = 0; i &lt; row; i++)&#123; for (j = 0; j &lt; col; j++)&#123; if (qipan[i][j] == ' ')&#123; return 0; &#125; &#125; &#125; return 1;&#125; 判断胜负123456789101112131415161718192021222324252627282930char CheckWinner(char qipan[ROWS][COLS], int row, int col)&#123; //判断行 for (int col = 0; col &lt; COLS; col++)&#123; if (qipan[0][col] == qipan[1][col] &amp;&amp; qipan[0][col] == qipan[2][col] &amp;&amp; qipan[0][col] != ' ')&#123; return qipan[0][col]; &#125; &#125; //判断列 for (int row = 0; row &lt; ROWS; row++)&#123; if (qipan[row][0] == qipan[row][1] &amp;&amp; qipan[row][0] == qipan[row][2] &amp;&amp; qipan[row][0] != ' ')&#123; return qipan[row][0]; &#125; &#125; //判断斜 if (qipan[0][0] == qipan[1][1] &amp;&amp; qipan[0][0] == qipan[2][2] &amp;&amp; qipan[0][0] != ' ')&#123; return qipan[0][0]; &#125; else if (qipan[2][0] == qipan[1][1] &amp;&amp; qipan[2][0] == qipan[0][2] &amp;&amp; qipan[2][0] != ' ')&#123; return qipan[2][0]; &#125; //判断和棋 else if (Show_full(qipan,row,col))&#123; return 'q'; &#125; return ' ';&#125; 代码比较容易理解，但是我们也有几个必须注意的地方。 首先，定义的每个函数中，参数不能忘，对其中添加数组，行，列三个。因为我们对输入值后，要把每个值传入函数中，让其进行判断。所以这是一个关键。 其次是和棋的判断，在返回值为0与1的意思是假与真（估计大家都知道），但是关键在于CheckWinner()中，我们要知道判断结束后要有返回值。我们之前设置初始化的数组值是‘ ’。接着我们可以在源文件中进行判断。 源文件的代码12345678910111213141516171819202122232425262728293031323334353637#include"chess.h"int main()&#123; srand((unsigned int)time(NULL)); Init(qipan, ROWS, COLS); Choice(); char winner; int a; scanf("%d", &amp;a); switch (a)&#123; case 1: while (1)&#123; Show_qipan(qipan, ROWS, COLS); Playmove(qipan, ROWS, COLS); Show_qipan(qipan, ROWS, COLS); winner = CheckWinner(qipan, ROWS, COLS); if (winner != ' ')&#123; break; &#125; Computermove(qipan, ROWS, COLS); winner = CheckWinner(qipan, ROWS, COLS); &#125; if (winner == 'x')&#123; printf("你赢了！\n"); &#125; else if (winner == 'o')&#123; printf("电脑赢了！\n"); &#125; else if (winner == 'q')&#123; printf("五五开！真厉害！\n"); &#125; case 2: system("exit"); &#125; system("pause"); return 0;&#125; 看了winner的值你就可以看出来，如果之前返回的不是‘ ’，那么winner将直接跳出循环。 在其中我还添加了一个switch语句增加一些选择来让程序更生动点。下图实例： 大家如果有什么想法，还可以自己往里面添加！ 加油！会越来越强的！]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之静态顺序表]]></title>
    <url>%2F2018%2F11%2F09%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%9D%99%E6%80%81%E9%A1%BA%E5%BA%8F%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[静态顺序表属于数据结构开始的一种基本结构首先我们要知道数据结构的概念 数据结构 数据的组织关系 算法 为了达到特定的目的的一系列过程。在这个过程中又分为两种角度1） 逻辑角度：线性结构，树形结构，图形结构2） 存储角度：顺序存储，链式存储 在线性结构中顺序存储的方式，在本次中为顺序表，分为静态和动态而静态顺序表的理解可以分为1） 结构体定义（定义、背后的内存布局模型）2） 顺序表的基本操作：插/删/查/改。重点需要去掌握的是插和删。插（头插/尾插/插入），删（头删/尾删/删除）接下来开始对于整个代码进行一个分析。 123456789101112#pragma once#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt; //一般不着急于先定义一堆，你需要什么在去定义什么。typedef int DataType; //为现有类型创建别名。用DataType来代替int。#define MAX_SIZE(100) //开出一块空间，占用内存的最大位置。typedef struct SeqList&#123; //定义结构体的别名 DataType array[MAX_SIZE]; int size;&#125;SeqList; //变量名 当把结构体都定义好了之后，我们开始先进行两个基本操作，对数组进行初始化和销毁此时我们要用到assert()。在开头首先要定义这个宏#include&lt;assert.h&gt;,他的功能就是测试一个条件可能使程序终止。用法void assert(int test)在初始过程中，可能需要把内存清空一下，所以我们可能需要memset()这个函数。这个函数的用法void memset(void s, int ch, size_t n);将s所指向的某一块内存中的后n个 字节的内容全部设置为ch指定的ASCII值，第一个值为指定的内存地址，块的大小由第三个参数指定，这个函数通常为新申请的内存做初始化工作，其返回值为s。 123456789101112//初始化void SeqListInit(Seqlist *pSeq)&#123; //初始化size assert(pSeq != NULL); pSep-&gt;size = 0; memset(pSep-&gt;array,0,SIZE_MAX * sizeof(DataType));&#125;//销毁void SeqListDestory(SeqList *pSeq)&#123; assert(pSeq); pSeq-&gt;size = 0;&#125; 我们还需要部署一个测试函数，先暂时定义一下，当增删改查部署完后，可以往其中添加增删改查的函数来进行实验。 插入：有头插，尾插，插入头插的使用PS：考虑完了普通情况后，我们要考虑的是特殊情况，当size超过了定义的最大尺寸情况，我们需要进行一个判断， 123456789101112131415161718void SeqListPushTop(SeqList *pSeq,DataType data)&#123; assert(pSeq); if(pSeq-&gt;size &gt;= MAX_SIZE)&#123; printf("满了\n"); assert(0); return; &#125; //从最后开始向每一个后面开始搬运，如果不这么做，将会将每一次的值覆盖掉 for(int i = pSeq-&gt;szie;i &gt; 0; i--)&#123; // i此时是定义的为位置,位置为[size,0],从后往前搬 pSeq-&gt;array[i] = pSeq-&gt;array[i - 1]; &#125; //将i定位为数据,位置size[0,size),将整体的位置向后移 for(int i = size - 1；i &gt; 0;i++)&#123; pSeq-&gt;array[i + 1] = pSeq-&gt;array[i]; &#125; pSeq-&gt;array[0]=data; pSeq-&gt;size++;&#125; 这是一个自我思考的图示，仅供参考 尾插的使用尾插就相当于正常插入了，这个是比较简单的一种插入 1234567891011void SeqListPushBack(SeqList *pSeq,DataType data)&#123; //还是要先考虑特殊情况 assert(pSeq); if(pSeq-&gt;size &gt;= MAX_SIZE)&#123; printf("满了\n"); assert(0); return; &#125; pSeq-&gt;array[pSeq-&gt;size] = data; pSeq-&gt;size++;&#125; 中间插入的使用中间插入根据下标来使用，此时这么想，我们先将要插入的地方定义一个pos下标，此时将此下标之后的（包括此下标的）所有数据向后移动。 123456789101112131415161718void SeqListInsert(SeqList *pSeq,int pos, DataType data)&#123; //考虑特殊情况 assert(pSeq); if(pSeq-&gt;size &gt;= MAX_SIZE)&#123; printf("满了\n"); assert(0); return; //此时i作为位置 for(int i = pSeq-&gt;size; i &gt;= pos; i--)&#123; pSeq-&gt;array[i] = pSeq-&gt;array[i - 1]; &#125; //此时i作为数据 for(int i = pSeq-&gt;size - 1;i &gt;= pos; i--)&#123; pSeq-&gt;array[i + 1] = pSeq-&gt;array[i]; &#125; pSeq-&gt;array[pos] = data; pSeq-&gt;szie++;&#125; 自我图示，仅供参考 删除：头删，尾删，删除头删的使用最开始的数删除后，其他的数据向前补进。当然，也别忘了特殊情况！ 123456789101112131415161718void SeqListPushFont(SeqList *pSeq)&#123; //特殊情况 assert(pSeq) if(pSeq-&gt;size &lt;= 0)&#123; printf("空了\n"); assert(0); return; &#125; //i此时为位置时 for(int i = 0; i &lt; pSeq-&gt;size - 1;i++)&#123; pSeq-&gt;array[i] = pSeq-&gt;array[i + 1]; &#125; //i此时为数据时 for(int i = 1;i &lt; pSeq-&gt;size;i++)&#123; pSeq-&gt;array[i - 1] = pSeq-&gt;array[i]; &#125; pSeq-&gt;size--;&#125; 尾删的使用尾删比较简单，也就是直接将最后一个删除 123456789void SeqListPushPop(SeqList *pSeq)&#123; assert(pSeq) if(pSeq-&gt;size &lt;= 0)&#123; printf("空了\n"); assert(0); return; &#125; pSeq-&gt;size--;//直接将空间减小&#125; 删除的使用删除从中间删除，还是定义一个pos下标，删除之后，在将所有数据向前移动 1234567891011void SeqListPushErase(SeqList *pSeq,int pos)&#123; assert(pSeq) if(pSeq-&gt;size &lt;= 0)&#123; printf("空了\n"); assert(0); return; &#125; for(int i = pos;i &lt;= pSeq-&gt;size ;i--)&#123; pSeq-&gt;array[i - 1] = pSeq-&gt;array[i]; &#125;&#125; 当我们基本的这些操作编写完之后，我们需要输出这些数组，来观察。 1234567void SeqListPrint(const SeqList *pSeq)&#123; assert(pSeq != NULL); for(int i = 0;i &lt; pSeq-&gt;size;i++)&#123; printf("%d",pSeq-&gt;array[i]); &#125; printf("\n");&#125; 删除的第二种形态用接口的方式来实现删除。 接口可以理解为封装一个函数来对其使用。这样我们就可以有一些其他的删除方式 删除第一个遇到的数据的形式12345678void SeqListRemove(SeqList *pSeq, DataType data)&#123; int pos = SeqListFind(pSeq,data); if(pos == -1)&#123; //找不到删除 return; &#125; SeqListPushErase(pSeq, pos);&#125; 删除遇到的所有数据的形式123456void SeqListRemoveALL(SeqList *pSeq,DataType data)&#123; //第一种方式 while(pos = SeqListFind(pSeq,data) != -1)&#123; SeqListPushErase(pSeq,data); &#125;&#125; 12345678910111213141516171819202122void SeqListRemovALL(SeqList *pSeq,DataType data)&#123; //第二种方式 //一次遍历空间，时间快，但是开辟了新空间，空间大小和size有关系 //开辟一个新空间，遍历原来的数组 //if arr[i] != data //new [j+1]= arr[j+1] //else i++ //把数据在搬回来，还剩的数据个数为i个 DataType *newArray = (DataType *)malloc(sizeof(DataType)*pSeq-&gt;size); int i, j; for(i = 0,j = 0;i &lt; pSeq-&gt;size;i++)&#123; if(data != pSeq-&gt;array[i])&#123; newArray[j] = pSeq-&gt;array[i]; j++ &#125; &#125; for(i = 0;i &lt; j; i++)&#123; pSeq-&gt;array[i] = newArray[i]; &#125; pSeq-&gt;size = j; free(newArray);&#125; 1234567891011void SeqListRemoveALL(SeqList *pSeq,DataType data)&#123; //第三种方法 //这个方法没有开辟新的空间，直接对其每个所对应的新区域赋值 //这样我们最后将数组size直接改为新开辟的大小 int i, j; for(i = 0,j = 0;i &lt; pSeq-&gt;size, i++)&#123; pSeq-&gt;array[j] = pSeq-&gt;array[i]; j++; &#125; pSeq-&gt;size = j;&#125; 查找的使用查找也是一个关键的选择，因为，在查找到我们需要的下标之后，我们可以对此进行各种增删改操作 查找也有很多方式，这里先仅做一种顺序遍历查找。查找也有二分查找(前提有序) 12345678int SeqListFind(SeqList *pSeq,DataType data)&#123; for(int i = 0;i &lt; pSeq-&gt;size;i++)&#123; if(data = pSeq-&gt;size[i])&#123; return 1; &#125; return -1; &#125;&#125; 一些其他的使用操作对于顺序表的操作我们还有一些其他的操作 1234int SeqListSize(SeqList *pSeq)&#123; //查看当前size的大小 return pSeq-&gt;size;&#125; 1234int SeqListEmpty(SeqList *pSeq)&#123; //清空当前数组 return pSeq-&gt;size == 0;&#125; 1234int SeqListFull(SeqList *pSeq)&#123; //将数组的size放到最大 return pSeq-&gt;size == MAX_SIZE;&#125; 123456void Swap(DataType *a,DataType *b)&#123; //交换两个数据 DataType t = *a; *a = *b; *b = t;&#125; 改的使用我们可以理解为，我们将要怎么让这个数组去改变，那么我们可以使用排序的方式将数组发生变化。这是一种改法。在静态顺序表中。通过举冒泡排序的例子来使用。 12345678910111213141516void SeqListBubbleSort(SeqList *pSeq)&#123; int i,j; int isSort; for(i = 0;i &lt; pSeq-&gt;size - 1;i++)&#123; isSort = 1; for(j = 0;j &lt; pSeq-&gt;size - 1 - i; j++)&#123; if(pSeq-&gt;array[i] &gt; pSeq-&gt;array[i + j])&#123; Swap(pSeq-&gt;array + j, pSeq-&gt;array + j + 1) &#125; isSort = 0; &#125; if(isSort)&#123; break; &#125; &#125;&#125; 在这里调用冒泡排序的方法是可以进行数组的改变。 以上就是关于静态顺序数组的基本组成。总的来说，数据结构的难点在于思想过程。怎么把在纸上我们通过绘画的东西，利用代码的形式去表达出来，这是一个很关键的思考过程。]]></content>
      <tags>
        <tag>C-数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初阶C-1107]]></title>
    <url>%2F2018%2F11%2F08%2F%E5%88%9D%E9%98%B6C-1107%2F</url>
    <content type="text"><![CDATA[这次的初阶都是跟C语言中的递归有关的。可以说递归是一个不好理解的，比较抽象的东西。 递归（Recursion），指在函数的定义中使用函数自身的方法，即程序的自身调用。 递归就是方法里调用自身。 但是递归的缺陷也是非常大的。在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储。递归次数过多容易造成栈溢出等，所以一般不提倡用递归算法设计程序。 1.递归和非递归分别实现求第n个斐波那契数。 12345678910111213141516171819202122232425262728//利用了递归int Fibonacci(int n)&#123; if (n == 1 || n == 2)&#123; return 1; &#125; return Fibonacci(n - 1) + Fibonacci(n - 2);&#125;//不使用递归void Fib(int n)&#123; int j = 1, k = 1, sum = 0; if (n == 1 || n == 2)&#123; return 1; &#125; if (n % 2 == 0)&#123; for (int i = 1; i &lt; n / 2; i++)&#123; j += k; k += j; &#125; printf("%d", k); &#125; else if(n % 2 == 1)&#123; for (int i = 1; i &lt;= n / 2; i++)&#123; j += k; k += j; &#125; printf("%d", j); &#125;&#125; 2.编写一个函数实现n^k，使用递归实现. 12345678//n^k 如果调用递归，我们先拆分这个算式// n^k=1,k=0;n^k=n*n^(k-1),k&gt;0double index(double n,double k)&#123; if (k == 0)&#123; return 1; &#125; return n*index(n, k - 1);&#125; 3.写一个递归函数DigitSum(n),输入一个非负整数,返回组成它的数字之和,例如,调用DigitSum(1729)，则应该返回1+7+2+9,它的和是19. 12345678910int DigitSum(int n)&#123; int m = 0; int sum = 0; if (n != 0)&#123; m = n % 10; n = n / 10; sum = m + DigitSum(n); &#125; return sum;&#125; 4.递归和非递归分别实现strlen. 123456789101112131415int Strlen(const char*str)&#123; if ('\0' == *str)&#123; return 0; &#125; return 1+Strlen(str + 1);//这里的+1可以理解成每次进行拆分去算 //比如“abcd” 先为“a”+“bcd”，第二次在为“b”+“cd”，以此类推&#125;int Strlen2(char str[])&#123; int size = 0; while (str[size] != '\0')&#123; size++; &#125; return size;&#125; 5.递归和非递归分别实现求n的阶乘 . 1234567891011121314151617void Fac(int n)&#123; int j = 1; if (n == 1)&#123; return 1; &#125; for (int i = 1; i &lt;= n; i++)&#123; j *= i; &#125; printf("%d", j);&#125;int Fac1(int a)&#123; if (a == 1)&#123; return 1; &#125; return a*Fac1(a-1);&#125; 6.递归方式实现打印一个整数的每一位. 1234567891011121314int PrintfNum(int n)&#123; if (n &lt; 9)&#123; printf("%d",PrintfNum(n) / 10); &#125; printf("%d", n); //逆序实现,非递归 //while (n)&#123; // m = n % 10; // n = n / 10; // printf("%d", m); //&#125; &#125; 本次就结束了，还有一个利用递归进行逆序的题，我觉得这道题很不好理解。我将专门写一篇关于这道题目的文章。 递归的思想是很重要的。我们可以想象成电影《盗梦空间》，一层接着一层的梦境，就好比我们的递归不断的往下进行，只有上一层完成后，才可到下一层。多加练习，多思考，一定会掌握的。]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初阶C-1103]]></title>
    <url>%2F2018%2F11%2F05%2F%E5%88%9D%E9%98%B6C-1103%2F</url>
    <content type="text"><![CDATA[1.实现一个函数，打印乘法口诀表，口诀表的行数和列数自己指定，输入9，输出99口诀表，输入12，输出1212的乘法口诀表。12345678910111213#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;void MultiplicationTable(int a)&#123; for (int i = 1; i &lt;= a; i++)&#123; for (int j = 1; j &lt;= i; j++)&#123; int k = 0; k = j*i; printf("%d*%d=%d ", j,i,k); &#125; printf("\n"); &#125;&#125; 2.使用函数实现两个数的交换。1234567void ChangeNum(int a, int b)&#123; int temp = 0; temp = b; b = a; a = temp; printf("%d,%d", a, b);&#125; 3.实现一个函数判断year是不是润年。1234567891011void LeapYear(int a)&#123; if (a % 100 == 0 &amp;&amp; a % 400 == 0)&#123; printf("%d is LeapYear", a); &#125; else if (a % 4 == 0 &amp;&amp; a % 100 != 0)&#123; printf("%d is LeapYear", a); &#125; else&#123; printf("Not LeapYear"); &#125;&#125; 4.实现一个函数，判断一个数是不是素数。1234567891011121314void prime(int a)&#123; if (a == 2)&#123; printf("It's a prime"); &#125; else &#123; for (int i = 3; i &lt;= a; i++)&#123; if (a%i == 0)&#123; break; &#125; printf("It's a prime"); &#125; printf("It's not a prime"); &#125;&#125; 5.创建一个数组,实现函数init()初始化数组、实现empty()清空数组、实现reverse()函数完成数组元素的逆置。 要求：自己设计函数的参数，返回值。12345678910111213141516171819202122232425262728293031#define size 5//数组初始化 就是定义数组变量的同时给其中的数组元素赋值，由于是给多个元素同时赋值void init()&#123; int arr[size] = &#123; 20, 16, 23, 75, 95, &#125;; for (int i = 0; i &lt; size; i++)&#123; printf("arr[%d]=%2d \n", i, arr[i]); &#125; printf("\n");&#125;void empty()&#123; int arr[5] = &#123; 20, 16, 23, 75, 95, &#125;; for (int i = 0; i &lt; (sizeof(arr) / sizeof(arr[0])); i++)&#123; arr[i] = '\0'; printf("arr[%d]=%2d \n", i, arr[i]); &#125; printf("\n");&#125;void reverse()&#123; int temp = 0; int i = 0; int arr[5] = &#123; 20, 16, 23, 75, 95, &#125;; for (i = 0; i &lt; 3; i++)&#123; temp = arr[i]; arr[i] = arr[4 - i]; arr[4 - i] = temp; &#125; for (i = 0; i &lt; 5; i++)&#123; printf("arr[%d]=%2d \n",i, arr[i]); &#125;&#125; 前4题很简单，并没有特别大的难度，只要掌握了计算公式，就可以算出。第五题的思路有很多种，这是我目前想出来的一种，初始化和清空比较容易想到。关于逆置，我的方法是比较繁琐的，要根据数组内个数的多少来判断i的取值范围，当然i是可以通过sizeof()来取代的，在此我就不更换了。还有memset()这个函数可以使用，以后我将找机会将其写出。 欢迎大家留言！我们可以一起讨论]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初阶C-1101]]></title>
    <url>%2F2018%2F11%2F04%2F%E5%88%9D%E9%98%B6C-1101%2F</url>
    <content type="text"><![CDATA[1.完成猜数字游戏。 源文件内需执行的1234567891011121314151617181920int main()&#123; while (1)&#123; printf("输入1，开始游戏\n"); printf("输入0，退出游戏\n"); int i = 0; scanf("%d", &amp;i); if (i == 1)&#123; Game(); &#125; else if(i == 0)&#123; printf("goodbye!\n"); break; &#125; else&#123; printf("请重新输入！\n"); &#125; &#125; system("pause"); return 0;&#125; 头文件.h1234567891011121314151617181920212223#define _CRT_SECURE_NO_WARNINGS#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;#include&lt;time.h&gt;#include&lt;windows.h&gt;void Game()&#123; int num = 0; int result = 0; srand((unsigned int)time(NULL)); result = rand() % 100 + 1; do&#123; printf("请输入一个数:"); scanf("%d", &amp;num); if (num &lt; result)&#123; printf("lower\n"); &#125; else if(num &gt; result)&#123; printf("higher\n"); &#125; &#125; while (num != result); printf("congratulations!\n");&#125; 2.写代码可以在整型有序数组中查找想要的数字，找到了返回下标，找不到返回-1.（折半查找）123456789101112131415161718192021222324252627void find()&#123; int arr[] = &#123; 11, 12, 13, 14, 15, 16, 17, 18, 19 &#125;; int left = 0; int right = sizeof(arr) / sizeof(arr[0]) - 1;//减一是因为数组下标规则 int i = 0; int mid = (left + right) / 2; printf("输入一个数字进行查找："); scanf("%d", &amp;i); while (left &lt;= right)&#123;//在左边数小于右边数的情况下 mid = (left + right) / 2; if (arr[mid] &lt; i)&#123; left =mid + 1; &#125; else if(arr[mid] &gt; i)&#123; right = mid - 1; &#125; else&#123; break; &#125; &#125; if (arr[mid] == i)&#123; printf("%d", mid); &#125; else&#123; printf("-1"); &#125;&#125; 3.编写代码模拟三次密码输入的场景。 最多能输入三次密码，密码正确，提示“登录成功”,密码错误，可以重新输入，最多输入三次。三次均错，则提示退出程序。123456789101112void login()&#123; char pass[1024] = &#123;&#125;; char password[] = "123456"; for (int i = 0; i &lt; 3; i++)&#123; printf("Please enter you password:\n"); scanf("%s", &amp;pass); if (strcmp(password, pass) == 0)&#123; printf("Welcome to system!\n"); break; &#125; &#125;printf("sorry,exiting");&#125; 4.编写一个程序，可以一直接收键盘字符，如果是小写字符就输出对应的大写字符，如果接收的是大写字符，就输出对应的小写字符，如果是数字不输出。123456789101112void receive()&#123; printf("please enter successively\n"); while(1)//永真情况下。永远进行循环。在字符数c为数字时跳出循环。 &#123; char c; c = getchar();//从控制台读取一个字符，但不显示在屏幕上。 if (c &gt;= 48 &amp;&amp; c &lt;= 57)&#123; break; &#125; putchar(c); &#125;&#125; 本次作业都是一些关于for和while循环的一些用法。第二题是需要好好思考一下的，难点在于中间值在比较过后，向右还是向左的问题。最后一定要break退出，否则会无法跳出循环。]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初阶C_1030]]></title>
    <url>%2F2018%2F10%2F31%2F%E5%88%9D%E9%98%B6C-1030%2F</url>
    <content type="text"><![CDATA[1.在屏幕上输出一个上下倒三角星形的图案123456789101112131415161718192021222324252627void star()&#123;//将代码分为上三角和下三角来输出 int i, j, n = 7; for (i = 1; i &lt;= n; i++) &#123; for (j = 1; j &lt;= n - i; j++) &#123; printf(" "); &#125; for (j = 0; j &lt; 2 * i - 1; j++) &#123; printf("*"); &#125; printf("\n"); &#125; for (i = 6; i &gt; 0 ; i--) &#123; for (j = 1; j &lt;= n-i; j++) &#123; printf(" "); &#125; for (j = 1; j &lt; 2 * i ; j++) &#123; printf("*"); &#125; printf("\n"); &#125;&#125; 2.求出0～999之间的所有“水仙花数”并输出。例如： 153 = 1^3 + 5^3 + 3^3。 370 = 3^3 + 7^3 + 0^3。 371 = 3^3 + 7^3 + 1^3。 407 = 4^3 + 0^3 + 7^3。12345678910111213void narcissus()&#123; int i; int j, k, l; for (i = 0; i &lt; 1000; i++) &#123; j = i % 10; k = (i / 10) % 10; l = i / 100; if (i == j * j * j + k * k * k + l * l * l )&#123;//老铁！注意是"=="!! printf("%d\n", i); &#125; &#125;&#125; 3.求Sn=a+aa+aaa+aaaa+aaaaa的前5项之和，其中a是一个数字，例如：2+22+222+2222+22222 123456789void he(int a)&#123; //j每次都是j*10，之后在加上a。 int Sn = 0, i, j; j = a; //j=a，定义在循环之外，a的赋值只在第一次填写参数时。 for (i = 0; i &lt; 5; i++)&#123; Sn = j+ Sn; j = j * 10 + a; &#125; printf("%d", Sn);&#125;]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初阶C_1027]]></title>
    <url>%2F2018%2F10%2F31%2F%E5%88%9D%E9%98%B6C-1027%2F</url>
    <content type="text"><![CDATA[将数组A中的内容和数组B中的内容进行交换。（数组一样大） 12345678910111213141516171819void change_num()&#123; int a[5] = &#123; 12, 52, 36, 45, 62 &#125;; int b[5] = &#123; 21, 34, 13, 24, 72 &#125;; int i = 0; int tmp = 0; int sz = sizeof(a) / sizeof(a[0]);//所有数据的字节数除以一个数据的字节数等于数组的长度 for (i = 0; i &lt; sz; i++)&#123; tmp = a[i]; a[i] = b[i]; b[i] = tmp; &#125; for (i = 0; i &lt; sz; i++)&#123; printf("%d,", a[i]); &#125; printf("\n"); for (i = 0; i &lt; sz; i++)&#123; printf("%d,", a[i]); &#125;&#125; 计算1/1-1/2+1/3-1/4+1/5 …… + 1/99 - 1/100 的值。 12345678910111213void jisuan()&#123; double i;//最好改为double类型，因为1/i和1.0/i这两种写法，如果i的类型不同那么得出的答案也不同 double sum=0,sum1=0,sum2=0; for (i = 1; i &lt; 100; i += 2)&#123; sum1 = sum1 + 1 / i; &#125; for (i = 2; i &lt; 101; i += 2)&#123; sum2 = sum2 - 1 / i; &#125; sum=sum1+sum2; printf("%lf", sum);//%f和%lf分别是float类型和double类型用于格式化输入输出时对应的格式符号。 //%lf为双精度浮点&#125; 编写程序数一下 1到 100 的所有整数中出现多少次数字9。 12345678910void js9()&#123; int i; int count = 0; for (i = 0; i &lt; 101; i++)&#123; if ((i - 9) % 10 == 0||i / 9 == 10 )&#123; count++; &#125; &#125; printf("%d", count);//计算出来为19，这是因为99中有两个9存在，所以计算两次。刚开始总以为应该是18...&#125; 类型与计算公式别混淆，否则很容易代码出问题。]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初阶C_1025]]></title>
    <url>%2F2018%2F10%2F31%2F%E5%88%9D%E9%98%B6%E9%98%B6C-1025%2F</url>
    <content type="text"><![CDATA[#C常见的几种比较我用的VS2013，头文件与源文件分开，在此只贴出函数。 1.给定两个整形变量的值，将两个值的内容进行交换。 123456789void compare()&#123; int a = 10; int b = 20; int tmp = 0; tmp = a; a = b; b = tmp; printf("a=%d,b=%d", a, b);&#125; 2.不允许创建临时变量，交换两个数的内容 12345678void compare2()&#123; int a = 20; int b = 10; a = a - b; b = a + b; a = b - a; printf("a=%d,b=%d", a, b);&#125; 3.求10 个整数中最大值。 1234567891011void compare3()&#123; int a[10] = &#123; 12, 23, 51, 5, 24, 35, 62, 25, 19, 60 &#125;; int i; int max = a[0]; for (i = 0; i &lt; 11; i++)&#123; if (max &lt; a[i])&#123; max = a[i]; &#125; &#125; printf("最大数为%d", max);&#125; 4.将三个数按从大到小输出。 12345678910111213141516171819void compare4(int a,int b,int c)&#123; int tmp = 0; if (a &gt; b)&#123; tmp = a; a = b; b = tmp; &#125; if (b &gt; c)&#123; tmp = b; b = c; c = tmp; &#125; if (a &gt; b)&#123; tmp = a; a = b; b = tmp; &#125; printf("这三个数的排序为：%d,%d,%d", a, b, c);&#125; 在这里特别说一下，求最大公约数这用的是相减法，在while语句中，有个特别注意的。a-b的数需要考虑大小的问题，因为一直用大数减小数直到为0.5.求两个数的最大公约数。 12345678910111213141516171819void compare5(int a,int b)&#123; int tmp = 0; if (a &lt; b)&#123; tmp = a; a = b; b = tmp; &#125; while (a-b!=0)&#123; tmp = a - b; a = b; b = tmp; if (a &lt; b)&#123; tmp = a; a = b; b = tmp; &#125; &#125; printf("最大公约数为：%d", b);&#125;]]></content>
      <tags>
        <tag>C初阶</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新的开始]]></title>
    <url>%2F2018%2F10%2F29%2F%E6%96%B0%E7%9A%84%E5%BC%80%E5%A7%8B%2F</url>
    <content type="text"><![CDATA[博客今日搭建初步完成，Markdown形式还不知道具体操作，会陆陆续续的进行完善。 说实话，一直就想搭建一个属于自己的博客。就为了能有个属于自己的小天地。 国内也有CSDN，博客园之类的。 但我觉得自己动手的会更好。 当我觉得自己足够强大时，会去尝试WordPress来搭建另外一种博客。 加油！程序程！]]></content>
      <tags>
        <tag>程序人生</tag>
      </tags>
  </entry>
</search>
