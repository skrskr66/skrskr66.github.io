<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>程序程</title>
  
  <subtitle>为了梦想的skr</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://skrskr66.github.io/"/>
  <updated>2019-04-26T15:57:37.438Z</updated>
  <id>https://skrskr66.github.io/</id>
  
  <author>
    <name>Lyc</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux进程信号</title>
    <link href="https://skrskr66.github.io/2019/04/23/Linux%E8%BF%9B%E7%A8%8B%E4%BF%A1%E5%8F%B7/"/>
    <id>https://skrskr66.github.io/2019/04/23/Linux进程信号/</id>
    <published>2019-04-23T10:26:30.000Z</published>
    <updated>2019-04-26T15:57:37.438Z</updated>
    
    <content type="html"><![CDATA[<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><h4 id="信号概念"><a href="#信号概念" class="headerlink" title="信号概念"></a>信号概念</h4><p>通知进程发生了某件事情导致了软件中断—-会打断当前的阻塞操作，去处理事情</p><h4 id="信号的种类"><a href="#信号的种类" class="headerlink" title="信号的种类"></a>信号的种类</h4><p>信号有不同的种类，每个信号都对应了不同的事件</p><p>通过命令行<code>kill -l</code>可以查看信号的种类</p><p><img src="/2019/04/23/Linux进程信号/信号1.png" alt="信号1"></p><p>在图中可以看到这些都是信号的种类，总共有62个种信号</p><p>1-31—-&gt;每个都有各自对应的事件        非可靠信号/非实时信号</p><p>34-64—-&gt;后续添加的信号                可靠信号/非可靠信号</p><p>信号的生命周期：产生—–&gt;注册(注册在进程当中)—–&gt;注销(在进程中注销)—–&gt;处理</p><p><strong>信号是在软件层次上对中断机制的一种模拟，在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。信号是异步的，一个进程不必通过任何操作来等待信号的到达，事实上，进程也不知道信号到底什么时候到达。</strong></p><p>信号是进程间通信机制中唯一的异步通信机制，可以看作是异步通知，通知接收信号的进程有哪些事情发生了。信号机制经过POSIX实时扩展后，功能更加强大，除了基本通知功能外，还可以传递附加信息。</p><h5 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h5><p>我自己也是在写的过程中才发觉不了解同步与异步，所以也补充一下</p><p><strong>同步：就是发出一个功能调用时，在没有得到结果之前，该调用就不返回或继续执行后续操作</strong></p><p><strong>异步：当一个异步过程调用发出后，调用者在没有得到结果之前，就可以继续执行后续操作。当这个调用完成后，一般通过状态、通知和回调来通知调用者。对于异步调用，调用的返回并不受调用者控制</strong></p><h5 id="信号的产生"><a href="#信号的产生" class="headerlink" title="信号的产生"></a>信号的产生</h5><p>硬件产生：ctrl+c，ctrl+|，ctrl+z。通过键盘强行关闭，比如在一个无限循环中，使用键盘组合按键将该进程强行停掉。</p><p>软件产生：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;信号&quot;&gt;&lt;a href=&quot;#信号&quot; class=&quot;headerlink&quot; title=&quot;信号&quot;&gt;&lt;/a&gt;信号&lt;/h3&gt;&lt;h4 id=&quot;信号概念&quot;&gt;&lt;a href=&quot;#信号概念&quot; class=&quot;headerlink&quot; title=&quot;信号概念&quot;&gt;&lt;/a&gt;信号概念&lt;/h
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://skrskr66.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程间通信</title>
    <link href="https://skrskr66.github.io/2019/04/20/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>https://skrskr66.github.io/2019/04/20/Linux进程间通信/</id>
    <published>2019-04-20T08:27:21.000Z</published>
    <updated>2019-04-22T06:57:26.043Z</updated>
    
    <content type="html"><![CDATA[<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>一般简称为IPC—-InterProcess Communication。是指在不同进程之间传播或交换信息。</p><p>进程间通信有这么几个方式：管道（命名管道/匿名管道），共享队列，消息队列，信号量</p><p><strong>进程间为什么要通信呢？</strong></p><p>因为进程的独立性，因此想要通信必须能够共同访问一个相同的媒介。</p><p><strong>进程间通信的目的</strong>：数据传输，数据共享，进程间的访问控制。</p><p>也正因为通信的目的不同，使用场景不同，因此操作系统提供了多种进程间通信方式：</p><p><strong>管道—-传输数据</strong></p><p><strong>共享内存—-共享数据</strong></p><p><strong>消息队列—-传输数据</strong></p><p><strong>信号量—-进程间的访问控制</strong></p><h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>管道是半双工通信，双向选择的单向通信（即数据只能在一个方向上流动），具有固定的读端和写端</p><p>它是<strong>进程间的数据资料传输</strong>。在通信过程中，<strong>先将数据放到buf中，在将数据拷贝到自己的buf中在进行操作</strong></p><p><img src="/2019/04/20/Linux进程间通信/通信1.png" alt="通信1"></p><p><strong>管道生命周期随进程，如果进程消亡了，那么通信也就结束了</strong></p><h5 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> pipefd[<span class="number">2</span>])</span></span>;</span><br><span class="line"><span class="comment">//pipefd输出型参数</span></span><br><span class="line"><span class="comment">//数组pipefd用于返回引用结尾的两个文件描述符。</span></span><br><span class="line"></span><br><span class="line">pipefd[<span class="number">0</span>] 从管道读数据</span><br><span class="line">pipefd[<span class="number">1</span>] 从管道写数据</span><br><span class="line"></span><br><span class="line">如果成功，则返回 <span class="number">0</span>；不成功，则返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p><strong>只能用于具有亲缘关系的进程间通信</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;    </span></span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </span><br><span class="line">  <span class="keyword">int</span> pipefd[<span class="number">2</span>];    </span><br><span class="line">  <span class="keyword">int</span> ret = pipe(pipefd);    </span><br><span class="line">  <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;    </span><br><span class="line">    perror(<span class="string">"pipe error"</span>);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="keyword">int</span> pid = fork();    </span><br><span class="line">  <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;    </span><br><span class="line">    perror(<span class="string">"fork error"</span>);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;    </span><br><span class="line">    close(pipefd[<span class="number">1</span>]);    </span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;    </span><br><span class="line">    sleep(<span class="number">1</span>);    </span><br><span class="line">    close(pipefd[<span class="number">1</span>]);    </span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;    </span><br><span class="line">    <span class="keyword">int</span> ret = read(pipefd[<span class="number">0</span>], buf, <span class="number">1023</span>);    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"read buf:[%d - %s]\n"</span>,ret, buf);    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先建立管道，之后再创建子进程。这个时候就要考虑到管道的读写特性了</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">若管道中没有数据，则read会阻塞，直到读到数据返回</span><br><span class="line">若管道中数据写满了，则write会阻塞，直到数据被读取，管道中有空闲位置，写入数据后返回</span><br><span class="line"></span><br><span class="line">若管道中所有的读端都被关闭，则write会触发异常----SIGPIPE(信号标志)----导致进程退出</span><br><span class="line">若管道中的所有写有写端都被关闭，则read返回0----通知用户没人写了</span><br><span class="line"></span><br><span class="line">父子进程两端都要进行关闭</span><br></pre></td></tr></table></figure><p>所以代码中将管道中写端关闭了，所以读端返回的是0.</p><p><img src="/2019/04/20/Linux进程间通信/通信2.png" alt="通信2"></p><p><strong>虽然管道提供了双向选择，但是如果我们没有用到某一端，就把这一端关闭掉</strong></p><h5 id="管道同步与互斥特性"><a href="#管道同步与互斥特性" class="headerlink" title="管道同步与互斥特性"></a>管道同步与互斥特性</h5><p>当读写数据的大小&lt;管道pipe_buf ，是保证操作原子性—–这时操作不可被打断</p><p>互斥：保证对一个临界资源（公共资源，比如全局变量）同一时间的唯一访问性（我操作的时候你不能操作）</p><p>同步：保证对一个临界资源访问的时序可控性（我操作完了你才能操作）</p><p><code>|</code>管道符就是匿名访问</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;                               </span><br><span class="line">  <span class="keyword">int</span> pipefd[<span class="number">2</span>];                          </span><br><span class="line">  <span class="keyword">int</span> ret = pipe(pipefd);                 </span><br><span class="line">  <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;                            </span><br><span class="line">    perror(<span class="string">"pipe error"</span>);                 </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;                            </span><br><span class="line">  &#125;                                       </span><br><span class="line">  <span class="keyword">int</span> pid1 = fork();                      </span><br><span class="line">  <span class="keyword">if</span>(pid1 == <span class="number">0</span>)&#123;                          </span><br><span class="line">    close(pipefd[<span class="number">0</span>]);<span class="comment">//关闭从管道读数据    </span></span><br><span class="line">    dup2(pipefd[<span class="number">1</span>],<span class="number">1</span>);<span class="comment">//将文件描述符表中 向管道写数据 替换 标准输出    </span></span><br><span class="line">    execlp(<span class="string">"ps"</span>,<span class="string">"ps"</span>,<span class="string">"-ef"</span>,<span class="literal">NULL</span>);<span class="comment">//程序替换    </span></span><br><span class="line">  &#125;                                       </span><br><span class="line">  <span class="keyword">int</span> pid2 = fork();                      </span><br><span class="line">  <span class="keyword">if</span>(pid2 == <span class="number">0</span>)&#123;                          </span><br><span class="line">    close(pipefd[<span class="number">1</span>]);                     </span><br><span class="line">    dup2(pipefd[<span class="number">0</span>],<span class="number">0</span>);                    </span><br><span class="line">    execlp(<span class="string">"grep"</span>,<span class="string">"grep"</span>,<span class="string">"ssh"</span>,<span class="literal">NULL</span>);     </span><br><span class="line">  &#125;                                       </span><br><span class="line">  close(pipefd[<span class="number">0</span>]);<span class="comment">//不用的时候将读端和写端都关闭    </span></span><br><span class="line">  close(pipefd[<span class="number">1</span>]);    </span><br><span class="line">  waitpid(pid1,<span class="literal">NULL</span>,<span class="number">0</span>);    </span><br><span class="line">  waitpid(pid2,<span class="literal">NULL</span>,<span class="number">0</span>);    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>grep读数据时不知道自己需要多少数据，过滤之后再次读取。</p><p>代码用图示来解答一下</p><p><img src="/2019/04/20/Linux进程间通信/通信3.png" alt="通信3"></p><h5 id="命名管道-FIFO"><a href="#命名管道-FIFO" class="headerlink" title="命名管道(FIFO)"></a>命名管道(FIFO)</h5><p>FIFO是一种文件类型，可以用于任意进程间通信。</p><p>可见于文件系统，因为创建命名管道会随之在文件系统中创建一个命名管道文件</p><p>类似于在进程中使用文件来传输数据，只不过FIFO类型文件同时具有管道的特性</p><p>因为所有的进程都能够通过打开管道文件，进而获取管道的操作句柄，因此命名管道可以用于同一主机上任意进程间通信</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line">pathname:管道文件名</span><br><span class="line">mode:创建权限 <span class="number">0664</span></span><br></pre></td></tr></table></figure><p>fifo_read.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;    </span></span></span><br><span class="line">      </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </span><br><span class="line">  <span class="keyword">char</span> *file = <span class="string">"./test.fifo"</span>;    </span><br><span class="line">  umask(<span class="number">0</span>);    </span><br><span class="line">  <span class="keyword">int</span> ret = mkfifo(file, <span class="number">0664</span>);    </span><br><span class="line">  <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;    </span><br><span class="line">    <span class="keyword">if</span>(errno != EEXIST)&#123;    </span><br><span class="line">      perror(<span class="string">"mkfifo errno"</span>);    </span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"open file\n"</span>);    </span><br><span class="line">  <span class="keyword">int</span> fd = open(file, O_RDWR);    </span><br><span class="line">  <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;    </span><br><span class="line">    perror(<span class="string">"open error"</span>);                </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"open success!!\n"</span>);    </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;    </span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;    </span><br><span class="line">    <span class="keyword">int</span> ret = read(fd, buf, <span class="number">1023</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"read buf:[%s]\n"</span>, buf);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"write closed~~~\n"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      perror(<span class="string">"read error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"---------\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  close(fd);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fifo_write.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *file = <span class="string">"./test.fifo"</span>;</span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = mkfifo(file,<span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ret != EEXIST)&#123;</span><br><span class="line">            perror(<span class="string">"mkfifo error"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"open file\n"</span>);</span><br><span class="line">    <span class="keyword">int</span> fd = open(file, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">"open error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"open success!!\n"</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, buf);</span><br><span class="line">        write(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/20/Linux进程间通信/通信4.png" alt="通信4"></p><p>这有点类似于服务器–客户端之间建立连接</p><p>fifo_write类似于客服端发送一个请求 fifo_read类似于服务器返回一个请求</p><p>命名管道利用了文件系统创建文件进行通信。当write写入了数据，将数据从自己的buf写到test.fifo文件中，之后read在将数据从test.fifo中读取到自己的buf中，最后输出。</p><h5 id="命名管道的读写特性"><a href="#命名管道的读写特性" class="headerlink" title="命名管道的读写特性"></a>命名管道的读写特性</h5><p>若管道没有被以写的方式打开，这时如果只读打开则会阻塞，直到文件被以写的方式打开</p><p>若管道没有被以读的方式打开，这时如果只写打开则会阻塞，直到文件被以读的方式打开</p><p>若管道以读写的方式打开，则不会阻塞    </p><h5 id="匿名管道和命名管道的区别"><a href="#匿名管道和命名管道的区别" class="headerlink" title="匿名管道和命名管道的区别"></a>匿名管道和命名管道的区别</h5><p>匿名管道：速度慢，容量有限，只有父进程进程能通讯</p><p>命名管道：任何进程间都能通讯，但速度慢</p><h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p>共享内存的定义：在物理上开辟一块空间，<strong>内存直接映射到虚拟内存中，如果一块内存被多个进程映射，那么多个进程访问同一块内存，则可以实现通信。</strong> 是<strong>最快的</strong>进程间通信。因为相较于其他进程间通信方式(将数据从用户态拷贝到内核态，用的时候，从内核态拷贝到用户态)，共享内存直接将一块内存映射到用户空间，用户可以直接通过地址对内存进行操作，并反馈到其他进程，少了两步数据拷贝的过程。</p><h5 id="共享内存使用流程"><a href="#共享内存使用流程" class="headerlink" title="共享内存使用流程"></a>共享内存使用流程</h5><p>1、创建/打开共享内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> shmflg)</span></span>;</span><br><span class="line">    key:    共享内存标识符</span><br><span class="line">    size：  共享内存大小</span><br><span class="line">    shmflg：打开方式/创建权限</span><br><span class="line">    IPC_CREAT 共享内存不存在则创建</span><br><span class="line">    IPC_EXCL 与IPC_CREAT同用，若存在则报错，不存在则创建</span><br><span class="line">    返回值：操作句柄shmid失败：<span class="number">-1</span></span><br><span class="line"><span class="keyword">key_t</span> ftok(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> proj_id);</span><br><span class="line">    pathname:   文件名</span><br><span class="line">    proj_id：   数字</span><br><span class="line">    通过文件的 inode节点号 和 proj_id 共同得出一个key值</span><br></pre></td></tr></table></figure><p>2、将共享内存映射到虚拟地址空间(建立映射关系)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span> *shmaddr, <span class="keyword">int</span> shmflg)</span></span>;</span><br><span class="line">shmid:创建共享内存返回的操作句柄</span><br><span class="line">shmaddr：用于指定映射在虚拟空间的首地址通常置<span class="literal">NULL</span></span><br><span class="line">    shmflg：<span class="number">0</span>----可读可写</span><br><span class="line">    返回值：映射首地址（通过这个地址对共享内存进行操作)失败：（<span class="keyword">void</span>*)<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>3、对共享内存进行基本的内存操作，memcpy</p><p>4、解除映射关系    shmdt</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *shmaddr)</span></span></span><br><span class="line">shamddr:映射返回的首地址</span><br></pre></td></tr></table></figure><p>5、删除共享内存    shmctl</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">int</span> cmd, struct shmid_ds *buf)</span></span>;</span><br><span class="line">shmid:操作句柄</span><br><span class="line">cmd：IPC_RMID删除共享内存</span><br><span class="line">buf：设置或者获取共享内存信息，用不着置<span class="literal">NULL</span></span><br><span class="line">共享内存并不是立即删除的，只是拒绝后续映射连接，当共享内存</span><br><span class="line">映射连接数为<span class="number">0</span>时，则删除共享内存</span><br></pre></td></tr></table></figure><p>shm_read.c</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPC_KEY 0x12345678</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROJ_ID 12345</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHM_SIZE  4096</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> shmid;    </span><br><span class="line">  <span class="comment">//1、创建共享内存    </span></span><br><span class="line">  shmid = shmget(IPC_KEY, SHM_SIZE, IPC_CREAT|<span class="number">0666</span>);    </span><br><span class="line">  <span class="keyword">if</span>(shmid &lt; <span class="number">0</span>)&#123;    </span><br><span class="line">    perror(<span class="string">"shmget error"</span>);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="comment">//2、将共享内存映射到虚拟地址空间    </span></span><br><span class="line">  <span class="keyword">char</span> *shm_start = (<span class="keyword">char</span>*)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);    </span><br><span class="line">  <span class="keyword">if</span>(shm_start == (<span class="keyword">void</span>*)<span class="number">-1</span>)&#123;    </span><br><span class="line">    perror(<span class="string">"shmat error"</span>);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, shm_start);    </span><br><span class="line">    sleep(<span class="number">1</span>);    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="comment">//4、解除映射    </span></span><br><span class="line">  shmdt(shm_start);    </span><br><span class="line">  <span class="comment">//5、删除共享内存    </span></span><br><span class="line">  shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>shm_write.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPC_KEY 0x12345678    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROJ_ID 12345    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHM_SIZE  4096    </span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </span><br><span class="line">  <span class="keyword">int</span> shmid;    </span><br><span class="line">  <span class="comment">//1、创建共享内存    </span></span><br><span class="line">  shmid = shmget(IPC_KEY, SHM_SIZE, IPC_CREAT|<span class="number">0666</span>);    </span><br><span class="line">  <span class="keyword">if</span>(shmid &lt; <span class="number">0</span>)&#123;    </span><br><span class="line">    perror(<span class="string">"shmget error"</span>);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="comment">//2、将共享内存映射到虚拟地址空间    </span></span><br><span class="line">  <span class="keyword">char</span> *shm_start = (<span class="keyword">char</span>*)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);    </span><br><span class="line">  <span class="keyword">if</span>(shm_start == (<span class="keyword">void</span>*)<span class="number">-1</span>)&#123;    </span><br><span class="line">    perror(<span class="string">"shmat error"</span>);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;    </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;    </span><br><span class="line">    <span class="built_in">sprintf</span>(shm_start, <span class="string">"明天又是可以学习的一天！！！+%d\n"</span>,i++);    </span><br><span class="line">    sleep(<span class="number">1</span>);    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//4、解除映射</span></span><br><span class="line">  shmdt(shm_start);</span><br><span class="line">  <span class="comment">//5、删除共享内存</span></span><br><span class="line">  shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/20/Linux进程间通信/通信5.png" alt="通信5"></p><p>共享内存双方都可以修改</p><p>共享内存没有同步与互斥</p><p>删除一块共享内存，并不会立即删除，而是判断映射连接数，若为0则删除，不为0则拒绝后续连接，直到为0删除</p><h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p>消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。 </p><p>消息队列的建立过程为</p><p>创建消息队列—-&gt;添加数据节点—-&gt;获取数据节点—-&gt;删除</p><p>msgget—-&gt;msgsnd—-&gt;msgrcv(接收数据)—-&gt;msgctl</p><p>消息队列传输的是有类型的数据块，用户可以根据自己的需要选择性的获取某些数据类型</p><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>内核中的一个计数器—-具有等待队列(PCB等待队列)，具有等待和唤醒功能</p><p>用于资源计数，若计数小于等于0，表示没有资源，则需要等待</p><p>若计数大于0，表示有资源，则可以获取资源，然后计数-1</p><p>如果放置了资源，则计数+1，并且唤醒等待的进程</p><p>实现进程间的同步和互斥（资源计数为0或1的时候才具有互斥）</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>消息队列和信号量现在的使用不是特别多，了解一下就可以。重点还是共享内存和管道的学习。</p><p>在代码过程中，我们应该可以感觉到，这种通信方式有点类似于服务器和客户端之间的处理过程。但是具体的实现是不同的。</p><p>匿名管道是通过对读端和写端的关闭和开启，在buf缓存区对数据进行拷贝和使用。</p><p>而命名管道是通过文件系统的打开和关闭，将数据进行读写。读写必须同时打开，否则另一端会被阻塞。</p><p>而共享内存是在同一个地址映射的一块虚拟地址被多个进程访问，这时也就是多个进程同时访问同一个内存。此时共享内存直接映射一块内存到用户空间，用户直接通过地址对内存进行操作，并反馈到其他进程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;进程间通信&quot;&gt;&lt;a href=&quot;#进程间通信&quot; class=&quot;headerlink&quot; title=&quot;进程间通信&quot;&gt;&lt;/a&gt;进程间通信&lt;/h3&gt;&lt;p&gt;一般简称为IPC—-InterProcess Communication。是指在不同进程之间传播或交换信息。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://skrskr66.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux-基础IO</title>
    <link href="https://skrskr66.github.io/2019/04/12/Linux-%E5%9F%BA%E7%A1%80IO/"/>
    <id>https://skrskr66.github.io/2019/04/12/Linux-基础IO/</id>
    <published>2019-04-12T05:02:15.000Z</published>
    <updated>2019-04-15T16:24:08.402Z</updated>
    
    <content type="html"><![CDATA[<p>文件的输入输出在c语言之前了解过。比如标准库的IO接口</p><h4 id="回顾C语言的库函数"><a href="#回顾C语言的库函数" class="headerlink" title="回顾C语言的库函数"></a>回顾C语言的库函数</h4><p>fopen，fread，fwrite，fseek，fclose这几个函数。关键在于参数的使用。</p><p>例如fopen，<code>FILE *fopen(const char *path, const char *mode)</code>,在不同的模式下打开文件所能作的操作也不同。</p><table><thead><tr><th style="text-align:center">文件使用方式</th><th style="text-align:center">含义</th><th style="text-align:center">如果指定文件不存在</th></tr></thead><tbody><tr><td style="text-align:center">r–只读</td><td style="text-align:center">为了输入数据，打开一个已经存在的文本</td><td style="text-align:center">文件出错</td></tr><tr><td style="text-align:center">w–只写</td><td style="text-align:center">为了输出数据，打开一个文本文件</td><td style="text-align:center">建立一个新文件</td></tr><tr><td style="text-align:center">a–追加</td><td style="text-align:center">向文本文件尾添加数据</td><td style="text-align:center">出错</td></tr><tr><td style="text-align:center">rb–只读</td><td style="text-align:center">为了输入数据，打开一个二进制文件</td><td style="text-align:center">出错</td></tr><tr><td style="text-align:center">wb–只写</td><td style="text-align:center">为了输出数据，打开一个二进制文件</td><td style="text-align:center">建立一个新文件</td></tr><tr><td style="text-align:center">ab–追加</td><td style="text-align:center">向一个二进制文件<strong>尾</strong>添加数据</td><td style="text-align:center">出错</td></tr><tr><td style="text-align:center">r+–读写</td><td style="text-align:center">为了读和写，打开一个文本文件</td><td style="text-align:center">出错</td></tr><tr><td style="text-align:center">w+–读写</td><td style="text-align:center">为了读和写，建立一个新的文件</td><td style="text-align:center">建立一个新文件</td></tr><tr><td style="text-align:center">a+–读写</td><td style="text-align:center">打开一个文件，在文件尾进行读写</td><td style="text-align:center">建立一个新的文件</td></tr><tr><td style="text-align:center">rb+–读写</td><td style="text-align:center">为了读和写打开一个二进制文件</td><td style="text-align:center">出错</td></tr><tr><td style="text-align:center">wb+–读写</td><td style="text-align:center">为了读和写，新建一个新的二进制文件</td><td style="text-align:center">建立一个新的文件</td></tr><tr><td style="text-align:center">ab+–读写</td><td style="text-align:center">打开一个二进制文件，在文件尾进行读和写</td><td style="text-align:center">建立一个新的文件</td></tr></tbody></table><p>先回顾一下C语言中的文件操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;    </span></span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> ret;    </span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;    </span><br><span class="line">    fp = fopen(<span class="string">"./tmp.txt"</span>,<span class="string">"r+"</span>);    </span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)&#123;    </span><br><span class="line">      perror(<span class="string">"打开失败"</span>);                                                                                               </span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">  fseek(fp, <span class="number">5</span>, SEEK_END);    </span><br><span class="line">      </span><br><span class="line">  <span class="keyword">char</span> *ptr = <span class="string">"nihao---\n"</span>;    </span><br><span class="line">      </span><br><span class="line">  ret = fwrite(ptr, <span class="number">1</span>, <span class="built_in">strlen</span>(ptr), fp);    </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"write item:%d\n"</span>,ret);    </span><br><span class="line">      </span><br><span class="line">  fseek(fp, <span class="number">0</span>, SEEK_SET);    </span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;    </span><br><span class="line">      </span><br><span class="line">  ret = fread(buf, <span class="number">1</span>, <span class="number">1023</span>, fp);    </span><br><span class="line">  perror(<span class="string">"读取失败"</span>);    </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"read buf[%s]-[%d]"</span>,buf,ret);    </span><br><span class="line">      </span><br><span class="line">  fclose(fp);    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>先打开当前路径下的tmp.txt文件以读写的方式打开，之后利用fseek函数跳转读写位置从当前文件位置的末尾开始向后五个位置跳转。然后写入数据，一个字节写入，写入长度为*ptr的字符串长度，然后再跳转到文件的开头开始读取数据读取到buf中。fread返回值是读取的数据长度。最后关闭文件。</strong></p><p>这是C语言库函数中的使用方法。</p><h4 id="系统调用IO接口"><a href="#系统调用IO接口" class="headerlink" title="系统调用IO接口"></a>系统调用IO接口</h4><h5 id="文件描述符和文件流指针"><a href="#文件描述符和文件流指针" class="headerlink" title="文件描述符和文件流指针"></a>文件描述符和文件流指针</h5><p><strong>标准库接口使用文件流指针 <code>*FILE</code></strong></p><p><strong>系统调用接口使用文件描述符 比如 int fd</strong></p><p>进程中使用open函数打开某个文件，前提是需要我们将进程与文件联系起来。所以进程PCB中就有一个 <code>*FILE</code>指针，这个<code>*FILE</code>指针指向一个数组files_struct，这个数组内每个元素都对应了一个文件指针，文件指针指向各个FILE结构体。</p><p><strong>文件流指针这个结构体中就包含了文件描述符，当使用标准库接口进行io，则最终是通过文件流指针找到文件描述符进而对文件进行操作</strong></p><p>文件描述符是一个正整型数字。文件描述符实际上就是一个数组下标，当进程每打开一个文件，都会使用struct file描述这个文件，并且将描述信息添加到struct file这个结构中的file结构体数组中，并且向用户返回数组下标作为文件描述符，用户通过文件描述符对文件进行操作，再内核实际上是通过文件描述符找到文件描述信息，进而操作文件。</p><p>​    标准输入        标准输出        标准错误</p><p>​    stdin        stdout        stderr</p><p>​    0            1            2</p><p><img src="/2019/04/12/Linux-基础IO/基础IO1.png" alt="基础IO1"></p><p><strong>文件描述符分配规则：最小未使用</strong></p><h5 id="系统调用函数"><a href="#系统调用函数" class="headerlink" title="系统调用函数"></a>系统调用函数</h5><p>open write read close lseek</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br><span class="line"><span class="keyword">off_t</span> lseek(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line">pathname：文件路径名</span><br><span class="line">flags：选项标志</span><br><span class="line">必选项：</span><br><span class="line">O_RDONLY 只读</span><br><span class="line">O_WRONLY 只写</span><br><span class="line">O_REWR 可读可写</span><br><span class="line">可选项：</span><br><span class="line">O_CREAT 文化不存在则创建，存在则打开</span><br><span class="line">O_EXCL 与O_CREAT同用时，若文件存在则报错</span><br><span class="line">O_APPEND 写追加模式</span><br><span class="line">mode：创建文件时给定权限 （八进制数字）</span><br><span class="line">mode &amp; （~umask)</span><br><span class="line">返回值：文件描述符-正整数错误：<span class="number">-1</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br><span class="line">fd:打开文件所返回的文件描述符</span><br><span class="line">buf：要向文件写入数据</span><br><span class="line">count：要写入的数据长度</span><br><span class="line">返回值：实际的写入字节数错误：<span class="number">-1</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br><span class="line">fd:打开文件所返回的文件描述符</span><br><span class="line">buf：对读取到的数据进行存储的位置</span><br><span class="line">count：要读取的数据长度</span><br><span class="line">返回值：实际的读取字节数错误：<span class="number">-1</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">off_t</span> lseek(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence);</span><br><span class="line">fd:打开文件所返回的文件描述符</span><br><span class="line">offset：偏移量</span><br><span class="line">whence：偏移位置</span><br><span class="line">SEEK_SET</span><br><span class="line">SEEK_CUR</span><br><span class="line">SEEK_END</span><br><span class="line">返回值：返回当前位置到文件起始位置的偏移量</span><br></pre></td></tr></table></figure><p>掌握知识的最好办法还是结合代码！！！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#inlcude <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//mode_t umask</span></span><br><span class="line">    <span class="comment">//修改调用进程的文件创建权限掩码</span></span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"./tmp.txt"</span>,O_RDWR | O_CREAT | O_APPEND,<span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      perror(<span class="string">"open error"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>] = <span class="string">"nihaoa~~!!"</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = write(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      perror(<span class="string">"write error"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0x00</span>, <span class="number">1024</span>);<span class="comment">//对buf数组所在的内存空间全部初始化为0，初始化的长度为1024</span></span><br><span class="line">    ret = read(fd, buf, <span class="number">1023</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      perror(<span class="string">"read error"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"read buf:[%s]\n"</span>, buf);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/12/Linux-基础IO/基础IO2.png" alt="基础IO2"></p><p>运行如图，系统调用函数还是比较简单的。</p><h5 id="标准输入输出的重定向"><a href="#标准输入输出的重定向" class="headerlink" title="标准输入输出的重定向"></a>标准输入输出的重定向</h5><p>这里要学习一个dup2函数。</p><p>函数dup和dup2提供了复制文件描述符的功能。他们通常用于stdin,stdout或进程的stderr的重定向。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">int</span> newfd)</span></span>;</span><br></pre></td></tr></table></figure><p>dup2用来复制参数oldfd所指的文件描述符，并将oldfd拷贝到参数newfd后一起返回。若参数newfd为一个打开的文件描述符，则newfd所指的文件会先被关闭，若newfd等于oldfd，则返回newfd，而不关闭newfd所指的文件。dup2所复制的文件描述符与原来的文件描述符共享各种文件状态。共享所有的锁定，读写位置和各项权限或flags。</p><p>返回值：如果成功则返回新的文件描述符，否则出错返回-1.</p><p>由dup2函数返回的新文件描述符一定是当前文件描述符可用的最小值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;    </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </span><br><span class="line">  <span class="keyword">int</span> fd = open(<span class="string">"./tmp.txt"</span>,O_RDWR,<span class="number">0777</span>);                                                                               </span><br><span class="line">    </span><br><span class="line">  dup2(fd, <span class="number">1</span>);    </span><br><span class="line">    </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,fd);    </span><br><span class="line">    </span><br><span class="line">  fflush(<span class="built_in">stdout</span>);    </span><br><span class="line">  close(fd);    </span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时输出的结果为1，因为oldfd为打开文件的文件描述符，本应该为3，但是调用了dup2函数，此时stdout关闭了，将oldfd复制进去此时在返回新的文件描述符即为1。</p><p><img src="/2019/04/12/Linux-基础IO/基础IO3.png" alt="基础IO3"></p><h5 id="模拟实现minishell重定向"><a href="#模拟实现minishell重定向" class="headerlink" title="模拟实现minishell重定向"></a>模拟实现minishell重定向</h5><p>1、接收标准输入数据</p><p>2、解析命令（判断是否包含重定向符号 &gt;   \   &gt;&gt;）</p><p>3、如果包含，则认为需要输出重定向，这时候获取重定向符号后边的文件名将重定向符号替换成’\0’</p><p>4、在子进程中打开文件，将标准输出重定向到这个文件，进行程序替换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wait.h&gt;                                                                                                       </span></span></span><br><span class="line"><span class="comment">//之前写过一个关于minishell的文件，先对之前的一些进行封装函数    </span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;    </span><br><span class="line"><span class="keyword">char</span> *argv[<span class="number">32</span>];    </span><br><span class="line"><span class="keyword">int</span> argc = <span class="number">0</span>;    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_face</span><span class="params">()</span></span>&#123;    </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"[liuyucheng@localhost]$ "</span>);    </span><br><span class="line">  fflush(<span class="built_in">stdout</span>);    </span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0x00</span>, <span class="number">1024</span>);    </span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">scanf</span>(<span class="string">"%[^\n]"</span>,buf) != <span class="number">1</span>)&#123;    </span><br><span class="line">    getchar();    </span><br><span class="line">  &#125;    </span><br><span class="line">&#125;    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_parse</span><span class="params">()</span></span>&#123;    </span><br><span class="line">  <span class="keyword">char</span> *ptr = buf;    </span><br><span class="line">  argc = <span class="number">0</span>;    </span><br><span class="line">  <span class="keyword">while</span>(*ptr != <span class="string">'\0'</span>)&#123;    </span><br><span class="line">   <span class="keyword">if</span>(!<span class="built_in">isspace</span>(*ptr))&#123;</span><br><span class="line">     argv[argc++] = ptr; </span><br><span class="line">     <span class="keyword">while</span>(!<span class="built_in">isspace</span>(*ptr) &amp;&amp; *ptr != <span class="string">'\0'</span>)&#123;</span><br><span class="line">       ptr++;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      *ptr = <span class="string">'\0'</span>;</span><br><span class="line">      ptr++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  argv[argc] = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  do_face();</span><br><span class="line">  <span class="keyword">int</span> redirect = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">char</span> *file = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">char</span> *ptr = buf;</span><br><span class="line">  <span class="keyword">while</span>(*ptr != <span class="string">'\0'</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(*ptr == <span class="string">'&gt;'</span>)&#123;                                                                                                    </span><br><span class="line">      redirect = <span class="number">1</span>;<span class="comment">//清空重定向</span></span><br><span class="line">      *ptr++ = <span class="string">'\0'</span>;</span><br><span class="line">      <span class="keyword">if</span>(*ptr == <span class="string">'&gt;'</span>)&#123;</span><br><span class="line">        redirect = <span class="number">2</span>;</span><br><span class="line">        *ptr++ = <span class="string">'\0'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span>(<span class="built_in">isspace</span>(*ptr) &amp;&amp; *ptr != <span class="string">'\0'</span>)&#123;</span><br><span class="line">        ptr++;</span><br><span class="line">      &#125;</span><br><span class="line">      file = ptr;</span><br><span class="line">      <span class="keyword">while</span>(!<span class="built_in">isspace</span>(*ptr) &amp;&amp; *ptr != <span class="string">'\0'</span>)&#123;</span><br><span class="line">        ptr++;</span><br><span class="line">      &#125;</span><br><span class="line">      *ptr = <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ptr++;</span><br><span class="line">  &#125;</span><br><span class="line">  do_parse();</span><br><span class="line">  <span class="keyword">int</span> pid = fork();</span><br><span class="line">  <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(redirect == <span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">int</span> fd = open(file, O_CREAT | O_WRONLY | O_TRUNC, <span class="number">0664</span>);</span><br><span class="line">      dup2(fd, <span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(redirect == <span class="number">2</span>)&#123;</span><br><span class="line">      <span class="keyword">int</span> fd = open(file, O_CREAT | O_WRONLY | O_TRUNC, <span class="number">0664</span>);                                                          </span><br><span class="line">      dup2(fd, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    execvp(argv[<span class="number">0</span>], argv);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  wait(<span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Linux-ext2文件系统"><a href="#Linux-ext2文件系统" class="headerlink" title="Linux ext2文件系统"></a>Linux ext2文件系统</h4><p>注：图中应为inode。</p><p><img src="/2019/04/12/Linux-基础IO/基础IO4.png" alt="基础IO4"></p><p>上图是一个磁盘文件系统的内置。</p><p>每个分区都有一个文件系统，不同的分区拥有不同的文件系统。</p><p>什么是inode？<strong>inode里面包含了大小，权限，用户，时间，块位置</strong></p><p>利用指令<code>ls -i</code>可以查看inode节点号</p><h5 id="存储文件的流程"><a href="#存储文件的流程" class="headerlink" title="存储文件的流程"></a>存储文件的流程</h5><p>通过inode bitmap在inode table(表结构)找到空闲的inode节点，通过data bitmap在数据块区域找到空闲数据块，将数据块位置信息，记录到inode节点中，将文件数据写入到数据块中；将文件名和inode节点名写入父目录中。</p><p>目录文件中：存放了一张目录下有什么文件的表，表中记录了文件名。<strong>inode节点号—&gt;目录项</strong></p><p>当我们 <code>cat ./a.txt</code>输出文件内容时，在当前目录文件中查找文件名信息，通过文件名获取inode节点号，通过inode节点号，找到inode节点，进而访问数据块，读取数据进行打印。</p><h4 id="软硬链接"><a href="#软硬链接" class="headerlink" title="软硬链接"></a>软硬链接</h4><p>创建硬链接：<code>ln a.txt b.txt</code></p><p>创建软链接：<code>ln -s a.txt a.soft</code></p><p><strong>硬链接是一个文件的另一个名字，跟源文件并没有什么区别，—-inode节点号相同</strong></p><p><strong>软链接是一个独立的文件，像是一个文件的快捷方式，—-inode节点号不同</strong></p><p>删除源文件，软链接失效—-&gt;通过记录的源文件名路径查找源文件数据；</p><p>硬链接无影响—-&gt;通过inode节点找文件只是链接数-1</p><p>软链接可以针对目录进行创建，硬链接不可以</p><p>软链接可以跨分区建立，硬链接不可以</p><h4 id="静态库与动态库"><a href="#静态库与动态库" class="headerlink" title="静态库与动态库"></a>静态库与动态库</h4><p>静态库：<strong>名字一般为libxxx.a</strong>，编译时会整合到可执行程序中。程序在编译链接的时候把库的代码链接到可执行文件中。程序运行的时候将不再需要静态库 。<strong>优点是运行时不需要外部函数库支持，缺点是编译后程序较大，一旦静态库改变，程序需要重新编译。</strong> </p><p>动态库：<strong>名字一般为libxxx.M.N.so,M为主版本号，N为副版本号</strong> ，程序在运行的时候才去链接动态库的代码，多个程序共享使用库的代码。优点是运行时，有需要时才动态调用外部库中的函数，节省空间，缺点是运行环境中必须提供相应的库，动态库更新升级方便。 </p><h5 id="建立静态库"><a href="#建立静态库" class="headerlink" title="建立静态库"></a>建立静态库</h5><p>​    <code>gcc -fPIC -c b.c -o b.o</code>产生位置无关代码</p><p>​    生成静态库gcc -c b.c -o b.o</p><p>​    <code>ar -cr libmytest.a b.o</code>生成静态库</p><p>gcc选项:</p><p>​        -fPIC：产生位置无关代码</p><p>​        –share：生成一个共享库而不是可执行程序</p><p>​    ar：静态库打包所有命令</p><p>​        -c 创建</p><p>​        -r 替换</p><h5 id="建立动态库"><a href="#建立动态库" class="headerlink" title="建立动态库"></a>建立动态库</h5><p>生成动态库gcc -fPIC -c b.c -o b.o    </p><p><code>gcc --share b.o -o libmytest.so</code>生成动态库</p><h5 id="库的使用"><a href="#库的使用" class="headerlink" title="库的使用"></a>库的使用</h5><p>动态库—&gt;libmytest.so        静态库—&gt;libmytest.a</p><p><strong>同名动态和静态库，先链接动态库</strong></p><p>链接库的时候：gcc a.c -o main -lmytest。如果报错，找不到库(链接库的查找路径—-库的查找路径)</p><p>库链接的时候和运行加载的时候都需要在指定目录下</p><p>库文件的默认查找路径/lib64    /usr/lib64</p><p>设置环境变量：LIBRARY_PATH=.(库的链接路径)——&gt;使用选项 ’-L‘</p><p>因为gcc默认是动态链接—因此优先使用动态库生成可执行程序</p><p><strong>注意！</strong></p><p>通常我们自己链接静态库生成可执行程序的时候，并不是使用-static静态链接，而是将静态库放到指定路径下，然后直接使用gcc -L选项指定库的链接路径链接静态库生成可执行程序</p><p>-static：作用是可执行程序使用静态链接生成，不依赖任何动态库</p><h4 id="关于基础IO的总结"><a href="#关于基础IO的总结" class="headerlink" title="关于基础IO的总结"></a>关于基础IO的总结</h4><p>最重要的还是区分系统调用和库函数调用的区别和用法。在不同的语言中有着不同的用法，Linux下的使用可能还要考虑到进程的创建，程序替换等操作。</p><p>还有就是文件系统的理解与inode节点的作用，磁盘的分配有着独特的规则，通过inode来调用分配空间的使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;文件的输入输出在c语言之前了解过。比如标准库的IO接口&lt;/p&gt;
&lt;h4 id=&quot;回顾C语言的库函数&quot;&gt;&lt;a href=&quot;#回顾C语言的库函数&quot; class=&quot;headerlink&quot; title=&quot;回顾C语言的库函数&quot;&gt;&lt;/a&gt;回顾C语言的库函数&lt;/h4&gt;&lt;p&gt;fopen，f
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://skrskr66.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程控制</title>
    <link href="https://skrskr66.github.io/2019/04/08/Linux%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <id>https://skrskr66.github.io/2019/04/08/Linux进程控制/</id>
    <published>2019-04-08T11:53:27.000Z</published>
    <updated>2019-04-21T09:22:30.897Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的Linux进程概念中提到了一些关于进程的创建。进程的创建通过fork函数创建子进程。</p><h4 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h4><p>进程终止顾名思义，进程结束。但是结束有各种可能，可能成功，可能失败，也可能异常。</p><h5 id="进程常见退出方法"><a href="#进程常见退出方法" class="headerlink" title="进程常见退出方法"></a>进程常见退出方法</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">正常退出</span><br><span class="line">1、从main返回 return</span><br><span class="line">2、调用exit</span><br><span class="line">3、_exit</span><br><span class="line">异常退出</span><br><span class="line">ctrl + c</span><br></pre></td></tr></table></figure><h5 id="exit函数"><a href="#exit函数" class="headerlink" title="exit函数"></a>exit函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></span><br><span class="line"><span class="keyword">void</span> _exit(<span class="keyword">int</span> status);</span><br><span class="line">参数：status 定义了进程的终止状态，父进程通过wait来获取该值 </span><br><span class="line">说明：虽然status是<span class="keyword">int</span>，但是仅有低<span class="number">8</span>位可以被父进程所用。</span><br><span class="line">所以_exit(<span class="number">-1</span>)时，在终端执行$?发现返回值 是<span class="number">255</span>。</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;    </span></span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </span><br><span class="line">  <span class="keyword">int</span> pid = fork();    </span><br><span class="line">  <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;    </span><br><span class="line">    perror(<span class="string">"fork error"</span>);    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork error:%s\n"</span>,strerror(errno));    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;    </span><br><span class="line">  <span class="keyword">for</span>( ;i &lt; <span class="number">256</span>; i++)&#123;    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"errno:[%s]\n"</span>,strerror(i));    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"hello bit"</span>);    </span><br><span class="line">  sleep(<span class="number">1</span>);    </span><br><span class="line">  _exit(<span class="number">257</span>);            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这之中调用的是_exit函数，关于这两个函数，并没有什么太大的区别，<code>exit()</code>就是对<code>-exit</code>进行的一个分装。通过man手册可以详细了解。</p><p>_ exit()的退出是简单粗暴的，exit()还做了一些其他的工作。可自行查看</p><p>他们俩的共同点就是都会关闭文件描述符，都会清空内存，但是exit还会额外地清空输入输出流缓存，移除临时创建的文件，调用注册好的出口函数等等。 </p><h4 id="进程等待"><a href="#进程等待" class="headerlink" title="进程等待"></a>进程等待</h4><p>为什么要进行进程等待？</p><p>之前写过僵尸进程的危害，一个僵尸进程对内存的资源泄漏是积少成多的。一个两个倒没啥，但是如果多了将无法再创建新的进程，并且就连最强大的杀死进程<code>kill -9</code>也无法将其杀死，所以进程等待的必要性是很重要的。当父进程创建一个子进程时，通过进程等待，回收子进程资源，获取子进程的退出信息，而不让其保存在操作系统中。</p><p>总的来说：因为父进程不知道子进程什么时候退出，因此只能在子进程进程创建之后调用wait()，进行进程等待。因为调用wait就是一直在等待子进程的退出。</p><h5 id="进程等待的方法"><a href="#进程等待的方法" class="headerlink" title="进程等待的方法"></a>进程等待的方法</h5><p>wait()接口是一个阻塞函数，功能是等待子进程退出，如果子进程没有退出，一直等待到有子进程退出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span> *status);</span><br><span class="line">函数的返回值：成功返回等待的pid，失败返回<span class="number">-1</span></span><br><span class="line">参数：输出型参数，获取子进程的状态，不关心则可以设置为<span class="literal">NULL</span></span><br></pre></td></tr></table></figure><p>waitpid()函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *status,<span class="keyword">int</span> options);</span><br><span class="line">返回值：    </span><br><span class="line">当正常返回的时候waitpid返回收集到的子进程的进程ID；    </span><br><span class="line">如果设置了选项WNOHANG,而调用中waitpid发现没有已退出的子进程可收集,则返回<span class="number">0</span>；    </span><br><span class="line">如果调用中出错,则返回<span class="number">-1</span>,这时errno会被设置成相应的值以指示错误所在； </span><br><span class="line"></span><br><span class="line">参数：    pid：        </span><br><span class="line">Pid=<span class="number">-1</span>,等待任一个子进程。与wait等效。        </span><br><span class="line">Pid&gt;<span class="number">0.</span>等待其进程ID与pid相等的子进程。    </span><br><span class="line">status:        </span><br><span class="line">WIFEXITED(status): 若为正常终止子进程返回的状态，则为真。（查看进程是否是正常退出）       WEXITSTATUS(status): 若WIFEXITED非零，提取子进程退出码。（查看进程的退出码）    </span><br><span class="line">options:        </span><br><span class="line">WNOHANG: 若pid指定的子进程没有结束，则waitpid()函数返回<span class="number">0</span>，不予以等待。若正常结束，则返回该子进 程的ID。</span><br></pre></td></tr></table></figure><p>第二种wait还是一种封装方式。只不过需要讨论以下status的参数获取。</p><p>status是输出型参数，由操作系统填充。status的使用只在低16位上(因为int类型为4个字节，只用后两个字节，所以用低16位)<img src="/2019/04/08/Linux进程控制/进程控制1.png" alt="进程控制1"></p><p>从图片可以看出status低八位中的低七位保存异常的情况，高八位保存的是我们的数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*进程等待-避免产生建时进程demo*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"fork error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">255</span>);<span class="comment">//此时返回的是1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">while</span> (waitpid(pid, &amp;status, WNOHANG) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"no exit~~~smoking~~\n"</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//低7位为0则正常退出</span></span><br><span class="line">    <span class="keyword">if</span> (!(status &amp; <span class="number">0x7f</span>))  &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child exit code:%d\n"</span>, (status &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//man 2 wait 自行查看这个WIFEXITED的参数返回设置</span></span><br><span class="line">    <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child exit code:%d\n"</span>, WEXITSTATUS(status));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (WIFSIGNALED(status)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"exit signal:%d\n"</span>, WTERMSIG(status));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"打麻将~~~\n"</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>但是waitpid第三个参数可以将waitpid设置为非阻塞，没有子进程退出则立即报错返回0.</strong></p><p><strong>阻塞：为了完成某个功能发起调用，如果当前不具备完成条件，一直等待，直到完成后返回</strong></p><p><strong>非阻塞：为了完成某个功能发起调用，如果当前不具备完成条件，直接报错返回</strong></p><p><img src="/2019/04/08/Linux进程控制/进程控制2.png" alt="进程控制2"></p><p>当自己进程没有退出正在执行sleep函数时，waitpid()一直在运行等待子进程的退出。退出成功后，输出此时status此时右移到低八位的数值—–就是exit()的返回值。然后判断子进程是否正常退出，如果非正常退出将有退出信号。</p><h4 id="进程替换"><a href="#进程替换" class="headerlink" title="进程替换"></a>进程替换</h4><p>父进程创建了子进程，子进程如果总是做着和父进程相同的工作，那么子进程没有太大的意义。所以这时候可以调用exec函数来执行另一个程序。<strong>当进程调用一种exec函数时，该进程的用户空间代码和数据完全被新程序替换</strong>，从新程序的启动例程开始执行。调用exec并不创建新进程，所以调用exec前后该进程的id并未改变。</p><p>也可以这样认为：替换的是程序所运行的程序，将另一段程序加载到内存中，通过页表将原先进程的映射关系，重新建立到新程序在内存中的地址，相当于替换了进程所运行的程序以及所要处理的数据，因此，替换了代码段，重新初始化数据段。</p><p><strong>替换进程正在运行的程序（替换代码段以及运行数据，更行页表，从main函数重新运行）</strong></p><h5 id="替换函数"><a href="#替换函数" class="headerlink" title="替换函数"></a>替换函数</h5><p>通过exec函数群来实现</p><p>execve是系统调用接口，以下是函数群</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ..., <span class="keyword">char</span> * <span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvpe</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure><p>execl(ls,ls,-a,-l,-i,null)    参数是平铺赋予</p><p>execv(/bin/ls,argv)    参数是通过参数数组赋予argv[0]=ls,argv[1]=-a,argv[2]=-l…argv[4]=NULL</p><p><strong>execl与execv区别：参数的赋予是以指针数组赋予还是以不定参数形式赋予</strong></p><p><strong>最后必须将null写入！！！</strong></p><p><strong>最后必须将null写入！！！</strong></p><p><strong>最后必须将null写入！！！</strong></p><p><strong>有无p的区别：是否自动到PATH所制定的路径下找程序文件</strong></p><p><strong>有无e的区别：是否自定义环境变量的区别</strong></p><p><strong>如果带e的话将当前进程的环境变量也将会发生改变。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">    execl(<span class="string">"./env"</span>,<span class="string">"env"</span>,<span class="string">"-l"</span>,<span class="literal">NULL</span>);<span class="comment">//谁调用就对谁进行程序替换</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果 execl() 执行成功，下面执行不到，因为当前进程已经被执行的 ./env 替换了</span></span><br><span class="line">    <span class="comment">//所以执行之后一直都是第一个printf循环执行</span></span><br><span class="line">    <span class="keyword">char</span> *env[<span class="number">32</span>];</span><br><span class="line">    env[<span class="number">0</span>] = <span class="string">"MYENV=10000"</span>;</span><br><span class="line">    env[<span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">char</span> **environ;<span class="comment">//保存环境变量</span></span><br><span class="line">    execle(<span class="string">"./env"</span>,<span class="string">"env"</span>,<span class="string">"-l"</span>,<span class="literal">NULL</span>,environ);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world~~\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>exec 只是用另一个新程序替换了当前进程的正文、数据、堆和栈段（进程替换）</strong> </p><p>不断的强调这句话因为，exec的替换的理解：我们可以想象为我们在当前内存空间中执行的程序替换到一个新的内存空间中。程序将在新的空间中执行</p><p>这里的理解感觉有些繁琐，但是进程替换之后，执行成功之后不会返回，而且exec函数族下面的代码执行不到，只有调用失败了，才会返回-1，失败后从原程序的调用点接着往下执行。</p><p>从物理角度来理解：<strong>将进程的虚拟地址空间所映射在物理内存的区域进行改变，改编成另一个程序中在内存中的位置，更新页表信息，重新初始化虚拟地址空间，为了让进程运行另一个程序</strong></p><h5 id="自主minishell的实现"><a href="#自主minishell的实现" class="headerlink" title="自主minishell的实现"></a>自主minishell的实现</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[liuyucheng@localhost]$ "</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">scanf</span>(<span class="string">"%[^\n]%*c"</span>, buf) != <span class="number">1</span>)&#123;</span><br><span class="line">      getchar();</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取出空白字符，获取程序名称和参数</span></span><br><span class="line">    <span class="keyword">char</span> *argv[<span class="number">32</span>];<span class="comment">//将自己定义的缓冲区的字符放入该数组中</span></span><br><span class="line">    <span class="keyword">int</span> argc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> *ptr = buf;</span><br><span class="line">    <span class="keyword">while</span>(*ptr != <span class="string">'\0'</span>)&#123;</span><br><span class="line">      <span class="comment">//若参数c为空格字符，则返回TRUE，否则返回NULL(0)。</span></span><br><span class="line">      <span class="keyword">if</span>(!<span class="built_in">isspace</span>(*ptr))&#123;</span><br><span class="line">        argv[argc++] = ptr;</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">isspace</span>(*ptr) &amp;&amp; *ptr != <span class="string">'\0'</span>)&#123;</span><br><span class="line">          ptr++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        *ptr = <span class="string">'\0'</span>;            </span><br><span class="line">        ptr++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    argv[argc] = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">int</span> pid = fork();</span><br><span class="line">  <span class="comment">//创建子进程</span></span><br><span class="line">  <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);<span class="comment">//退出返回-1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;<span class="comment">//如果子进程创建成功</span></span><br><span class="line">    execvp(argv[<span class="number">0</span>], argv);<span class="comment">//程序替换,此时argv保存了指令的字符串，替换到argv[0]中，这样execvp自动在当前PATH路径下寻找指令，例如ls，ll</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  wait(<span class="literal">NULL</span>);<span class="comment">//等待子进程退出</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/08/Linux进程控制/进程控制3.png" alt="进程控制3"></p><p>如图则为程序运行。不过cd指令不行。不能跳到另一个文件夹中。</p><p>将所学的几个进程都用到了，很有帮助。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在之前的Linux进程概念中提到了一些关于进程的创建。进程的创建通过fork函数创建子进程。&lt;/p&gt;
&lt;h4 id=&quot;进程终止&quot;&gt;&lt;a href=&quot;#进程终止&quot; class=&quot;headerlink&quot; title=&quot;进程终止&quot;&gt;&lt;/a&gt;进程终止&lt;/h4&gt;&lt;p&gt;进程终止顾名思义
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://skrskr66.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>数据结构之二叉树</title>
    <link href="https://skrskr66.github.io/2019/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://skrskr66.github.io/2019/04/04/数据结构之二叉树/</id>
    <published>2019-04-04T08:13:39.000Z</published>
    <updated>2019-04-20T08:23:33.569Z</updated>
    
    <content type="html"><![CDATA[<h4 id="树的概念"><a href="#树的概念" class="headerlink" title="树的概念"></a>树的概念</h4><p>树是一种<strong>非线性</strong>的结构，它是由n(n&gt;0)个有限结点组成一个具有层次关系的集合。把他叫做树是因为它看起来像一个倒挂的树，它的根是朝上的，但是它的叶是朝下的。</p><p>它具有以下特点：每个节点有零个或多个子结点；没有父结点的称为根节点；每一个非根节点有且只有一个父结点；除了根节点外，每个子节点可以分为多个不相交的子树。</p><p>关于树，还有一些相关知识，我们需要了解。</p><p>节点的度：一个节点含有的子树的个数称为该节点的度。</p><p>双亲节点或父节点：若一个节点含有子节点，那么这个节点就是该子节点的父节点</p><p>孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点</p><p>节点的层次：从根节点开始定义，根为第一次，根的子节点为第二层，以此类推</p><p>树的高度或深度：树中节点的最大层次</p><h4 id="二叉树的概念"><a href="#二叉树的概念" class="headerlink" title="二叉树的概念"></a>二叉树的概念</h4><p>一棵二叉树是节点的一个有限集合，该集合或者为空，或者是由一个根节点加上两棵被称为左子树和右子树的二叉树组成</p><h5 id="二叉树的特点"><a href="#二叉树的特点" class="headerlink" title="二叉树的特点"></a>二叉树的特点</h5><p>1、每个节点最多有两棵子树，即二叉树不存在度大于2的节点。</p><p>2、二叉树的子树有左右之分，其子树的次序不能颠倒。</p><h5 id="二叉树的链式存储"><a href="#二叉树的链式存储" class="headerlink" title="二叉树的链式存储"></a>二叉树的链式存储</h5><p>二叉树的链式存储结构是指，用链表来表示一棵二叉树，即用链来指示元素的逻辑关系。通常的方法是链表中每个节点由三个域组成，数据域和左右指针域，左右指针分别用来给出该节点左孩子和右孩子所在的链节点的存储地址。</p><h5 id="二叉树的代码实现"><a href="#二叉树的代码实现" class="headerlink" title="二叉树的代码实现"></a>二叉树的代码实现</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//定义一个二叉树节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">right</span>;</span></span><br><span class="line">    <span class="keyword">char</span> value;</span><br><span class="line">&#125; Node;</span><br></pre></td></tr></table></figure><p>树的枝干是向外不断地延伸出去的，那么二叉树的节点链接也是。有三种方式可以遍历二叉树，也就是我们常说的前序遍历，中序遍历，后序遍历。</p><p><img src="/2019/04/04/数据结构之二叉树/二叉树1.png" alt="二叉树1"></p><p>以前的我对于二叉树的遍历也不是很懂，但是学完之后，我就记住了这一个方法。我个人觉得这样记忆是最好的。就是经过节点的次数。</p><p>如果是前序遍历，当第一次经过该节点时就将该节点记录。中序遍历，当第二次经过该节点时就将该节点记录。后序遍历，当第三次经过该节点时就将该节点记录。但是最后的每个左子树或者右子树也要遍历是否是空节点。这样才能全部遍历生成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Preorder</span><span class="params">(Node *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,root-&gt;value);</span><br><span class="line">        Preorder(root-&gt;left);</span><br><span class="line">        Preorder(root-right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inorder</span><span class="params">(Node *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        Inorder(root-&gt;left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,root-&gt;value);</span><br><span class="line">        Inorder(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Postorder</span><span class="params">(Node *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        Postorder(root-&gt;left);</span><br><span class="line">        Postorder(root-&gt;right);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,root-&gt;value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码看起来是很简单，主要需要记住的就是前中后序的特点。</p><p>前序—根，左子树，右子树</p><p>中序—左子树，根，右子树</p><p>后序—左子树，右子树，根</p><p>但是递归的特点就是代码简单，所需要的就是<strong>找到终止条件，返回上一层。</strong></p><p><strong>还是代码学习知识！！！</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建二叉树结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateNode</span><span class="params">(<span class="keyword">char</span> v)</span></span>&#123;</span><br><span class="line">    Node *node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    node-&gt;value = v;</span><br><span class="line">    node-&gt;left = node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回该二叉树的总节点数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetSize</span><span class="params">(Node *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = GetSize(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right = GetSize(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left + right + <span class="number">1</span>;<span class="comment">//不要忘了根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回叶子节点的数量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetLeafSize</span><span class="params">(Node *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//如果没有左右子树，直接记录该子树的父结点</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> GetLeafSize(root-&gt;left) + GetLeafSize(root-&gt;right);<span class="comment">//叶子节点递归查询</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>递归中有一个返回值之后将跳到上一层，在上一层之后将寻找层中合适的出口在返回上上一层。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回二叉树的层数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetHeight</span><span class="params">(Node *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = GetHeight(root-&gt;left) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = GetHeight(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (left &gt; right ? left : right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历根节点的左右两个节点，谁返回的数值大，那么这个数就是层数</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回K层中的节点个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetKLevelSize</span><span class="params">(Node *root, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = GetKLevelSize(root-&gt;left, k<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> right = GetKLevelSize(root-&gt;right, k<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> left + right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二叉树的查找</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通二叉树的查找</span></span><br><span class="line"><span class="comment">// 如果找到了，返回 v 所在结点的地址</span></span><br><span class="line"><span class="comment">// 如果没找到，返回 NULL</span></span><br><span class="line"><span class="comment">// 先去根里找</span></span><br><span class="line"><span class="comment">// 如果没找到，再去左子树找</span></span><br><span class="line"><span class="comment">// 如果还没找到，再去右子树找</span></span><br><span class="line"><span class="comment">// 在空树里找的结果，一定找不到，return NULL</span></span><br><span class="line"><span class="function">Node *<span class="title">Find</span><span class="params">(Node *root, <span class="keyword">char</span> v)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>判断是否是相同的二叉树</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSame</span><span class="params">(Node *p, Node *q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span> &amp;&amp; q ==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ture;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span> || q == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;value == p-&gt;value &amp;&amp; isSame(p-&gt;left, q-&gt;left) &amp;&amp; isSame(p-&gt;right, q-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>另一颗树的子树</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">preorder</span><span class="params">(Node *root, Node *t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isSame(root, t))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="comment">//如果t就是root的一个子树，直接返回true</span></span><br><span class="line">        <span class="keyword">if</span>(preorder(root-&gt;left, t) == <span class="literal">true</span>)&#123;<span class="comment">//如果在左子树中找到t子树，直接返回true，否则直接去右子树中查找</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preorder(root-&gt;right, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flase;<span class="comment">//如果都没找到直接返回false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(Node *s, Node *t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> preorder(s,t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二叉树的构建及遍历</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node *<span class="title">CreatTree</span><span class="params">(<span class="keyword">char</span> preorder[], <span class="keyword">int</span> size, <span class="keyword">int</span> *used)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如下图所示，数组保存的是前序遍历的一棵二叉树，#代表的是NULL</span></span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">        *used = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(preorder[<span class="number">0</span>] == <span class="string">'#'</span>)&#123;<span class="comment">//#也占了一个数组的*used，所以+1</span></span><br><span class="line">        *used = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node *root = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="comment">//先定义一个父节点</span></span><br><span class="line">    <span class="keyword">int</span> leftUesd;</span><br><span class="line">    root-&gt;left = CreatTree(preorder + <span class="number">1</span>, size - <span class="number">1</span>, &amp;leftUsed);</span><br><span class="line">    <span class="comment">//根的左子数为：递归中数组中下一个的数，数组的容量-1，将左子树用的值返回</span></span><br><span class="line">    <span class="keyword">int</span> rightUsed;</span><br><span class="line">    root-&gt;right = CreatTree(preorder + <span class="number">1</span> + leftUsed, size - <span class="number">1</span> - leftUsed, &amp;rightUsed);</span><br><span class="line">    </span><br><span class="line">    *used = <span class="number">1</span> + leftUsed + rightUsed;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/04/数据结构之二叉树/二叉树2.png" alt="二叉树2"></p><p>在二叉树的递归中，不用特别明确的想出具体的递归路线。当为<code>root-&gt;left</code>那么此时一直都走的是左子树，反之一直都走的右子树。关键还是在于终止条件的寻找，只要找到了终止条件，那么递归才可一层一层的向上返回。</p><p>前中后序组合找出二叉树。怎么组合可以找出？</p><p>前序    找根最方便，preorder[0]</p><p>中序    分割左右子树最方便</p><p>后序    找根最方便，preorder[size - 1]</p><p>答案一目了然，只有<strong>前序+中序</strong>和<strong>后序+中序</strong>。前序+后序的组合，都是找根，那么左右子树的划分就不方便了。这样遍历起来明显有问题</p><p>就比如生活中，工作应该配合做才能更快，如果是两个做相同事情的人，那么工作总有一部分完成不了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Find</span><span class="params">(<span class="keyword">char</span> <span class="built_in">array</span>[], size, v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>[i] == v)&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//利用中序和后序进行创建二叉树</span></span><br><span class="line"><span class="function">Node *<span class="title">buildtree</span><span class="params">(<span class="keyword">char</span> inorder[], <span class="keyword">char</span> postorder[], <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> rootValue = postorder[size - <span class="number">1</span>];<span class="comment">//记录根节点的值，对于前后序不是第一个就是最后一个</span></span><br><span class="line">    <span class="keyword">int</span> leftsize = Find(inorder,size,rootValue);<span class="comment">//查找的是中序数组中左子树的个数</span></span><br><span class="line">    </span><br><span class="line">    Node *root = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    root-&gt;value = rootValue;</span><br><span class="line">    <span class="comment">//左子树不断的向下个递归创建。</span></span><br><span class="line">    root-&gt;left = buildtree(inorder, postorder, leftsize);</span><br><span class="line">    root-&gt;right = buildtree(inorder + leftsize + <span class="number">1</span>,postorder + leftsize,size - <span class="number">1</span> - leftsize);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/04/数据结构之二叉树/二叉树3.png" alt="二叉树3"></p><p>那么可以试下写前序和中序组合的方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比如上图这个组合</span></span><br><span class="line"><span class="function">Node *<span class="title">buildtree</span><span class="params">(<span class="keyword">char</span> postorder[], <span class="keyword">char</span> inorder[], <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> treeValue = postorder[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> leftused = Find(inorder, size, treeValue);</span><br><span class="line">    Node *root = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    </span><br><span class="line">    root-&gt;value = treeValue;</span><br><span class="line">    buildtree(postorder + <span class="number">1</span>, inorder, leftused);</span><br><span class="line">    buildtree(postorder + leftused + <span class="number">1</span>,inorder + <span class="number">1</span> + leftsize, size - <span class="number">1</span> - leftsize);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h4><p><strong>堆是一种逻辑上的完全二叉树，利用顺序存储，存在数组里。</strong></p><p>二叉堆用的是顺序存储的方式，更多用在完全二叉树。</p><p>任取一个节点，要求根的值 &gt;= 左右孩子的值（大堆）</p><p>任取一个节点，要求根的值 &lt;= 左右孩子的值（小堆）</p><p>作用：找最大值，永远出现在二叉树的根</p><p>操作：向下调整，为了调整成小堆，不断的向下将大的节点往下放(这个可以认为是寻找最小值)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustDown</span><span class="params">(<span class="keyword">char</span> <span class="built_in">array</span>[], <span class="keyword">int</span> size, <span class="keyword">int</span> rootIdx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> leftIdx = rootIdx * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> rightIdx = rootIdx * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(leftIdx &gt; size)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> min = leftIdx;</span><br><span class="line">    <span class="keyword">if</span>(rightIdx &lt; size &amp;&amp; rightIdx &lt; leftIdx)&#123;</span><br><span class="line">        min = rightIdx;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">array</span>[min] &gt;= <span class="built_in">array</span>[rootIdx])&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="built_in">array</span>[min];</span><br><span class="line">    <span class="built_in">array</span>[min] = <span class="built_in">array</span>[rootIdx];</span><br><span class="line">    <span class="built_in">array</span>[rootIdx] = tmp;</span><br><span class="line">    </span><br><span class="line">    AdjustDown(<span class="built_in">array</span>, size, min);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的都是怎么调整堆，那么怎么<strong>将一个完全无序的随机分布的数组变成满足堆的性质？</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateHeap</span><span class="params">(<span class="keyword">int</span> tree[], <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="comment">//最后一个节点的下标是 size - 1</span></span><br><span class="line">    <span class="comment">//最后一个非子叶节点就是最后一个节点的双亲</span></span><br><span class="line">    <span class="comment">//parent = (child - 1) / 2;</span></span><br><span class="line">    <span class="comment">//带入之后得 （size - 2） / 2</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = (size - <span class="number">2</span>) / <span class="number">2</span>;i &gt;= <span class="number">0</span>;i++)&#123;</span><br><span class="line">        AdjustDown(tree, size, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/04/数据结构之二叉树/二叉树4.png" alt="二叉树4"></p><p>这些只能算是初步了解了二叉树的逻辑和算法，毕竟二叉树不仅仅需要递归，非递归也是可以完成的。而且关于二叉堆只是仅仅懂了方法，还是不太知道具体的使用位置。学习还是得不断努力呀！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;树的概念&quot;&gt;&lt;a href=&quot;#树的概念&quot; class=&quot;headerlink&quot; title=&quot;树的概念&quot;&gt;&lt;/a&gt;树的概念&lt;/h4&gt;&lt;p&gt;树是一种&lt;strong&gt;非线性&lt;/strong&gt;的结构，它是由n(n&amp;gt;0)个有限结点组成一个具有层次关系的集合。把他叫
      
    
    </summary>
    
    
      <category term="C-数据结构" scheme="https://skrskr66.github.io/tags/C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程概念</title>
    <link href="https://skrskr66.github.io/2019/03/31/Linux%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5/"/>
    <id>https://skrskr66.github.io/2019/03/31/Linux进程概念/</id>
    <published>2019-03-31T15:09:31.000Z</published>
    <updated>2019-04-04T08:08:05.663Z</updated>
    
    <content type="html"><![CDATA[<p>进程是什么？在操作系统中，我们经常能听到这样的话。我们要终止一个进程或者杀死一个进程，父进程创建了子进程这一类的话。往往我们听到都会觉得很高大上，这跟编程语言完全不同的感觉，操作了整个计算机。</p><h3 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h3><h4 id="冯诺依曼体系结构"><a href="#冯诺依曼体系结构" class="headerlink" title="冯诺依曼体系结构"></a>冯诺依曼体系结构</h4><p>在进程之前首先要提一下我们的“祖师爷”——冯诺依曼体系结构。</p><p>这个是一个计算机入门第一节课必然会提到的知识。</p><p>冯诺依曼体系结构提出了计算机采用二进制；计算机应该按照程序顺序执行。</p><p>它由<strong>输入设备，输出设备，存储器，控制器，运算器</strong>组成</p><p>注意！注意！注意！</p><p>1、这里的存储器指的是内存。</p><p>2、不考虑缓存情况，这里的cpu（控制器+运算器）只能对内存进行读写，不能访问外设（输入或输出设备）</p><p>3、外设要输入或输出数据，也只能写入内存或者从内存中读取</p><h4 id="操作系统（0S）"><a href="#操作系统（0S）" class="headerlink" title="操作系统（0S）"></a>操作系统（0S）</h4><p>任何计算机系统都包含一个基本的程序集合，称为操作系统(OS)</p><p>操作系统的存在就是让计算机更加的好用，能更方便的、统筹合理的管理计算机的软硬件资源。</p><p>那么是怎么管理的？</p><p>我们可以先举一个例子，学校的管理，首先我们被辅导员统一管理，辅导员又由院内领导管理，院内领导又由校长管理。</p><p>学生-&gt;辅导员-&gt;院内领导-&gt;校长    这么一个层次结构。但在这之前管理需要制定一个制度来管理，每一个层次的人都遵守这个制度。这样才能按部就班的进行工作的分配。</p><p>那么操作系统也一样。总的来说就是：<strong>先描述，再组织</strong></p><p><strong>描述用struct结构体，比如进程有task_struct这样一个结构体来描述</strong></p><p><strong>组织可以用链表或者其他高效的数据结构</strong></p><h5 id="系统调用和库函数概念"><a href="#系统调用和库函数概念" class="headerlink" title="系统调用和库函数概念"></a>系统调用和库函数概念</h5><p>在开发角度，操作系统对外会表现一个整体，但是会暴露自己的部分接口，供上层开发使用，这部分由操作系统提供的接口，叫做系统调用。</p><p>系统调用在使用上，功能比较基础，对用户的要求也相对比较高，所以，有心的开发者可以对部分系统调用进行适度封装，从而形成了库，有了库，就很有利于更上层用户或者开发者进行二次开发</p><h4 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h4><p>从用户角度：进程就是一个正在运行中的程序。</p><p>操作系统角度：操作系统运行一个程序，需要描述这个程序的运行过程，这个描述通过一个结构体task_struct{}来描述，统称为PCB，因此对操作系统来说进程就是PCB(process control block)程序控制块</p><p>进程的描述信息有：标识符PID，进程状态，优先级，程序计数器，上下文数据，内存指针，IO状态信息，记账信息。都需要操作系统进行调度。</p><p>那么在Linux操作系统下，怎么查看进程呢</p><h4 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h4><p>输入<code>ls /porc</code>指令即可</p><p><img src="/2019/03/31/Linux进程概念/进程1.png" alt="进程1"></p><p>前面蓝色数字代表的进程的ID。如果你想查看PID为1的进程信息，你需要查看<code>/porc/1</code>这个文件夹</p><p>我们也可以使用<code>ps -ef -aux</code>指令来直接显示进程状态</p><p><img src="/2019/03/31/Linux进程概念/进程2.png" alt="进程2"></p><p>还有getpid()和getppid()这两个函数用来查看当前程序的进程和父进程PID。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"getpid:%d"</span>,getpid());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"getppid:%d"</span>,getppid());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h4><p>Linux中非常重要的函数——<code>fork()</code>，它从已存在的进程中创建一个新进程。新进程为子进程，而原进程为父进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>);</span><br><span class="line">返回值：</span><br><span class="line">父进程：返回值大于<span class="number">0</span>，子进程的pid</span><br><span class="line">子进程：返回值等于<span class="number">0</span></span><br></pre></td></tr></table></figure><p>写这么个程序来初始fork函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;   </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"parent pid:%d\n"</span>,getpid());    </span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">100</span>;    </span><br><span class="line">  <span class="keyword">pid_t</span> pid = fork();    </span><br><span class="line">  <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;    </span><br><span class="line">    a = <span class="number">20</span>;    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child !! pid:%d----a:%d--%p\n"</span>,getpid(),a ,&amp;a);    </span><br><span class="line">    </span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;    </span><br><span class="line">    sleep(<span class="number">1</span>);    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"parent !! pid:%d----a:%d--%p\n"</span>,getpid(), a, &amp;a);    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"nihaoa %d\n"</span>,a);    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于fork函数需要理解，每当调用一次fork函数时，会返回两个两次。一次是在调用进程中（父进程）返回一次，返回值是新派生的进程的进程ID。一次是在子进程中返回，返回值是0，代表当前进程为子进程。如果返回-1，那么则代表在创建子进程的过程中出现了错误。</p><p>将上面代码执行之后</p><p><img src="/2019/03/31/Linux进程概念/进程3.png" alt="进程3"></p><p>先返回了子进程的pid，之后再返回了父进程的pid。</p><p>fork()相当于创建了一个新的子进程，但是拷贝的是fork()函数之后的所有数据，之前的并不会拷贝。在代码之上就可以看到parentpid只打印了一次</p><p><strong>总的来说：复制pcb，代码共享，但是子进程并非从头开始，而是从fork()函数之后开始，数据独有</strong></p><p>借用一下网上大佬对fork()的理解</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(1)一个进程进行自身的复制，这样每个副本可以独立的完成具体的操作，在多核处理器中可以并行处理数据。这也是网络服务器的其中一个典型用途，多进程处理多连接请求。 </span><br><span class="line">(2)一个进程想执行另一个程序。比如一个软件包含了两个程序，主程序想调起另一个程序的话，它就可以先调用fork来创建一个自身的拷贝，然后通过exec函数来替换成将要运行的新程序。</span><br></pre></td></tr></table></figure><p>那么创建子进程的意义是什么————<strong>压力分摊/干其他工作</strong></p><h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><p>进程状态一般有：就绪态，阻塞态，运行态</p><p>在Linux下：R运行状态，S睡眠状态，D磁盘休眠状态，T停止状态，X死亡状态</p><p>这些当我们使用指令<code>ps -aux</code>就可以看到</p><h5 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h5><p>在进程状态中有两个比较特殊的存在。僵尸和孤儿</p><p>僵尸进程是进程退出后，但是资源没有释放，处于僵死状态的进程。</p><p>产生原因：子进程先于父进程退出，操作系统检测到进程的退出，通知父进程，但是父进程这时候正在执行其他操作，没有关注这个通知，这时候操作系统为了保护子进程，不会释放子进程资源，因为子进程的PCB中包含有退出原因。这时候因为既没有运行也没有退出，因此处于僵死状态，成为僵尸进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;                                                                                                         </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">  <span class="keyword">pid_t</span>  pid;    </span><br><span class="line">  <span class="comment">//循环创建子进程    </span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)    </span><br><span class="line">  &#123;    </span><br><span class="line">    pid = fork();    </span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)    </span><br><span class="line">    &#123;    </span><br><span class="line">      perror(<span class="string">"fork error:"</span>);    </span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)    </span><br><span class="line">    &#123;    </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"I am a child process.\nI am exiting.\n"</span>);    </span><br><span class="line">  <span class="comment">//子进程退出，成为僵尸进程    </span></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">    &#123;    </span><br><span class="line">      <span class="comment">//父进程休眠20s继续创建子进程    </span></span><br><span class="line">      sleep(<span class="number">20</span>);    </span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;       </span><br><span class="line">  &#125;      </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;                            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行这上面这个程序，子进程中途退出了。</p><p><img src="/2019/03/31/Linux进程概念/进程4.png" alt="进程4"></p><p><img src="/2019/03/31/Linux进程概念/进程5.png" alt="进程5"></p><p>z+这个标志就是僵尸进程的标志。</p><p>那么怎么避免僵尸进程的产生？</p><p>我们一般<strong>处理就是关闭父进程</strong>，这样僵尸子进程也随之消失了。</p><p>所以我们最好设置<strong>进程等待</strong>，等待子进程完成了工作，并且通知了父进程之后，在退出。</p><h5 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h5><p>孤儿进程与僵尸进程在理解上可以认为相反。</p><p>父进程先于子进程退出，父进程退出后，子进程成为后台进程，并且父进程为1号进程。</p><p>守护进程：特殊（脱离了与终端的关联+会话的关联）的孤儿进程    </p><h4 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h4><p>优先级：决定资源的优先分配权的等级划分</p><p>那么进程为什么具有优先级呢？</p><p><strong>为了让操作系统的运行更加的合理——交互式进程（一旦有操作优先处理）和批处理进程（一直处理程序，但对CPU要求不高）</strong></p><p>设置优先级，可以使用指令<code>ps -elf</code>先查看进程</p><p>可以看到 PRI 和 NI这两个数值</p><p>PRI：优先级    NI：nice值</p><p>PRI是无法直接调整的，但是可以通过调整nice值来调整优先级的大小</p><p>PRI = PRI + NI，但是NI也是有范围的——(-20~19)</p><p>指令操作为<code>renice -n size -p pid</code></p><p>运行时操作为<code>nice -n size ./main(可执行文件)</code></p><p>这里稍微提一下，程序在运行时具有并行和并发两种执行。</p><p>并行：CPU资源足够，多个程序同时运行</p><p>并发：CPU资源不够，多个程序切换调度运行（可以看看我之前的一篇关于操作系统的博客，有关调度方法的介绍）</p><p><img src="/2019/03/31/Linux进程概念/进程6.png" alt="进程6"></p><p>Linux下指令<code>top</code>指令可以查看进程的优先级</p><p>进入top后按<code>“r”–&gt;输入进程PID–&gt;输入nice值</code></p><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>环境变量是保存系统运行环境参数的变量</p><p>环境变量在安装java的过程中，可能接触过，需要进入系统环境变量，然后设置PATH添加java的路径</p><p>在Linux下可以通过命令指令自己设置</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo 通过变量名称，查看指定环境变量</span><br><span class="line">env 查看所有环境变量</span><br><span class="line">set 查看环境变量以及临时变量</span><br><span class="line">export 声明一个环境</span><br><span class="line">unset 删除一个临时变量</span><br></pre></td></tr></table></figure><p>常见的环境变量：HOME SHELL USER PATH</p><p><img src="/2019/03/31/Linux进程概念/进程7.png" alt="进程7"></p><p><strong>环境变量的全局特性：在子进程中获取继承于父进程的环境变量信息</strong></p><p>三种获取环境变量的参数</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argc[],<span class="keyword">char</span> *env[])参数获取</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;全局变量获取</span><br><span class="line"></span><br><span class="line">char *getenv(const char *env_name)接口获取</span><br></pre></td></tr></table></figure><p>写一个获取变量的demo</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;    </span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;    </span></span></span><br><span class="line">      </span><br><span class="line">W&gt;<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[], <span class="keyword">char</span> *env[])</span></span>&#123;    </span><br><span class="line">    <span class="comment">//main函数的参数值是从操作系统命令行上获得的。当我们要运行一个可执行文件时，在DOS提示符下键入文件名，再输入实际参数&gt;  即可把这些实参传送到main的形参中去。        </span></span><br><span class="line">    <span class="comment">//C:\&gt;可执行文件名 参数 参数……    </span></span><br><span class="line">    <span class="comment">//argv参数是字符串指针数组，其各元素值为命令行中各字符串(参数均按字符串处理)的首地址    </span></span><br><span class="line">    <span class="comment">//env：字符指针的数组，每一个元素是指向一个环境变量的字符指针                                                       </span></span><br><span class="line">    <span class="keyword">int</span> i;                                      </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; argc; i++)&#123;                   </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"argv[%d]=[%s]\n"</span>,i , argv[i]);     </span><br><span class="line">    &#125;                                            </span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">char</span> **environ;                       </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;environ[i] != <span class="literal">NULL</span>;i++)&#123;           </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"env[%d]=[%s]\n"</span>,i, environ[i]);    </span><br><span class="line">    &#125;                               </span><br><span class="line">    <span class="keyword">char</span> *ptr = getenv(<span class="string">"MYENV"</span>);    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"MYENV:[%s]\n"</span>,ptr);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                 </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/03/31/Linux进程概念/进程8.png" alt="进程8"></p><p>如果输入<code>export MYENV=&quot;10000&quot;</code>，在运行程序</p><p>MYENV将变成<code>MYENV:[10000]</code></p><h4 id="程序地址空间"><a href="#程序地址空间" class="headerlink" title="程序地址空间"></a>程序地址空间</h4><table><thead><tr><th style="text-align:center">内核空间</th></tr></thead><tbody><tr><td style="text-align:center">运行参数/环境变量</td></tr><tr><td style="text-align:center">栈</td></tr><tr><td style="text-align:center">栈区（从上往下取）中间有共享区</td></tr><tr><td style="text-align:center">堆区（从下往上取）中间有共享区</td></tr><tr><td style="text-align:center">堆</td></tr><tr><td style="text-align:center">初始化全局数据</td></tr><tr><td style="text-align:center">未初始化全局数据</td></tr><tr><td style="text-align:center">代码段</td></tr></tbody></table><p>地址是什么？地址是内存的编号，指向内存的一块区域</p><p>虚拟地址空间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mm_struct&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> size</span><br><span class="line">code_start</span><br><span class="line">code_end</span><br><span class="line">data_start</span><br><span class="line">a</span><br><span class="line">data_end</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/03/31/Linux进程概念/进程9.png" alt="进程9"></p><p>上图之中，中间的物理内存地址，两边的为虚拟内存地址。</p><p>右边是父进程将虚拟地址通过页表查找到物理内存的地址，这时父进程在运行一个程序。此时父进程又创建了一个子进程(图最右)。子进程也通过页表找到物理内存的地址，这时子进程运行的程序在物理内存的另一个新空间运行。</p><p>这是虚拟内存地址使用的过程。它的作用就是保持进程的独立性，通过页表映射物理地址，充分的利用物理地址，增加内存访问控制。</p><p>这就是进程有关的知识。总结一下</p><p>进程从用户角度和操作系统角度去理解。前者就是一个运行的程序，后者表示运行一个程序，需要描述一个程序的运行过程，通过一个结构体task_struct{}来描述，叫做PCB。对操作系统来说，进程就是PCB</p><p>进程的创建需要一个我们必须要掌握的函数——fork()函数，创建一个子进程。并且fork()函数会有两个返回值，在返回的过程中父进程之前的数据不进行拷贝，之后与父进程的运行一致。创建子进程是为了分摊压力/干其他工作</p><p>进程的状态有运行态，睡眠状态，磁盘休眠状态，停止状态，死亡状态。每一种状态是容易理解的。但是还有两个特殊的进程</p><p>僵尸进程和孤儿进程，<strong>前者</strong>是进程退出后资源没有释放，操作系统通知父进程，但是父进程此时正在处理其他事情，没有关注子进程的退出通知，系统为了保护资源，没有释放掉，并且在子进程的PCB中也保留了退出原因，此时既没有运行也没有完全退出，处于了僵死状态。但是<strong>后者</strong>是父进程先于子进程先退出，子进程成为了后台程序，由一号进程接管。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;进程是什么？在操作系统中，我们经常能听到这样的话。我们要终止一个进程或者杀死一个进程，父进程创建了子进程这一类的话。往往我们听到都会觉得很高大上，这跟编程语言完全不同的感觉，操作了整个计算机。&lt;/p&gt;
&lt;h3 id=&quot;进程的概念&quot;&gt;&lt;a href=&quot;#进程的概念&quot; clas
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://skrskr66.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux的文件权限</title>
    <link href="https://skrskr66.github.io/2019/03/30/Linux%E7%9A%84%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/"/>
    <id>https://skrskr66.github.io/2019/03/30/Linux的文件权限/</id>
    <published>2019-03-30T09:15:58.000Z</published>
    <updated>2019-03-30T10:45:28.961Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Linux的权限"><a href="#Linux的权限" class="headerlink" title="Linux的权限"></a>Linux的权限</h3><p>Linux下有三种用户，普通用户和超级用户和系统用户</p><p>超级用户就是我们所说的root，普通用户是我们自己所创建的一个用户，能在有限的权限内进行操作。</p><p>系统用户是<a href="https://www.baidu.com/s?wd=Linux%E7%B3%BB%E7%BB%9F&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">Linux系统</a>正常工作所必需的内建的用户，主要是为了满足相应的系统进程对文件属主的要求而建立的，系统用户不能用来登录，如bin、daemon、adm、lp等用户。 </p><h4 id="Linux权限的管理"><a href="#Linux权限的管理" class="headerlink" title="Linux权限的管理"></a>Linux权限的管理</h4><h5 id="文件访问者的管理"><a href="#文件访问者的管理" class="headerlink" title="文件访问者的管理"></a>文件访问者的管理</h5><p>文件访问者的管理分为：文件和文件目录的所有者u—user、文件和文件目录的所有者的组的用户g—group、其他用户o—others.</p><h5 id="文件类型和访问权限"><a href="#文件类型和访问权限" class="headerlink" title="文件类型和访问权限"></a>文件类型和访问权限</h5><p><img src="/2019/03/30/Linux的文件权限/权限1.png" alt="权限1"></p><p>上图是我在我的云服务器上输入<code>ll</code>指令出来的当前文件夹下的文件显示</p><p><strong>d</strong>代表的<strong>文件类型</strong>，在这之外还有许多文件类型</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">d：文件夹</span><br><span class="line">-：普通文件</span><br><span class="line">l：软链接（类似windows的快捷方式）</span><br><span class="line">b：块设备文件（例如硬盘、光驱等）</span><br><span class="line">p：管道文件</span><br><span class="line">c：字符设备文件</span><br><span class="line">s：套接口文件（socket）</span><br></pre></td></tr></table></figure><p><strong>rwxr-xr-x</strong>这代表的是权限，每三个代表的是文件访问者的管理。前三位是user的权限，中间三位是group的权限，后三位是其他用户的权限。</p><p><strong>rwx</strong>又分别为可读文件，可写文件，可执行文件。</p><p>读（r/4）：Read对文件而言，具有读取文件内容的权限；对目录来说，具有浏览该目录信息的权限</p><p>写（w/2）：Write对文件而言，具有修改文件内容的权限；对目录来说具有删除移动目录内文件的权限</p><p>执行（x/1）：execute对文件而言，具有执行文件的权限；对目录来说，具有进入目录的权限</p><p>“—”：表示不具有该项权限</p><table><thead><tr><th>Linux表示</th><th>说明</th><th>Linux表示</th><th>说明</th></tr></thead><tbody><tr><td>r–</td><td>只读</td><td>-w-</td><td>仅可写</td></tr><tr><td>–x</td><td>仅可执行</td><td>rw-</td><td>可读可写</td></tr><tr><td>-wx</td><td>可写和可执行</td><td>r-x</td><td>可读可执行</td></tr><tr><td>rwx</td><td>可读可写可执行</td><td>—</td><td>无权限</td></tr></tbody></table><p>8进制数值表示法</p><table><thead><tr><th>权限符号</th><th>八进制</th><th>二进制</th></tr></thead><tbody><tr><td>r</td><td>4</td><td>100</td></tr><tr><td>w</td><td>2</td><td>010</td></tr><tr><td>x</td><td>1</td><td>001</td></tr><tr><td>rw</td><td>6</td><td>110</td></tr><tr><td>rx</td><td>5</td><td>101</td></tr><tr><td>wx</td><td>3</td><td>011</td></tr><tr><td>rwx</td><td>7</td><td>111</td></tr><tr><td>—</td><td>0</td><td>000</td></tr></tbody></table><h5 id="文件访问权限的相关方法"><a href="#文件访问权限的相关方法" class="headerlink" title="文件访问权限的相关方法"></a>文件访问权限的相关方法</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chomd </span><br><span class="line">设置文件的访问权限</span><br><span class="line">格式：chmod [参数] 权限 文件名</span><br></pre></td></tr></table></figure><p>这是最常用的文件访问，它的使用有两种方式</p><p>1、<code>chmod u+w filename</code>，<code>chmod o-x filename</code></p><p>通过用户表示符 +/-= 权限字符</p><p>这里用户表示符还有<code>a</code>,代表了所有文件访问管理者</p><p>2、三位8进制数字表示，<code>chmod 741 filename</code> </p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chown</span><br><span class="line">修改文件的拥有者</span><br><span class="line">格式：chown [参数] 用户名 文件名</span><br></pre></td></tr></table></figure><p>chown user1 f1</p><p>chown -R user1 filegroup1</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chgrp</span><br><span class="line">修改文件或目录的所属组</span><br><span class="line">格式：chgrp [参数] 用户组名 文件名</span><br><span class="line">常用选项：-R 递归修改文件或目录的所属组</span><br></pre></td></tr></table></figure><h5 id="umask"><a href="#umask" class="headerlink" title="umask"></a><strong>umask</strong></h5><p>功能：查看或修改文件掩码</p><p>比如新建了一个文件夹默认权限为666，新建目录为777。但实际上你所创建的文件和目录，看到的往往不是上面这个值。</p><p>原因就是创建文件或目录的时候还要受到umask的影响。假如默认权限mask，则实际创建出来的文件权限是：mask &amp; ~umask 其实就是——<code>默认权限mask-文件掩码umask</code></p><h5 id="沾滞位"><a href="#沾滞位" class="headerlink" title="沾滞位"></a>沾滞位</h5><p>当一堆用户在做一个项目时，大家都在同一个服务器上。这时每个人的文件都被保存在一个文件夹下。那么当文件具有可读可写可执行的某一权限时，每个人都可以对别人的文件进行操作，那这样张三岂不是可以把李四的文章随便删除？</p><p>为了解决这一方法，引出了沾滞位这一概念。</p><p>当一个目录被设置为“沾滞位”（chmod + t），则该目录下的文件只能由</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一、超级管理员删除 </span><br><span class="line">二、该目录的所有者删除 </span><br><span class="line">三、该文件的所有者删除</span><br></pre></td></tr></table></figure><h4 id="权限的总结"><a href="#权限的总结" class="headerlink" title="权限的总结"></a>权限的总结</h4><p>目录的可执行权限是表示你可否在目录下执行命令。 </p><p>如果目录没有-x权限，则无法对目录执行任何命令，甚至无法cd进入目录, 即使目录仍然有-r 读权限(这个地方很容易犯错，认为有读权限就可以进入目录读取目录下的文件)</p><p>而如果目录具有-x权限，但没有-r权限，则用户可以执行命令，可以cd进入目录。但由于没有目录的读权限，所以在目录下，即使可以执行ls命令，但仍然没有权限独出目录下的文档。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Linux的权限&quot;&gt;&lt;a href=&quot;#Linux的权限&quot; class=&quot;headerlink&quot; title=&quot;Linux的权限&quot;&gt;&lt;/a&gt;Linux的权限&lt;/h3&gt;&lt;p&gt;Linux下有三种用户，普通用户和超级用户和系统用户&lt;/p&gt;
&lt;p&gt;超级用户就是我们所说的r
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://skrskr66.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>数据结构之链表练习题</title>
    <link href="https://skrskr66.github.io/2019/03/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8%E7%BB%83%E4%B9%A0%E9%A2%98/"/>
    <id>https://skrskr66.github.io/2019/03/27/数据结构之链表练习题/</id>
    <published>2019-03-27T08:52:15.000Z</published>
    <updated>2019-03-29T04:38:32.496Z</updated>
    
    <content type="html"><![CDATA[<p>这些练习都是力扣中的真题，挺容易对链表有个更进一步了解的</p><p>1、删除链表中等于给定值 val 的所有节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SListRemoveAll</span><span class="params">(SList *s, SLDataType v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;first == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s-&gt;first-&gt;value == v)&#123;</span><br><span class="line">        Node *next = s-&gt;first;</span><br><span class="line">        s-&gt;first = s-&gt;first-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(s-&gt;first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Node *c = s-&gt;first;</span><br><span class="line">        <span class="keyword">while</span>(c-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c-&gt;next-&gt;value == v)&#123;</span><br><span class="line">                Node *next = c-&gt;next;</span><br><span class="line">                c-&gt;next = c-&gt;next-&gt;next;</span><br><span class="line">                <span class="built_in">free</span>(c-&gt;next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                c = c-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、 反转一个单链表。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SListReverse</span><span class="params">(SList *head)</span></span>&#123;</span><br><span class="line">    Node *result = <span class="literal">NULL</span>;</span><br><span class="line">    Node *c = head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(c != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        Node *next = c-&gt;next;</span><br><span class="line">        </span><br><span class="line">        c-&gt;next = result;</span><br><span class="line">        result = c;</span><br><span class="line">        </span><br><span class="line">        c = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、给定一个带有头结点 head 的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个 中间结点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">middleNode</span><span class="params">(SList *head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="comment">//利用快慢指针的思想</span></span><br><span class="line">    Node *fast = head;</span><br><span class="line">    Node *slow = head;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(fast == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(fast == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、输入一个链表，输出该链表中倒数第k个结点。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node *<span class="title">FindKthToTail</span><span class="params">(Node *head, <span class="keyword">unsigned</span> <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    Node *front = head;</span><br><span class="line">    Node *back = head;</span><br><span class="line">    <span class="comment">//让前面的先走k步</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; k &amp;&amp; front != <span class="literal">NULL</span>;i++)&#123;</span><br><span class="line">        front = front-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; k)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(front != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        front = front-&gt;next;</span><br><span class="line">        back = back-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> back;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成 的。新链表也是有序的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">mergeTwoList</span><span class="params">(SList *c1, SList *c2)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SList</span> *<span class="title">c1</span> = <span class="title">l1</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SList</span> *<span class="title">c2</span> = <span class="title">l2</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SList</span> *<span class="title">result</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SList</span> *<span class="title">last</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(l1 == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l2 == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l1 != <span class="literal">NULL</span> &amp;&amp; l2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;value &lt;= l2-&gt;value)&#123;</span><br><span class="line">            <span class="keyword">if</span>(result == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                result = last = l1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                last-&gt;next = last;</span><br><span class="line">                last = l1;</span><br><span class="line">            &#125;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">if</span>(result == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                result = last = l2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                last-&gt;next = last;</span><br><span class="line">                last = l2;</span><br><span class="line">            &#125;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//两个有序链表不一定等长，多出来的直接接到新链表之后就可以</span></span><br><span class="line">    <span class="keyword">if</span>(l1 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        last-&gt;next = l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        last-&gt;next = l2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、 编写代码，以给定值x为基准将链表分割成两部分，所有小于x的结点排在大于或等于x的结点之前 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node *<span class="title">partition</span><span class="params">(SList* head, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    SList *small;</span><br><span class="line">    SList *big;</span><br><span class="line">    SList *lastsmall;</span><br><span class="line">    SList *lastbig;</span><br><span class="line">    </span><br><span class="line">    SList *node = head;</span><br><span class="line">    <span class="keyword">while</span>(node != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;value &lt; x)&#123;</span><br><span class="line">            <span class="keyword">if</span>(small == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                small = smalllast =node;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                lastsmall-&gt;next = node;</span><br><span class="line">                lastsmall = node; <span class="comment">// lastsmall表示的是最后一个节点，它等于node说明他就是最后一个结点，因为node每次将判断好的结点放在最后一个位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(big == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            big = lastbig =node;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                lastbig-&gt;next = node;</span><br><span class="line">                lastbig = node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(lastsmall != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">//如果比x小的结点存在，则该链表最后接上big链表</span></span><br><span class="line">        lastsmall-&gt;next = big;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(lastbig != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">//如果比x大的结点存在，则该链表最后指向NULL</span></span><br><span class="line">        lastbig-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(lastsmall != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> small;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> big;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7、在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node *<span class="title">deleteDuplication</span><span class="params">(SList* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SList *fake = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">//先定义一个假结点</span></span><br><span class="line">    fake-&gt;next = head;</span><br><span class="line">    </span><br><span class="line">    SList *prev = fake;</span><br><span class="line">    SList *p1 = head;</span><br><span class="line">    SList *p2 = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p2 != <span class="literal">NULL</span>)&#123;<span class="comment">//不要忘了判断，否则p2为空后继续走，将会发生内存泄漏</span></span><br><span class="line">    <span class="comment">//前后指针，一个在前走，一个在后走，在前走的同时判断有没有重复的</span></span><br><span class="line">    <span class="keyword">if</span>(p1-&gt;val != p2-&gt;val)&#123;</span><br><span class="line">        prev = p1;</span><br><span class="line">        p1 = p2;</span><br><span class="line">        p2 = p2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(p2 != <span class="literal">NULL</span> &amp;&amp; p1-&gt;val == p2-&gt;val)&#123;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        SList *cur = p1;</span><br><span class="line">        <span class="keyword">while</span>(cur != p2)&#123;</span><br><span class="line">            SList *next = cur-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(cur);</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        prev-&gt;next = p2;<span class="comment">//很关键的一步，删完之后继续连接未删除的</span></span><br><span class="line">        p1 = p2;</span><br><span class="line">        <span class="keyword">if</span>(p2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    head = fake-&gt;next;</span><br><span class="line">    <span class="comment">//prev在链表中一直相当于记录，就是fake</span></span><br><span class="line">    <span class="built_in">free</span>(fake);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8、对于一个链表，请设计一个时间复杂度为O(n),额外空间复杂度为O(1)的算法，判断其是否为回文结构。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1-&gt;2-&gt;2-&gt;1</span><br></pre></td></tr></table></figure><p>思路还是很好理解的</p><p>1、找到中间结点</p><p>2、从中间结点开始往后逆转整个链表</p><p>3、将头结点和逆转数组作比较</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">middleNode</span><span class="params">(ListNode *head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *slow = head;</span><br><span class="line">    ListNode *fast = head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(fast == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(fast == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">reverlist</span><span class="params">(ListNode *head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *result = <span class="literal">NULL</span>;</span><br><span class="line">    ListNode *cur = head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        ListNode *next = cur-&gt;next;</span><br><span class="line">        </span><br><span class="line">        cur-&gt;next = result;</span><br><span class="line">        result = cur;</span><br><span class="line">        </span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chkPalindrome</span><span class="params">(ListNode* A)</span></span>&#123;</span><br><span class="line">    ListNode *middle = middleNode(A);</span><br><span class="line">    ListNode *r = reverselist(middle-&gt;next);</span><br><span class="line">    </span><br><span class="line">    ListNode *n1 = A, *n2 = r;</span><br><span class="line">    <span class="keyword">while</span>(n1 != <span class="literal">NULL</span> &amp;&amp; n2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n1-&gt;val != n2-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n1 = n1-&gt;next;</span><br><span class="line">        n2 = n2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这些练习都是力扣中的真题，挺容易对链表有个更进一步了解的&lt;/p&gt;
&lt;p&gt;1、删除链表中等于给定值 val 的所有节点&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class
      
    
    </summary>
    
    
      <category term="C-数据结构" scheme="https://skrskr66.github.io/tags/C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Django建立一个音乐网站(五)</title>
    <link href="https://skrskr66.github.io/2019/03/25/Django%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AA%E9%9F%B3%E4%B9%90%E7%BD%91%E7%AB%99-%E4%BA%94/"/>
    <id>https://skrskr66.github.io/2019/03/25/Django建立一个音乐网站-五/</id>
    <published>2019-03-25T06:17:50.000Z</published>
    <updated>2019-03-26T14:36:05.160Z</updated>
    
    <content type="html"><![CDATA[<p>接下来就是后台管理了。</p><p>在这本书这个项目之前，我最初接触python看的是《python基础教程—从实践到入门》，这本后面讲解了django，而且这里面讲解是从admin开始。如果有兴趣了解的可以看看书或者从网上寻找资料，但是django版本不是很高，看起来可能让人容易懵</p><p>后台管理是管理员对用户数据进行管理的存在。在这之中也可以对用户进行权限的赋予（知道为啥VIP牛X了吧）。</p><p>登陆后台管理操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python manage.py runserver</span><br><span class="line"><span class="comment">#启动之后，在浏览器输入栏输入</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8000</span>/admin</span><br><span class="line">即可进入</span><br></pre></td></tr></table></figure><p>在整个网站中，index和user算两个app所以分别定义模型，因此在Admin后台系统是区分两个模块的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#index的__init__.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#对功能模块进行命名</span></span><br><span class="line"><span class="keyword">from</span> django.apps <span class="keyword">import</span> AppConfig</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment">#修改App在Admin后台显示的名称</span></span><br><span class="line"><span class="comment">#default_app_config的值来自apps.py的类名</span></span><br><span class="line">default_app_config = <span class="string">'index.IndexConfig'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取当前App的命名</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_cuurrent_app_name</span><span class="params">(_file)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> os.path.split(os.path.dirname(_file))[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#重写类IndexConfig</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexConfig</span><span class="params">(AppConfig)</span>:</span></span><br><span class="line">    name = get_cuurrent_app_name(__file__)</span><br><span class="line">    verbose_name = <span class="string">'网站首页'</span></span><br><span class="line">    </span><br><span class="line">------------------------------------------------------------------------------------------------    </span><br><span class="line"><span class="comment">#index的admin.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改title和header</span></span><br><span class="line"></span><br><span class="line">admin.site.site_title = <span class="string">'我的音乐后台管理系统'</span></span><br><span class="line">admin.site.site_header = <span class="string">'我的音乐'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#模型Label</span></span><br><span class="line"><span class="meta">@admin.register(Label)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LabelAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    <span class="comment">#设置模型字段，用于Admin后台数据的表头设置</span></span><br><span class="line">    list_display = [<span class="string">'label_id'</span>, <span class="string">'label_name'</span>]</span><br><span class="line">    <span class="comment">#设置可搜索的字段并在Admin后台数据生成搜索框,如有外键应使用双下画线链接两个模型的字段</span></span><br><span class="line">    search_fields = [<span class="string">'label_name'</span>]</span><br><span class="line">    <span class="comment">#设置排序方式</span></span><br><span class="line">    ordering = [<span class="string">'label_id'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#模型Song</span></span><br><span class="line"><span class="meta">@admin.register(Song)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SongAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    list_display = [<span class="string">'song_id'</span>,<span class="string">'song_name'</span>,<span class="string">'song_singer'</span>,<span class="string">'song_album'</span>,<span class="string">'song_languages'</span>,<span class="string">'song_release'</span>]</span><br><span class="line">    search_fields = [<span class="string">'song_name'</span>,<span class="string">'song_singer'</span>,<span class="string">'song_album'</span>,<span class="string">'song_languages'</span>]</span><br><span class="line">    <span class="comment">#设置过滤器，在后台数据的右侧生成导航栏,如有外键应使用双下画线连接两个模型的字段</span></span><br><span class="line">    list_filter = [<span class="string">'song_singer'</span>,<span class="string">'song_album'</span>,<span class="string">'song_languages'</span>]</span><br><span class="line">    ordering = [<span class="string">'song_id'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#模型Dynamic</span></span><br><span class="line"><span class="meta">@admin.register(Dynamic)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DynamicAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    list_display = [<span class="string">'dynamic_id'</span>,<span class="string">'song'</span>,<span class="string">'dynamic_plays'</span>,<span class="string">'dynamic_search'</span>,<span class="string">'dynamic_down'</span>]</span><br><span class="line">    search_fields = [<span class="string">'song'</span>]</span><br><span class="line">    list_filter = [<span class="string">'dynamic_plays'</span>,<span class="string">'dynamic_search'</span>,<span class="string">'dynamic_down'</span>]</span><br><span class="line">    ordering = [<span class="string">'dynamic_id'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#模型Comment</span></span><br><span class="line"><span class="meta">@admin.register(Comment)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    list_display = [<span class="string">'comment_id'</span>,<span class="string">'comment_text'</span>,<span class="string">'comment_user'</span>,<span class="string">'song'</span>,<span class="string">'comment_date'</span>]</span><br><span class="line">    search_fields = [<span class="string">'comment_user'</span>,<span class="string">'song'</span>,<span class="string">'comment_date'</span>]</span><br><span class="line">    list_filter = [<span class="string">'song'</span>,<span class="string">'comment_date'</span>]</span><br><span class="line">    ordering = [<span class="string">'comment_id'</span>]</span><br></pre></td></tr></table></figure><p>接下来就是user这个app的一些设置，与上面大同小异</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#user的__init__.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.apps <span class="keyword">import</span> AppConfig</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">default_app_config = <span class="string">'user.IndexConfig'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取当前App的命名</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_current_app_name</span><span class="params">(_file)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> os.path.split(os.path.dirname(_file))[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#重写类IndexConfig</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexConfig</span><span class="params">(AppConfig)</span>:</span></span><br><span class="line">    name = get_current_app_name(__file__)</span><br><span class="line">    verbose_name = <span class="string">'用户管理'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">#user的admin.py</span></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> MyUser</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.admin <span class="keyword">import</span> UserAdmin</span><br><span class="line"><span class="keyword">from</span> django.utils.translation <span class="keyword">import</span> gettext_lazy <span class="keyword">as</span> _</span><br><span class="line"><span class="meta">@admin.register(MyUser)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyUserAdmin</span><span class="params">(UserAdmin)</span>:</span></span><br><span class="line">    list_display = [<span class="string">'username'</span>,<span class="string">'email'</span>,<span class="string">'mobile'</span>,<span class="string">'qq'</span>,<span class="string">'weChat'</span>]</span><br><span class="line">    <span class="comment">#在用户信息界面添加’mobile‘，'qq','weChat'的信息输入框</span></span><br><span class="line">    <span class="comment">#将源码的UserAdmin.filesets转换成列表格式</span></span><br><span class="line">    fieldsets = list(UserAdmin.fieldsets)</span><br><span class="line">    <span class="comment">#重写UserAdmin的fieldsets，添加'mobile','qq','weChat'的信息录入</span></span><br><span class="line">    fieldsets[<span class="number">1</span>] = (_(<span class="string">'Personal info'</span>),</span><br><span class="line">                    &#123;<span class="string">'fields'</span>:(<span class="string">'first_name'</span>,<span class="string">'last_name'</span>,<span class="string">'email'</span>,<span class="string">'mobile'</span>,<span class="string">'qq'</span>,<span class="string">'weChat'</span>)&#125;)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">#设置fieldsets 控制管理“添加”和 “更改” 页面的布局.</span></span><br><span class="line"><span class="comment">#fieldsets 是一个以二元元组为元素的列表, 每一个二元元组代表一个在管理表单二元元组的格式是 (name, field_options), 其中 name 是一个字符串相当于 fieldset的标题， field_options 是一个关于 fieldset的字典信息,一个字段列表包含在里面。</span></span><br></pre></td></tr></table></figure><p>当网页遇到错误时，往往我们会返回404，这时候我们在网页中也可以设置一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#music的urls.py</span></span><br><span class="line"><span class="comment">#设置404、500错误状态码</span></span><br><span class="line"><span class="keyword">from</span> index <span class="keyword">import</span> views</span><br><span class="line">handler404 = views.page_not_found</span><br><span class="line">handler500 = views.page_not_found</span><br><span class="line"></span><br><span class="line"><span class="comment">#index的views.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">page_not_found</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'error404.html'</span>, status = <span class="number">404</span>)</span><br></pre></td></tr></table></figure><p>到这块基本网站的建立就完成了，这时候可以在后台进行对用户设置权限，可以更换音乐和照片素材，也可以进行新的数据库数据添加，但是要考虑到数据改变是否影响到html的设置。这个由个人随机操作。</p><p>最后重头戏就是项目上线部署了，一般采用django+nginx+uWSGI这样。我利用虚拟机进行了多次部署….期间废掉了好几个VM…目前还没成功，等我成功之后将继续写博客分享经验。</p><p>根据书上的内容进行了操作对django框架有了一个简单的认识，我还是打算在此立个flag，我也会继续学习，建立一个属于自己的电影网站！</p><p>加油吧！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;接下来就是后台管理了。&lt;/p&gt;
&lt;p&gt;在这本书这个项目之前，我最初接触python看的是《python基础教程—从实践到入门》，这本后面讲解了django，而且这里面讲解是从admin开始。如果有兴趣了解的可以看看书或者从网上寻找资料，但是django版本不是很高，看起来可
      
    
    </summary>
    
    
      <category term="python, django" scheme="https://skrskr66.github.io/tags/python-django/"/>
    
  </entry>
  
  <entry>
    <title>Django建立一个音乐网站(四)</title>
    <link href="https://skrskr66.github.io/2019/03/16/Django%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AA%E9%9F%B3%E4%B9%90%E7%BD%91%E7%AB%99-%E5%9B%9B/"/>
    <id>https://skrskr66.github.io/2019/03/16/Django建立一个音乐网站-四/</id>
    <published>2019-03-16T15:56:35.000Z</published>
    <updated>2019-03-25T06:16:09.929Z</updated>
    
    <content type="html"><![CDATA[<p>之前将网站一些该有的元素都准备完成了。接下来就是关于用户注册和后台admin设置。</p><h5 id="user模块"><a href="#user模块" class="headerlink" title="user模块"></a>user模块</h5><p>关于一个网站的浏览量是靠用户的数量来决定的。所以每一个用户在网站的操作，要做出限制。这个是可以实现的。接着还有一些个人的账号和数据信息可以完善，让管理员能更好的管理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#user的urls模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    <span class="comment">#用户的注册和登陆</span></span><br><span class="line">    path(<span class="string">'login.html'</span>, views.loginView, name=<span class="string">'login'</span>),</span><br><span class="line">    <span class="comment">#用户登录中心</span></span><br><span class="line">    path(<span class="string">'home/&lt;int:page&gt;.html'</span>, views.homeView, name=<span class="string">'home'</span>),</span><br><span class="line">    <span class="comment">#退出用户登陆</span></span><br><span class="line">    path(<span class="string">'logout.html'</span>, views.logoutView, name=<span class="string">'logout'</span>),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">#两个html文件已经放到之前的文件下载中</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">#user的models模块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> AbstractUser</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyUser</span><span class="params">(AbstractUser)</span>:</span></span><br><span class="line">    qq = models.CharField(<span class="string">'QQ号码'</span>, max_length=<span class="number">20</span>)</span><br><span class="line">    weChat = models.CharField(<span class="string">'微信账号'</span>, max_length=<span class="number">20</span>)</span><br><span class="line">    mobile = models.CharField(<span class="string">'手机账号'</span>, max_length=<span class="number">11</span>, unique=<span class="keyword">True</span>)</span><br><span class="line">    <span class="comment">#设置返回值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.username</span><br><span class="line"></span><br><span class="line"><span class="comment">#这里与之前数据库的建立连接是一个意思，此时需要将之前库内所有表删除(建议先导出数据保存)，在将这个执行</span></span><br><span class="line"><span class="comment">#python manage.py makemigrations和python manage.py migrate 两个指令操作</span></span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">#user的forms模块</span></span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.forms <span class="keyword">import</span> UserCreationForm</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> MyUser</span><br><span class="line"><span class="keyword">from</span> django <span class="keyword">import</span> forms</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义MyUser的数据表单，用于用户注册</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyUserCreationForm</span><span class="params">(UserCreationForm)</span>:</span></span><br><span class="line">    <span class="comment">#重写初始化函数，设置自定义字段password1和password2的样式和属性</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        super(MyUserCreationForm, self).__init__(*args, **kwargs)</span><br><span class="line">        self.fields[<span class="string">'password1'</span>].widget = forms.PasswordInput(attrs=&#123;<span class="string">'class'</span>:<span class="string">'txt tabInput'</span>, <span class="string">'placeholder'</span>:<span class="string">'密码，4-16位数字/字母。特殊符号（空格除外）'</span>&#125;)</span><br><span class="line">        self.fields[<span class="string">'password2'</span>].widget = forms.PasswordInput(attrs=&#123;<span class="string">'class'</span>:<span class="string">'txt tabInput'</span>, <span class="string">'placeholder'</span>:<span class="string">'重复密码'</span>&#125;)</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span><span class="params">(UserCreationForm.Meta)</span>:</span></span><br><span class="line">        model = MyUser</span><br><span class="line">        <span class="comment">#在注册界面添加模型字段：手机号码和密码</span></span><br><span class="line">        fields = UserCreationForm.Meta.fields + (<span class="string">'mobile'</span>,)</span><br><span class="line">        <span class="comment">#设置模型字段的样式和属性(widgets)</span></span><br><span class="line">        widgets = &#123;</span><br><span class="line">            <span class="string">'mobile'</span>:forms.widgets.TextInput(attrs=&#123;<span class="string">'class'</span>:<span class="string">'txt tabInput'</span>,<span class="string">'placeholder'</span>:<span class="string">'手机号'</span>&#125;),</span><br><span class="line">            <span class="string">'username'</span>:forms.widgets.TextInput(attrs=&#123;<span class="string">'class'</span>:<span class="string">'txt tabInput'</span>,<span class="string">'placeholder'</span>:<span class="string">'用户名'</span>&#125;),</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">#实现用户的注册和登陆之前，除了自定义用户模型MyUser之外，还需要定义用户注册的表单类。</span></span><br><span class="line">        <span class="comment">#这里通过重写Django中的内置表单类UserCreationForm</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">#user的views模块</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render, redirect</span><br><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Q</span><br><span class="line"><span class="keyword">from</span> index.models <span class="keyword">import</span> Dynamic</span><br><span class="line"><span class="keyword">from</span> user.models <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth <span class="keyword">import</span> login, logout</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.hashers <span class="keyword">import</span> check_password</span><br><span class="line"><span class="keyword">from</span> .form <span class="keyword">import</span> MyUserCreationForm</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.decorators <span class="keyword">import</span> login_required</span><br><span class="line"><span class="keyword">from</span> django.core.paginator <span class="keyword">import</span> Paginator, EmptyPage, PageNotAnInteger</span><br><span class="line"></span><br><span class="line"><span class="comment">#用户注册与登录</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loginView</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="comment">#表单对象user</span></span><br><span class="line">    user = MyUserCreationForm()</span><br><span class="line">    <span class="comment">#表单提交</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">        <span class="comment">#判断表单提交是     用户登陆     还是       用户注册</span></span><br><span class="line">        <span class="comment">#用户登陆</span></span><br><span class="line">        <span class="keyword">if</span> request.POST.get(<span class="string">'loginUser'</span>, <span class="string">''</span>):<span class="comment">#获取搜索内容如果为loginUser，没有返回空</span></span><br><span class="line">            loginUser = request.POST.get(<span class="string">'loginUser'</span>, <span class="string">''</span>)<span class="comment">#这里是已经获取到用户输入的</span></span><br><span class="line">            password = request.POST.get(<span class="string">'password'</span>, <span class="string">''</span>)</span><br><span class="line">            <span class="keyword">if</span> MyUser.objects.filter(Q(mobile = loginUser) | Q(username=loginUser)):</span><br><span class="line">                user = MyUser.objects.filter(Q(mobile=loginUser) | Q(username=loginUser)).first()<span class="comment">#这里是sql语句在django中的不同表示方法</span></span><br><span class="line">                <span class="keyword">if</span> check_password(password, user.password):</span><br><span class="line">                    login(request, user)</span><br><span class="line">                    <span class="keyword">return</span> redirect(<span class="string">'/user/home/1.html'</span>)<span class="comment">#页面跳转</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    tips = <span class="string">'密码错误'</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                tips = <span class="string">'用户不存在'</span></span><br><span class="line">        <span class="comment">#用户注册</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            user = MyUserCreationForm(request.POST)</span><br><span class="line">            <span class="keyword">if</span> user.is_valid():</span><br><span class="line">                user.save()</span><br><span class="line">                tips = <span class="string">'注册成功'</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> user.errors.get(<span class="string">'username'</span>, <span class="string">''</span>):</span><br><span class="line">                    tips = user.errors.get(<span class="string">'username'</span>, <span class="string">'注册失败'</span>)</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    tips = user.errors.get(<span class="string">'mobile'</span>, <span class="string">'注册失败'</span>)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'login.html'</span>, locals())</span><br><span class="line"></span><br><span class="line"><span class="comment">#用户中心</span></span><br><span class="line"><span class="comment">#设置用户登录限制</span></span><br><span class="line"><span class="meta">@login_required(login_url='/user/login.html')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">homeView</span><span class="params">(request, page)</span>:</span></span><br><span class="line">    <span class="comment">#热搜歌曲</span></span><br><span class="line">    search_song = Dynamic.objects.select_related(<span class="string">'song'</span>).order_by(<span class="string">'-dynamic_search'</span>).all()[:<span class="number">4</span>]</span><br><span class="line">    <span class="comment">#分页功能</span></span><br><span class="line">    song_info = request.session.get(<span class="string">'play_list'</span>, [])</span><br><span class="line">    paginator = Paginator(song_info, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">try</span>:<span class="comment">#错误解决方法</span></span><br><span class="line">        contacts = paginator.page(page)</span><br><span class="line">    <span class="keyword">except</span> PageNotAnInteger:</span><br><span class="line">        contacts = paginator.page(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">except</span> EmptyPage:</span><br><span class="line">        contacts = paginator.page(paginator.num_pages)</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'home.html'</span>, locals())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logoutView</span><span class="params">(request)</span>:</span></span><br><span class="line">    logout(request)</span><br><span class="line">    <span class="keyword">return</span> redirect(<span class="string">'/'</span>)</span><br></pre></td></tr></table></figure><p>在上面的代码中涉及到了表单类这么一个概念。</p><p>在这里要说明以下，<strong>表单</strong>是搜集用户数据信息的各种表单元素的集合，作用是实现网页上的数据交互，用户在网站输入数据信息，然后提交到网站服务器端进行处理</p><p>表单我们学过html的知道，定义一个类似下拉菜单的样式，在这个项目中是先利用了内置表单类，然后重写了两个新功能。</p><p>1、添加用户注册的字段，在Meta类对fields属性设置字段即可，添加的字段必须是模型字段并且以元组或列表的形式添加</p><p>2、设置字段的CSS格式，设置表单字段mobile、username、password1、password2的attrs属性。其中mobile和username是模型MyUser的字段，所以在Meta类中重写widgets属性。widgets是内置表单类的一个参数，两个密码password是额外定义的表单字段，所以重写初始函数<code>__init__</code>可以实现字段样式设置</p><p>这里对表单说的有点多，因为在网站中，用户注册是一个非常重要的环节。而且表单这里还是涉及到了前端的知识…原谅本小白不才….实在能力有限。</p><p>至此除了后台系统之外，基本全部完成。上几个截图看看吧</p><p><img src="/2019/03/16/Django建立一个音乐网站-四/django.png" alt="django"></p><p><img src="/2019/03/16/Django建立一个音乐网站-四/django1.png" alt="django1"></p><p><img src="/2019/03/16/Django建立一个音乐网站-四/django3.png" alt="django3"></p><p><img src="/2019/03/16/Django建立一个音乐网站-四/django4.png" alt="django4"></p><p>接下来就是后台系统了….</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前将网站一些该有的元素都准备完成了。接下来就是关于用户注册和后台admin设置。&lt;/p&gt;
&lt;h5 id=&quot;user模块&quot;&gt;&lt;a href=&quot;#user模块&quot; class=&quot;headerlink&quot; title=&quot;user模块&quot;&gt;&lt;/a&gt;user模块&lt;/h5&gt;&lt;p&gt;关于一个网
      
    
    </summary>
    
    
      <category term="python, django" scheme="https://skrskr66.github.io/tags/python-django/"/>
    
  </entry>
  
  <entry>
    <title>Django建立一个音乐网站(三)</title>
    <link href="https://skrskr66.github.io/2019/03/13/Django%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AA%E9%9F%B3%E4%B9%90%E7%BD%91%E7%AB%99-%E4%B8%89/"/>
    <id>https://skrskr66.github.io/2019/03/13/Django建立一个音乐网站-三/</id>
    <published>2019-03-13T09:51:06.000Z</published>
    <updated>2019-03-25T05:59:55.099Z</updated>
    
    <content type="html"><![CDATA[<p>Django+mysql连接成功之后，就是我们对网页设计了。</p><p>但我并不擅长html的一些前端，不做多的描述….因此将这些html文件和静态文件，打包提供大家参考。</p><p><a href="/download/download.zip">点击下载</a>  这个是数据文件，静态文件，html文件，可以将其导入进行测试</p><p>主要了解对app中各模块的写法</p><h5 id="index模块"><a href="#index模块" class="headerlink" title="index模块"></a>index模块</h5><p>之前将<code>index的models.py</code>为了建立数据库完成了，现在继续写<code>views.py</code>和<code>urls.py</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#index的urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">''</span>, views.indexView, name=<span class="string">'index'</span>),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#index的views.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">indexView</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="comment">#热搜歌曲</span></span><br><span class="line">    search_song = Dynamic.objects.select_related(<span class="string">'song'</span>).order_by(<span class="string">'-dynamic_search'</span>).all()[:<span class="number">8</span>]</span><br><span class="line">    <span class="comment">#select_related的用法可以用于表之间建立联系的查询。</span></span><br><span class="line">    <span class="comment">#select_related的参数为'song'，我们可以理解为在这个表中，排序为逆序，显示前八个数据</span></span><br><span class="line">    <span class="comment">#等同于SQL：SELECT * FROM index_dynamic INNER JOIN index_song ON (song_id = id)</span></span><br><span class="line">    <span class="comment">#查询两个模型的全部数据</span></span><br><span class="line">    <span class="comment">#音乐分类</span></span><br><span class="line">    label_list = Label.objects.all()</span><br><span class="line">    <span class="comment">#热门歌曲</span></span><br><span class="line">    play_hot_song = Dynamic.objects.select_related(<span class="string">'song'</span>).order_by(<span class="string">'-dynamic_search'</span>).all()[:<span class="number">10</span>]</span><br><span class="line">    <span class="comment">#新歌推荐</span></span><br><span class="line">    daily_recommendation = Song.objects.order_by(<span class="string">'-song_release'</span>).all()[:<span class="number">3</span>]</span><br><span class="line">    <span class="comment">#热门搜索、热门下载</span></span><br><span class="line">    search_ranking = search_song[:<span class="number">6</span>]</span><br><span class="line">    down_ranking = Dynamic.objects.select_related(<span class="string">'song'</span>).order_by(<span class="string">'-dynamic_down'</span>).all()[:<span class="number">6</span>]</span><br><span class="line">    all_ranking = [search_ranking,down_ranking]</span><br><span class="line">    <span class="comment">#render()结合一个给定的模板和一个给定的上下文字典, 并返回一个渲染后的HttpResponse对象。</span></span><br><span class="line">    <span class="comment">#locals()用法：locals()可以直接将函数中所有的变量全部传给模板</span></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'index.html'</span>, locals())</span><br></pre></td></tr></table></figure><p>在上面的代码中，我将大部分都用注释标记了出来。</p><p>Django使用请求和响应对象来通过系统传递状态。 </p><p>视图所对应的是在html显示中可以将数据库中的数据进行查询，然后将选择出来的数据放到站点进行浏览。</p><p>比如我们在index.html节选文件中可以看到,在view中定义的label_list列表我们在其中使用利用for循环进行调用，最后将数据库建立连接的数据显示在主页上。</p><p>这里也涉及到前端中JavaScript，本小白实在是不知语言原理，只能看懂一二…各位见谅！！！</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"nav-box"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"nav-box-inner"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"nav clearfix"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/"</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'ranking' %&#125;"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>歌曲排行<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;% url 'home' 1 %&#125;"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>用户中心<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"category-nav"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"category-nav-header"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">strong</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:;"</span> <span class="attr">title</span>=<span class="string">""</span>&gt;</span>音乐分类<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"category-nav-body"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"J_CategoryItems"</span> <span class="attr">class</span>=<span class="string">"category-items"</span>&gt;</span></span><br><span class="line">                &#123;% for label in label_list  %&#125;</span><br><span class="line">                    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item"</span> <span class="attr">data-index</span>=<span class="string">"1"</span>&gt;</span><span class="tag">&lt;<span class="name">h3</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:;"</span>&gt;</span>&#123;&#123; label.label_name &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">                &#123;% endfor  %&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>接下来的各个模块的代码，我将根据index.html出现的顺序依次往下罗列。</p><h5 id="search模块"><a href="#search模块" class="headerlink" title="search模块"></a>search模块</h5><p>首先是search的代码，搜索是对网站内的数据进行检索</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#search的urls.ps</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'&lt;int:page&gt;.html'</span>, views.searchView, name=<span class="string">'search'</span>),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">#views.py</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render, redirect</span><br><span class="line"><span class="keyword">from</span> django.core.paginator <span class="keyword">import</span> Paginator, EmptyPage, PageNotAnInteger</span><br><span class="line"><span class="keyword">from</span> django.db.models <span class="keyword">import</span> Q</span><br><span class="line"><span class="keyword">from</span> index.models <span class="keyword">import</span> *</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">searchView</span><span class="params">(request, page)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">        <span class="comment">#搜索歌曲</span></span><br><span class="line">        search_song = Dynamic.objects.select_related(<span class="string">'song'</span>).order_by(<span class="string">'-dynamic_search'</span>).all()[:<span class="number">6</span>]</span><br><span class="line">        <span class="comment">#获取搜索内容，如果kword为空就查询全部歌曲</span></span><br><span class="line">        kword = request.session.get(<span class="string">'kword'</span>, <span class="string">''</span>)</span><br><span class="line">        <span class="keyword">if</span> kword:</span><br><span class="line">            <span class="comment">#Q是SQL语句里的or语法</span></span><br><span class="line">            song_info = Song.objects.values(<span class="string">'song_id'</span>, <span class="string">'song_name'</span>,<span class="string">'song_singer'</span>, <span class="string">'song_time'</span>).filter(Q(song_name__icontains=kword) | Q(song_singer=kword)).order_by(<span class="string">'-song_release'</span>).all()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            song_info = Song.objects.values(<span class="string">'song_id'</span>, <span class="string">'song_name'</span>, <span class="string">'song_singer'</span>, <span class="string">'song_time'</span>).order_by(<span class="string">'-song_release'</span>).all()[:<span class="number">50</span>]</span><br><span class="line">    <span class="comment">#分页功能,是django的一个库函数，叫做分页器，设置每一页显示几条数据</span></span><br><span class="line">        paginator = Paginator(song_info, <span class="number">5</span>)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            contacts = paginator.page(page)</span><br><span class="line">        <span class="keyword">except</span> PageNotAnInteger:</span><br><span class="line">            contacts = paginator.page(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">except</span> EmptyPage:</span><br><span class="line">            contacts = paginator.page(paginator.num_pages)</span><br><span class="line">    <span class="comment">#添加歌曲搜索次数</span></span><br><span class="line">        song_exist = Song.objects.filter(song_name=kword)</span><br><span class="line">        <span class="keyword">if</span> song_exist:</span><br><span class="line">            song_id = song_exist[<span class="number">0</span>].song_id</span><br><span class="line">            dynamic_info = Dynamic.objects.filter(song_id=int(song_id)).first()</span><br><span class="line">            <span class="comment">#判断歌曲动态信息是否存在,存在就在原来的基础上加1</span></span><br><span class="line">            <span class="keyword">if</span> dynamic_info:</span><br><span class="line">                dynamic_info.dynamic_search += <span class="number">1</span></span><br><span class="line">                dynamic_info.save()</span><br><span class="line">            <span class="comment">#若动态信息不存在，则创建新的动态信息</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                dynamic = Dynamic(dynamic_plays=<span class="number">0</span>, dynamic_search=<span class="number">1</span>, dynamic_down=<span class="number">0</span>, song_id=song_id)</span><br><span class="line">                dynamic.save()</span><br><span class="line">            <span class="keyword">return</span> render(request, <span class="string">'search.html'</span>, locals())</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment">#处理POST请求，并重定向搜索页面</span></span><br><span class="line">        request.session[<span class="string">'kword'</span>] = request.POST.get(<span class="string">'kword'</span>, <span class="string">''</span>)</span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">'/search/1.html'</span>)</span><br></pre></td></tr></table></figure><p>大概说明一下，method用于获取用户的请求方式。属性GET和POST用于获取用户的请求参数</p><p>GET请求一般做查询（有缓存），POST请求一般做添加/删除/修改（无缓存） </p><p>session就是用来在服务器端保存用户的会话状态。</p><p>Paginator是一个django中自带的分页器，将搜索结果进行每页5条来显示。</p><p>根据搜索的内容kword查找完全匹配的歌名，匹配成功，才会判断歌曲的动态信息是否存在。</p><p>存在就在数据库的数据中+1，否则创建一条动态信息，并将搜索次数设为1.</p><h5 id="ranking模块"><a href="#ranking模块" class="headerlink" title="ranking模块"></a>ranking模块</h5><p>歌曲信息列表，当我们在站点进行搜索时，显示出来的排名。这个排名根据设置的降序进行排序。下面上代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ranking的urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> .<span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">''</span>,views.rankingView,name=<span class="string">'ranking'</span>),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">#ranking的views.py</span></span><br><span class="line"><span class="keyword">from</span> djagno.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> index.models <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rankingView</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="comment">#热搜歌曲</span></span><br><span class="line">    search_song = Dynamic.objects.select_related(<span class="string">'song'</span>).order_by(<span class="string">'-dynamic_search'</span>).all()[:<span class="number">4</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#歌曲分类列表</span></span><br><span class="line">    All_list = Song.objects.values(<span class="string">'song_type'</span>).distinct()</span><br><span class="line">    <span class="comment">#关键词 DISTINCT 用于返回唯一不同的值。</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">#歌曲列表信息</span></span><br><span class="line">    song_type = request.GET.get(<span class="string">'type'</span>, <span class="string">''</span>)</span><br><span class="line">    <span class="comment">#寻找名为type的GET参数，而且如果参数没有提交，返回一个空的字符串。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> song_type:</span><br><span class="line">        song_info = Dynamic.objects.select_related(<span class="string">'song'</span>).filter(song__song_type=song_type).order_by(<span class="string">'-dynamic_plays'</span>).all()[:<span class="number">10</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        song_info = Dynamic.objects.select_related(<span class="string">'song'</span>).order_by(<span class="string">'-dynamic_plays'</span>).all()[:<span class="number">10</span>]</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'ranking.html'</span>, locals())</span><br></pre></td></tr></table></figure><p>web开发一般是一个无聊的过程，尤其在视图编写功能方面。所以在Django中植入了通用视图这一概念，该功能封装了视图开发常用的代码和模式。根据用途划分三大类：</p><p><strong>TemplateView</strong>直接返回HTML模板，但无法将数据库的数据展示出来</p><p><strong>ListView</strong>能将数据库的数据传递给HTML模板，通常获取某个表的所有数据</p><p><strong>DetailView</strong>能将数据库的数据传递给HTML模板，通常获取数据表的单条数据</p><p>通用模板的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#ranking.urls</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    <span class="comment">#通用视图</span></span><br><span class="line">    path(<span class="string">'.list'</span>, views.RankingList.as_view(), name = <span class="string">'rankingList'</span>),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">#ranking.views</span></span><br><span class="line"><span class="keyword">from</span> django.views.generic <span class="keyword">import</span> ListView</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RankingList</span><span class="params">(ListView)</span>:</span></span><br><span class="line">    <span class="comment">#context_object_name 设置HTML模板的某一个变量名称</span></span><br><span class="line">    context_object_name = <span class="string">'song_info'</span></span><br><span class="line">    <span class="comment">#设定模板文件</span></span><br><span class="line">    template_name = <span class="string">'ranking.html'</span></span><br><span class="line">    <span class="comment">#查询变量song_info的数据</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_queryset</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment">#获取请求参数</span></span><br><span class="line">        song_type = self.request.GET.get(<span class="string">'type'</span>, <span class="string">''</span>)</span><br><span class="line">        <span class="keyword">if</span> song_type:</span><br><span class="line">            song_info = Dynamic.objects.select_related(<span class="string">'song'</span>).filter(song__song_type=song_type).order_by(<span class="string">'-dynamic_plays'</span>).all()[:<span class="number">10</span>]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            song_info = Dynamic.objects.select_related(<span class="string">'song'</span>).order_by(<span class="string">'-dynamic_plays'</span>).all()[:<span class="number">10</span>]</span><br><span class="line">        <span class="keyword">return</span> song_info</span><br><span class="line"></span><br><span class="line">    <span class="comment">#添加其他变量</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_context_data</span><span class="params">(self, **kwargs)</span>:</span></span><br><span class="line">        context = super().get_context_data(**kwargs)</span><br><span class="line">        <span class="comment">#搜索歌曲</span></span><br><span class="line">        context[<span class="string">'search_song'</span>] = Dynamic.objects.select_related(<span class="string">'song'</span>).order_by(<span class="string">'-dynamic_search'</span>).all()[:<span class="number">4</span>]</span><br><span class="line">        <span class="comment">#所有歌曲分类</span></span><br><span class="line">        context[<span class="string">'All_list'</span>] = Song.objects.values(<span class="string">'song_type'</span>).distinct()</span><br><span class="line">        <span class="keyword">return</span> context</span><br></pre></td></tr></table></figure><p>我个人觉得通用视图还是比较方便的。首先如果自己构思时，不一定能想出最好的代码块，可能有出错的可能。但是通用视图在模板上进行一定的修改，设定模板文件，将所要查询的数据SQL转换成django中的语法，在之后添加其他变量，设置HTML中的其他变量。</p><h5 id="play模块"><a href="#play模块" class="headerlink" title="play模块"></a>play模块</h5><p>音乐网站那么最重要的就是歌曲的视听效果了。前面提到了，除了HTML在相关的模块templates中，所有静态的文件资源都被保存在一个static文件夹中，那么肯定我们需要读取这个文件，读取了之后在网页播放</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#play的urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line">urlpatterns = [</span><br><span class="line">    <span class="comment">#歌曲播放页面</span></span><br><span class="line">    path(<span class="string">'&lt;int:song_id&gt;.html'</span>, views.playView, name=<span class="string">'play'</span>),</span><br><span class="line">    <span class="comment">#歌曲下载</span></span><br><span class="line">    path(<span class="string">'download/&lt;int:song_id&gt;.html'</span>, views.downloadView, name=<span class="string">'download'</span>)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">#views.py</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> index.models <span class="keyword">import</span> *</span><br><span class="line"><span class="comment">#歌曲播放页面</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">playView</span><span class="params">(request, song_id)</span>:</span></span><br><span class="line">    <span class="comment">#热搜歌曲</span></span><br><span class="line">    search_song = Dynamic.objects.select_related(<span class="string">'song'</span>).order_by(<span class="string">'-dynamic_search'</span>).all()[:<span class="number">6</span>]</span><br><span class="line">    <span class="comment">#歌曲信息</span></span><br><span class="line">    song_info = Song.objects.get(song_id=int(song_id))</span><br><span class="line">    <span class="comment">#歌曲列表</span></span><br><span class="line">    play_list = request.session.get(<span class="string">'play_list'</span>, [])</span><br><span class="line">    song_exist = <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">if</span> play_list:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> play_list:</span><br><span class="line">            <span class="keyword">if</span> int(song_id) == i[<span class="string">'song_id'</span>]:</span><br><span class="line">                song_exist = <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">if</span> song_exist == <span class="keyword">False</span>:</span><br><span class="line">        play_list.append(&#123;<span class="string">'song_id'</span>: int(song_id), <span class="string">'song_singer'</span>: song_info.song_singer, <span class="string">'song_name'</span>: song_info.song_name, <span class="string">'song_time'</span>: song_info.song_time&#125;)</span><br><span class="line">        request.session[<span class="string">'play_list'</span>] = play_list</span><br><span class="line">        <span class="comment">#歌词</span></span><br><span class="line">    <span class="keyword">if</span> song_info.song_lyrics != <span class="string">'暂无歌词'</span>:</span><br><span class="line">        f = open(<span class="string">'static/songLyric/'</span> +song_info.song_lyrics, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">        song_lyrics = f.read()</span><br><span class="line">        f.close()</span><br><span class="line">        <span class="comment">#相关歌曲</span></span><br><span class="line">    song_type = Song.objects.values(<span class="string">'song_type'</span>).get(song_id = song_id)[<span class="string">'song_type'</span>]</span><br><span class="line">    song_relevant = Dynamic.objects.select_related(<span class="string">'song'</span>).filter(song__song_type=song_type).order_by(<span class="string">'-dynamic_plays'</span>).all()[:<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line">    <span class="comment">#添加播放次数</span></span><br><span class="line">    <span class="comment">#扩展功能:可使用session实现每天只添加一次播放次数</span></span><br><span class="line">    dynamic_info = Dynamic.objects.filter(song_id=int(song_id)).first()</span><br><span class="line">    <span class="comment">#判断歌曲动态信息是否存在, 存在就在原来的基础上+1</span></span><br><span class="line">    <span class="keyword">if</span> dynamic_info:</span><br><span class="line">        dynamic_info.dynamic_plays += <span class="number">1</span></span><br><span class="line">        dynamic_info.save()</span><br><span class="line">        <span class="comment">#若动态信息不存在，则创建新的动态信息</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        dynamic_info = Dynamic(dynamic_plays=<span class="number">1</span>, dynamic_search=<span class="number">0</span>, dynamic_down=<span class="number">0</span>, song_id=song_id)</span><br><span class="line">        dynamic_info.save()</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'play.html'</span>, locals())</span><br></pre></td></tr></table></figure><p>关于播放列表的部分，这里获取当前Session的play_list的信息，play_list代表用户的播放记录。将用户URL的参数song_id与play_list的song_id进行对比，如果两者匹配的上，说明当前歌曲已加入播放记录。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">#歌曲下载</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">downloadView</span><span class="params">(request, song_id)</span>:</span></span><br><span class="line">    <span class="comment">#根据song_id查找歌曲信息</span></span><br><span class="line">    song_info = Song.objects.get(song_id=int(song_id))</span><br><span class="line">    <span class="comment">#添加下载次数</span></span><br><span class="line">    dynamic_info = Dynamic.objects.filter(song_id=int(song_id)).first()</span><br><span class="line">    <span class="keyword">if</span> dynamic_info:</span><br><span class="line">        dynamic_info.dynamic_down += <span class="number">1</span></span><br><span class="line">        dynamic_info.save()</span><br><span class="line">        <span class="comment">#若动态信息不存在，则创建新的动态信息</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">         dynamic_info = Dynamic(dynamic_plays=<span class="number">0</span>, dynamic_search=<span class="number">0</span>, dynamic_down=<span class="number">1</span>, song_id=song_id)</span><br><span class="line">         dynamic_info.save()</span><br><span class="line">        <span class="comment">#读取文件内容</span></span><br><span class="line">    file = <span class="string">'static/songFile/'</span> + song_info.song_file</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">file_iterator</span><span class="params">(file, chunk_size=<span class="number">512</span>)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> open(file, <span class="string">'rb'</span>) <span class="keyword">as</span> f:<span class="comment">#读取静态音乐文件</span></span><br><span class="line">            <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">                c = f.read(chunk_size)</span><br><span class="line">                <span class="keyword">if</span> c:</span><br><span class="line">                    <span class="keyword">yield</span> c</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">    <span class="comment">#将文件内容写入StreamingHttpResponse对象，并以字节流的方式返回给用户，实现文件下载</span></span><br><span class="line">    filename = str(song_id) + <span class="string">'.mp3'</span></span><br><span class="line">    response = StreamingHttpResponse(file_iterator(file))</span><br><span class="line">    response[<span class="string">'Content-Type'</span>] = <span class="string">'application/octet-stream'</span></span><br><span class="line">    response[<span class="string">'Content-Disposition'</span>] = <span class="string">'attachment; filename="%s"'</span>%(filename)</span><br><span class="line">    <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure><p>在代码中response的使用就是将音频文件在HTML中进行播放的方法。</p><p>在各个模块中的代码中，视图更多的还是将数据库中的数据查询出来，存放到一个标量或者列表里，这是在学习过程中更需要我们去了解视图在web中的方法实现。而models文件一般在index文件中，用于数据库时进行类的书写。</p><h5 id="comment模块"><a href="#comment模块" class="headerlink" title="comment模块"></a>comment模块</h5><p>这个模块的使用，也是我对django好感度一个巨大的提升。因为django自己封装了这么一个可以进行评论的函数。这让我们使用起来就非常方便。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#comment的urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'&lt;int:song_id&gt;.html'</span>, views.commentView, name=<span class="string">'comment'</span>),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">#views.py</span></span><br><span class="line"><span class="keyword">from</span> django.core.paginator <span class="keyword">import</span> Paginator, PageNotAnInteger, EmptyPage</span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render, redirect</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> Http404</span><br><span class="line"><span class="keyword">from</span> index.models <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">commentView</span><span class="params">(request, song_id)</span>:</span></span><br><span class="line">    <span class="comment">#搜索结果</span></span><br><span class="line">    search_song = Dynamic.objects.select_related(<span class="string">'song'</span>).order_by(<span class="string">'-dynamic_search'</span>).all()[:<span class="number">6</span>]</span><br><span class="line">    <span class="comment">#点评提交处理</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">'POST'</span>:</span><br><span class="line">        comment_text = request.POST.get(<span class="string">'comment'</span>, <span class="string">''</span>)</span><br><span class="line">        comment_user = request.user.username <span class="keyword">if</span> request.user.username <span class="keyword">else</span> <span class="string">'匿名用户'</span></span><br><span class="line">        <span class="keyword">if</span> comment_text:</span><br><span class="line">            comment = Comment()</span><br><span class="line">            comment.comment_text = comment_text</span><br><span class="line">            comment.comment_user = comment_user</span><br><span class="line">            comment.comment_date = time.strftime(<span class="string">'%Y-%m-%d'</span>, time.localtime(time.time()))</span><br><span class="line">            comment.song_id = song_id</span><br><span class="line">            comment.save()</span><br><span class="line">        <span class="keyword">return</span> redirect(<span class="string">'/comment/%s.html'</span> %(str(song_id)))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        song_info = Song.objects.filter(song_id = song_id).first()</span><br><span class="line">        <span class="comment">#歌曲不存在，抛出404</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> song_info:</span><br><span class="line">            <span class="keyword">raise</span> Http404</span><br><span class="line">        comment_all = Comment.objects.filter(song_id = song_id).order_by(<span class="string">'comment_date'</span>)</span><br><span class="line">        song_name = song_info.song_name</span><br><span class="line">        page = int(request.GET.get(<span class="string">'page'</span>,<span class="number">1</span>))<span class="comment">#当请求参数不存在时，默认页数为1，如果存在，将参数值转化为Int类型</span></span><br><span class="line">        <span class="comment">#每两条点评信息设置为一页</span></span><br><span class="line">        paginator = Paginator(comment_all, <span class="number">2</span>)<span class="comment">#  Paginator分页功能 可以接收列表、元组或其它可迭代的对象。</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            contacts = paginator.page(page)</span><br><span class="line">        <span class="keyword">except</span> PageNotAnInteger:</span><br><span class="line">            contacts = paginator.page(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">except</span> EmptyPage:</span><br><span class="line">            contacts = paginator.page(paginator.num_pages)</span><br><span class="line">        <span class="keyword">return</span> render(request, <span class="string">'comment.html'</span>, locals())</span><br></pre></td></tr></table></figure><p>如果歌曲存在，在歌曲点评表comment中查询当前歌曲的全部点评信息，然后获取到GET请求的请求参数page。参数page点评的分页页数，如果请求参数page不存在，默认页数为1，如果存在，将参数值转换成Int类型。</p><p>当用户评论时，浏览器向网站发送POST请求，POST请求由歌曲点评页的URL接收和处理。首先获取到表单里的点评内容，命名为comment_text,然后获取当前用户名，如果当前用户没有登陆网站，用户为匿名用户，用户为comment_user。如果comment不为空，在歌曲点评表comment中新增一条点评信息，分别记录点评内容、用户名、点评日期和当前歌曲在歌曲信息表的主键。</p><p>最后在使用分页功能进行对数据的显示。</p><p>基本模块就完成了。目前来看，基本不算太难，在有python基本语法的情况下时容易去了解。就是对视图，模块，url这三个进行设计和数据库的连接。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Django+mysql连接成功之后，就是我们对网页设计了。&lt;/p&gt;
&lt;p&gt;但我并不擅长html的一些前端，不做多的描述….因此将这些html文件和静态文件，打包提供大家参考。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;/download/download.zip&quot;&gt;点击下载&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="python, django" scheme="https://skrskr66.github.io/tags/python-django/"/>
    
  </entry>
  
  <entry>
    <title>Django建立一个音乐网站(二)</title>
    <link href="https://skrskr66.github.io/2019/03/12/Django%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AA%E9%9F%B3%E4%B9%90%E7%BD%91%E7%AB%99-%E4%BA%8C/"/>
    <id>https://skrskr66.github.io/2019/03/12/Django建立一个音乐网站-二/</id>
    <published>2019-03-12T02:55:31.000Z</published>
    <updated>2019-03-12T04:07:59.397Z</updated>
    
    <content type="html"><![CDATA[<p>初步模板建立完成之后，就是数据的保存。数据也算是当前互联网中最热门的话题。</p><p>数据库的配置是西纳泽项目所使用的数据库的类型，不同的数据库需要设置不同的数据库引擎，Django提供4种数据库引擎。分别是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'django.db.backends.mysql'</span></span><br><span class="line"><span class="string">'django.db.backends.postgresql'</span></span><br><span class="line"><span class="string">'django.db.backends.sqlite3'</span></span><br><span class="line"><span class="string">'django.db.backends.oracle'</span></span><br></pre></td></tr></table></figure><p>在我看来，我觉得数据的连接和使用对程序员也是一个非常大的提升。</p><p>项目创建时默认使用Sqlite3数据库，这是一款轻型的数据库，常用于嵌入式系统开发，而且占用的资源非常多。但是django2中不再支持<code>mysqldb</code>作为MySQL的连接模块，而选择了<code>mysqlclient</code>模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install mysqlclient</span><br></pre></td></tr></table></figure><p>但是我在安装完成之后，还是有错误显示，这个时候在安装一个</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install PyMySQL</span><br></pre></td></tr></table></figure><p>这两个模块安装后，将MySQL开启，进行连接。</p><p>书上用5.7作为一个，我也建议使用5.7，因为在8版本的密码加密方式发生了改变。</p><p>所以8版本需要在MySQL的可视化工具中运行以下SQL语句：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER USER <span class="string">'root'</span>@<span class="string">'localhost'</span> IDENTIFIED WITH mysql_native_password BY <span class="string">'newpassword'</span>;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure><p>之后我们下载一个navicat进行数据的管理。</p><p>建议下载navicat10版本的，网上有许多的注册码，我先贴一个我自用的，如果不行，在继续寻找</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NAVN-LNXG-XHHX-5NOO</span><br></pre></td></tr></table></figure><p><img src="/2019/03/12/Django建立一个音乐网站-二/Django1.png" alt="Django1"></p><p>然后将之前<code>DATABASE</code>中设置的用户名和密码填入，连接就成功</p><p>首页的歌曲信息应该来自于数据库，除了Django内置的数据表之外，根据项目的数据库设计得知，网站一共定义了4张数据表，将4个数据表所对应的模型都在index的models.py中进行定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#index的models.py</span></span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="comment">#歌曲分类表label</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Label</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    label_id = models.AutoField(<span class="string">'序号'</span>, primary_key=<span class="keyword">True</span>)</span><br><span class="line">    label_name = models.CharField(<span class="string">'分类标签'</span>, max_length=<span class="number">10</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment">#设置返回值，若不设置，则默认返回Type对象</span></span><br><span class="line">        <span class="keyword">return</span> self.label_name</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        <span class="comment">#设置Admin界面的显示内容</span></span><br><span class="line">        verbose_name = <span class="string">'歌曲分类'</span></span><br><span class="line">        verbose_name_plural = <span class="string">'歌曲分类'</span></span><br></pre></td></tr></table></figure><p>上面的就是一个对数据表的定义，表名就是一个类名，并且在label_id定义了主键。跟SQL语句是相似的，只不过用的语言不同而已。接着分别定义了歌曲信息表song，歌曲动态表dynamic，歌曲点评表comment。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#歌曲信息表song</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Song</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    song_id = models.AutoField(<span class="string">'序号'</span>, primary_key=<span class="keyword">True</span>)</span><br><span class="line">    song_name = models.CharField(<span class="string">'歌名'</span>, max_length=<span class="number">50</span>)</span><br><span class="line">    song_singer = models.CharField(<span class="string">'歌手'</span>, max_length=<span class="number">50</span>)</span><br><span class="line">    song_time = models.CharField(<span class="string">'时长'</span>, max_length=<span class="number">10</span>)</span><br><span class="line">    song_album = models.CharField(<span class="string">'专辑'</span>, max_length=<span class="number">50</span>)</span><br><span class="line">    song_languages = models.CharField(<span class="string">'语种'</span>, max_length=<span class="number">20</span>)</span><br><span class="line">    song_type = models.CharField(<span class="string">'类型'</span>, max_length=<span class="number">20</span>)</span><br><span class="line">    song_release = models.CharField(<span class="string">'发行时间'</span>, max_length=<span class="number">20</span>)</span><br><span class="line">    song_img = models.CharField(<span class="string">'歌曲图片'</span>, max_length=<span class="number">20</span>)</span><br><span class="line">    song_lyrics = models.CharField(<span class="string">'歌词'</span>, max_length=<span class="number">50</span>, default=<span class="string">'暂无歌词'</span>)</span><br><span class="line">    song_file = models.CharField(<span class="string">'歌曲文件'</span>, max_length=<span class="number">50</span>)</span><br><span class="line">    label = models.ForeignKey(Label, on_delete=models.CASCADE,verbose_name=<span class="string">'歌名分类'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.song_name</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        <span class="comment">#设置Admin界面的显示内容</span></span><br><span class="line">        verbose_name = <span class="string">'歌曲信息'</span></span><br><span class="line">        verbose_name_plural = <span class="string">'歌曲信息'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#歌曲动态表dynamic</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dynamic</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    dynamic_id = models.AutoField(<span class="string">'序号'</span>, primary_key=<span class="keyword">True</span>)<span class="comment">#生成默认的id字段</span></span><br><span class="line">    song = models.ForeignKey(Song, on_delete=models.CASCADE, verbose_name=<span class="string">'歌名'</span>)</span><br><span class="line">    dynamic_plays = models.IntegerField(<span class="string">'播放次数'</span>)</span><br><span class="line">    dynamic_search = models.IntegerField(<span class="string">'搜索次数'</span>)</span><br><span class="line">    dynamic_down = models.IntegerField(<span class="string">'下载次数'</span>)</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        <span class="comment">#设置admin界面的显示内容</span></span><br><span class="line">        verbose_name = <span class="string">'歌曲动态'</span></span><br><span class="line">        verbose_name_plural = <span class="string">'歌曲动态'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Comment</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    comment_id = models.AutoField(<span class="string">'序号'</span>, primary_key=<span class="keyword">True</span>)</span><br><span class="line">    comment_text = models.CharField(<span class="string">'内容'</span>, max_length=<span class="number">500</span>)</span><br><span class="line">    comment_user = models.CharField(<span class="string">'用户'</span>, max_length=<span class="number">20</span>)</span><br><span class="line">    song = models.ForeignKey(Song, on_delete=models.CASCADE,verbose_name=<span class="string">'歌名'</span>)</span><br><span class="line">    <span class="comment">#on_delete=models.CASCADE,删除关联数据,与之关联也删除</span></span><br><span class="line">    comment_date = models.CharField(<span class="string">'日期'</span>, max_length=<span class="number">50</span>)</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        verbose_name = <span class="string">'歌曲评论'</span>  <span class="comment">#verbose_name 在站点管理设置字段的显示名称</span></span><br><span class="line">        verbose_name_plural = <span class="string">'歌曲评论'</span></span><br></pre></td></tr></table></figure><p>一些django定义的说明</p><p>AutoField：只是为模型创建一个自增长的字段，所做的仅仅是创建。自增的工作由所使用的数据库完成。 </p><p>CharField：只是字符串类型</p><p>ForeignKey：类似SQL中的外键，在某类名中使用，作为另一类名的外键</p><p><strong>只要了解SQL，并且有了一定的SQL语法，这些理解起来比较容易的</strong></p><p>定义完成之后，再次到Pycharm中的Terminal输入数据迁移指令：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">F:\music&gt;python manage.py makemigrations</span><br><span class="line">Migrations for 'index':</span><br><span class="line"><span class="code">index\migrations\0001_initial.py</span></span><br><span class="line"><span class="code">...</span></span><br><span class="line"><span class="code"></span></span><br><span class="line">F:\music&gt;python manage.py migrate</span><br></pre></td></tr></table></figure><p>之后打开navicat，可以看到建立了许多表</p><p><img src="/2019/03/12/Django建立一个音乐网站-二/django2.png" alt="django2"></p><p>点开表之后，我们可以进行导入数据等一些列操作。接下来就是对站点进行装饰。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;初步模板建立完成之后，就是数据的保存。数据也算是当前互联网中最热门的话题。&lt;/p&gt;
&lt;p&gt;数据库的配置是西纳泽项目所使用的数据库的类型，不同的数据库需要设置不同的数据库引擎，Django提供4种数据库引擎。分别是：&lt;/p&gt;
&lt;figure class=&quot;highlight 
      
    
    </summary>
    
    
      <category term="python, django" scheme="https://skrskr66.github.io/tags/python-django/"/>
    
  </entry>
  
  <entry>
    <title>Django建立一个音乐网站(一)</title>
    <link href="https://skrskr66.github.io/2019/03/06/Django%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AA%E9%9F%B3%E4%B9%90%E7%BD%91%E7%AB%99-%E4%B8%80/"/>
    <id>https://skrskr66.github.io/2019/03/06/Django建立一个音乐网站-一/</id>
    <published>2019-03-06T14:45:58.000Z</published>
    <updated>2019-03-12T02:58:26.655Z</updated>
    
    <content type="html"><![CDATA[<p>Django是python学习的一个分支。最近跟着书上在学习。关于书上的项目我觉得拿来练手非常合适。而且涉及了数据库，html相关知识，对程序员的学习关联性我觉得还是有很大的提升的。</p><p>根据《玩转Django2.0》在此理解记忆关于python在Django中的使用。</p><h4 id="Django的安装"><a href="#Django的安装" class="headerlink" title="Django的安装"></a>Django的安装</h4><p>因为Django也到了2.0的时代，而且2.0之前的版本与现在有了一些很大变化，所以根据书上进行，使用2.0进行的学习。</p><p>python的环境不再多说，应该都是准备好了。</p><p>但是django与python的版本互搭问题这个请网上自己寻找。django-2.0还是推荐python3.5之上版本</p><h5 id="利用pip安装"><a href="#利用pip安装" class="headerlink" title="利用pip安装"></a>利用pip安装</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install Django</span><br></pre></td></tr></table></figure><p>这个是最简单的方式，但是如果pip版本不高，可能下的django版本也不高。还有另一个方法</p><h5 id="下载源码安装"><a href="#下载源码安装" class="headerlink" title="下载源码安装"></a>下载源码安装</h5><p><a href="https://www.djangoproject.com/download/" target="_blank" rel="noopener">https://www.djangoproject.com/download/</a> </p><p>如果是源码包, 比如 django-1.11.8.tar.gz </p><p>直接用解压软件解压，然后到命令行（XP/Win7点击<strong>开始</strong>，在下面的那个输入框中输入 cmd, Win8在开始那里点右键，选择命令行)</p><p>比如在<code>D:\django-1.11.8\</code>这个文件夹下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd D:</span><br><span class="line">cd django<span class="number">-1.11</span><span class="number">.8</span></span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure><p>之后检查是否安装成功,从终端进入python环境.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> django</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>django.VERSION</span><br><span class="line">(<span class="number">1</span>, <span class="number">11</span>, <span class="number">8</span>, <span class="string">'final'</span>, <span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>django.get_version()</span><br><span class="line"><span class="string">'1.11.8'</span></span><br></pre></td></tr></table></figure><h4 id="Django项目的创建"><a href="#Django项目的创建" class="headerlink" title="Django项目的创建"></a>Django项目的创建</h4><p>当基本安装完成后，开始项目的创建。这时候使用Pycharm来进行项目的创建。</p><p>选择Pycharm的理由是IDE能更好的帮助我们，工具好，我们才能更好的去理解其他的知识。</p><p>在Pycharm直接新建工程。</p><p><strong>注意！注意！注意！</strong></p><p>此时不要建立成了python工程，要选择django工程。(如果你没有，说明你下载的可能是社区版，请寻找激活码激活的版本)</p><p><img src="/2019/03/06/Django建立一个音乐网站-一/django1.png" alt="django1"></p><p>如上图所示，建立完成后，开始进行项目的初始配置</p><p>建立完成后，我建议直接在pycharm的终端下进行，这样我们在框架之内创建我们的app程序</p><p>在terminal中输入，例如我的</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">F:\music&gt;python manage.py startapp index</span><br><span class="line">F:\music&gt;python manage.py startapp comment</span><br><span class="line">F:\music&gt;python manage.py startapp play</span><br><span class="line">F:\music&gt;python manage.py startapp search</span><br><span class="line">F:\music&gt;python manage.py startapp ranking</span><br><span class="line">F:\music&gt;python manage.py startapp user</span><br></pre></td></tr></table></figure><p>完成项目的创建之后，在项目music的根目录下创建文件夹templates和music(pycharm下创建成功)，两者分别存放模板文件和静态资源文件。</p><p>在templates中放置公用模板title_base.html，在static目录下创建文件夹css，js，font，image，songFile，songLyric，songImg以及在当前目录下放置favicon.ico</p><p><img src="/2019/03/06/Django建立一个音乐网站-一/django2.png" alt="django2"></p><p>接着就是关于setting中的设置。</p><p>在setting中有些地方需要我们去添加，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">'django.contrib.admin'</span>,</span><br><span class="line">    <span class="string">'django.contrib.auth'</span>,</span><br><span class="line">    <span class="string">'django.contrib.contenttypes'</span>,</span><br><span class="line">    <span class="string">'django.contrib.sessions'</span>,</span><br><span class="line">    <span class="string">'django.contrib.messages'</span>,</span><br><span class="line">    <span class="string">'django.contrib.staticfiles'</span>,</span><br><span class="line">    <span class="string">'index'</span>,</span><br><span class="line">    <span class="string">'ranking'</span>,</span><br><span class="line">    <span class="string">'user'</span>,</span><br><span class="line">    <span class="string">'play'</span>,</span><br><span class="line">    <span class="string">'search'</span>,</span><br><span class="line">    <span class="string">'comment'</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">MIDDLEWARE = [</span><br><span class="line">    <span class="string">'django.middleware.security.SecurityMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.contrib.sessions.middleware.SessionMiddleware'</span>,</span><br><span class="line">    <span class="comment">#使用中文</span></span><br><span class="line">    <span class="string">'django.middleware.locale.LocaleMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.middleware.common.CommonMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.middleware.csrf.CsrfViewMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.contrib.auth.middleware.AuthenticationMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.contrib.messages.middleware.MessageMiddleware'</span>,</span><br><span class="line">    <span class="string">'django.middleware.clickjacking.XFrameOptionsMiddleware'</span>,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">TEMPLATES = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'BACKEND'</span>: <span class="string">'django.template.backends.django.DjangoTemplates'</span>,</span><br><span class="line">        <span class="string">'DIRS'</span>: [os.path.join(BASE_DIR, <span class="string">'templates'</span>),</span><br><span class="line">                 os.path.join(BASE_DIR,<span class="string">'index/templates'</span>),</span><br><span class="line">                 os.path.join(BASE_DIR,<span class="string">'ranking/templates'</span>),</span><br><span class="line">                 os.path.join(BASE_DIR,<span class="string">'user/templates'</span>),</span><br><span class="line">                 os.path.join(BASE_DIR,<span class="string">'play/templates'</span>),</span><br><span class="line">                 os.path.join(BASE_DIR,<span class="string">'comment/templates'</span>),</span><br><span class="line">                 ],</span><br><span class="line">        <span class="string">'APP_DIRS'</span>: <span class="keyword">True</span>,</span><br><span class="line">        <span class="string">'OPTIONS'</span>: &#123;</span><br><span class="line">            <span class="string">'context_processors'</span>: [</span><br><span class="line">                <span class="string">'django.template.context_processors.debug'</span>,</span><br><span class="line">                <span class="string">'django.template.context_processors.request'</span>,</span><br><span class="line">                <span class="string">'django.contrib.auth.context_processors.auth'</span>,</span><br><span class="line">                <span class="string">'django.contrib.messages.context_processors.messages'</span>,</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">DATABASES = &#123;</span><br><span class="line">    <span class="string">'default'</span>: &#123;</span><br><span class="line">        <span class="string">'ENGINE'</span>: <span class="string">'django.db.backends.mysql'</span>,</span><br><span class="line">        <span class="string">'NAME'</span>: <span class="string">'music_db'</span>,</span><br><span class="line">        <span class="string">'USER'</span>: <span class="string">'root'</span>,</span><br><span class="line">        <span class="string">'PASSWORD'</span>: <span class="string">'123456'</span>,</span><br><span class="line">        <span class="string">'HOST'</span>: <span class="string">'127.0.0.1'</span>,</span><br><span class="line">        <span class="string">'PORT'</span>: <span class="string">'3306'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当所有常规设置信息都完成之后，我们接着对项目url进行配置，在项目的<code>urls.py</code>中分别对新建的App设置相应的URL地址</p><p><strong>注意！！！</strong></p><p><strong>注意！！！</strong></p><p><strong>注意！！！</strong></p><p>根据书上所描述一开始就将所有的App数据进行了添加。但是在操作过程中，因为其他模板应用并没有完成设计所以，会报错不存在model</p><p>此时可以先添加进行，完成一个模板之后，将其注释去掉</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">''</span>, include(<span class="string">'index.urls'</span>)),</span><br><span class="line">    <span class="comment">#path('ranking.html', include('ranking.urls')),</span></span><br><span class="line">    <span class="comment">#path('play/', include('play.urls')),</span></span><br><span class="line">    <span class="comment">#path('comment/', include('comment.urls')),</span></span><br><span class="line">    <span class="comment">#path('search/', include('search.urls')),</span></span><br><span class="line">    <span class="comment">#path('user/', include('user.urls')),</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>基本配置就算完成，下一部分先关于数据库的建立写博客</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Django是python学习的一个分支。最近跟着书上在学习。关于书上的项目我觉得拿来练手非常合适。而且涉及了数据库，html相关知识，对程序员的学习关联性我觉得还是有很大的提升的。&lt;/p&gt;
&lt;p&gt;根据《玩转Django2.0》在此理解记忆关于python在Django中的
      
    
    </summary>
    
    
      <category term="python, django" scheme="https://skrskr66.github.io/tags/python-django/"/>
    
  </entry>
  
  <entry>
    <title>利用结构体实现一个通讯录</title>
    <link href="https://skrskr66.github.io/2019/02/22/%E2%80%9C%E5%88%A9%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%80%9A%E8%AE%AF%E5%BD%95/"/>
    <id>https://skrskr66.github.io/2019/02/22/“利用结构体实现一个通讯录/</id>
    <published>2019-02-22T03:16:12.000Z</published>
    <updated>2019-03-01T03:33:13.814Z</updated>
    
    <content type="html"><![CDATA[<p>实现一个通讯录；  通讯录可以用来存储1000个人的信息，每个人的信息包括：  姓名、性别、年龄、电话、住址   </p><p>提供方法1.添加联系人信息  2.删除指定联系人信息  3.查找指定联系人信息  4.修改指定联系人信息  5.显示所有联系人信息  6.清空所有联系人  7.以名字排序所有联系人  8. 保存联系人到文件  9. 加载联系人   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PERSON_INFO_MAX_SIZE 1024</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PersonInfo</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">char</span> phone[<span class="number">1024</span>];</span><br><span class="line">&#125;PersonInfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AddressBook</span>&#123;</span><span class="comment">//结构体数组</span></span><br><span class="line">    PersonInfo infos[PERSON_INFO_MAX_SIZE];</span><br><span class="line">    <span class="keyword">int</span> size;<span class="comment">//描述数组中前多少个元素是被使用的，有效元素区间[0,size)</span></span><br><span class="line">&#125;AddressBook;</span><br><span class="line"><span class="comment">//我们将生活中的常识抽象成计算机中的语言</span></span><br><span class="line"></span><br><span class="line">AddressBook g_address_book;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(AddressBook* addr_book)</span></span>&#123;</span><br><span class="line">    assert(addr_book != <span class="literal">NULL</span>);</span><br><span class="line">    addr_book-&gt; size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddPersonInfo</span><span class="params">(AddressBook* addr_book)</span></span>&#123;</span><br><span class="line">    assert(addr_book != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"插入一个联系人！\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(addr_book-&gt;size &gt;= PERSON_INFO_MAX_SIZE)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"当前通讯已满,插入失败!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//每次都把新的联系人放到有效数组的最后一个元素上</span></span><br><span class="line">    PersonInfo *p = &amp;addr_book-&gt;infos[addr_book-&gt;size];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入新增的联系人姓名:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,p-&gt;name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入新增的联系人的电话:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,p-&gt;phone);</span><br><span class="line">    <span class="comment">//新增完成后，需要更新size</span></span><br><span class="line">    ++addr_book-&gt;size;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"插入联系人成功！\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DelPersonInfo</span><span class="params">(AddressBook* addr_book)</span></span>&#123;</span><br><span class="line">    assert(addr_book != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"删除联系人！\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据用户输入的下标来删除联系人</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入要删除的联系人符号："</span>);</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;id);</span><br><span class="line">    <span class="keyword">if</span>(id &lt; <span class="number">0</span> || id &gt;= addr_book-&gt;size)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"您输入的序号有误!删除失败!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PersonInfo *p = &amp;addr_book-&gt;infos[id];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"您要删除的联系人为[%d] %s,确认请输入Y:"</span>,id,p-&gt;name);</span><br><span class="line">    <span class="keyword">char</span> cmd[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,cmd);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(cmd, <span class="string">"Y"</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"删除操作已经取消!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PersonInfo* from = &amp;aaddr_book-&gt;infos[addr_book-&gt;size - <span class="number">1</span>];</span><br><span class="line">    PersonInfo* to = p;</span><br><span class="line">    *to = *from;</span><br><span class="line">    --addr_book-&gt;size;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"删除成功!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModifyPersonInfo</span><span class="params">(AddressBook* addr_book)</span></span>&#123;</span><br><span class="line">    assert(addr_book != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"修改联系人\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入需要修改的联系人序号:"</span>);</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;id);</span><br><span class="line">    <span class="keyword">if</span>(id &lt; <span class="number">0</span> || id &gt;= addr_book-&gt;size)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"您输入的序号错误"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PersonInfo *p = &amp;addr_book-&gt;infos[id];</span><br><span class="line">    <span class="keyword">char</span> input[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入要修改的姓名:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,input);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(input,<span class="string">"#"</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(p-&gt;name,input);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入要修改的电话:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,input);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(input,<span class="string">"#"</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(p-&gt;phone,input);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"修改成功!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindPersonInfo</span><span class="params">(AddressBook* addr_book)</span></span>&#123;</span><br><span class="line">    assert(addr_book != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"开始进行查找！\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入要查找的姓名："</span>);</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,name);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; addr_book-&gt;size;++i)&#123;</span><br><span class="line">        PersonInfo* p = &amp;addr_book-&gt;infos[i];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(name,p-&gt;name) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[%d] %s\t%s\n"</span>,i,p-&gt;name,p-&gt;phone);</span><br><span class="line">        ++count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"查找完毕！共找到 %d 条记录！\n"</span>,count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SortPersonInfo</span><span class="params">(AddressBook* addr_book)</span></span>&#123;<span class="comment">//只适用于英文名字的排序</span></span><br><span class="line">    assert(addr_book != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; addr_book-&gt;size;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; addr_book-&gt;size - <span class="number">1</span> - i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strcmp</span>(addr_book-&gt;infos[j].name,addr_book-&gt;infos[j + <span class="number">1</span>].name) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                PersonInfo tmp;</span><br><span class="line">                tmp = addr_book-&gt;infos[j];</span><br><span class="line">                addr_book-&gt;infos[j] = addr_book-&gt;infos[j + <span class="number">1</span>];</span><br><span class="line">                addr_book-&gt;infos[j + <span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAllPersonInfo</span><span class="params">(AddressBook* addr_book)</span></span>&#123;</span><br><span class="line">    assert(addr_book != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; addr_book-&gt;size;++i)&#123;</span><br><span class="line">        PersonInfo* p = &amp;addr_book-&gt;infos[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[%d] %s\t%s\n"</span>,i ,p-&gt;name,p-phone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearPersonInfo</span><span class="params">(AddressBook* addr_book)</span></span>&#123;</span><br><span class="line">    assert(addr_book != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"清空所有记录！\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"您确认要清空所有记录吗？输入 Y 表示确定"</span>);</span><br><span class="line">    <span class="keyword">char</span> cmd[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,&amp;cmd);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(cmd,<span class="string">"Y"</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"清空操作取消"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    addr_book-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"清空操作成功！\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Menu</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"================="</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"1.新增\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"2.删除\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"3.修改\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"4.查找\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"5.排序\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"6.显示全部\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"7.清空全部\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"0.退出\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"================="</span>);</span><br><span class="line">    <span class="keyword">int</span> choice = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;choice);</span><br><span class="line">    <span class="keyword">return</span> choice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.对通讯录进行初始化</span></span><br><span class="line">    Init(&amp;g_address_book);</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*<span class="keyword">pfunc_t</span>)</span><span class="params">(AddressBook*)</span></span>;</span><br><span class="line">    <span class="keyword">pfunc_t</span> table[] = &#123;</span><br><span class="line">        AddPersonInfo,</span><br><span class="line">        DelPersonInfo,</span><br><span class="line">        ModifyPersonInfo,</span><br><span class="line">        FindPersonInfo,</span><br><span class="line">        SortPersonInfo,</span><br><span class="line">        PrintAllPersonInfo,</span><br><span class="line">        ClearPersonInfo</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> choice = Menu();</span><br><span class="line">        <span class="keyword">if</span>(choice &lt; <span class="number">0</span> || choice &gt; (<span class="keyword">int</span>)(<span class="keyword">sizeof</span>(table) / <span class="keyword">sizeof</span>(table[<span class="number">0</span>])))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"您的输入有误!\n"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(choice == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"goodbye!\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        table[choice - <span class="number">1</span>](&amp;g_address_book);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个通讯录只是一个静态的，此时还可以进行一些改版，将其变为动态结合的，这时候可利用到malloc函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PERSON_INFO_MAX_SIZE 1024</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PersonInfo</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">char</span> phone[<span class="number">1024</span>];</span><br><span class="line">&#125;PersonInfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AddressBook</span>&#123;</span><span class="comment">//结构体数组</span></span><br><span class="line">    PersonInfo* infos;</span><br><span class="line">    <span class="keyword">int</span> capacity;<span class="comment">//容量，infos指针指向的动态数组的长度（元素个数）</span></span><br><span class="line">    <span class="keyword">int</span> size;<span class="comment">//描述数组中前多少个元素是被使用的，有效元素区间[0,size)</span></span><br><span class="line">&#125;AddressBook;</span><br><span class="line"><span class="comment">//我们将生活中的常识抽象成计算机中的语言</span></span><br><span class="line"></span><br><span class="line">AddressBook g_address_book;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(AddressBook* addr_book)</span></span>&#123;</span><br><span class="line">    assert(addr_book != <span class="literal">NULL</span>);</span><br><span class="line">    addr_book-&gt; size = <span class="number">0</span>;</span><br><span class="line">    addr_book-&gt;capacity = <span class="number">10</span>;</span><br><span class="line">    addr_book-&gt;infos = (PersonInfo*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(PersonInfo) * addr_book-&gt;capacity);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Realloc</span><span class="params">(AddressBook* addr_book)</span></span>&#123;</span><br><span class="line">    assert(addr_book != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//此处每次扩容多少，这样的策略完全是我们自定制的</span></span><br><span class="line">    <span class="comment">//1.扩大capacity的取值</span></span><br><span class="line">    addr_book-&gt;capacity *= <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//2.申请一个更大的内存</span></span><br><span class="line">    PersonInfo* old_infos = addr_book-&gt;infos;    </span><br><span class="line">    addr_book-&gt;infos = (PersonInfo*)<span class="built_in">malloc</span>(addr_book-&gt;capacity * <span class="keyword">sizeof</span>(PersonInfo));</span><br><span class="line">    <span class="comment">//3.把原有的内存中的数据复制过来</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; addr_book-&gt;size;++i)&#123;</span><br><span class="line">        addr_book-&gt;infos[i] = old_infos[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.释放原有的内存</span></span><br><span class="line">    <span class="built_in">free</span>(old_infos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddPersonInfo</span><span class="params">(AddressBook* addr_book)</span></span>&#123;</span><br><span class="line">    assert(addr_book != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"插入一个联系人！\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(addr_book-&gt;size &gt;= addr_book-&gt;capacity)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"当前通讯已满,插入失败!进行扩容！\n"</span>);</span><br><span class="line">        Realloc(addr_book);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//每次都把新的联系人放到有效数组的最后一个元素上</span></span><br><span class="line">    PersonInfo *p = &amp;addr_book-&gt;infos[addr_book-&gt;size];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入新增的联系人姓名:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,p-&gt;name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入新增的联系人的电话:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,p-&gt;phone);</span><br><span class="line">    <span class="comment">//新增完成后，需要更新size</span></span><br><span class="line">    ++addr_book-&gt;size;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"插入联系人成功！\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DelPersonInfo</span><span class="params">(AddressBook* addr_book)</span></span>&#123;</span><br><span class="line">    assert(addr_book != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"删除联系人！\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据用户输入的下标来删除联系人</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入要删除的联系人符号："</span>);</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;id);</span><br><span class="line">    <span class="keyword">if</span>(id &lt; <span class="number">0</span> || id &gt;= addr_book-&gt;size)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"您输入的序号有误!删除失败!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PersonInfo *p = &amp;addr_book-&gt;infos[id];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"您要删除的联系人为[%d] %s,确认请输入Y:"</span>,id,p-&gt;name);</span><br><span class="line">    <span class="keyword">char</span> cmd[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,cmd);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(cmd, <span class="string">"Y"</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"删除操作已经取消!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PersonInfo* from = &amp;aaddr_book-&gt;infos[addr_book-&gt;size - <span class="number">1</span>];</span><br><span class="line">    PersonInfo* to = p;</span><br><span class="line">    *to = *from;</span><br><span class="line">    --addr_book-&gt;size;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"删除成功!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModifyPersonInfo</span><span class="params">(AddressBook* addr_book)</span></span>&#123;</span><br><span class="line">    assert(addr_book != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"修改联系人\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入需要修改的联系人序号:"</span>);</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;id);</span><br><span class="line">    <span class="keyword">if</span>(id &lt; <span class="number">0</span> || id &gt;= addr_book-&gt;size)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"您输入的序号错误"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PersonInfo *p = &amp;addr_book-&gt;infos[id];</span><br><span class="line">    <span class="keyword">char</span> input[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入要修改的姓名:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,input);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(input,<span class="string">"#"</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(p-&gt;name,input);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入要修改的电话:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,input);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(input,<span class="string">"#"</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(p-&gt;phone,input);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"修改成功!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindPersonInfo</span><span class="params">(AddressBook* addr_book)</span></span>&#123;</span><br><span class="line">    assert(addr_book != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"开始进行查找！\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入要查找的姓名："</span>);</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,name);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; addr_book-&gt;size;++i)&#123;</span><br><span class="line">        PersonInfo* p = &amp;addr_book-&gt;infos[i];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(name,p-&gt;name) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[%d] %s\t%s\n"</span>,i,p-&gt;name,p-&gt;phone);</span><br><span class="line">        ++count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"查找完毕！共找到 %d 条记录！\n"</span>,count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SortPersonInfo</span><span class="params">(AddressBook* addr_book)</span></span>&#123;<span class="comment">//只适用于英文名字的排序</span></span><br><span class="line">    assert(addr_book != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; addr_book-&gt;size;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; addr_book-&gt;size - <span class="number">1</span> - i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strcmp</span>(addr_book-&gt;infos[j].name,addr_book-&gt;infos[j + <span class="number">1</span>].name) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                PersonInfo tmp;</span><br><span class="line">                tmp = addr_book-&gt;infos[j];</span><br><span class="line">                addr_book-&gt;infos[j] = addr_book-&gt;infos[j + <span class="number">1</span>];</span><br><span class="line">                addr_book-&gt;infos[j + <span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAllPersonInfo</span><span class="params">(AddressBook* addr_book)</span></span>&#123;</span><br><span class="line">    assert(addr_book != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; addr_book-&gt;size;++i)&#123;</span><br><span class="line">        PersonInfo* p = &amp;addr_book-&gt;infos[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[%d] %s\t%s\n"</span>,i ,p-&gt;name,p-phone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearPersonInfo</span><span class="params">(AddressBook* addr_book)</span></span>&#123;</span><br><span class="line">    assert(addr_book != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"清空所有记录！\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"您确认要清空所有记录吗？输入 Y 表示确定"</span>);</span><br><span class="line">    <span class="keyword">char</span> cmd[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,&amp;cmd);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(cmd,<span class="string">"Y"</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"清空操作取消"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    addr_book-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"清空操作成功！\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Menu</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"================="</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"1.新增\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"2.删除\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"3.修改\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"4.查找\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"5.排序\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"6.显示全部\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"7.清空全部\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"0.退出\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"================="</span>);</span><br><span class="line">    <span class="keyword">int</span> choice = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;choice);</span><br><span class="line">    <span class="keyword">return</span> choice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.对通讯录进行初始化</span></span><br><span class="line">    Init(&amp;g_address_book);</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*<span class="keyword">pfunc_t</span>)</span><span class="params">(AddressBook*)</span></span>;</span><br><span class="line">    <span class="keyword">pfunc_t</span> table[] = &#123;</span><br><span class="line">        AddPersonInfo,</span><br><span class="line">        DelPersonInfo,</span><br><span class="line">        ModifyPersonInfo,</span><br><span class="line">        FindPersonInfo,</span><br><span class="line">        SortPersonInfo,</span><br><span class="line">        PrintAllPersonInfo,</span><br><span class="line">        ClearPersonInfo</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> choice = Menu();</span><br><span class="line">        <span class="keyword">if</span>(choice &lt; <span class="number">0</span> || choice &gt; (<span class="keyword">int</span>)(<span class="keyword">sizeof</span>(table) / <span class="keyword">sizeof</span>(table[<span class="number">0</span>])))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"您的输入有误!\n"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(choice == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"goodbye!\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        table[choice - <span class="number">1</span>](&amp;g_address_book);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在扩容过程中，我们经过分析之后，当内存不够时，考虑到只有添加才需要开辟新的空间。</p><p>所以在第一个静态的版本之上，又加入了动态开辟，这样当添加不够时，我们的程序会自动开辟新的空间，为了当前能够使用。</p><p>在代码中有注释，关于开辟的关键。</p><p>内存中原先保存的位置我们也要管理，否则会造成内存泄漏。必须要保证这有一个合适的内存分配。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实现一个通讯录；  通讯录可以用来存储1000个人的信息，每个人的信息包括：  姓名、性别、年龄、电话、住址   &lt;/p&gt;
&lt;p&gt;提供方法1.添加联系人信息  2.删除指定联系人信息  3.查找指定联系人信息  4.修改指定联系人信息  5.显示所有联系人信息  6.清空所
      
    
    </summary>
    
    
      <category term="进阶C" scheme="https://skrskr66.github.io/tags/%E8%BF%9B%E9%98%B6C/"/>
    
  </entry>
  
  <entry>
    <title>模拟实现strncpy,strncat,strncmp</title>
    <link href="https://skrskr66.github.io/2019/02/21/%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0strncpy-strncat-strncmp/"/>
    <id>https://skrskr66.github.io/2019/02/21/模拟实现strncpy-strncat-strncmp/</id>
    <published>2019-02-21T13:05:23.000Z</published>
    <updated>2019-02-21T13:13:26.421Z</updated>
    
    <content type="html"><![CDATA[<p>main()函数中的例子全部取于cplusplus网站</p><p>模拟实现strncat</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">Strncat</span><span class="params">(<span class="keyword">char</span>* dest,<span class="keyword">const</span> <span class="keyword">char</span>* src,<span class="keyword">size_t</span> num)</span></span>&#123;    </span><br><span class="line">  assert(dest != <span class="literal">NULL</span>);    </span><br><span class="line">  assert(src != <span class="literal">NULL</span>);    </span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>;    </span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; num; i++);    </span><br><span class="line">  <span class="built_in">strncpy</span>(&amp;dest[i],src,num);    </span><br><span class="line">  <span class="keyword">return</span> dest;    </span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </span><br><span class="line">  <span class="keyword">char</span> str1[<span class="number">20</span>];    </span><br><span class="line">  <span class="keyword">char</span> str2[<span class="number">20</span>];    </span><br><span class="line">  <span class="built_in">strcpy</span> (str1,<span class="string">"To be "</span>);    </span><br><span class="line">  <span class="built_in">strcpy</span> (str2,<span class="string">"or not to be"</span>);    </span><br><span class="line">  Strncat (str1, str2, <span class="number">6</span>);    </span><br><span class="line">  <span class="built_in">puts</span> (str1);    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟实现strncmp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Strncmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span>*src, <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(dest != <span class="literal">NULL</span>);</span><br><span class="line">assert(src != <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">while</span> (count &amp;&amp; *dest != <span class="string">'\0'</span> &amp;&amp; *src != <span class="string">'\0'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*dest &gt; *src)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*dest &lt; *src)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">dest++;</span><br><span class="line">src++;</span><br><span class="line">count--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> str[][<span class="number">5</span>] = &#123; <span class="string">"R2D2"</span>, <span class="string">"C3PO"</span>, <span class="string">"R2A6"</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Looking for R2 astromech droids...\n"</span>);</span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">0</span>; n&lt;<span class="number">3</span>; n++)</span><br><span class="line"><span class="keyword">if</span> (Strncmp(str[n], <span class="string">"R2xx"</span>, <span class="number">2</span>) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"found %s\n"</span>, str[n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>strncpy模拟实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">Strncpy</span><span class="params">(<span class="keyword">char</span>* dest, <span class="keyword">const</span> <span class="keyword">char</span>* src, <span class="keyword">size_t</span> num)</span></span>&#123;    </span><br><span class="line">  assert(dest != <span class="literal">NULL</span>);    </span><br><span class="line">  assert(src != <span class="literal">NULL</span>);    </span><br><span class="line">  <span class="keyword">int64_t</span> i = <span class="number">0</span>;    </span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>;(<span class="keyword">unsigned</span>)i &lt; num;i++)&#123;    </span><br><span class="line">    dest[i] = src[i];    </span><br><span class="line">  &#125;    </span><br><span class="line">  dest[num] = <span class="string">'\0'</span>;    </span><br><span class="line">  <span class="keyword">return</span> dest;    </span><br><span class="line">&#125;    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> str1[]= <span class="string">"To be or not to be"</span>;</span><br><span class="line">  <span class="keyword">char</span> str2[<span class="number">40</span>];</span><br><span class="line">  <span class="keyword">char</span> str3[<span class="number">40</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* copy to sized buffer (overflow safe): */</span></span><br><span class="line">  Strncpy ( str2, str1, <span class="keyword">sizeof</span>(str2)  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* partial copy (only 5 chars): */</span></span><br><span class="line">  Strncpy ( str3, str2, <span class="number">7</span>  );</span><br><span class="line">  str3[<span class="number">7</span>] = <span class="string">'\0'</span>;   <span class="comment">/* null character manually added */</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span> (str1);</span><br><span class="line">  <span class="built_in">puts</span> (str2);</span><br><span class="line">  <span class="built_in">puts</span> (str3);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;main()函数中的例子全部取于cplusplus网站&lt;/p&gt;
&lt;p&gt;模拟实现strncat&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/s
      
    
    </summary>
    
    
      <category term="进阶C" scheme="https://skrskr66.github.io/tags/%E8%BF%9B%E9%98%B6C/"/>
    
  </entry>
  
  <entry>
    <title>C语言标准库函数的理解与重写</title>
    <link href="https://skrskr66.github.io/2019/02/16/C%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86%E5%BA%93%E5%87%BD%E6%95%B0%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E9%87%8D%E5%86%99/"/>
    <id>https://skrskr66.github.io/2019/02/16/C语言标准库函数的理解与重写/</id>
    <published>2019-02-16T04:33:44.000Z</published>
    <updated>2019-02-17T10:36:56.129Z</updated>
    
    <content type="html"><![CDATA[<p>1.实现strcpy  2.实现strcat  3.实现strstr  4.实现strchr  5.实现strcmp  6.实现memcpy  7.实现memmove </p><p>为了更好的去理解这几个函数的用法，自己去实现一下功能，才能更好的学习</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">size_t</span> Strlen(<span class="keyword">const</span> <span class="keyword">char</span>* str)&#123;<span class="comment">//无符号整型</span></span><br><span class="line">    assert(str != <span class="literal">NULL</span>);<span class="comment">//首先要进行合法性判断，如果字符串本身都有问题，那么就没必要检验了</span></span><br><span class="line">    <span class="keyword">size_t</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(str[count] != <span class="string">'\0'</span>)&#123;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> conunt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">Strcpy</span><span class="params">(<span class="keyword">char</span>* dest,<span class="keyword">const</span> <span class="keyword">char</span>* src)</span></span>&#123;</span><br><span class="line">    assert(dest != <span class="literal">NULL</span>);</span><br><span class="line">    assert(src != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">int64_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;src[i] != <span class="string">'\0'</span>;i++)&#123;</span><br><span class="line">        dest[i] = src[i];</span><br><span class="line">    &#125;</span><br><span class="line">    dest[i] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">Strcat</span><span class="params">(<span class="keyword">char</span>* dest,<span class="keyword">const</span> <span class="keyword">char</span>* src)</span></span>&#123;</span><br><span class="line">    assert(dest != <span class="literal">NULL</span>);</span><br><span class="line">    assert(src != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; dest[i] != <span class="string">'\0'</span>;i++);</span><br><span class="line">    Strcpy(&amp;dest[i],src);</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">Strstr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str1,<span class="keyword">const</span> <span class="keyword">char</span>* str2)</span></span>&#123;</span><br><span class="line">    assert(str1 != <span class="literal">NULL</span>);</span><br><span class="line">    assert(str2 != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(*str1 == <span class="string">'\0'</span> || *str2 == <span class="string">'\0'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* black_ptr = str1;</span><br><span class="line">    <span class="keyword">while</span>(*black_ptr != <span class="string">'\0'</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* sub_ptr = str2;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* red_ptr = black_ptr;</span><br><span class="line">        <span class="keyword">while</span>(*red_ptr != <span class="string">'\0'</span> &amp;&amp; *sub_ptr != <span class="string">'\0'</span> &amp;&amp;(*red_ptr == *sub_ptr))&#123;</span><br><span class="line">            ++red_ptr;</span><br><span class="line">            ++sub_ptr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(*sub_ptr == <span class="string">'\0'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> black_ptr;</span><br><span class="line">        &#125;</span><br><span class="line">        ++black_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">Strchr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str,<span class="keyword">int</span> chr)</span></span>&#123;</span><br><span class="line">    assert(str != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span>(*str)&#123;<span class="comment">//*str表示字符数组中第一个字符</span></span><br><span class="line">        <span class="keyword">if</span>(*str == (<span class="keyword">char</span>)chr)&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">char</span>*)str;<span class="comment">//此时返回的是第一个找到所需字符的地址</span></span><br><span class="line">        &#125;</span><br><span class="line">        ++str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str1, <span class="keyword">const</span> <span class="keyword">char</span>* str2)</span></span>&#123;</span><br><span class="line">    assert(str1 != <span class="literal">NULL</span>);</span><br><span class="line">    assert(str2 != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span>(*str1 != <span class="string">'\0'</span> &amp;&amp; *str2 != <span class="string">'\0'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*str1 &gt; *str2)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(*str1 &lt; *str2)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ++str1;</span><br><span class="line">            ++str2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此时如果str1或者str2有一个提前遇到了'\0',那么跳出了while循环，接着判断</span></span><br><span class="line">    <span class="keyword">if</span>(*str1 &gt; *str2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(*str1 &lt; *str2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Memcpy</span><span class="params">(<span class="keyword">void</span>* dest,<span class="keyword">void</span>* src,<span class="keyword">size_t</span> num)</span></span>&#123;</span><br><span class="line">    assert(dest != <span class="literal">NULL</span>);</span><br><span class="line">    assert(src != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">char</span>* pdest = (<span class="keyword">char</span>*)dest;<span class="comment">//void*不能解引用，类型改变，只在运算中起作用，是临时的，本身的类型不改变，所以最后还是返回dest</span></span><br><span class="line">    <span class="keyword">char</span>* psrc = (<span class="keyword">char</span>*)src;</span><br><span class="line">    <span class="keyword">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; num;++i)&#123;</span><br><span class="line">        pdest[i] = psrc[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Memmove</span><span class="params">(<span class="keyword">void</span>* dest,<span class="keyword">const</span> <span class="keyword">void</span>* src,<span class="keyword">size_t</span> num)</span></span>&#123;</span><br><span class="line">    assert(dest != <span class="literal">NULL</span>);</span><br><span class="line">    assert(src != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">char</span>* pdest = (<span class="keyword">char</span>*)dest;</span><br><span class="line">    <span class="keyword">char</span>* psrc = (<span class="keyword">char</span>*)src;</span><br><span class="line">    <span class="keyword">if</span>(pdest &gt;= psrc &amp;&amp; pdest &lt; psrc + num)&#123;<span class="comment">//这是标准库认为的缓冲区重合</span></span><br><span class="line">        <span class="comment">//起始dest指针如果在src缓冲区范围以内，拷贝为缓冲区重合</span></span><br><span class="line">        <span class="comment">//以外则不为缓冲区拷贝</span></span><br><span class="line">        <span class="keyword">int64_t</span> i = <span class="number">0</span>;<span class="comment">//从最后一个元素的下标开始，倒着拷贝</span></span><br><span class="line">        <span class="keyword">for</span>(i = num - i;i &gt;= <span class="number">0</span>;i++)&#123;</span><br><span class="line">            pdest[i] = psrc[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//完全按照原来方法拷贝</span></span><br><span class="line">        Memcpy(dest,src,num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.实现strcpy  2.实现strcat  3.实现strstr  4.实现strchr  5.实现strcmp  6.实现memcpy  7.实现memmove &lt;/p&gt;
&lt;p&gt;为了更好的去理解这几个函数的用法，自己去实现一下功能，才能更好的学习&lt;/p&gt;
&lt;figur
      
    
    </summary>
    
    
      <category term="进阶C" scheme="https://skrskr66.github.io/tags/%E8%BF%9B%E9%98%B6C/"/>
    
  </entry>
  
  <entry>
    <title>初阶C-0215</title>
    <link href="https://skrskr66.github.io/2019/02/15/%E5%88%9D%E9%98%B6C-0215/"/>
    <id>https://skrskr66.github.io/2019/02/15/初阶C-0215/</id>
    <published>2019-02-15T13:31:49.000Z</published>
    <updated>2019-02-16T04:24:29.986Z</updated>
    
    <content type="html"><![CDATA[<p>1.实现一个函数，可以左旋字符串中的k个字符。  </p><p>ABCD左旋一个字符得到BCDA  ABCD左旋两个字符得到CDAB  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">left_rotate</span><span class="params">(<span class="keyword">char</span>* str,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">    <span class="keyword">char</span> tmp = *str;</span><br><span class="line">    <span class="keyword">char</span>* cur = str;</span><br><span class="line">    <span class="keyword">while</span>(*(cur + <span class="number">1</span>))&#123;<span class="comment">//判断真假是否到了‘\0’</span></span><br><span class="line">    *cur = *(cur + <span class="number">1</span>);</span><br><span class="line">    cur++;</span><br><span class="line">    &#125;</span><br><span class="line">        *cur = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个问题需要我们去注意</p><p>当我们左旋的时候，将B  C  D移动向前之后，之前字符串的<code>\0</code>也被提前了。</p><p>但是字符串数组本身最后有一个<code>\0</code>,所以我们要在字符串的前一个位置，把旋转的字符与前面的<code>\0</code>交换</p><p>那么这个时候在while循环里，需要将我们的<code>cur</code>向后移动一个位置，也就是字符串之前的最后一个位置。</p><p>此时的判断条件为<code>cur + 1</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">"ABCD"</span>;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,str)</span><br><span class="line">    left_rotate(str, k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于右旋，右旋就是左旋的相反，即<code>strlen(str)-k</code>次，直接在右旋中，调用左旋设置k的次数即可</p><p>2.判断一个字符串是否为另外一个字符串旋转之后的字符串。  </p><p>例如：给定s1 =AABCD和s2 = BCDAA，返回1，给定s1=abcd和s2=ACBD，返回0.   </p><p>AABCD左旋一个字符得到ABCDA  </p><p>AABCD左旋两个字符得到BCDAA   </p><p>AABCD右旋一个字符得到DAABC  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_rotate</span><span class="params">(<span class="keyword">char</span>* dest, <span class="keyword">char</span>* src)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(dest) != <span class="built_in">strlen</span>(src))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(src);</span><br><span class="line">    <span class="keyword">while</span>(len--)&#123;</span><br><span class="line">        right_rotate(src, <span class="number">1</span>);<span class="comment">//一次一个判断</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(dest, src) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.一个数组中只有两个数字是出现一次，  其他所有数字都出现了两次。  </p><p>找出这两个数字，编程实现。  </p><p>首先要清楚连续异或的结果，因为单独出现的数字会在最后呈现出来</p><p>这样我们就可以找到异或结果中，二进制‘1’在什么位置不同</p><p>根据‘1’的位置把所有数分成两组，每一组当中必有一个数单独出现一次</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[]=&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sz = <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; sz;i++)&#123;</span><br><span class="line">        ret ^= a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">32</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(((ret &gt;&gt; i) &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">        pos = i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; sz;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(((a[i] &gt;&gt; pos) &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">            x ^= a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            y ^= a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d"</span>,x,y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.喝汽水，1瓶汽水1元，2个空瓶可以换一瓶汽水，  给20元，可以多少汽水。  </p><p>编程实现。   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> empty ;</span><br><span class="line">    <span class="keyword">int</span> total ;</span><br><span class="line">    <span class="keyword">int</span> money;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;money);</span><br><span class="line">    total = money;</span><br><span class="line">    empty = money;</span><br><span class="line">    <span class="keyword">while</span>(empty &gt; <span class="number">1</span>)&#123;</span><br><span class="line">       total +=  (empty / <span class="number">2</span>);</span><br><span class="line">        empty = (empty % <span class="number">2</span>) + (empty / <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.实现一个函数，可以左旋字符串中的k个字符。  &lt;/p&gt;
&lt;p&gt;ABCD左旋一个字符得到BCDA  ABCD左旋两个字符得到CDAB  &lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;
      
    
    </summary>
    
    
      <category term="C初阶" scheme="https://skrskr66.github.io/tags/C%E5%88%9D%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>八皇后问题(C+python)</title>
    <link href="https://skrskr66.github.io/2019/01/27/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98-C-python/"/>
    <id>https://skrskr66.github.io/2019/01/27/八皇后问题-C-python/</id>
    <published>2019-01-27T05:01:59.000Z</published>
    <updated>2019-01-29T03:48:22.673Z</updated>
    
    <content type="html"><![CDATA[<p>最近继续自学python，看到了八皇后问题，觉得是个有点意思的问题。</p><p>八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。</p><p>首先得说一下什么是回溯算法，<strong>实际是一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。</strong>回溯法是一种优选搜索法，按优选条件向前搜索，以达到目标。</p><p>该问题是在8x8格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、后一列、或同一斜线上有多少种摆法。</p><h5 id="通过C语言解决"><a href="#通过C语言解决" class="headerlink" title="通过C语言解决"></a>通过C语言解决</h5><p>因为是在python递归、迭代和生成器时碰到的这些问题，看了好久，还是有点懵，所以先用C语言的思想去理解一下。</p><p>首先我们得明确我们的思想，在这个8x8的棋盘上，我们如何去部署我们的棋子，我们已y轴为我们定义的数组下标范围，让x轴为数组内表示的元素所在的格子位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> board[<span class="number">8</span>] = &#123;&#125;;</span><br><span class="line"><span class="keyword">int</span> board_size = <span class="keyword">sizeof</span>(board)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure><p>接着需要去思考如何使用数学的语言来表述<strong>斜线上重叠的皇后</strong>。对于棋盘上任意的一点，都要在[0，7]这个范围内，那么这个关系就是目标格子(a,b)和当前所在格子(x,y)等价于&#124;a-x&#124;==&#124;b-y&#124;</p><p>所以首先进行一个判定</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> *board,<span class="keyword">int</span> row)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; row)&#123;</span><br><span class="line">        <span class="keyword">if</span>(board[i] == board[row] || row - i == board[row] - board[i] || row - i == board[i] - board[row])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们从第一行开始给每一行的皇后确定一个位置。每来到新的一行时，对本行的所有可能位置（皇后放在这个位置和前面所有已放置的皇后无冲突）分别进行递归地深入；若某一行可能放置地位置为0，那么说明这是一个四路，此时需要返回到上一层去重新选择。若此时八行都结束后，那么说明这是一个可行的方法。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">eight_queen</span><span class="params">(<span class="keyword">int</span> *board,<span class="keyword">int</span> row)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(row == <span class="number">8</span>)&#123;</span><br><span class="line">        printf_board(board);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    board[row] = <span class="number">0</span>;<span class="comment">//每次当row行跳转到下一行时，需要重新初始化一下</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(check(board,row) &amp;&amp; eight_queen(board,row + <span class="number">1</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(++board[row] &gt;= <span class="number">8</span>)&#123;<span class="comment">//当上面的判断条件失败之后，将row行的值向后+1看是否满足了全部落完棋子的情况</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要解释一下这个递归，在第一个if语句中，进行了两个函数的判断。首先是check函数，当第一个棋子部署后，进行第二个部署并且此时还要提前检查是否在第一个棋子的周围。如果不符合，那么board[row]+1，在进行判断，看此时是否符合要求。如果这时已经符合要求了，那么eight_queen函数也返回1，那么此时第二个就可以部署，以此类推，第三个也按照如此去部署。</p><p>当数组board[row]知道每个确切的值之后，我们将其数组打印，并且，打印出一个大概的图像</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_board</span><span class="params">(<span class="keyword">int</span> *board)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> size = board_size;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; size; ++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,board[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    i = <span class="number">0</span>;<span class="comment">//局部变量此时值不相同</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; size)&#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; size; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j == board[i])&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s"</span>,<span class="string">"x"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">"%s"</span>,<span class="string">"0"</span>);   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码比较不好理解的就是，在递归的过程中，何时board[row]被赋值，知道具体哪个位置可以被部署皇后。所以建议利用调试器去看！</p><h5 id="通过python解决"><a href="#通过python解决" class="headerlink" title="通过python解决"></a>通过python解决</h5><p>其实早都该写完这篇博客，有点懒了，也是有点小受挫，总觉得python简单。现在不会再轻敌了。</p><p>关于问题的本身跟用C语言来分析是大概一样的，那么就是应该怎么样利用去python去想这个问题</p><p>还是先定义一个判定的方法，当我们去放置皇后时，判定是否可以去落棋子,这里称为检测冲突</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conflict</span><span class="params">(state, nextX)</span>:</span><span class="comment">#这里的state将其定义为元组，它表示皇后落在每一行的第几个位置上</span></span><br><span class="line">    nextY = len(state)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(nextY):<span class="comment">#检查每一个已摆放的棋子和当前行摆放的棋子的位置是否冲突</span></span><br><span class="line">        <span class="keyword">if</span> abs(state[i] - nextX) <span class="keyword">in</span> (<span class="number">0</span>,nextY - i):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><p>主函数的思想则是利用python的生成器和递归的思想</p><p>将问题拆解，如果一个已经布置好了，那么接下来就是有限制的七皇后问题。那么每一次剩下的皇后没有放好，就遍历所有可能的位置，并放回那些不会引发冲突的位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eight_queen</span><span class="params">(num=<span class="number">8</span>,state=<span class="params">()</span>)</span>:</span><span class="comment">#num为皇后数目，state为元组</span></span><br><span class="line">    <span class="keyword">for</span> pos <span class="keyword">in</span> range(num):<span class="comment">#pos此时可以看成当前所在的行数</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> conflict(state, pos):<span class="comment">#此时是冲突判断，not是与函数内的true和false相反</span></span><br><span class="line">            <span class="keyword">if</span> len(state) == num - <span class="number">1</span><span class="comment">#当没有冲突时，元组内记录的皇后数-1，这样就代表继续向下部署</span></span><br><span class="line">            <span class="keyword">yield</span>(pos,)<span class="comment">#yield函数存在，此时已经成为了一个生成器，每次从上次pos结束的位置进行判断</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> result <span class="keyword">in</span> queens(num,state + (pos,)):<span class="comment">#此时将已得到的数据存入元组</span></span><br><span class="line">                    <span class="keyword">yield</span>(pos,) + result</span><br></pre></td></tr></table></figure><p>当主函数没问题了，我们也会想知道总共有多少方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len(list(eight_queen(<span class="number">8</span>)))</span><br></pre></td></tr></table></figure><p>这样就可以知道有多少方法了。</p><p>最后，这个问题让我想了好久好久啊，感觉如果学习一门新的语言出现疑惑时，不妨利用C语言去思考一下，这样有助于更好去发现自己的盲点存在那里。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近继续自学python，看到了八皇后问题，觉得是个有点意思的问题。&lt;/p&gt;
&lt;p&gt;八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。&lt;/p&gt;
&lt;p&gt;首先得说一下什么是回溯算法，&lt;strong&gt;实际是一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当
      
    
    </summary>
    
    
      <category term="算法分析" scheme="https://skrskr66.github.io/tags/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>C进阶-C语言文件操作</title>
    <link href="https://skrskr66.github.io/2019/01/22/%E8%BF%9B%E9%98%B6C-C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <id>https://skrskr66.github.io/2019/01/22/进阶C-C语言文件操作/</id>
    <published>2019-01-22T03:23:39.000Z</published>
    <updated>2019-01-22T05:25:46.390Z</updated>
    
    <content type="html"><![CDATA[<h5 id="什么是文件"><a href="#什么是文件" class="headerlink" title="什么是文件"></a>什么是文件</h5><p>磁盘上的文件是文件。但在程序设计中，我们一般谈的文件有两种：程序文件、数据文件</p><p><strong>程序文件：</strong>包括源程序文件，目标文件，可执行文件。</p><p><strong>数据文件：</strong>文件的内容不一定是程序，而是程序运行时读写的数据，比如程序运行需要从中读取数据的文件，或者输出内容的文件。</p><h5 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h5><p>文件标识常被成为文件名</p><h5 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h5><p>根据数据的组织形式，数据文件被称为<strong>文本文件</strong>或者<strong>二进制文件</strong>。</p><p>数据在内存中以二进制的形式存储，如果不加转换的输出的外存，就是<strong>二进制文件</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;什么是文件&quot;&gt;&lt;a href=&quot;#什么是文件&quot; class=&quot;headerlink&quot; title=&quot;什么是文件&quot;&gt;&lt;/a&gt;什么是文件&lt;/h5&gt;&lt;p&gt;磁盘上的文件是文件。但在程序设计中，我们一般谈的文件有两种：程序文件、数据文件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;程序文
      
    
    </summary>
    
    
      <category term="进阶C" scheme="https://skrskr66.github.io/tags/%E8%BF%9B%E9%98%B6C/"/>
    
  </entry>
  
  <entry>
    <title>进阶C-动态内存管理</title>
    <link href="https://skrskr66.github.io/2019/01/20/%E8%BF%9B%E9%98%B6C-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://skrskr66.github.io/2019/01/20/进阶C-动态内存管理/</id>
    <published>2019-01-20T11:11:55.000Z</published>
    <updated>2019-01-21T10:22:47.148Z</updated>
    
    <content type="html"><![CDATA[<p>动态内存分配可以说是C语言中的超级大BOSS，他能使用的地方有许多许多，而且与free搭配使用。很多初学者，经常会忘记这个的使用。</p><p>而且它也是数据结构中很关键的一环。在各种的链表，顺序表等等，我们都需要去使用它。所以这是一个非常重要的一节</p><h5 id="为什么存在动态内存分配"><a href="#为什么存在动态内存分配" class="headerlink" title="为什么存在动态内存分配"></a>为什么存在动态内存分配</h5><p>我们以尽掌握的内存开辟方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">20</span>;<span class="comment">//在栈空间上开辟四个字节</span></span><br><span class="line"><span class="keyword">char</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//在栈空间上开辟10个字节的连续空间</span></span><br></pre></td></tr></table></figure><p>但是上述的开辟方式有两个特点：</p><p>1.空间的开辟大小是固定的。</p><p>2.数组在申明的时候，必须指定数组的长度，它所需要的内存在编译时分配。</p><p>但比如我们在动态顺序表中，我们先开辟了一部分，但是在分配过程中，我们所分配的内存不够了，此时我们就需要malloc函数先临时开辟一个空间，之后再去使用，当使用完成之后在free释放掉。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入长度:"</span>);    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;len);    </span><br><span class="line">    <span class="comment">//malloc只是动态申请一块连续的内存空间                            </span></span><br><span class="line"><span class="keyword">int</span>* a = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">malloc()函数的优点</span><br><span class="line">1.申请内存空间的长度能够比较灵活    </span><br><span class="line">2.何时释放，完全由用户来掌控</span><br></pre></td></tr></table></figure><h5 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>这个函数向内存申请一块连续可用的空间，并返回指向这块空间的指针。</strong><br>    如果开辟成功，则返回一个指向开辟好空间的指针。</p><p>如果开辟失败，则返回一个NULL指针，因此malloc的返回值一定要做检查。</p><p>返回值的类型是 void* ，所以malloc函数并不知道开辟空间的类型，具体在使用的时候使用者自己来决定。</p><p>如果参数 size 为0，malloc的行为是标准是未定义的，取决于编译器。</p><h5 id="free"><a href="#free" class="headerlink" title="free"></a>free</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span>* ptr)</span></span>;</span><br></pre></td></tr></table></figure><p>free函数用来释放动态开辟的内存。</p><p>如果参数 ptr 指向的空间不是动态开辟的，那free函数的行为是未定义的。</p><p>如果参数 ptr 是NULL指针，则函数什么事都不做。</p><p><strong>如果频繁 malloc 但是忘记 free，此时就是内存泄漏</strong></p><h5 id="关于一些经典的动态分配"><a href="#关于一些经典的动态分配" class="headerlink" title="关于一些经典的动态分配"></a>关于一些经典的动态分配</h5><p>1.首先不能malloc()两次，或者free两次。动态分配两次也就是说你释放的时候只能释放一个，另一个并没有释放掉。即使你释放了两次。</p><p>2.free必须搭配malloc函数来使用。如果定义一个指针的地址，是不能释放掉的。这是错误的操作。</p><p>3.还有特殊规定，C++标准中规定了对 空指针进行 free/delete，都是合法的（无事发生）。所以当free一个内存之后，就把这个指针设为NULL。推荐这样做</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//如果*p = 100；这就是一个未定义行为</span></span><br></pre></td></tr></table></figure><p><strong>calloc</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> num,<span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><p>函数的功能是为<code>num</code>个大小为size的元素开辟一块空间，并且把空间的每个字节初始化为0.</p><p>与函数<code>malloc</code>的区别只在于<code>calloc</code>会返回地址之前把申请的空间的每个字节初始化为全0.</p><p><strong>realloc</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">realloc</span><span class="params">(<span class="keyword">void</span>* ptr,<span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><p>当我们发现我们申请的内存空间过大或者过小，我此时就可以使用<code>realloc</code>函数就可以对动态开辟内存大小的调整</p><p><code>ptr</code>是要调整的内存地址</p><p><code>size</code>调整之后新的大小</p><p>返回值为调整之后的内存起始位置</p><p>这个函数调整原内存空间大小的基础上，还会将原来内存中的数据移动到<strong>新</strong>的空间上</p><h5 id="一些常见的动态内存错误"><a href="#一些常见的动态内存错误" class="headerlink" title="一些常见的动态内存错误"></a>一些常见的动态内存错误</h5><p>对NULL指针的解引用操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(INT_MAX/<span class="number">4</span>);</span><br><span class="line">    *p = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 对动态开辟空间的越界访问</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == p)&#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);<span class="comment">//是个宏，返回1成功，返回0失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt;= <span class="number">10</span>;i++)&#123;</span><br><span class="line">        *(p+i) = i;<span class="comment">//当i是10的时候越界访问，*(p+i)相当于p[i]，i为10时，数组下标越界</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用free释放一块动态开辟内存的一部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    p++;</span><br><span class="line">    <span class="built_in">free</span>(p);<span class="comment">//p不再指向动态内存的起始位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>free只能释放开辟的所有空间，这种行为是未定义行为</p><h5 id="经典笔试题"><a href="#经典笔试题" class="headerlink" title="经典笔试题"></a>经典笔试题</h5><p><strong>第一题</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetMemory</span><span class="params">(<span class="keyword">char</span> *p)</span></span>&#123;</span><br><span class="line"> p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"> <span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line"> GetMemory(str);</span><br><span class="line"> <span class="built_in">strcpy</span>(str, <span class="string">"hello world"</span>);</span><br><span class="line"> <span class="built_in">printf</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Test函数中，*str是实参，当通过GetMemory调用之后的str是形参，当函数结束结束之后，就不存在了，str依旧是一个空指针，将字符拷贝到一个空指针中，这将发生段错误，也就是未定义行为。应该修改为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetMemory</span><span class="params">(<span class="keyword">char</span> **p)</span></span>&#123;    </span><br><span class="line">  *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);    </span><br><span class="line">          </span><br><span class="line">&#125;         </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;    </span><br><span class="line">  <span class="keyword">char</span> *str = <span class="literal">NULL</span>;    </span><br><span class="line">  GetMemory(&amp;str);    </span><br><span class="line">  <span class="built_in">strcpy</span>(str, <span class="string">"hello world"</span>);    </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,str);    </span><br><span class="line">  <span class="built_in">free</span>(str);                                                 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二题</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">GetMemory</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">char</span> p[] = <span class="string">"hello world"</span>;</span><br><span class="line"> <span class="keyword">return</span> p;<span class="comment">//返回的是数组的首元素地址</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line"> str = GetMemory();</span><br><span class="line"> <span class="built_in">printf</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是p[]数组仅仅是一个局部变量，函数结束，内存就释放了。应该修改为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">GetMemory</span><span class="params">(<span class="keyword">void</span>)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* p = <span class="string">"hello world"</span>;    </span><br><span class="line">  <span class="keyword">return</span> p;    </span><br><span class="line">&#125;    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *str = <span class="literal">NULL</span>;                                        </span><br><span class="line">  str = GetMemory();    </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,str);       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然内存可以访问，但是不可以修改</p><p><strong>第三题</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetMemory2</span><span class="params">(<span class="keyword">char</span> **p, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line"> GetMemory(&amp;str, <span class="number">100</span>);</span><br><span class="line"> <span class="built_in">strcpy</span>(str, <span class="string">"hello"</span>);</span><br><span class="line"> <span class="built_in">printf</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先没有释放内存，并且在我们的调用过程中最好进行一个if对str的判断</p><p><strong>第四题</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(str, “hello”);</span><br><span class="line">    <span class="built_in">free</span>(str);</span><br><span class="line"> <span class="keyword">if</span>(str != <span class="literal">NULL</span>)&#123;</span><br><span class="line">     <span class="built_in">strcpy</span>(str, “world”);</span><br><span class="line">     <span class="built_in">printf</span>(str);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放完毕之后就不能在使用了，此时str就相当于一个野指针，虽然有结果打印出来，但是这个打印是非法的。</p><p>那么我们什么时候需要malloc内存？</p><p>当申请的内存空间比较大的时候，需要malloc</p><p>什么时候血药直接定义临时变量？</p><p>如果对于内存申请的性能要求较高的时候</p><h5 id="柔性数组"><a href="#柔性数组" class="headerlink" title="柔性数组"></a>柔性数组</h5><p>只在C语言中存在</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Test</span>&#123;</span></span><br><span class="line"> <span class="keyword">int</span> i;</span><br><span class="line"> <span class="keyword">int</span> a[<span class="number">0</span>];<span class="comment">//a成员就是柔性数组成员</span></span><br><span class="line">&#125;Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Test2</span>&#123;</span></span><br><span class="line"> <span class="keyword">int</span> i;</span><br><span class="line"> <span class="keyword">int</span>* a;</span><br><span class="line">&#125;Test;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Test* t = (Test*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)+<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">10</span>);</span><br><span class="line">    t-&gt;i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">        t-&gt;a[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(t);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    Test2* t2 = (Test2*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)+<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">100</span>);</span><br><span class="line">    t2-&gt;i = <span class="number">10</span>;</span><br><span class="line">    t2-&gt;a  = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">free</span>(t2-&gt;a);</span><br><span class="line">    <span class="built_in">free</span>(t2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>柔性数组的特点：</strong></p><p>结构中的柔性数组成员前面必须至少一个其他成员。</p><p>sizeof 返回的这种结构大小不包括柔性数组的内存。</p><p>包含柔性数组成员的结构用malloc ()函数进行内存的动态分配，并且分配的内存应该大于结构的大小，以适应柔性数组的预期大小。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;动态内存分配可以说是C语言中的超级大BOSS，他能使用的地方有许多许多，而且与free搭配使用。很多初学者，经常会忘记这个的使用。&lt;/p&gt;
&lt;p&gt;而且它也是数据结构中很关键的一环。在各种的链表，顺序表等等，我们都需要去使用它。所以这是一个非常重要的一节&lt;/p&gt;
&lt;h5 id
      
    
    </summary>
    
    
      <category term="进阶C" scheme="https://skrskr66.github.io/tags/%E8%BF%9B%E9%98%B6C/"/>
    
  </entry>
  
</feed>
