<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>程序程</title>
  
  <subtitle>为了梦想的skr</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://skrskr66.github.io/"/>
  <updated>2019-07-11T06:54:15.661Z</updated>
  <id>https://skrskr66.github.io/</id>
  
  <author>
    <name>Lyc</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++-多态</title>
    <link href="https://skrskr66.github.io/2019/07/11/C-%E5%A4%9A%E6%80%81/"/>
    <id>https://skrskr66.github.io/2019/07/11/C-多态/</id>
    <published>2019-07-11T06:45:30.000Z</published>
    <updated>2019-07-11T06:54:15.661Z</updated>
    
    <content type="html"><![CDATA[<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><h3 id="多态的概念"><a href="#多态的概念" class="headerlink" title="多态的概念"></a>多态的概念</h3><p>通俗的来讲，就是多种形态。具体点就是<strong>去完成某个行为，当不同的对象去完成时会产生不同的状态。</strong></p><p>比如：买票这个行为，当<strong>普通人</strong>买票时，是<strong>全价</strong>买票；<strong>学生</strong>买票时，是<strong>半价</strong>买票；<strong>军人</strong>买票时是<strong>优</strong> </p><p><strong>先</strong>买票。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;多态&quot;&gt;&lt;a href=&quot;#多态&quot; class=&quot;headerlink&quot; title=&quot;多态&quot;&gt;&lt;/a&gt;多态&lt;/h2&gt;&lt;h3 id=&quot;多态的概念&quot;&gt;&lt;a href=&quot;#多态的概念&quot; class=&quot;headerlink&quot; title=&quot;多态的概念&quot;&gt;&lt;/a&gt;多态的概
      
    
    </summary>
    
    
      <category term="C++" scheme="https://skrskr66.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>网络基础知识(2)</title>
    <link href="https://skrskr66.github.io/2019/07/03/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86-2/"/>
    <id>https://skrskr66.github.io/2019/07/03/网络基础知识-2/</id>
    <published>2019-07-03T02:35:05.000Z</published>
    <updated>2019-07-06T08:54:34.868Z</updated>
    
    <content type="html"><![CDATA[<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>负责端与端之间的数据传输。也就是说进程与进程之间的数据传输，进程用端口来表示，所以也可以叫做端口和端口之间的传输。</p><h4 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h4><p>端口号为0-65535，一般0-1023为知名端口，不推荐使用，在一台主机上表示一个进程。</p><p>操作系统拿到网卡接收的数据之后，通过数据中的端口号知道数据放到哪一个socket缓冲区中</p><h4 id="五元组"><a href="#五元组" class="headerlink" title="五元组"></a>五元组</h4><p>一条数据中包含的五个信息。源IP+源端口+目的IP+目的端口+协议</p><p><strong>主机上网络状态的查看：netstat -anptu</strong></p><h3 id="传输层的传输协议"><a href="#传输层的传输协议" class="headerlink" title="传输层的传输协议"></a>传输层的传输协议</h3><h4 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h4><p>UDP协议的定义：无连接，不可靠，面向数据报</p><p>面向数据报：数据整条收发；灵活性低；但是不会造成粘包问题。每条数据有长度标识，数据有明显的间隔，带有报头的整条发，整条收，传输不灵活，但不存在粘包问题。</p><p>UDP不提供可靠性： 它把应用程序传给IP层(网络层)的数据发送出去，但是并不保证它们能到达目的地。UDP数据报封装成一份IP数据报的格式如图所示：</p><p><strong>IP首部20字节，UDP首部8字节</strong> </p><p><img src="/2019/07/03/网络基础知识-2/网络3.png" alt="网络3"></p><h4 id="UDP协议包含字段"><a href="#UDP协议包含字段" class="headerlink" title="UDP协议包含字段"></a>UDP协议包含字段</h4><p><img src="/2019/07/03/网络基础知识-2/网络2.png" alt="网络2"></p><p><img src="/2019/07/03/网络基础知识-2/网络1.png" alt="网络1"></p><p>UDP的协议字段包括<strong>源端口，目的端口，UDP长度，UDP校验和</strong>(总共8字节，统称为UDP首部)</p><h5 id="源端口-目的端口"><a href="#源端口-目的端口" class="headerlink" title="源端口/目的端口"></a>源端口/目的端口</h5><p>负责传输，为了确定数据应该哪个进程处理</p><h5 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h5><p>通过<strong>二进制的反码求和</strong>，它也等价于二进制求和在取反</p><p><strong>计算UDP校验和方法计算16位的二进制和，包括UDP首部数据。将校验和首先置为0，将每个16位的按位相加，第17，18位如果出现进位的话，将结果重新与结果的第1，2位相加，再将所得的结果取反码，最后得到的结果即为UDP校验和，存在校验和字段中。</strong></p><h5 id="数据报长度"><a href="#数据报长度" class="headerlink" title="数据报长度"></a>数据报长度</h5><p>UDP提供整条数据向应用层交付，实际上收到的数据都是经过检验过的，比如发送”ABCD“，不会出现“ABED”，只可能发生乱序或者丢包。因此如果发送成功但是是乱序的情况，那么用户需要在应用层进行包序管理。</p><p>UDP包的大小可以达到64K，但实际上以太网数据帧的长度必须在<strong>46~1500字节</strong>，这是由以太网的物理特性决定的。这个1500被称为链路层的MTU（最大传输单元）</p><p>如果直接发一个超过MTU的包，就会在协议层分片，这样的问题是如果一个分片在传输中出错了即校验不正确（这是较容易发生的），整个传输的UDP包可能就丢失了。</p><p>又因为UDP数据报的首部8字节，所以UDP数据报的数据区最大长度为64-8K。如果发送给予的数据大于64K-8则会报错；</p><p>UDP在传输层并不会进行分片，在IP层才会进行分片操作。</p><h5 id="UDP的缓冲区"><a href="#UDP的缓冲区" class="headerlink" title="UDP的缓冲区"></a>UDP的缓冲区</h5><p>UDP没有真正意义上的缓冲区。调用sendto会直接交给内核，由内核数据传给网络层协议进行后续传输动作。</p><p>UDP具有接收缓冲区，但是这个接收缓冲区不能保证收到的UDP报的顺序和发送的UDP报的顺序一样。如果缓冲区满了，则再到达的UDP数据则会被丢弃。</p><h4 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h4><p>TCP传输是面向连接，可靠传输，面向字节流</p><p><img src="/2019/07/03/网络基础知识-2/网络4.png" alt="网络4"></p><h5 id="源端口-目的端口-1"><a href="#源端口-目的端口-1" class="headerlink" title="源端口/目的端口"></a>源端口/目的端口</h5><p>一个IP地址和端口的组合称为“套接字”和端点，在IP协议中的源IP地址和目的地址和TCP协议中的源端口和目的端口，组成了“一对”套接字(发送端的套接字和接收端的套接字)</p><h5 id="序列号"><a href="#序列号" class="headerlink" title="序列号"></a>序列号</h5><p>每一个TCP报文段中的第一个字节都会被赋予一个序列号。序列号是个32位数，到达2^32-1后会再回到0</p><h5 id="确认序列号"><a href="#确认序列号" class="headerlink" title="确认序列号"></a>确认序列号</h5><p>也称ACK或ACK字段。确认号包含的值为”确认号的发送方“希望对方接收的下一个序列号。即序列号+数据长度。</p><h5 id="4位TCP报头长度"><a href="#4位TCP报头长度" class="headerlink" title="4位TCP报头长度"></a>4位TCP报头长度</h5><p>表示TCP头部有多少个32位bit(有多少个4字节)，由于”选项字段”大小是可变的，所以“头部长度”是必须的，TCP头部长度最大为60字节，如果没有选项字段，那么TCP头部长度为20字节。</p><h5 id="6位标志位"><a href="#6位标志位" class="headerlink" title="6位标志位"></a>6位标志位</h5><p>URG: 紧急指针是否有效 </p><p>ACK: 确认号是否有效 </p><p>PSH: 提示接收端应用程序立刻从TCP缓冲区把数据读走 </p><p>RST: 对方要求重新建立连接; 我们把携带RST标识的称为<strong>复位报文段</strong> </p><p>SYN: 请求建立连接; 我们把携带SYN标识的称为<strong>同步报文段</strong> </p><p>FIN: 通知对方, 本端要关闭了, 我们称携带FIN标识的为<strong>结束报文段</strong></p><h5 id="窗口大小"><a href="#窗口大小" class="headerlink" title="窗口大小"></a>窗口大小</h5><p>在TCP协议中，一个分组从发送端发送到接收端中，接收端应该返回一个ACK号。</p><p>每一个分组都是从“序列号”开始的，我们定一个术语“窗口”，来表示：已发送的分组们，但这些分组还未返回确认号(ACK号)。窗口中的分组数量称之为：“窗口大小”，<strong>不会大于缓冲区的大小</strong></p><p>下图为发送方的窗口以及其他分组队列：</p><p><img src="/2019/07/03/网络基础知识-2/网络5.png" alt="网络5"></p><p>如果发送方下一步接收到了序列号为4的分组“ACK”，则“窗口向右滑动一个分组”，意味着分组4可以释放了，分组7可以发送了。这种行为称之为：“窗口滑动协议”(下面详细叙述)</p><h5 id="TCP校验和"><a href="#TCP校验和" class="headerlink" title="TCP校验和"></a>TCP校验和</h5><p>该校验算法与IP、ICMP、UDP校验算法一致，其覆盖了TCP头部和数据中的一些字段。</p><h5 id="紧急指针"><a href="#紧急指针" class="headerlink" title="紧急指针"></a>紧急指针</h5><p>只有在有<strong>URG字段时才有效</strong>。该指针是一个加到“序列号字段”上的正偏移，以产生“紧急数据”的最后一个字节的序列号。</p><h4 id="面向连接"><a href="#面向连接" class="headerlink" title="面向连接"></a>面向连接</h4><p>这就不得不在提到TCP的三次握手和四次挥手了。以客户端先发送请求为例。</p><h5 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h5><p>首先客户端先发送一个SYN包，请求建立连接。此时客户端处于SYN_SEND状态。这时服务端接收到了请求，会先发送一个SYN+ACK组合包确认一下是否建立连接。此时服务端处于SYN_RECV状态。当客户端接收到了组合包时，明白了服务端同意建立请求，这时客户端再次发送一个ACK包，’’表达”想要建立连接的决心，进行回复确认。当服务端再次收到这个ACK包之后，双方都处于ESTABLISH状态，此时双方可以互相发送数据信息了。</p><h5 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h5><p>发送了一段数据之后，客户端想要断开连接。客户端向服务端发送一个FIN包，请求断开连接，此时客户端处于FIN_WAIT_1状态，等待ACK回复。服务端接收到了之后，向客户端发送一个ACK包，同意断开连接。此时服务端处于CLOSE_WAIT状态，客户端处于FIN_WAIT_2状态。这时服务端会在发送一个FIN包确认一下，是否断开连接，<strong>最后确认一次</strong>，此时服务端处于LAST_ACK状态。客户端收到该FIN包之后，会立刻回复一个ACK确认包，此时客户端处于TIME_WAIT状态，但是客户端会等待2个MSL(最大报文段生成时间)，因为可能最后一次ACK包如果丢失的话，服务端会在发送一个FIN包过来。当在这个等待的时间内，服务端没有在发送之后，彻底断开连接，服务端和客户端都进入CLOSED状态。等待回收资源。</p><p><a href="https://skrskr66.top/2019/06/13/TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/#more" target="_blank" rel="noopener">参考我之前的博客</a></p><h4 id="可靠传输"><a href="#可靠传输" class="headerlink" title="可靠传输"></a>可靠传输</h4><p><strong>确认应答机制</strong>或者<strong>超时重传机制</strong>是保证安全到达</p><p><strong>协议字段中的序号/确认序号</strong>是进行包序管理</p><p><strong>校验和</strong>为了验证数据的一致性</p><p>因为TCP为了保证可靠传输，因此牺牲了部分传输性能；为了保证TCP传输性能不会进一步下降(因为ack丢失而重传)，因此又有了一些新的机制。</p><h5 id="滑动窗口机制-拥塞控制-快速重传机制"><a href="#滑动窗口机制-拥塞控制-快速重传机制" class="headerlink" title="滑动窗口机制+拥塞控制+快速重传机制"></a>滑动窗口机制+拥塞控制+快速重传机制</h5><p><strong>滑动窗口</strong>：</p><p>​    <strong>窗口是接收方为了告诉发送方最多发送多少，而不是非要让发送方发送多少。</strong></p><p>​    通信双方通过协议中的窗口字段，来协商能够一次发送的最多数据，然后连续发送多条数据；在socket当中使用两个指针维护窗口<strong>后沿(起始位置)</strong>和<strong>前沿(发送的结束位置)</strong>。</p><p>​    发送端：若窗口中后沿数据没有接收到ack确认，后沿就不能向前移动，数据就不能从缓冲区移除，接收到ack确认后窗口，<strong>前后沿</strong>向后移动。</p><p>​    接收端：当接收数据的时候，如果没有接收到第一条数据，则后沿不能移动，只有接收到数据之后，后沿才会向前移动。</p><p><strong>滑动窗口机制规定</strong>：</p><p>​    ack确认丢失的情况：每条数据都要进行回复，并且应该按序逐条回复，如果没有收到第一条，但是都到了第二条，第二条就不能先回复，应该先回复第一条；带来的好处就是，因为第一条ack丢失后，如果发送端收到第二条的回复，也会认为第一条正常接收；第一条就不需要重传了。</p><p>​    数据丢失的情况：当数据连续发送n条，但是第一条数据丢失，接收端先接收到第二条，这时候接收端认为第一条数据有可能丢失，因此直接开始向发送端发送第一条数据的重传请求；连续发送三次(防止网络延迟又接收到数据报)；当发送端连接收到三条重传请求，则会对这条数据进行重传。</p><p><img src="/2019/07/03/网络基础知识-2/网络6.png" alt="网络6"></p><h5 id="延迟应答机制"><a href="#延迟应答机制" class="headerlink" title="延迟应答机制"></a>延迟应答机制</h5><p>接收方接收数据后不立刻进行确认回复，而是等待一段时间，因为这段延迟的时间内，有可能用户recv将缓冲区中的数据取走，窗口就尽可能地保证最大窗口，保证传输地吞吐量。尽可能地保证滑动窗口地性能。</p><h5 id="捎带应答机制"><a href="#捎带应答机制" class="headerlink" title="捎带应答机制"></a>捎带应答机制</h5><p>接收方对每一条数据地确认回复都需要发送一个TCP数据报；但是空报头地传输会降低性能</p><p>因此会考虑在即将要发送地数据报中包含有确认信息(可以少发一个确认的空报头)</p><h4 id="面向字节流：传输字节流"><a href="#面向字节流：传输字节流" class="headerlink" title="面向字节流：传输字节流"></a>面向字节流：传输字节流</h4><p>发送方：每次调用send都会将数据放到缓冲区中，然后内核选择合适时机发送数据。</p><p>接收方：网卡接收到数据，都会将数据放到接收缓冲区中，用户recv就是从接收缓冲区中取数据</p><h5 id="粘包问题主要发生位置"><a href="#粘包问题主要发生位置" class="headerlink" title="粘包问题主要发生位置"></a>粘包问题主要发生位置</h5><p><img src="/2019/07/03/网络基础知识-2/网络7.png" alt="网络7"></p><p>发送缓冲区中的数据堆积 or 接收缓冲区中的数据堆积</p><p><strong>粘包本质原因：数据之间没有明显边界，tcp只管传输数据的字节流导致发送端/接收端因为数据的堆积在实际发送或recv时一次获取到半条或多条数据，这就是TCP的粘包问题</strong></p><h5 id="如何解决TCP粘包"><a href="#如何解决TCP粘包" class="headerlink" title="如何解决TCP粘包"></a>如何解决TCP粘包</h5><p>TCP在传输层没有数据边界，但是用户可以在应用层进行边界处理。</p><p><strong>常见方法：</strong>特殊字符间隔(比如HTTP协议)；定长数据(UDP头中包含长度)</p><p>对于定长的包，保证每次都按固定大小读取即可；</p><p>对于变长的包，可以在包头的位置，约定一个包总长度的字段，从而就知道了包的结束位置；</p><p>对于变长的包，还可以在包和包之间使用明确的分隔符(应用层协议，是程序员自己来定的只要保证分隔符和正文不冲突即可)；</p><h4 id="TCP小结"><a href="#TCP小结" class="headerlink" title="TCP小结"></a>TCP小结</h4><p>为了保证TCP的可靠性，同时又尽可能地提高性能。</p><p>可靠性：校验和；序列号；确认应答；超时重发；连接管理；</p><p>提高性能：拥塞控制；流量控制；滑动窗口；超时重传；快速重传；延迟应答；捎带应带</p><h4 id="TCP和UDP的比较"><a href="#TCP和UDP的比较" class="headerlink" title="TCP和UDP的比较"></a>TCP和UDP的比较</h4><p>TCP和UDP之间并不能绝对的说谁比较好，而是通过场景来判断</p><p>TCP用于可靠传输，应用于文件传输，重要状态更新场景</p><p>UDP用于高速传输和实时性要求比较高的通信领域，比如视频传输。UDP还可以用于广播</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;传输层&quot;&gt;&lt;a href=&quot;#传输层&quot; class=&quot;headerlink&quot; title=&quot;传输层&quot;&gt;&lt;/a&gt;传输层&lt;/h2&gt;&lt;p&gt;负责端与端之间的数据传输。也就是说进程与进程之间的数据传输，进程用端口来表示，所以也可以叫做端口和端口之间的传输。&lt;/p&gt;
&lt;h4 
      
    
    </summary>
    
    
      <category term="网络" scheme="https://skrskr66.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>C++-继承</title>
    <link href="https://skrskr66.github.io/2019/06/25/C-%E7%BB%A7%E6%89%BF/"/>
    <id>https://skrskr66.github.io/2019/06/25/C-继承/</id>
    <published>2019-06-25T04:18:07.000Z</published>
    <updated>2019-07-03T02:29:30.190Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-继承"><a href="#C-继承" class="headerlink" title="C++继承"></a>C++继承</h2><h3 id="继承的概念及定义"><a href="#继承的概念及定义" class="headerlink" title="继承的概念及定义"></a>继承的概念及定义</h3><h4 id="继承的概念"><a href="#继承的概念" class="headerlink" title="继承的概念"></a>继承的概念</h4><p>继承机制是<strong>面向对象程序设计使代码可以复用</strong>的常用手段，它允许<strong>程序员保持原有类特性的基础上进行扩展</strong>，增加功能，这样产生新的类，称派生类。<strong>继承呈现了面向对象程序设计的层次结构</strong>，体现了由简单到复杂的认知过程。以前我们接触的复用是函数复用，<strong>继承是类设计层次的复用。</strong></p><p>最普通的继承例子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"name"</span>&lt;&lt;_name&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"age"</span>&lt;&lt;_age&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="built_in">string</span> _name = <span class="string">"peter"</span>;</span><br><span class="line">  <span class="keyword">int</span> _age = <span class="number">18</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span><span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">int</span> _stuid;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span>:</span> <span class="keyword">public</span> Person </span><br><span class="line">&#123;                                    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">int</span> _jobid;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Student s;</span><br><span class="line">  Teacher t;</span><br><span class="line">  s.Print();</span><br><span class="line">  t.Print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="继承的定义"><a href="#继承的定义" class="headerlink" title="继承的定义"></a>继承的定义</h4><p>定义格式如图</p><p><img src="/2019/06/25/C-继承/继承.png" alt="继承"></p><h5 id="继承基类成员访问方式的变化"><a href="#继承基类成员访问方式的变化" class="headerlink" title="继承基类成员访问方式的变化"></a>继承基类成员访问方式的变化</h5><table><thead><tr><th style="text-align:center">类成员(列)/继承方式（行）</th><th style="text-align:center">public继承</th><th style="text-align:center">protected继承</th><th style="text-align:center">private继承</th></tr></thead><tbody><tr><td style="text-align:center"><strong>基类的public成员</strong></td><td style="text-align:center">派生类的public成员</td><td style="text-align:center">派生类的protected成员</td><td style="text-align:center">派生类的private成员</td></tr><tr><td style="text-align:center"><strong>基类的protected成员</strong></td><td style="text-align:center">派生类的protected成员</td><td style="text-align:center">派生类的protected成员</td><td style="text-align:center">派生类的private成员</td></tr><tr><td style="text-align:center"><strong>基类的private成员</strong></td><td style="text-align:center">派生类中不可见</td><td style="text-align:center">派生类中不可见</td><td style="text-align:center">派生类中不可见</td></tr></tbody></table><h5 id="继承小结"><a href="#继承小结" class="headerlink" title="继承小结"></a>继承小结</h5><p>1.基类private成员在派生类中无论以什么方式继承都不可见。这里的<strong>不可见是指在基类的私有成员还是被继承到了派生类对象中，但是语法上限制派生类对象不管在类的里面还是类的外面都不能去访问它。</strong>可以概括的理解不可见那么派生类就完全不能访问基类的所有成员。</p><p>2.基类private成员在派生类中是无法被访问的，如果基类成员不想在类外直接被访问，但需要在派生类能访问，就定义为protected。可以看出保护成员限定符是因继承才出现。</p><p>3.根据表格可以看到，基类的私有成员在子类都是不可见。基<strong>类的其他成员在子类的访问==min（成员在基类的访问限定符，继承方式）。</strong></p><p>4.使用关键字class时默认的继承方式是private，使用struct时的默认继承方式是public，不过最好显示的写出继承方式。</p><p>5.在实际运用中一般都是用public继承，protected/private继承一般很少用。也不提倡使用这两种继承，实际中的扩展与维护不强。</p><h3 id="基类和派生类对象赋值转换"><a href="#基类和派生类对象赋值转换" class="headerlink" title="基类和派生类对象赋值转换"></a>基类和派生类对象赋值转换</h3><p>派生类对象可以赋值给<strong>基类的对象/基类的指针/基类的引用</strong>。这里有个形象的说法叫做切片(其实我个人认为与python中的切片意思差不多)。把派生类中父类那部分切下赋值过去。</p><p><strong>基类对象不能赋值给派生类对象</strong></p><p>基类的指针可以通过强制类型转换赋值给派生类的指针。但是必须了解</p><p><img src="/2019/06/25/C-继承/继承2.png" alt="继承2"></p><p>上图为切片的模型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">"---"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">protected</span> :</span><br><span class="line">    <span class="built_in">string</span> _name; <span class="comment">// 姓名</span></span><br><span class="line">    <span class="built_in">string</span> _sex; <span class="comment">// 性别</span></span><br><span class="line">    <span class="keyword">int</span> _age; <span class="comment">// 年龄</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">public</span> :</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">"_No"</span>&lt;&lt;_No&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> _No ; <span class="comment">// 学号                                        </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Student A;</span><br><span class="line">  <span class="comment">//1.子类对象可以赋值给父类对象/指针/引用</span></span><br><span class="line">  Person B;</span><br><span class="line">  Person* bb = &amp;A;</span><br><span class="line">  Person&amp; aa = A;</span><br><span class="line">  bb-&gt;Print();</span><br><span class="line">  aa.Print();</span><br><span class="line">  </span><br><span class="line">  A = B;<span class="comment">//这是错误的赋值方式，2.基类的对象不能赋值给派生类对象</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">//3.基类的指针可以通过强制类型转换赋值给派生类的指针</span></span><br><span class="line">  bb = &amp;A;</span><br><span class="line">  Student* pp1 = (Student*)bb;</span><br><span class="line">  pp1-&gt;_No = <span class="number">10</span>;</span><br><span class="line">  pp1-&gt;Print();</span><br><span class="line"></span><br><span class="line">  bb = &amp;B;                                   </span><br><span class="line">  Student* pp2 = (Student*)bb;<span class="comment">//这相当于将基类强转成派生类，在赋值给派生类,这种转换虽然可以，但会是存在越界访问的情况</span></span><br><span class="line">  pp2-&gt;_No = <span class="number">1000</span>;</span><br><span class="line">  pp2-&gt;Print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="继承中的作用域"><a href="#继承中的作用域" class="headerlink" title="继承中的作用域"></a>继承中的作用域</h3><p>在继承体系中<strong>基类和派生类</strong>都有<strong>独立的作用域</strong></p><p><strong>关键！！！</strong></p><p><strong>关键！！！</strong></p><p><strong>关键！！！</strong></p><p><strong>子类和父类中有同名函数，子类成员将屏蔽父类对成员函数的直接访问，这种情况叫隐藏，也叫重定义。在子类成员函数中，可以使用<code>基类::基类成员</code>显示访问。</strong></p><p>如果是成员函数的隐藏，只要函数名相同就构成隐藏。所以在实际中在继承体系里面最好不要定义同名的成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">protected</span> :</span><br><span class="line"> <span class="built_in">string</span> _name = <span class="string">"skr"</span>; <span class="comment">// 姓名</span></span><br><span class="line"> <span class="keyword">int</span> _num = <span class="number">666</span>; <span class="comment">// 身份证号</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;<span class="string">" 姓名:"</span>&lt;&lt;_name&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;<span class="string">" 身份证号:"</span>&lt;&lt;Person::_num&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;<span class="string">" 学号:"</span>&lt;&lt;_num&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"> <span class="keyword">int</span> _num = <span class="number">12138</span>; <span class="comment">// 学号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>虽然这样编译可以编译过也能运行，但是太容易让人混淆了，都是_num，当程序复杂起来这就一定会成为一个BUG的大坑等着自己去跳。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">skr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">"Do you have freestyle?"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cxk</span> :</span> <span class="keyword">public</span> skr</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> skr::fun();</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt;<span class="string">"I like singsing dance rap and basketball "</span>&lt;&lt;i&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> cxk b;</span><br><span class="line"> b.fun(<span class="number">10</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当skr::fun()调用时的情况完全不同</p><p>当没有skr::fun()直接调用时</p><p><img src="/2019/06/25/C-继承/继承3.png" alt="继承3"></p><p>当具有skr::fun()直接调用时</p><p><img src="/2019/06/25/C-继承/继承4.png" alt="继承4"></p><p>skr类和cxk类中的fun函数不是构成重载，因为它们不是同一个作用域。它们构成了隐藏。这就印证了当子类与父类同时具有同名函数时，子类函数将屏蔽父类对成员函数的访问。其实就是它们都不能在随便的互相访问了，父类对象只能访问父类自己的成员函数，子类可以访问双方的成员函数，但是子类如果想要访问父类的成员函数需要使用固定的格式<code>基类::成员函数</code>，才可以进行访问。</p><h3 id="派生类的默认成员函数"><a href="#派生类的默认成员函数" class="headerlink" title="派生类的默认成员函数"></a>派生类的默认成员函数</h3><p>在基类中我们一般新写了一个类之后，如果不是必须的话，我们由系统操作完成对默认成员函数的创建，但是派生类中是继承基类，又是如何？</p><ul><li><p>派生类的构造函数<strong>必须调用基类的构造函数初始化基类的那一部分成员</strong>。如果基类没有默认构造函数，则必须在派生类构造函数的初始化列表阶段显示调用。</p></li><li><p>派生类的拷贝构造函数必须调用基类的拷贝构造函数完成基类的拷贝初始化</p></li><li><p>派生类的operator=必须要调用基类的operator=完成基类的复制</p></li><li><p>派生类的析构函数会在被调用完成后自动调用基类的析构函数清理基类成员。但是<strong>清理的顺序是先清理派生类成员在清理基类的成员的顺序</strong>。</p></li><li><p><strong>派生类对象初始化先调用基类构造函数在调用派生类构造</strong></p></li><li><p><strong>派生类对象析构先调用派生类析构函数在调用基类析构函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Person(<span class="keyword">const</span> <span class="keyword">char</span>* name = <span class="string">"peter"</span>)                                                                                                  </span><br><span class="line">    :_name(name)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">"Person()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  Person(<span class="keyword">const</span> Person&amp; p)</span><br><span class="line">    :_name(p._name)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Person(const Person&amp; p)"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Person&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Person&amp; p)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Person&amp; operator=(const Person&amp; p)"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;p)</span><br><span class="line">    &#123;</span><br><span class="line">      _name = p._name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> ~Person()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"~Person()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="built_in">string</span> _name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span><span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Student(<span class="keyword">const</span> <span class="keyword">char</span>* name,<span class="keyword">int</span> num)</span><br><span class="line">  :Person(name)</span><br><span class="line">  ,_num(num)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Student()"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Student(<span class="keyword">const</span> Student&amp; s)</span><br><span class="line">  :Person(s)</span><br><span class="line">  ,_num(s._num)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Student(const Student&amp; s)"</span>&lt;&lt;<span class="built_in">endl</span>;                                                                                          </span><br><span class="line">  &#125;</span><br><span class="line">  Student&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Student&amp; s)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"Student&amp; operator=(const Student&amp; s)"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;s)</span><br><span class="line">    &#123;</span><br><span class="line">      Person::<span class="keyword">operator</span>=(s);</span><br><span class="line">      _num = s._num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ~Student()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"~Student"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  <span class="keyword">int</span> _num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">Student <span class="title">s1</span><span class="params">(<span class="string">"jack"</span>,<span class="number">18</span>)</span></span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="function">Student <span class="title">s2</span><span class="params">(s1)</span></span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="function">Student <span class="title">s3</span><span class="params">(<span class="string">"rose"</span>,<span class="number">17</span>)</span></span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  s1 = s3;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2019/06/25/C-继承/继承5.png" alt="继承5"></p><p>运行如图，打印的结果为派生类和基类的先后调用顺序</p><h4 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h4><p>实现一个类不能被继承</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoInherit</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">static</span> NoInherit <span class="title">GetInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> NoInherit();</span><br><span class="line">      &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    NoInherit()</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//在c++98中构造函数私有化，派生类中调不到基类中的构造函数，则无法继承</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoInherit</span> <span class="title">final</span></span></span><br><span class="line"><span class="class">&#123;</span>&#125;</span><br><span class="line"><span class="comment">//在C++11中给出了新的关键字final禁止继承</span></span><br></pre></td></tr></table></figure><h3 id="继承与友元"><a href="#继承与友元" class="headerlink" title="继承与友元"></a>继承与友元</h3><p><strong>友元函数</strong>可以直接访问类的私有成员，它是定义在类外部的普通函数，不属于任何类，但需要在类的内部声明，声明时需要加friend关键字。 </p><p><strong>但是友元关系不能被继承，也就是说类友元不能访问子类私有和保护成员</strong></p><p><img src="/2019/06/25/C-继承/继承6.png" alt="继承6"></p><p>比如在实例代码中，友元函数想要访问子类的私有成员和保护的成员，结果显示编译错误</p><h3 id="继承与静态成员"><a href="#继承与静态成员" class="headerlink" title="继承与静态成员"></a>继承与静态成员</h3><p><strong>基类定义了static静态成员，则整个继承体系里面只有一个这样的继承成员</strong>。无论派生出多少个子类，都还是只有一个static成员实例</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line">Person () &#123;++ _count ;&#125;</span><br><span class="line"><span class="keyword">protected</span> :</span><br><span class="line"><span class="built_in">string</span> _name ; <span class="comment">// 姓名</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> _count; <span class="comment">// 统计人的个数。</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> Person :: _count = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span> :</span><br><span class="line"><span class="keyword">int</span> _stuNum ; <span class="comment">// 学号</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graduate</span> :</span> <span class="keyword">public</span> Student</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span> :</span><br><span class="line"><span class="built_in">string</span> _seminarCourse ; <span class="comment">// 研究科目</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Student s1 ;</span><br><span class="line">Student s2 ;</span><br><span class="line">Student s3 ;</span><br><span class="line">Graduate s4 ;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">" 人数 :"</span>&lt;&lt; Person ::_count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">Student ::_count = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;<span class="string">" 人数 :"</span>&lt;&lt; Person ::_count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为<code>0</code>和<code>4</code>，这说明静态成员只有一个，最后设为0，就又被赋值为0了。</p><h3 id="菱形继承和菱形虚拟继承"><a href="#菱形继承和菱形虚拟继承" class="headerlink" title="菱形继承和菱形虚拟继承"></a>菱形继承和菱形虚拟继承</h3><h4 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h4><p>一个子类只有一个直接父类时称这个继承关系为单继承</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span>&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span><span class="keyword">public</span> A</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">public</span> B</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h4><p>一个子类有两个或以上直接父类时称这个继承关系为多继承</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span>&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">&#123;</span>&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span><span class="keyword">public</span> A,<span class="keyword">public</span> B</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="菱形继承"><a href="#菱形继承" class="headerlink" title="菱形继承"></a>菱形继承</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span>pubilc Person</span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span>:</span><span class="keyword">public</span> Person</span><br><span class="line">&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Assistant</span>:</span><span class="keyword">public</span> Student,<span class="keyword">public</span> Teacher</span><br><span class="line">&#123;&#125;</span><br></pre></td></tr></table></figure><p>菱形继承的问题从对象成员模型构造中可以看出菱形继承有数据冗余和二义性的问题。在Assistant的对象中Person成员会有两份</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"><span class="built_in">string</span> _name ; <span class="comment">// 姓名</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span> :</span><br><span class="line"><span class="keyword">int</span> _num ; <span class="comment">//学号</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> :</span> <span class="keyword">public</span> Person</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span> :</span><br><span class="line"><span class="keyword">int</span> _id ; <span class="comment">// 职工编号</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Assistant</span> :</span> <span class="keyword">public</span> Student, <span class="keyword">public</span> Teacher</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span> :</span><br><span class="line"><span class="built_in">string</span> _majorCourse ; <span class="comment">// 主修课程</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 这样会有二义性无法明确知道访问的是哪一个</span></span><br><span class="line">Assistant a ;</span><br><span class="line">a._name = <span class="string">"peter"</span>;</span><br><span class="line"><span class="comment">// 需要显示指定访问哪个父类的成员可以解决二义性问题，但是数据冗余问题无法解决</span></span><br><span class="line">a.Student::_name = <span class="string">"xxx"</span>; </span><br><span class="line">a.Teacher::_name = <span class="string">"yyy"</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>重复的数据依旧没有得到一个好的解决，通过虚拟继承可以同时解决数据二义性和数据冗余。在Student和Teacherd的继承Person时使用虚拟继承。虚拟继承不能乱用，更不能将其想为虚函数，它们是完全没有关系的</strong></p><p>当使用了虚继承之后，数据只有一份了，改动任意一处，都只会对这一部分数据产生变化</p><h4 id="虚基表"><a href="#虚基表" class="headerlink" title="虚基表"></a>虚基表</h4><p><img src="/2019/06/25/C-继承/继承7.png" alt="继承7"></p><p>总的来说，虚基表是因为虚继承的存在才出现的，为了解决数据二义性和数据冗余，虚基表为了能够准确寻找到基类的地址(就是为了从派生类中访问虚基类成员时)，通过虚基表指针来访问基类成员变量。</p><p>具体操作为该指针地址+偏移量即为基类成员的地址</p><h3 id="继承的总结"><a href="#继承的总结" class="headerlink" title="继承的总结"></a>继承的总结</h3><p>多继承可以体现出C++语法的复杂。有了多继承，就存在菱形继承，有了菱形继承，就有菱形虚拟继承，这让底层的实现越来越复杂。所以我们也不建议使用多继承去设计。</p><p>多继承也被看做是C++的缺陷之一。</p><h4 id="继承和组合"><a href="#继承和组合" class="headerlink" title="继承和组合"></a>继承和组合</h4><p>继承是一种<code>is-a</code>的关系，每个派生类对象都是一个基类对象。</p><p>组合是一种<code>has-a</code>的关系，B组合了A，每个B对象中都有一个A对象</p><p>优先使用组合，而不是类继承</p><p><strong>继承允许你根据基类的实现来定义派生类的实现。这种通过生成派生类的复用通常被称为白箱复用 (white-box reuse)。术语“白箱”是相对可视性而言：在继承方式中，基类的内部细节对子类可见 。继承一定程度破坏了基类的封装，基类的改变，对派生类有很大的影响。派生类和基类间的依赖关系很强，耦合度高。</strong></p><p><strong>对象组合是类继承之外的另一种复用选择。新的更复杂的功能可以通过组装或组合对象来获得。对象组合要求被组合的对象具有良好定义的接口。这种复用风格被称为黑箱复用(black-box reuse)，因为对象的内部细节是不可见的。对象只以“黑箱”的形式出现。 组合类之间没有很强的依赖关系，耦合度低。优先使用对象组合有助于你保持每个类被封装。实际尽量多去用组合。组合的耦合度低，代码维护性好。不过继承也有用武之地的，有些关系就适 合继承那就用继承，另外要实现多态，也必须要继承。类之间的关系可以用继承，可以用组合，就用组合。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Car和BMW Car和Benz构成is-a的关系</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="built_in">string</span> _colour = <span class="string">"白色"</span>; <span class="comment">// 颜色</span></span><br><span class="line"><span class="built_in">string</span> _num = <span class="string">"陕ABIT00"</span>; <span class="comment">// 车牌号</span></span><br><span class="line"> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BMW</span> :</span> <span class="keyword">public</span> Car&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Drive</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"好开-操控"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line"> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Benz</span> :</span> <span class="keyword">public</span> Car&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Drive</span><span class="params">()</span> </span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"好坐-舒适"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line"> &#125;;</span><br><span class="line"><span class="comment">// Tire和Car构成has-a的关系</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tire</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="built_in">string</span> _brand = <span class="string">"Michelin"</span>; <span class="comment">// 品牌</span></span><br><span class="line"><span class="keyword">size_t</span> _size = <span class="number">17</span>; <span class="comment">// 尺寸</span></span><br><span class="line"> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span>&#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"><span class="built_in">string</span> _colour = <span class="string">"白色"</span>; <span class="comment">// 颜色</span></span><br><span class="line"><span class="built_in">string</span> _num = <span class="string">"陕ABIT00"</span>; <span class="comment">// 车牌号</span></span><br><span class="line">Tire <span class="keyword">_t</span>; <span class="comment">// 轮胎</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;C-继承&quot;&gt;&lt;a href=&quot;#C-继承&quot; class=&quot;headerlink&quot; title=&quot;C++继承&quot;&gt;&lt;/a&gt;C++继承&lt;/h2&gt;&lt;h3 id=&quot;继承的概念及定义&quot;&gt;&lt;a href=&quot;#继承的概念及定义&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="C++" scheme="https://skrskr66.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>网络基础知识</title>
    <link href="https://skrskr66.github.io/2019/06/18/%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>https://skrskr66.github.io/2019/06/18/网络基础知识/</id>
    <published>2019-06-18T03:11:33.000Z</published>
    <updated>2019-06-18T08:07:28.049Z</updated>
    
    <content type="html"><![CDATA[<p>在了解网络整体模型之前学习了套接字编程和一些简单的网络知识。但是网络编程的理论基础是建立在多方面上的，比如数据在每一层是经过了怎么样的封装，每一层使用了哪些协议，每一层的协议又有哪些用途。只有掌握好这些基础知识，才能更好的成为一个服务器开发人员。</p><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>程序员写的一个个解决我们实际问题，满足我们日常需求的网络程序，都是在应用层完成的。</p><p>那么应用层使用了哪些协议呢？</p><h4 id="自定制协议"><a href="#自定制协议" class="headerlink" title="自定制协议"></a>自定制协议</h4><p>socket编程中，收发数据我们通过的是字符串的形式，假如我们想传输“结构化的数据”怎么办？</p><p>假定此时我们被分发了一个任务，需要自制一个网络计算器。此时有两种方案。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">约定方案一:</span><br><span class="line">客户端发送一个形如"1+1"的字符串;</span><br><span class="line">这个字符串中有两个操作数, 都是整形;</span><br><span class="line">两个数字之间会有一个字符是运算符, 运算符只能是 + ;</span><br><span class="line">数字和运算符之间没有空格;</span><br><span class="line"></span><br><span class="line">约定方案二:</span><br><span class="line">定义结构体来表示我们需要交互的信息;</span><br><span class="line">发送数据时将这个结构体按照一个规则转换成字符串, 接收到数据的时候再按照相同的规则把字符串转化回结构体;</span><br><span class="line">这个过程叫做 "序列化" 和 "反序列化"</span><br></pre></td></tr></table></figure><p><strong>序列化：</strong> 将数据按照持久化存储或网络数据传输的格式进行排布</p><p><strong>反序列化：</strong> 将数据按照指定的协议进行解析</p><p>我们将这个计算的传输数据保存到一个结构体中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cal</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num1;<span class="comment">//cal.num1 = 1 , cal.num2 = 2 , cal.op = '+'</span></span><br><span class="line">    <span class="keyword">int</span> num2;<span class="comment">//send(cal)----recv(char buf[9])</span></span><br><span class="line">    <span class="keyword">char</span> op;<span class="comment">//char *a = buf;</span></span><br><span class="line">&#125;cal;</span><br></pre></td></tr></table></figure><p>通过代码实现一下，将之前的TCP.h文件和服务端和客户端进行一个改变即可</p><p>之前博客可查看：<a href="https://blog.csdn.net/skrskr66/article/details/91452452" target="_blank" rel="noopener">https://blog.csdn.net/skrskr66/article/details/91452452</a> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tcpSocket.hpp</span></span><br><span class="line">类外添加</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">cal_t</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num1;</span><br><span class="line">    <span class="keyword">int</span> num2;</span><br><span class="line">    <span class="keyword">char</span> op;</span><br><span class="line">&#125;cal;</span><br><span class="line">类内添加</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetSockFd</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _sock;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//tcp_cli.cpp</span></span><br><span class="line">include <span class="string">"tcpsocket.hpp"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(argc != <span class="number">3</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"./tcp_client ip port"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">string</span> ip = argv[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">uint16_t</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">  <span class="comment">//字符串转换成整型数的一个函数</span></span><br><span class="line">  TcpSocket sock;</span><br><span class="line">  CHECK_RET(sock.Socket());</span><br><span class="line">  CHECK_RET(sock.Connect(ip,port));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    cal info;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;info.num1&gt;&gt;info.op&gt;&gt;info.num2;</span><br><span class="line">    <span class="keyword">int</span> fd = sock.GetSockFd();</span><br><span class="line">    send(fd,&amp;info,<span class="keyword">sizeof</span>(cal),<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  sock.Close();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//tcp_ser.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tcpsocket.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(argc != <span class="number">3</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"./tcp_server ip port"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">string</span> ip = argv[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">uint16_t</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  TcpSocket sock;</span><br><span class="line">  CHECK_RET(sock.Socket());</span><br><span class="line">  CHECK_RET(sock.Bind(ip,port));</span><br><span class="line">  CHECK_RET(sock.Listen());</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    TcpSocket clisock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(sock.Accept(clisock,&amp;cliaddr) == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"new connect client:"</span>&lt;&lt;inet_ntoa(cliaddr.sin_addr)&lt;&lt;<span class="string">":"</span>&lt;&lt;ntohs(cliaddr.sin_port)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd = clisock.GetSockFd();</span><br><span class="line">    cal info;</span><br><span class="line"></span><br><span class="line">    recv(fd,&amp;info,<span class="keyword">sizeof</span>(cal),<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">switch</span>(info.op)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'+'</span>:</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"num1: ["</span>&lt;&lt;info.num1&lt;&lt;<span class="string">"]"</span>&lt;&lt;info.op&lt;&lt;<span class="string">"num2: ["</span>&lt;&lt;info.num2&lt;&lt;<span class="string">"]"</span>&lt;&lt;<span class="string">"= ["</span>&lt;&lt;info.num1 + info.num2&lt;&lt;<span class="string">"]"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'-'</span>:</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"num1: ["</span>&lt;&lt;info.num1&lt;&lt;<span class="string">"]"</span>&lt;&lt;info.op&lt;&lt;<span class="string">"num2: ["</span>&lt;&lt;info.num2&lt;&lt;<span class="string">"]"</span>&lt;&lt;<span class="string">"= ["</span>&lt;&lt;info.num1 - info.num2&lt;&lt;<span class="string">"]"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'*'</span>:</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"num1: ["</span>&lt;&lt;info.num1&lt;&lt;<span class="string">"]"</span>&lt;&lt;info.op&lt;&lt;<span class="string">"num2: ["</span>&lt;&lt;info.num2&lt;&lt;<span class="string">"]= ["</span>&lt;&lt;info.num1 * info.num2&lt;&lt;<span class="string">"]"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"num1:["</span>&lt;&lt;info.num1&lt;&lt;<span class="string">"]"</span>&lt;&lt;info.op&lt;&lt;<span class="string">"num2: ["</span>&lt;&lt;info.num2&lt;&lt;<span class="string">"]= ["</span>&lt;&lt;info.num1 / info.num2&lt;&lt;<span class="string">"]"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  sock.Close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/06/18/网络基础知识/网络1.png" alt="网络1"></p><p>客户端输入计算值，服务端即可返回计算结果。传输了结构化数据</p><h4 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h4><p>虽然HTTP协议早已耳熟能详。但是它也是由大佬定义的协议，我个人认为也算在自定制协议中。</p><p>HTTP协议又称为超文本传输协议。是一个基于请求与响应模式的、无状态的、应用层的协议，常基于TCP的连接方式 。</p><h5 id="认识url"><a href="#认识url" class="headerlink" title="认识url"></a>认识url</h5><p>url简单的理解就是我们常说的网址。它的专业名称是：统一资源定位符</p><p><img src="/2019/06/18/网络基础知识/网络2.png" alt="网络2"></p><p>上面就是一个url各个部分的意义</p><h5 id="url的编码urlencode与解码urldecode"><a href="#url的编码urlencode与解码urldecode" class="headerlink" title="url的编码urlencode与解码urldecode"></a>url的编码urlencode与解码urldecode</h5><p><img src="/2019/06/18/网络基础知识/网络3.png" alt="网络3"></p><p>当我们进行一些查找的操作时，比如百度搜索C++,但是上面的url却变成了c%2B%2B，这是怎么回事？</p><p>像这样的字符，已经被url当作特殊意义理解了。因此这些字符不能随意出现。</p><p>比如，某个参数中需要带又这些特殊字符，就必须先对这些字符进行编码操作。</p><p>urlencode：将特殊字符转换为16进制字符串，并且在前方使用%表明两个字符是经过了编码的</p><p>urldecode：当查询字符串出现%则认为，后续两个字符是需要进行url解码的</p><h5 id="HTTP协议格式"><a href="#HTTP协议格式" class="headerlink" title="HTTP协议格式"></a>HTTP协议格式</h5><p>通过使用fiddler进行抓包，查看HTTP的协议格式</p><p>域名中的xx是我个人隐藏。。。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">GET http://123.207.58.xx/ HTTP/1.1</span><br><span class="line">Host: 123.207.58.xx</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.169 Safari/537.36</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,<span class="emphasis">*/*</span>;q=0.8,application/signed-exchange;v=b3</span><br><span class="line">Referer: http://123.207.58.25/homework/userHomework</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.9</span><br><span class="line">Cookie: PHPSESSID=1vgu9tcfei5t4erlc9sq9gj8o3; loginStatus=yes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Server: nginx/1.12.2</span><br><span class="line">Date: Tue, 18 Jun 2019 06:46:49 GMT</span><br><span class="line">Content-Type: text/html; charset=UTF-8</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line">Connection: keep-alive</span><br><span class="line">X-Powered-By: PHP/5.4.16</span><br><span class="line">Expires: Thu, 19 Nov 1981 08:52:00 GMT</span><br><span class="line">Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0</span><br><span class="line">Pragma: no-cache</span><br></pre></td></tr></table></figure><p>上面分别为http协议请求和http协议响应</p><p><strong>请求首行：[请求方法] + [url] + [版本]</strong></p><p><strong>Header(请求头部)：请求的属性，由一个个键值对组成，每个键值对都有对其含义和功能 key:val\r\nkay:val\r\n，每组属性之间使用\n分隔；遇到空行表示Header部分结束</strong></p><p><strong>响应首行：[版本号] + [状态码] + [状态码解释]</strong></p><p>Body：空行后面的内容都是Body. Body允许为空字符串. 如果Body存在, 则在Header中会有一个键值对Content-Length属性来标识Body的长度; 如果服务器返回了一个html页面, 那么html页面内容就是在body中.</p><h5 id="HTTP的方法"><a href="#HTTP的方法" class="headerlink" title="HTTP的方法"></a>HTTP的方法</h5><p>请求方法有很多，依次罗列，不过所有方法名均为大写</p><table><thead><tr><th style="text-align:center">GET</th><th style="text-align:center">请求获取request-url所标识的资源</th><th style="text-align:center">1.0/1.1</th></tr></thead><tbody><tr><td style="text-align:center">POST</td><td style="text-align:center">在request-url所标识的资源后附加新的数据</td><td style="text-align:center">1.0/1.1</td></tr><tr><td style="text-align:center">HEAD</td><td style="text-align:center">请求获取由request-url所标识的资源的响应消息报头</td><td style="text-align:center">1.0/1.1</td></tr><tr><td style="text-align:center">PUT</td><td style="text-align:center">请求服务器存储一个资源，并用request-url作为其标识</td><td style="text-align:center">1.0/1.1</td></tr><tr><td style="text-align:center">DELETE</td><td style="text-align:center">请求删除request-url所标识的资源</td><td style="text-align:center">1.0/1.1</td></tr><tr><td style="text-align:center">TRACE</td><td style="text-align:center">请求服务器回送收到的请求信息，主要用于测试或诊断</td><td style="text-align:center">1.1</td></tr><tr><td style="text-align:center">CONNECT</td><td style="text-align:center">保留将来使用</td><td style="text-align:center">1.1</td></tr><tr><td style="text-align:center">OPTIONS</td><td style="text-align:center">请求查询服务器的性能，或者查询与资源相关的选项和需求</td><td style="text-align:center">1.1</td></tr><tr><td style="text-align:center">LINK</td><td style="text-align:center">建立和资源之间的联系</td><td style="text-align:center">1.0</td></tr><tr><td style="text-align:center">UNLINE</td><td style="text-align:center">断开连接关系</td><td style="text-align:center">1.0</td></tr></tbody></table><p>其中最常用的就是GET和POST</p><p>GET方法：在浏览器的地址栏中输入网址的方式访问网页时，浏览器采用GET方法向服务器获取资源</p><p>POST方法要求被请求服务器接受附在请求后面的数据，常用于提交表单。</p><h5 id="HTTP的状态码"><a href="#HTTP的状态码" class="headerlink" title="HTTP的状态码"></a>HTTP的状态码</h5><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">类别</th><th style="text-align:center">原因</th></tr></thead><tbody><tr><td style="text-align:center">1xx</td><td style="text-align:center">Informational（信息性状态码）</td><td style="text-align:center">表示请求已被接收，正在被处理</td></tr><tr><td style="text-align:center">2xx</td><td style="text-align:center">Success（成功状态码）</td><td style="text-align:center">请求正常处理完毕</td></tr><tr><td style="text-align:center">3xx</td><td style="text-align:center">Redirection（重定向状态码）</td><td style="text-align:center">需要进行附加操作以完成请求</td></tr><tr><td style="text-align:center">4xx</td><td style="text-align:center">Client Error(客户端错误状态码)</td><td style="text-align:center">服务器不能处理该请求</td></tr><tr><td style="text-align:center">5xx</td><td style="text-align:center">Server Error（服务端错误状态码）</td><td style="text-align:center">服务器处理请求出错</td></tr></tbody></table><p>常见状态码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">200</span> OK      <span class="comment">//客户端请求成功</span></span><br><span class="line">    </span><br><span class="line"><span class="number">302</span> Redirect<span class="comment">//重定向</span></span><br><span class="line"></span><br><span class="line"><span class="number">400</span> Bad Request  <span class="comment">//客户端请求有语法错误，不能被服务器所理解</span></span><br><span class="line"></span><br><span class="line"><span class="number">401</span> Unauthorized <span class="comment">//请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 </span></span><br><span class="line"></span><br><span class="line"><span class="number">403</span> Forbidden  <span class="comment">//服务器收到请求，但是拒绝提供服务</span></span><br><span class="line"></span><br><span class="line"><span class="number">404</span> Not Found  <span class="comment">//请求资源不存在，eg：输入了错误的URL</span></span><br><span class="line"></span><br><span class="line"><span class="number">500</span> Internal Server Error <span class="comment">//服务器发生不可预期的错误</span></span><br><span class="line"></span><br><span class="line"><span class="number">503</span> Server Unavailable  <span class="comment">//服务器当前不能处理客户端的请求，一段时间后可能恢复正常</span></span><br></pre></td></tr></table></figure><h5 id="HTTP常见的头部信息"><a href="#HTTP常见的头部信息" class="headerlink" title="HTTP常见的头部信息"></a>HTTP常见的头部信息</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: 数据类型(text/html等);</span><br><span class="line">    </span><br><span class="line">Content-Length: Body的长度;</span><br><span class="line"></span><br><span class="line">Host: 客户端告知服务器, 所请求的资源是在哪个主机的哪个端口上;</span><br><span class="line"></span><br><span class="line">User-Agent: 声明用户的操作系统和浏览器版本信息;</span><br><span class="line"></span><br><span class="line">referer: 当前页面是从哪个页面跳转过来的;</span><br><span class="line"></span><br><span class="line">location: 搭配<span class="number">3</span>xx状态码使用, 告诉客户端接下来要去哪里访问;</span><br><span class="line"></span><br><span class="line">Cookie: 用于在客户端存储少量信息. 通常用于实现会话(session)的功能;</span><br></pre></td></tr></table></figure><h4 id="实现一个简单HTTP服务器"><a href="#实现一个简单HTTP服务器" class="headerlink" title="实现一个简单HTTP服务器"></a>实现一个简单HTTP服务器</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tcpsocket.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(argc != <span class="number">3</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"./httpserver ip port\n"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">string</span> ip = argv[<span class="number">1</span>];</span><br><span class="line">  <span class="keyword">uint16_t</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">  TcpSocket sock;</span><br><span class="line">  CHECK_RET(sock.Socket());</span><br><span class="line">  CHECK_RET(sock.Bind(ip,port));</span><br><span class="line">  CHECK_RET(sock.Listen());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    TcpSocket clisock;</span><br><span class="line">    <span class="keyword">if</span>(sock.Accept(clisock) == <span class="literal">false</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">string</span> buf;</span><br><span class="line">    clisock.Recv(buf);</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"req:["</span>&lt;&lt;buf&lt;&lt;<span class="string">"]"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> body;</span><br><span class="line">    body = <span class="string">"&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello Donkey&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;"</span>;</span><br><span class="line">    <span class="built_in">stringstream</span> ss;</span><br><span class="line"></span><br><span class="line">    ss &lt;&lt; <span class="string">"HTTP/1.1 502 Bad GateWay\r\n"</span>;</span><br><span class="line">    ss &lt;&lt; <span class="string">"Content-Length: "</span> &lt;&lt; body.size() &lt;&lt;<span class="string">"\r\n"</span>;</span><br><span class="line">    ss &lt;&lt; <span class="string">"Content-Type: text/html\r\n"</span>;</span><br><span class="line">    ss &lt;&lt; <span class="string">"Location: http://www.baidu.com\r\n"</span>;</span><br><span class="line">    ss &lt;&lt; <span class="string">"\r\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> header = ss.str();</span><br><span class="line"></span><br><span class="line">    clisock.Send(header);</span><br><span class="line">    clisock.Send(body);</span><br><span class="line">    clisock.Close();</span><br><span class="line">  &#125;</span><br><span class="line">  sock.Close();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/06/18/网络基础知识/网络4.png" alt="网络4"></p><p><img src="/2019/06/18/网络基础知识/网络5.png" alt="网络5"></p><p>运行如图~，感觉还不错~。</p><h5 id="个人小结"><a href="#个人小结" class="headerlink" title="个人小结"></a>个人小结</h5><p>应用层中最关键的是HTTP协议。而在HTTP协议中，首先是了解url，url又叫做统一资源定位符。</p><p>url在查找过程中当遇到特殊的字符存在时还有编码与解码的操作。将特殊字符转换为16进制。</p><p>HTTP的协议格式分为请求和响应。它们又分别具有请求首行，请求报头；响应首行，响应报头</p><p>HTTP的方法有多种，我们常用的为GET和POST这两种</p><p>HTTP的状态码有五种分别为1xx,2xx,3xx,4xx,5xx。它们分别对应了信息性状态码，成功状态码，重定向状态码，客户端错误状态码，服务端错误状态码</p><p>HTTP的常见头部信息有：</p><p>Content-Type: 数据类型(text/html等) </p><p>Content-Length: Body的长度 </p><p>Host: 客户端告知服务器, 所请求的资源是在哪个主机的哪个端口上; </p><p>User-Agent: 声明用户的操作系统和浏览器版本信息; </p><p>referer: 当前页面是从哪个页面跳转过来的; </p><p>location: 搭配3xx状态码使用, 告诉客户端接下来要去哪里访问; </p><p>Cookie: 用于在客户端存储少量信息. 通常用于实现会话(session)的功能; </p><p>HTTP协议的知识点比较多，还是多看才能记住</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在了解网络整体模型之前学习了套接字编程和一些简单的网络知识。但是网络编程的理论基础是建立在多方面上的，比如数据在每一层是经过了怎么样的封装，每一层使用了哪些协议，每一层的协议又有哪些用途。只有掌握好这些基础知识，才能更好的成为一个服务器开发人员。&lt;/p&gt;
&lt;h3 id=&quot;应
      
    
    </summary>
    
    
      <category term="网络" scheme="https://skrskr66.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>C++-内存管理</title>
    <link href="https://skrskr66.github.io/2019/06/17/C-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://skrskr66.github.io/2019/06/17/C-内存管理/</id>
    <published>2019-06-17T09:33:51.000Z</published>
    <updated>2019-06-19T14:43:59.426Z</updated>
    
    <content type="html"><![CDATA[<p>参考博客：<a href="https://blog.csdn.net/jing0611/article/details/4030237" target="_blank" rel="noopener">https://blog.csdn.net/jing0611/article/details/4030237</a> </p><p>在最开始的学习中，老师一直在说一个关于C++的话题。<strong>C++是一个极度追求性能的语言。</strong> 通过学习，这不是开玩笑，在我所学习的语言中，对内存的使用有如此的执着的“较真”也就是C++了。</p><p>因为性能的缘故，一个内存不合理的分配，都可能在日后成为一个隐患，成为一个令人头疼的BUG。所以最近想好好总结一下<strong>内存管理</strong>。我们在学习中也经常听到栈溢出，内存泄漏等这些感觉很严重的问题。首先我们要搞清楚什么是栈和什么是堆。</p><h3 id="栈和堆"><a href="#栈和堆" class="headerlink" title="栈和堆"></a>栈和堆</h3><p>首先要理解一个关键的问题。我们此时说的是<strong>内存分配中的栈和堆</strong>，不是在讨论<strong>数据结构中的栈和二叉堆</strong>。我在之前学习操作系统的时候划过一个图，是关于Linux下操作系统程序地址空间的。中间还有栈区和堆区的分布</p><p><img src="/2019/06/17/C-内存管理/内存管理.png" alt="内存管理"></p><p>从图中可以看出基本分布，内存中的栈区是处于高地址以地址的增长方向为上，栈地址是向下增长的。从上往下，<strong>栈区是分配局部变量空间</strong>。堆区是从下往上，堆区的地址是向上增长的<strong>用于分配程序员申请的内存空间。</strong></p><h3 id="内存分配方式"><a href="#内存分配方式" class="headerlink" title="内存分配方式"></a>内存分配方式</h3><p>内存分配方式有三种</p><h4 id="从静态存储区域分配"><a href="#从静态存储区域分配" class="headerlink" title="从静态存储区域分配"></a>从静态存储区域分配</h4><p>内存在程序编译的时候就已经分配好了，这块<strong>内存在程序的整个运行期间都存在</strong>。</p><p>例如全局变量，static静态成员变量</p><h4 id="在栈上创建"><a href="#在栈上创建" class="headerlink" title="在栈上创建"></a>在栈上创建</h4><p>执行函数时，函数内部变量的存储单位可以在栈上创建，函数执行结束时，这些存储单元自动释放。栈内存分配运算置于处理器的指令集中，效率很高，但是分配的内存容量有限</p><h4 id="在堆上分配"><a href="#在堆上分配" class="headerlink" title="在堆上分配"></a>在堆上分配</h4><p>也称为动态内存分配。程序在运行的时候用malloc或new申请任意多少内存，程序员自己负责在何时用free或delete来释放这块内存。动态内存的生命周期由程序员决定，使用非常灵活，但如果在堆上分配了空间，就有责任回收它，否则运行的程序会出现泄漏，频繁地分配和释放不同大小的堆空间将会产生堆内碎块。也就是我们常说的内存碎片。</p><h3 id="程序内存空间"><a href="#程序内存空间" class="headerlink" title="程序内存空间"></a>程序内存空间</h3><p>一个程序将操作系统分配给其运行的内存分为4个区域</p><table><thead><tr><th style="text-align:center">代码区（code area）</th></tr></thead><tbody><tr><td style="text-align:center">全局数据区（data area）</td></tr><tr><td style="text-align:center">堆区（heap area）</td></tr><tr><td style="text-align:center">栈区（stack area）</td></tr></tbody></table><p><strong>栈区</strong>：由编译器自动分配释放，<strong>存放为函数运行</strong>的局部变量，函数参数，返回数据，返回地址等。操作方式与数据结构中的类似。</p><p><strong>堆区</strong>：一般由程序员分配释放，若程序员不释放，程序结束时可能由OS回收。分配方式类似于链表</p><p><strong>全局数据区</strong>：也叫做静态区，存放全局变量，静态数据。程序结束后由系统释放</p><p><strong>文字常量区</strong>：可以理解为常量区，常量字符串存放这里。程序结束后由系统释放</p><p><strong>程序代码区</strong>：存放函数体的二进制代码。但是代码段中也分为代码段和数据段。</p><h5 id="关于文字常量区"><a href="#关于文字常量区" class="headerlink" title="关于文字常量区"></a>关于文字常量区</h5><p>文字常量区，在大多数解释中，都仅仅说明常量字符串存放这里。但是如果深究字眼，那么其他常量比如整型是否存放这里呢？我查阅了一些资料，是这么解释的：<strong>常量之所以称为“文字常量”，其中“文字”是指我们只能以它的值的形式指代它，“常量”是指它的值是不可变的。同时注意一点：文字常量是不可寻址的（即我们的程序中不可能出现获取所谓常量20的存储地址&amp;20这样的表达式），虽然常量也是存储在内存的某个地方，但是我们没有办法访问常量的地址的。</strong> </p><p>还有就是我们都知道的常量是有类型的。所以总的来说，只要是常量都存放在文字常量区！！</p><h5 id="程序例子"><a href="#程序例子" class="headerlink" title="程序例子"></a>程序例子</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>; <span class="comment">//全局初始化区</span></span><br><span class="line"><span class="keyword">char</span> *p1; <span class="comment">//全局未初始化区</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> b; <span class="comment">//栈</span></span><br><span class="line"><span class="keyword">char</span> s[] = /<span class="string">"abc/"</span>; <span class="comment">//栈</span></span><br><span class="line"><span class="keyword">char</span> *p2; <span class="comment">//栈</span></span><br><span class="line"><span class="keyword">char</span> *p3 = /<span class="string">"123456/"</span>; <span class="comment">//123456//0在常量区，p3在栈上。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> c =<span class="number">0</span>;<span class="comment">//全局（静态）初始化区</span></span><br><span class="line">p1 = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br><span class="line">p2 = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">20</span>];</span><br><span class="line"><span class="comment">//分配得来得和字节的区域就在堆区。</span></span><br><span class="line"><span class="built_in">strcpy</span>(p1, /<span class="string">"123456/"</span>); <span class="comment">//123456//0放在常量区，编译器可能会将它与p3所指向的/"123456/"优化成一个地方。</span></span><br><span class="line">&#125;</span><br><span class="line">--------------------- </span><br><span class="line">作者：jing0611 </span><br><span class="line">来源：CSDN </span><br><span class="line">原文：https:<span class="comment">//blog.csdn.net/jing0611/article/details/4030237 </span></span><br><span class="line">版权声明：本文为博主原创文章，转载请附上博文链接！</span><br></pre></td></tr></table></figure><h3 id="堆与栈的区别"><a href="#堆与栈的区别" class="headerlink" title="堆与栈的区别"></a>堆与栈的区别</h3><h4 id="申请方式"><a href="#申请方式" class="headerlink" title="申请方式"></a>申请方式</h4><p>stack：由系统自动分配。比如在函数运行中声明一个局部变量<code>int b = 10;</code>，系统自动在栈中为b开辟空间。</p><p>heap：需要程序员自己申请，并指明大小，在C中是有malloc函数，在C++中多使用new运算符</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p1 = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">p2 = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">10</span>];</span><br><span class="line">此时的p1和p2是在栈中的</span><br></pre></td></tr></table></figure><p>从C++角度上说，使用new分配堆空间可以调用类的构造函数，而malloc()函数仅仅是一个函数调用，它不会调用构造函数，它所接受的参数是一个unsigned long类型。同样，delete在释放堆空间之前会调用析构函数，而free函数则不会。 </p><h4 id="申请后系统的响应"><a href="#申请后系统的响应" class="headerlink" title="申请后系统的响应"></a>申请后系统的响应</h4><p>stack：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出</p><p>heap：在操作系统中有一个记录空闲内存地址的表，这是一种链式结构。它记<strong>录了有哪些还未使用的内存空间。当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。</strong></p><p>对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。由于找到的堆结点的大小不一定正好等于申请的大小，系统会将自动的多余的那部分重新放入空闲链表中。</p><h4 id="申请大小的限制"><a href="#申请大小的限制" class="headerlink" title="申请大小的限制"></a>申请大小的限制</h4><p>stack：在WINDOWS中，栈是向下增长的，是一块连续的区域。也就是说栈从<strong>栈顶的地址和栈的最大容量是系统预先规定好的</strong>。栈的大小是2M。当超过这个内存之后，会报Overflow异常。所以栈能申请的空间较小。</p><p>heap：堆是向上增长的，向高地址递增的，因为它是一个用链表来存储的空闲地址空间。自然是个不连续的内存区域。堆的大小受限于计算机系统中有效的虚拟内存。我们知道当我们玩网络游戏时，当虚拟内存不够时我们会更改虚拟内存的大小。一般初始值为512M，可以更大，所以堆能分配的区域是相当大的。</p><h4 id="申请效率的比较"><a href="#申请效率的比较" class="headerlink" title="申请效率的比较"></a>申请效率的比较</h4><p>stack：由系统自动分配，速度较快，但是程序员不可控</p><p>heap：由new或者malloc申请的一块新空间(内存)，一般速度比较慢，而且容易产生内存碎片，不过用起来方便。</p><p>在WINDOWS下，最好的方式是用VirtualAlloc分配内存，他不是在堆，也不是栈，而是直接在进程的地址空间中保留一快内存，虽然用起来最不方便。但是速度快，也最灵活。 </p><p>VirtualAlloc是一个Windows API函数，该函数的功能是在调用进程的虚拟地址空间,预定或者提交一部分页。 </p><h4 id="堆和栈的存储内容"><a href="#堆和栈的存储内容" class="headerlink" title="堆和栈的存储内容"></a>堆和栈的存储内容</h4><p>stack：在函数调用中，第一个进栈的是主函数中后的第一个指令(函数调用语句的下一条可执行语句)的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右向左入栈的，然后是函数中的局部变量。但是，<strong>静态变量不入栈</strong></p><p>当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，<strong>程序</strong>由该点继续运行。 </p><p>heap：一般是在堆的头部用一个字节存放堆的大小。堆中的内容由程序员自己安排。</p><h4 id="存取效率的比较"><a href="#存取效率的比较" class="headerlink" title="存取效率的比较"></a>存取效率的比较</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s1[] = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">char</span> *s2 = <span class="string">'b'</span>;</span><br></pre></td></tr></table></figure><p>a是在运行时刻才赋值的；而b是在编译时就确定的；但是，在以后的存取中，在栈上的数组比指针所指向的字符串(堆)快。</p><p>无论是堆还是栈，都要防止越界现象的发生（除非你是故意使其越界），因为越界的结果要么是<strong>程序</strong>崩溃，要么是摧毁<strong>程序</strong>的堆、栈结构，产生以想不到的结果。 </p><h4 id="个人总结"><a href="#个人总结" class="headerlink" title="个人总结"></a>个人总结</h4><p>堆和栈的分配区别在一下几个方面</p><p>1、管理方式不同；</p><p>2、空间大小不同；</p><p>3、能否产生碎片不同；</p><p>4、生长方向不同；</p><p>5、分配方式不同；</p><p>6、分配效率不同；</p><p><strong>管理方式：</strong> 栈是在函数运行时，由系统自动分配；而堆是通过程序员自己调用malloc函数或者new运算符去申请一个需要的大小空间。</p><p><strong>空间大小：</strong> 栈的空间大小并不大，一般最多为2M，超过之后会报Overflow错误。堆的空间非常大，最大可到达4G，可操作的空间非常大。</p><p><strong>能否产生碎片： </strong>栈的操作与数据结构中的栈用法是类似的。‘后进先出’的原则，以至于不可能有一个空的内存块从栈被弹出。因为在它弹出之前，在它上面的后进栈的数据已经被弹出。它是严格按照栈的规则来执行。但是堆是通过new/malloc随机申请的空间，频繁的调用它们，则会产生大量的内存碎片。这是不可避免地。</p><p><strong>生长方向：</strong> 栈的生长方向是由高地址向低地址增长，是自上而下的。堆的生长方向是由低地址向高地址增长，是自下而上的。</p><p><strong>分配方式：</strong> 堆都是动态分配的，没有静态分配。但是栈有两种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由malloc函数实现，但是<strong>栈的动态分配和堆是不同的，它的动态分配是由编译器进行和释放，无需程序员进行操作。</strong></p><p><strong>分配效率：</strong> 栈是机器系统提供的数据结构，计算机底层对栈提供支持：分配专门的寄存器存放栈的地址，压栈出栈都有专门的指令执行。这就决定了栈有着很高的效率。堆需要通过C/C++的库函数进行一个复杂的算法，在对内存中搜寻一个足够大小的空间，如果没有足够的空间(内存碎片空间太多)，就有可能调用系统功能去增加程序数据段的内存空间，这样就有机会分到足够大小的内存，然后进行返回。显然，堆的效率比栈要低的多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;参考博客：&lt;a href=&quot;https://blog.csdn.net/jing0611/article/details/4030237&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://blog.csdn.net/jing0611/artic
      
    
    </summary>
    
    
      <category term="C++" scheme="https://skrskr66.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++-String类</title>
    <link href="https://skrskr66.github.io/2019/06/16/C-String%E7%B1%BB/"/>
    <id>https://skrskr66.github.io/2019/06/16/C-String类/</id>
    <published>2019-06-16T06:16:16.000Z</published>
    <updated>2019-06-16T06:16:16.457Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>TCP的三次握手与四次挥手</title>
    <link href="https://skrskr66.github.io/2019/06/13/TCP%E7%9A%84%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%B8%8E%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/"/>
    <id>https://skrskr66.github.io/2019/06/13/TCP的三次握手与四次挥手/</id>
    <published>2019-06-13T10:54:49.000Z</published>
    <updated>2019-06-15T15:06:28.801Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TCP的三次握手与四次挥手"><a href="#TCP的三次握手与四次挥手" class="headerlink" title="TCP的三次握手与四次挥手"></a>TCP的三次握手与四次挥手</h3><p>关于题目的这个问题，在网络中有着非常重要的地位。因为客户端与服务端之间通过TCP协议，为了进行数据的传输会进行一系列的操作，这中间的操作就是TCP的三次握手与四次挥手。</p><h4 id="重新回顾TCP协议"><a href="#重新回顾TCP协议" class="headerlink" title="重新回顾TCP协议"></a>重新回顾TCP协议</h4><p>TCP协议称为数据传输协议，是可靠传输，面向连接的，并且面向字节流的。</p><p><strong>面向连接</strong>：通信之前先建立连接，确保双方在线。</p><p><strong>可靠传输</strong>：在网络正常的情况下，数据不会丢失。</p><p><strong>面向字节流</strong>：传输灵活，但是TCP的传输存在粘包问题，没有明显的数据约定。</p><h4 id="TCP协议的传输过程"><a href="#TCP协议的传输过程" class="headerlink" title="TCP协议的传输过程"></a>TCP协议的传输过程</h4><p><strong>先通过总体图来总的给一个传输过程印象。</strong></p><p><img src="/2019/06/13/TCP的三次握手与四次挥手/网络-三次握手-四次挥手.png" alt="网络-三次握手-四次挥手"></p><h5 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h5><p>我们已客户端先发送连接请求为前提进行连接。</p><p>SYN：同步序列编号（<strong>Synchronize Sequence Numbers</strong>），是TCP/IP建立连接时使用的握手信号 </p><p>ACK：确认字符，在数据通信中，接收站发给发送站的一种传输类控制字符。表示发来的数据已确认接收无误。 </p><p>首先客户端进行<strong>套接字编程操作</strong>创建套接字，再进行绑定地址操作，然后开始向服务端进行连接请求。</p><p>与此同时，服务端也创建套接字，也进行绑定地址，然后开始进行监听套接字操作。</p><p><strong>握手过程：</strong></p><p>客户端先向服务端发送一个<strong>SYN</strong>消息，此时客户端处于<strong>SYN_SEND</strong>状态。服务端此时接收到了该消息，这时服务端会发送<strong>SYN+ACK，进行消息回复确认。</strong>回复完之后，此时服务端处于<strong>SYN_RCVD</strong>状态，等待客户端进行最后一次确认。这个时候客户端接收到了SYN+ACK包之后，再给服务端发送一个<strong>ACK</strong>包，此时客户端将处于<strong>ESTABLISH</strong>状态(就绪状态)，代表了客户端此时可以进行收发数据。服务端接受了ACK包之后，此时连接建立成功，服务端也处于<strong>ESTABLISH</strong>状态，也可以进行收发消息了。</p><p>此时客户端与服务端的连接建立完成。它们之间可以进行数据的发送与接收….</p><p>但是<strong>人有悲欢离合，月有阴晴圆缺，网络迟早断开连接！！！</strong></p><p>发送了一段时间后，它们之间要断开连接…</p><h5 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h5><p>我们再次已客户端先发送断开请求为前提。</p><p>FIN：表示断开连接</p><p>RST：表示复位，用来异常的关闭连接 </p><p><strong>挥手过程：</strong></p><p>客户端发送完数据之后，关闭了网络套接字，此时客户端向服务端发送了一个<strong>FIN包</strong>，发送完毕之后，客户端处于<strong>FIN_WAIT_1状态</strong>。服务端接收到了之后，处于<strong>CLOSE_WAIT状态</strong>。服务端这时会向客户端发送一个<strong>ACK包</strong>，发送完了进入<strong>LAST_ACK状态</strong>，<strong>进行最后一次等待确认状态，此时伴随着close()关闭套接字</strong>。因为服务端还要再确认一次是否断开连接，此时服务端向客户端再发送一个<strong>FIN包</strong>。客户端接收到了该FIN包之后，再给服务端发送<strong>ACK包</strong>，代表确认关闭，执行完该操作之后，客户端并没有直接<strong>CLOSED并且回收资源</strong>，此时客户端处于<strong>TIME_WAIT状态，等待时间为两个MSL(最大报文段生存周期，一个大约30s)。</strong>服务端此时接收到了该ACK包，进入了CLOSED状态并且回收资源。客户端等待了两个MSL时间之后，也进入了CLOSED状态并且回收资源。</p><p>这时客户端与服务端之间断开连接。</p><p><strong>TIME_WAIT状态：</strong></p><p>在断开的过程中有一个TIME_WAIT状态，为什么会有该状态？</p><p>假设没有TIME_WAIT会有什么情况：最后一个ACK丢失，被动关闭方重发FIN包，没有等待直接关闭。若直接启动的客户端此时使用了相同的端口信息，有可能收到FIN包，此时就对新连接造成影响。</p><p>若新启动客户端使用了相同的端口信息，向服务器发送了SYN请求，但是服务端因为没有受到最后一个ACK包而一直处于LAST_ACK状态，受到SYN后判定状态错误，回复<strong>RST报文重置连接</strong>，也对新连接造成了影响。</p><p>所以主动关闭方发送最后一个ACK之后需要等待一段时间：两个MSL时间(最大报文等待时间)</p><p>1、处理ACK丢失，导致对端重发FIN包</p><p>2、等待双方延迟的报文全部消失在网络中，不会对后续连接造成影响。</p><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><h5 id="为什么握手是三次，挥手是四次？"><a href="#为什么握手是三次，挥手是四次？" class="headerlink" title="为什么握手是三次，挥手是四次？"></a>为什么握手是三次，挥手是四次？</h5><p><strong>在握手过程中，为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。</strong></p><p>当客户端发出的第一个连接请求报文段并没有丢失，而是在网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达服务端。本来这是一个早已失效的报文段。但是服务端收到此失效的连接请求报文段之后，就误认为是客户端再次发出的一个新的连接请求。于是就向客户端发出确认报文段，同意建立连接。假设我们不采用“三次握手”，那么服务端发出确认，新的连接就建立成功了。由于现在client并没有发出建立连接的请求，因此不会理睬服务端的确认，也不会像服务端发送数据。但是服务端却以为新的建立已经完成，一直等待消息发送到来。这样，服务端的数据很多数据被白白浪费了。采用“三次握手”可以有效的避免这种情况。客户端不会向服务端的确认发出确认，服务端由于收不到确认，就认为客户端没有建立连接。</p><p>所以，三次握手也可以看作为了防止服务端的一直等待而浪费资源。</p><p>挥手过程是一个相互的确认过程，首先我们都已知TCP的连接是全双工的，既可以发送也可以接收。那么当双方都确认自己没有数据可以发送，并且都互相表示双方知道对方没有数据之后，那么连接也就断开了。</p><p>假设挥手在第三次结束。客户端发送了一个FIN就打算断开连接。那么客户端又如何知道服务端想要断开连接？有可能客户端刚发送完了数据，但是服务端并没有。服务端打算发完了剩下的数据在跟客户端”拜拜“。</p><p>此时就出现了矛盾。所以挥手有第四次来进行双发的确认。确认双方的工作都做完了。</p><h5 id="SYN泛洪攻击"><a href="#SYN泛洪攻击" class="headerlink" title="SYN泛洪攻击"></a>SYN泛洪攻击</h5><p>SYN泛洪攻击利用TCP三次握手协议的缺陷，向目标主机发送大量的伪造源地址的SYN连接请求，使得被攻击方资源耗尽，从而不能够为正常用户提供服务。 </p><p>在TCP协议中被称为三次握手（Three-way Handshake）的连接过程中，如果一个用户向服务器发送了SYN报文，服务器又发出 SYN+ACK 应答报文后<strong>未收到客户端的 ACK 报文</strong>，这种情况下服务器端会再次发送SYN+ACK给客户端，并等待一段时间后丢弃这个未完成的连接，这段时间的长度称为<strong>SYN Timeout</strong>，一般来说这个时间是分钟的数量级。</p><p>SYN 泛洪攻击所做的就是利用这个SYN Timeout和TCP/IP协议族中的另一个漏洞: 报文传输过程中对报文的源 IP 地址完全信任进行攻击。SYN 泛洪攻击通过发送大量的伪造 TCP 链接报文而造成大量的 TCP 半连接,服务器端将为了维护这样一个庞大的半连接列表而消耗非常多的资源。这样服务器端将忙于处理攻击者伪造的TCP连接请求而无法处理正常连接请求,甚至会导致堆栈的溢出崩溃 </p><p>造成SYN洪泛攻击最主要的原因是TCP/IP协议的脆弱性。TCP/IP是一个开放的协议平台，它将越来越多的网络连接在一起，它基于的对象是可信用户群，所以缺少一些必要的安全机制，带来很大的安全威胁。例如常见的IP欺骗、TCP连接的建立、ICMP数据包的发送都存在巨大的安全隐患，给SYN洪泛攻击带来可乘之机。 </p><h6 id="防范方法"><a href="#防范方法" class="headerlink" title="防范方法"></a>防范方法</h6><p>1、<strong>缩短SYN Timeout时间</strong>，短时间内收不到客户端的ACK回复报文直接丢弃，防止被攻击</p><p>2、<strong>设置SYN cookie</strong>，给每一个请求连接的IP地址分配一个cookie，如果短时间内连续受到某个IP的重复SYN文，认定是受到了攻击，以后从这个IP地址来的包会被丢弃。 </p><p>3、<strong>设置SYN可疑队列</strong>  </p><p>4、<strong>使用防火墙</strong>  </p><p>推荐博客链接：<a href="https://blog.csdn.net/justenjoyitpy/article/details/78151239" target="_blank" rel="noopener">https://blog.csdn.net/justenjoyitpy/article/details/78151239</a> </p><h5 id="若服务端出现了大量的TIME-WAIT连接，为什么？如何解决？"><a href="#若服务端出现了大量的TIME-WAIT连接，为什么？如何解决？" class="headerlink" title="若服务端出现了大量的TIME_WAIT连接，为什么？如何解决？"></a>若服务端出现了大量的TIME_WAIT连接，为什么？如何解决？</h5><p>这种情况比较常见，一些爬虫服务器或者WEB服务器（如果网管在安装的时候没有做内核参数优化的话）上经常会遇到这个问题，在四次的挥手过程中我们已经可以了解TIME_WAIT状态的出现情况。</p><p>1、防止上一次连接的包迷路后重新出现，影响新连接，所以等待被动方发来的FIN包</p><p>2、可靠的关闭TCP连接。在主动方发送的最后一个ACK，有可能丢失，这时被动方会重新发FIN包，如果这时主动方处于CLOSED状态，就会响应RST而不是ACK。所以主动方要处于TIME_WAIT，而不能是CLOSED。</p><p><strong>解决的方案就是让服务器能够快速回收和重用那些TIME_WAIT资源</strong></p><p>这里推荐一篇博客链接：<a href="https://www.cnblogs.com/whx7762/p/9413787.html" target="_blank" rel="noopener">https://www.cnblogs.com/whx7762/p/9413787.html</a> </p><p><strong>下面是一篇文章中提到的/etc/sysctl.conf文件的修改</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于一个新建连接，内核要发送多少个 SYN 连接请求才决定放弃,不应该大于255，默认值是5，对应于180秒左右时间</span></span><br><span class="line">net.ipv4.tcp_syn_retries=<span class="number">2</span></span><br><span class="line">net.ipv4.tcp_synack_retries=<span class="number">2</span></span><br><span class="line"><span class="comment">//表示当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时，改为300秒</span></span><br><span class="line">net.ipv4.tcp_keepalive_time=<span class="number">1200</span></span><br><span class="line">net.ipv4.tcp_orphan_retries=<span class="number">3</span></span><br><span class="line"><span class="comment">//表示如果套接字由本端要求关闭，这个参数决定了它保持在FIN-WAIT-2状态的时间</span></span><br><span class="line">net.ipv4.tcp_fin_timeout=<span class="number">30</span></span><br><span class="line"><span class="comment">//表示SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多等待连接的网络连接数</span></span><br><span class="line">net.ipv4.tcp_max_syn_backlog = <span class="number">4096</span></span><br><span class="line"><span class="comment">//表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭 </span></span><br><span class="line">net.ipv4.tcp_syncookies = <span class="number">1</span></span><br><span class="line"><span class="comment">//表示开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0，表示关闭 </span></span><br><span class="line">net.ipv4.tcp_tw_reuse = <span class="number">1</span></span><br><span class="line"><span class="comment">//表示开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关 </span></span><br><span class="line">net.ipv4.tcp_tw_recycle = <span class="number">1</span></span><br><span class="line"><span class="comment">//减少超时前的探测次数</span></span><br><span class="line">net.ipv4.tcp_keepalive_probes=<span class="number">5</span></span><br><span class="line"><span class="comment">//优化网络设备接收队列</span></span><br><span class="line">net.core.netdev_max_backlog=<span class="number">3000</span></span><br></pre></td></tr></table></figure><p>修改完之后执行/sbin/sysctl -p让参数生效。</p><p>net.ipv4.tcp_tw_reuse和net.ipv4.tcp_tw_recycle的开启都是为了回收处于TIME_WAIT状态的资源。</p><p>net.ipv4.tcp_fin_timeout这个时间可以减少在异常情况下服务器从FIN-WAIT-2转到TIME_WAIT的时间。</p><p>net.ipv4.tcp_keepalive_*一系列参数，是用来设置服务器检测连接存活的相关配置。</p><p> 在TCP的传输过程中最重要的就是三次握手与四次挥手，但是TCP的传输过程是面向可信任群体的，安全性相对较弱，会受到一些攻击，不过有方法可以解决。都是根据传输过程进行范围内的防御措施。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;TCP的三次握手与四次挥手&quot;&gt;&lt;a href=&quot;#TCP的三次握手与四次挥手&quot; class=&quot;headerlink&quot; title=&quot;TCP的三次握手与四次挥手&quot;&gt;&lt;/a&gt;TCP的三次握手与四次挥手&lt;/h3&gt;&lt;p&gt;关于题目的这个问题，在网络中有着非常重要的地位。因为
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://skrskr66.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络套接字编程(2)</title>
    <link href="https://skrskr66.github.io/2019/06/06/Linux%E7%BD%91%E7%BB%9C%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B-2/"/>
    <id>https://skrskr66.github.io/2019/06/06/Linux网络套接字编程-2/</id>
    <published>2019-06-06T07:18:12.000Z</published>
    <updated>2019-06-11T09:56:45.456Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TCP传输"><a href="#TCP传输" class="headerlink" title="TCP传输"></a>TCP传输</h3><h4 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h4><p><img src="/2019/06/06/Linux网络套接字编程-2/网络1.png" alt="网络1"></p><p>图解为TCP协议的传输过程。</p><table><thead><tr><th style="text-align:center">客户端操作</th><th style="text-align:center">服务端操作</th></tr></thead><tbody><tr><td style="text-align:center">1、创建套接字</td><td style="text-align:center">1、创建套接字</td></tr><tr><td style="text-align:center">2、向服务端发起连接</td><td style="text-align:center">2、绑定地址信息</td></tr><tr><td style="text-align:center">3、发送数据</td><td style="text-align:center">3、监听(若有新的客户端，新建socket)</td></tr><tr><td style="text-align:center">4、接收数据</td><td style="text-align:center">4、接收已经连接成功的socket</td></tr><tr><td style="text-align:center">5、关闭套接字</td></tr></tbody></table><h4 id="TCP传输-socket编程"><a href="#TCP传输-socket编程" class="headerlink" title="TCP传输-socket编程"></a>TCP传输-socket编程</h4><p>通过C++实现一个类来封装tcp协议</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tcpsocket.hpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHECK_RET(q) <span class="meta-keyword">if</span>((q) == false)&#123;return -1;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TcpSocket</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        TcpSocket() : _sockfd(<span class="number">-1</span>)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">SetSockFd</span><span class="params">(<span class="keyword">int</span> fd)</span></span>&#123;</span><br><span class="line">            _sockfd = fd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">Socket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            _sockfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">            <span class="keyword">if</span> (_sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                perror(<span class="string">"socket error"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">Bind</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> &amp;ip, <span class="keyword">uint16_t</span> port)</span></span>&#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">            addr.sin_family = AF_INET;</span><br><span class="line">            addr.sin_port = htons(port);</span><br><span class="line">            addr.sin_addr.s_addr = inet_addr(ip.c_str());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">            <span class="keyword">int</span> ret = bind(_sockfd, (struct sockaddr*)&amp;addr, len);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                perror(<span class="string">"bind error"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">Listen</span><span class="params">(<span class="keyword">int</span> backlog = <span class="number">10</span>)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//int listen(int sockfd, int backlog);</span></span><br><span class="line">            <span class="comment">//backlog:最大并发连接数--内核中已完成连接队列的最大节点数</span></span><br><span class="line">            <span class="keyword">int</span> ret = listen(_sockfd, backlog);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                perror(<span class="string">"listen error"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>  <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">Connect</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> &amp;ip, <span class="keyword">uint16_t</span> port)</span> </span>&#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span></span><br><span class="line">            addr.sin_family = AF_INET;</span><br><span class="line">            addr.sin_port = htons(port);</span><br><span class="line">            addr.sin_addr.s_addr = inet_addr(ip.c_str());</span><br><span class="line">            <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> ret = connect(_sockfd, (struct sockaddr*)&amp;addr, len);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                perror(<span class="string">"connect error"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">Accept</span><span class="params">(TcpSocket &amp;csock, struct sockaddr_in *addr = <span class="literal">NULL</span>)</span></span>&#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> _<span class="title">addr</span>;</span></span><br><span class="line">            <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">            <span class="keyword">int</span> newfd = accept(_sockfd, (struct sockaddr*)&amp;_addr, &amp;len);</span><br><span class="line">            <span class="keyword">if</span> (newfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                perror(<span class="string">"accept error"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (addr != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="built_in">memcpy</span>(addr, &amp;_addr, len);</span><br><span class="line">            &#125;</span><br><span class="line">            csock.SetSockFd(newfd);</span><br><span class="line">            <span class="comment">//_sockfd--仅用于接收新客户端连接请求</span></span><br><span class="line">            <span class="comment">//newfd----专门用于与客户端进行通信</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">Recv</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> &amp;buf)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">char</span> tmp[<span class="number">4096</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">int</span> ret = recv(_sockfd, tmp, <span class="number">4096</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                perror(<span class="string">"recv error"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"peer shutdown\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            buf.assign(tmp, ret);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">Send</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> &amp;buf)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> ret = send(_sockfd, buf.c_str(), buf.size(), <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                perror(<span class="string">"send error"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">Close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            close(_sockfd);</span><br><span class="line">            _sockfd = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> _sockfd;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>tcp传输客户端</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tcpsocket.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span> ) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"./tcp_cli ip port\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">uint16_t</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    TcpSocket sock;</span><br><span class="line">    CHECK_RET(sock.Socket());</span><br><span class="line">    CHECK_RET(sock.Connect(ip, port));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> buf;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"client say:"</span>;</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt;buf;</span><br><span class="line">        sock.Send(buf);</span><br><span class="line"></span><br><span class="line">        buf.clear();</span><br><span class="line">        sock.Recv(buf);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"server say:"</span>&lt;&lt;buf&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sock.Close();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tcp传输服务端</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tcpsocket.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"./tcp_srv ip  port\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">uint16_t</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    TcpSocket sock;</span><br><span class="line">    CHECK_RET(sock.Socket());</span><br><span class="line">    CHECK_RET(sock.Bind(ip, port));</span><br><span class="line">    CHECK_RET(sock.Listen());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        TcpSocket clisock;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">        <span class="comment">//accept是阻塞获取已经完成的连接</span></span><br><span class="line">        <span class="keyword">if</span> (sock.Accept(clisock, &amp;cliaddr) == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"new connect client:%s:%d\n"</span>, </span><br><span class="line">                inet_ntoa(cliaddr.sin_addr), ntohs(cliaddr.sin_port));</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> buf;</span><br><span class="line">        clisock.Recv(buf);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"client say:%s\n"</span>, buf.c_str());</span><br><span class="line"></span><br><span class="line">        buf.clear();</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"server say:"</span>;</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt;buf;</span><br><span class="line">        clisock.Send(buf);</span><br><span class="line">    &#125;</span><br><span class="line">    sock.Close();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/06/06/Linux网络套接字编程-2/网络.jpg" alt="网络"></p><p>运行截图如上</p><p><strong>TCP的传输运行结果与UDP的传输运行结果不同</strong></p><p>这是因为在UDP的传输无连接，不可靠，面向数据报</p><p>但是TCP的传输不同是建立连接，可靠传输，面向字节流</p><p><strong>所以基本的tcp服务端只能与一个客户端通信一次，无法实现同时与多个客户端多次通信</strong></p><h5 id="如何快速判断连接是否已经断开"><a href="#如何快速判断连接是否已经断开" class="headerlink" title="如何快速判断连接是否已经断开"></a>如何快速判断连接是否已经断开</h5><p>tcp的连接管理中，内建有保活机制。当长时间没有数据来往的时候，每隔一段时间都会向对方发送一个保活探测包，要求对方回复，当多次发送保活探测包都没有响应，则认为连接断开。</p><p>若连接断开，则<strong>recv会返回0</strong>，send会触发异常SIGPIPE(导致进程退出)。recv返回0不是代表没有接收数据的意思，而是说明连接已经断开。</p><p>在TCP连接过程中，因为面向字节流，有可能接收到半条数据，因此一定要对返回值进行判断，判断数据是否已经完全接收或者完全发送。</p><h4 id="多进程版本tcp服务端"><a href="#多进程版本tcp服务端" class="headerlink" title="多进程版本tcp服务端"></a>多进程版本tcp服务端</h4><p>通过使用多进程来完成多个客户端的请求处理</p><p>将之前的通用版本改为多线程版本即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tcpsocket.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigcb</span><span class="params">(<span class="keyword">int</span> no)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG) &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"./tcp_srv ip  port\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    signal(SIGCHLD, sigcb);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">uint16_t</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    TcpSocket sock;</span><br><span class="line">    CHECK_RET(sock.Socket());</span><br><span class="line">    CHECK_RET(sock.Bind(ip, port));</span><br><span class="line">    CHECK_RET(sock.Listen());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        TcpSocket clisock;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">        <span class="comment">//accept是阻塞获取已经完成的连接</span></span><br><span class="line">        <span class="keyword">if</span> (sock.Accept(clisock, &amp;cliaddr) == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"new connect client:%s:%d\n"</span>, </span><br><span class="line">                inet_ntoa(cliaddr.sin_addr), ntohs(cliaddr.sin_port));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">string</span> buf;</span><br><span class="line">                clisock.Recv(buf);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"client say:%s\n"</span>, buf.c_str());</span><br><span class="line"></span><br><span class="line">                buf.clear();</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"server say:"</span>;</span><br><span class="line">                fflush(<span class="built_in">stdout</span>);</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt;buf;</span><br><span class="line">                clisock.Send(buf);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        clisock.Close();</span><br><span class="line">    &#125;</span><br><span class="line">    sock.Close();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/06/06/Linux网络套接字编程-2/网络2.png" alt="网络2"></p><p><strong>先进行多个客户端连接，在左上角的服务端可以看到有三个新的客户端进行了连接成功</strong></p><p><img src="/2019/06/06/Linux网络套接字编程-2/网络3.png" alt="网络3"></p><p><strong>这时候相继发送消息，服务端的回复顺序是根据接收客户端发送数据的顺序进行回复的</strong></p><p>哪怕有其他客户端抢先回答了，服务端还是按照发送数据的顺序依次给客户端进行发送数据</p><h4 id="多线程版本tcp服务端"><a href="#多线程版本tcp服务端" class="headerlink" title="多线程版本tcp服务端"></a>多线程版本tcp服务端</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"tcpsocket.hpp"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thr_start</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">    TcpSocket *sock = (TcpSocket*)arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> buf;</span><br><span class="line">        sock-&gt;Recv(buf);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"client say:%s\n"</span>, buf.c_str());</span><br><span class="line"></span><br><span class="line">        buf.clear();</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"server say:"</span>;</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt;buf;</span><br><span class="line">        sock-&gt;Send(buf);</span><br><span class="line">    &#125;</span><br><span class="line">    sock-&gt;Close();</span><br><span class="line">    <span class="keyword">delete</span> sock;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"./tcp_srv ip  port\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">uint16_t</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    TcpSocket sock;</span><br><span class="line">    CHECK_RET(sock.Socket());</span><br><span class="line">    CHECK_RET(sock.Bind(ip, port));</span><br><span class="line">    CHECK_RET(sock.Listen());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        TcpSocket *clisock = <span class="keyword">new</span> TcpSocket();</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cliaddr</span>;</span></span><br><span class="line">        <span class="comment">//accept是阻塞获取已经完成的连接</span></span><br><span class="line">        <span class="keyword">if</span> (sock.Accept(*clisock, &amp;cliaddr) == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"new connect client:%s:%d\n"</span>, </span><br><span class="line">                inet_ntoa(cliaddr.sin_addr), ntohs(cliaddr.sin_port));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">pthread_t</span> tid;</span><br><span class="line">        pthread_create(&amp;tid, <span class="literal">NULL</span>, thr_start, (<span class="keyword">void</span>*)clisock);</span><br><span class="line">        pthread_detach(tid);</span><br><span class="line">        <span class="comment">//多线程中 ，主线程不能关闭socket，因为线程之间共享文件描述符表</span></span><br><span class="line">        <span class="comment">//如果在主线程中关闭了socket，其它线程中的这个描述符也就关闭了</span></span><br><span class="line">    &#125;</span><br><span class="line">    sock.Close();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程版本的服务端与进程版本的服务端操作大同小异，差距就是进程与线程的创建方式不同，在方式上可能有区别。能了解这两个知识就能掌握。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;TCP传输&quot;&gt;&lt;a href=&quot;#TCP传输&quot; class=&quot;headerlink&quot; title=&quot;TCP传输&quot;&gt;&lt;/a&gt;TCP传输&lt;/h3&gt;&lt;h4 id=&quot;TCP的三次握手&quot;&gt;&lt;a href=&quot;#TCP的三次握手&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://skrskr66.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络编程套接字</title>
    <link href="https://skrskr66.github.io/2019/06/06/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%A5%97%E6%8E%A5%E5%AD%97/"/>
    <id>https://skrskr66.github.io/2019/06/06/Linux网络编程套接字/</id>
    <published>2019-06-06T03:49:33.000Z</published>
    <updated>2019-06-06T07:16:35.616Z</updated>
    
    <content type="html"><![CDATA[<h3 id="网络编程套接字"><a href="#网络编程套接字" class="headerlink" title="网络编程套接字"></a>网络编程套接字</h3><h4 id="udp传输"><a href="#udp传输" class="headerlink" title="udp传输"></a>udp传输</h4><h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h5><p>1、创建套接字 socket()</p><p>2、为套接字绑定地址 bind()</p><p>3、发送数据（如果socket还没有绑定地址，这时候操作系统会选择一个合适的地址端口进行绑定）</p><p>4、接收数据</p><p>5、关闭套接字</p><h5 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h5><p>1、创建套接字，通过创建套接字使进程与网卡建立联系，创建struct socket{…}</p><p>2、为套接字绑定地址信息</p><p>3、接收数据</p><p>4、发送数据</p><p>5、关闭套接字</p><h4 id="创建套接字"><a href="#创建套接字" class="headerlink" title="创建套接字"></a>创建套接字</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line">domin: 地址域</span><br><span class="line"><span class="function">AF_INET             IPv4 Internet protocols          <span class="title">ip</span><span class="params">(<span class="number">7</span>)</span></span></span><br><span class="line"><span class="function">AF_INET6            IPv6 Internet protocols          <span class="title">ipv6</span><span class="params">(<span class="number">7</span>)</span></span></span><br><span class="line">type：套接字类型</span><br><span class="line">SOCK_STREAM流式套接字，默认协议TCP，不支持UDP</span><br><span class="line">SOCK_DGRAM数据报套接字，默认协议UDP，不支持TCP</span><br><span class="line">protocol:协议类型</span><br><span class="line"><span class="number">0</span>：使用默认套接字协议</span><br><span class="line"><span class="number">6</span>/IPPOTO_TCPTCP协议</span><br><span class="line"><span class="number">17</span>/IPPOTO_UDPUDP协议</span><br><span class="line">返回值：套接字操作句柄-文件描述符失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><h4 id="为套接字绑定地址"><a href="#为套接字绑定地址" class="headerlink" title="为套接字绑定地址"></a>为套接字绑定地址</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> socket, <span class="keyword">const</span> struct sockaddr *address,<span class="keyword">socklen_t</span> address_len)</span></span>;</span><br><span class="line">bind（）函数应将本地套接字地址地址分配给由描述符套接字标识的套接字，该套接字没有分配本地套接字地址.使用socket（）函数创建的套接字最初是未命名的;它们仅由其地址族标识。</span><br><span class="line"></span><br><span class="line">socket:套接字文件描述符</span><br><span class="line">sockaddr：地址信息</span><br><span class="line">addrlen：地址信息长度</span><br><span class="line"></span><br><span class="line">返回值：<span class="number">0</span>失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><h5 id="详细了解地址家族"><a href="#详细了解地址家族" class="headerlink" title="详细了解地址家族"></a>详细了解地址家族</h5><p>在bind函数中我们看到了sockaddr这个关键的地址家族。通过man手册只能找到少量的描述。通过查找资料找到了一些，再此做出总结</p><p>一般我们使用<strong>struct sockaddr</strong>和<strong>struct sockaddr_in</strong>这两个结构体用来处理网络通信的地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> sa_family;    <span class="comment">//2 </span></span><br><span class="line">    <span class="keyword">char</span> sa_data[<span class="number">14</span>];     <span class="comment">//14</span></span><br><span class="line">&#125;;  </span><br><span class="line">该结构体的缺陷为sa_data[]把目标地址和端口信息混在一起了</span><br><span class="line">上面是通用的socket地址，具体到Internet socket，用下面的结构，二者可以进行类型转换</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>sin_family;<span class="comment">//地址族</span></span><br><span class="line">    <span class="keyword">uint16_t</span>sin_port;<span class="comment">//16位TCP/UCP端口号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span><span class="title">sin_addr</span>;</span><span class="comment">//32位IP地址</span></span><br><span class="line">    <span class="keyword">char</span>sin_zero[<span class="number">8</span>];<span class="comment">//不使用</span></span><br><span class="line">&#125;</span><br><span class="line">在这个结构体中存在另一个结构体，该结构体一般用来存放<span class="number">32</span>位IP地址</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    In_addr_ts_addr;<span class="comment">//32位IPV4地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sin_port和sin_addr都必须是网络字节序（NBO），一般可视化的数字都是主机字节序（HBO）。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">一般用法</span><br><span class="line"><span class="keyword">int</span> sockfd;  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>   <span class="title">my_addr</span>;</span>  <span class="comment">//赋值时用这个结构</span></span><br><span class="line">sockfd = socket(AF_INET,   SOCK_STREAM,   <span class="number">0</span>);      </span><br><span class="line">my_addr.sin_family   =   AF_INET;     </span><br><span class="line">my_addr.sin_port   =   htons(MYPORT);     </span><br><span class="line">my_addr.sin_addr.s_addr   =   inet_addr(<span class="string">"192.168.0.1"</span>);     </span><br><span class="line">bzero(&amp;(my_addr.sin_zero),   <span class="number">8</span>);         </span><br><span class="line">bind(sockfd,   (struct   sockaddr   *)&amp;my_addr,   <span class="keyword">sizeof</span>(struct   sockaddr));</span><br><span class="line"><span class="comment">//用(struct   sockaddr   *)转换即满足要求</span></span><br></pre></td></tr></table></figure><p>还有网络上另一个其他解释</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr 是一个通用地址结构，这是为了统一地址结构的表示方法，统一接口函数，使不同的地址结构可以被bind() , connect() 等函数调用；struct sockaddr<span class="emphasis">_in中的in 表示internet，就是网络地址，这只是我们比较常用的地址结构，属于AF_</span>INET地址族，他非常的常用，以至于我们都开始讨论它与 struct sockaddr通用地址结构的区别。</span><br></pre></td></tr></table></figure><h4 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> recvfrom(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</span><br><span class="line">                        struct sockaddr *src_addr, <span class="keyword">socklen_t</span> *addrlen);</span><br><span class="line"></span><br><span class="line">sockfd:套接字文件描述符</span><br><span class="line">buf:用buf存储接收的数据</span><br><span class="line">len:想要接收的数据长度</span><br><span class="line">flags：<span class="number">0</span>---默认阻塞接收</span><br><span class="line">src_addr：发送端地址信息</span><br><span class="line">addrlen：地址信息长度，不但要指定想接收多长，还要保存实际接受了多长</span><br><span class="line">返回值：实际接收的长度失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><h4 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> sendto(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</span><br><span class="line">                      <span class="keyword">const</span> struct sockaddr *dest_addr, <span class="keyword">socklen_t</span> addrlen);</span><br><span class="line">sockfd:套接字文件描述符</span><br><span class="line">buf:要发送的数据</span><br><span class="line">len:要发送的数据长度</span><br><span class="line">flags:<span class="number">0</span>---默认阻塞发送</span><br><span class="line">dest_addr:目的段地址信息--标识数据要发送到哪里去</span><br><span class="line">addrlen:地址信息长度</span><br><span class="line">返回值：实际发送的长度失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><h4 id="关闭套接字"><a href="#关闭套接字" class="headerlink" title="关闭套接字"></a>关闭套接字</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line">这个在Linux文件操作符中已经了解到了，文件描述符用完之后需要被关闭</span><br></pre></td></tr></table></figure><h4 id="UDP传输Demo"><a href="#UDP传输Demo" class="headerlink" title="UDP传输Demo"></a>UDP传输Demo</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//UdpSocket.hpp</span></span><br><span class="line"><span class="comment">//实现以UdpSocket类封装udp常用操作 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UdpSocket</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        UdpSocket():_sock(<span class="number">-1</span>)&#123;&#125;</span><br><span class="line">        ~UdpSocket()&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">Socket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            _sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);</span><br><span class="line">            <span class="keyword">if</span> (_sock &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                perror(<span class="string">"socket error"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">Bind</span><span class="params">(<span class="built_in">string</span> &amp;ip, <span class="keyword">uint16_t</span> port)</span> </span>&#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span><span class="comment">//定义一个结构体名称为addr，是socket地址</span></span><br><span class="line">            <span class="comment">//in 表示internet，就是网络地址</span></span><br><span class="line">            <span class="comment">//sin_family指代协议族，在socket编程中只能是AF_INET</span></span><br><span class="line">            <span class="comment">//sin_port存储端口号（使用网络字节顺序）</span></span><br><span class="line">            <span class="comment">//sin_addr存储IP地址，使用in_addr这个数据结构</span></span><br><span class="line">            </span><br><span class="line">            addr.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">            <span class="comment">//uint16_t htons(uint16_t hostshort);</span></span><br><span class="line">            </span><br><span class="line">            addr.sin_port = htons(port);<span class="comment">//htons是将整型变量从主机字节顺序转变成网络字节顺序， </span></span><br><span class="line">                                <span class="comment">//就是整数在地址空间存储方式变为高位字节存放在内存的低地址处。</span></span><br><span class="line">            <span class="comment">//in_addr_t inet_addr(const char *cp);</span></span><br><span class="line">            </span><br><span class="line">            addr.sin_addr.s_addr = inet_addr(ip.c_str());<span class="comment">//inet_addr是一个计算机函数，</span></span><br><span class="line">            <span class="comment">//addr.sin_addr.s_addr = INADDR_ANY;</span></span><br><span class="line">            <span class="comment">//      功能是将一个点分十进制的IP转换成一个长整数型数（u_long类型）等同于inet_addr()。</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">            <span class="comment">//int bind(int sockfd, struct sockaddr *addr, </span></span><br><span class="line">            <span class="comment">//  socklen_t addrlen);</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> ret = bind(_sock, (struct sockaddr*)&amp;addr, len);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                perror(<span class="string">"bind error"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">Recv</span><span class="params">(<span class="built_in">string</span> &amp;buf, struct sockaddr_in *saddr)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//ssize_t recvfrom(int sockfd, void *buf, size_t len, </span></span><br><span class="line">            <span class="comment">//int flags, struct sockaddr *src_addr, socklen_t *addrlen);</span></span><br><span class="line">            <span class="keyword">char</span> tmp[<span class="number">1500</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">            <span class="keyword">int</span> ret = recvfrom(_sock, tmp, <span class="number">1500</span>, <span class="number">0</span>, </span><br><span class="line">                    (struct sockaddr*)saddr, &amp;len);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                perror(<span class="string">"recvfrom error"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            buf.assign(tmp, ret);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">Send</span><span class="params">(<span class="built_in">string</span> &amp;buf, struct sockaddr_in *daddr)</span></span>&#123;</span><br><span class="line">            <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(struct  sockaddr_in);</span><br><span class="line">            <span class="keyword">int</span> ret = sendto(_sock, buf.c_str(), buf.size(), <span class="number">0</span>, </span><br><span class="line">                    (struct sockaddr*)daddr, len);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                perror(<span class="string">"sendto error"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">Close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            close(_sock);</span><br><span class="line">            _sock = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> _sock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这之外，上面的头文件中还有几个其他接口函数，需要了解</p><p><strong>htons()作用是将端口号由主机字节序转换为网络字节序的整数值。(host to net)</strong> </p><p><strong>inet_addr()作用是将一个IP字符串转化为一个网络字节序的整数值，用于sockaddr_in.sin_addr.s_addr。</strong> </p><p>数字的字节序转换：</p><p>​    主机字节序转换为网络字节序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span>htonl(<span class="keyword">uint32_t</span>hostlong)</span><br><span class="line"><span class="keyword">uint16_t</span>htons(<span class="keyword">uint16_t</span>hostshort)</span><br></pre></td></tr></table></figure><p>​    网络字节序转换为主机字节序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span>ntohl(<span class="keyword">uint32_t</span>hostlong)</span><br><span class="line"><span class="keyword">uint16_t</span>ntohs(<span class="keyword">uint16_t</span>hostshort)</span><br></pre></td></tr></table></figure><p>将点分十进制ip地址转换为网络字节序ip地址：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">in_addr <span class="title">inet_addr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> af,<span class="keyword">const</span> <span class="keyword">char</span> *src,<span class="keyword">void</span> *dst)</span></span></span><br></pre></td></tr></table></figure><p>将网络字节序IP地址转换为点分十进制IP地址：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> af,<span class="keyword">const</span> <span class="keyword">void</span>* src,<span class="keyword">char</span> *dst,<span class="keyword">socklen_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">inet_ntoa</span><span class="params">(struct in_addr in)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="udp服务端"><a href="#udp服务端" class="headerlink" title="udp服务端"></a>udp服务端</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"udpsocket.hpp"</span>    </span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHECK_RET(q) <span class="meta-keyword">if</span>((q) == false)&#123;return -1;&#125;    </span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">  <span class="keyword">if</span>(argc != <span class="number">3</span>)    </span><br><span class="line">  &#123;    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"./udp_server ip port:"</span>&lt;&lt;<span class="built_in">endl</span>;                                                                                </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="built_in">string</span> ip = argv[<span class="number">1</span>];    </span><br><span class="line">  <span class="keyword">uint16_t</span> port = atoi(argv[<span class="number">2</span>]);    </span><br><span class="line">    </span><br><span class="line">  UdpSocket sock;    </span><br><span class="line">  CHECK_RET(sock.Socket());    </span><br><span class="line">  CHECK_RET(sock.Bind(ip,port));    </span><br><span class="line">    </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)    </span><br><span class="line">  &#123;    </span><br><span class="line">    <span class="built_in">string</span> buf;    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cli_addr</span>;</span>    </span><br><span class="line">    CHECK_RET(sock.Recv(buf,&amp;cli_addr));    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"client say:"</span>&lt;&lt;buf&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"server say:"</span>;    </span><br><span class="line">    fflush(<span class="built_in">stdout</span>);    </span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;buf;                               </span><br><span class="line">    CHECK_RET(sock.Send(buf,&amp;cli_addr));</span><br><span class="line">  &#125; </span><br><span class="line">  sock.Close();             </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="udp客户端"><a href="#udp客户端" class="headerlink" title="udp客户端"></a>udp客户端</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"udpsocket.hpp"</span>    </span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHECK_RET(q) <span class="meta-keyword">if</span>((q) == false)&#123;return -1;&#125;    </span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">  <span class="keyword">if</span>(argc != <span class="number">3</span>)    </span><br><span class="line">  &#123;    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"./udp_client ip port"</span>&lt;&lt;<span class="built_in">endl</span>;                                                                                 </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="built_in">string</span> ip = argv[<span class="number">1</span>];    </span><br><span class="line">  <span class="keyword">uint16_t</span> port = atoi(argv[<span class="number">2</span>]);    </span><br><span class="line">    </span><br><span class="line">  UdpSocket sock;    </span><br><span class="line">  CHECK_RET(sock.Socket());    </span><br><span class="line">    </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">srv_addr</span>;</span>    </span><br><span class="line">  srv_addr.sin_family = AF_INET;    </span><br><span class="line">  srv_addr.sin_port = htons(port);    </span><br><span class="line">  srv_addr.sin_addr.s_addr = inet_addr(ip.c_str());    </span><br><span class="line">    </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)    </span><br><span class="line">  &#123;    </span><br><span class="line">    <span class="built_in">string</span> buf;    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"client say:"</span>;    </span><br><span class="line">    fflush(<span class="built_in">stdout</span>);    </span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;buf;                         </span><br><span class="line">    CHECK_RET(sock.Send(buf,&amp;srv_addr));               </span><br><span class="line">    CHECK_RET(sock.Recv(buf,&amp;srv_addr));</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"server say"</span>&lt;&lt;buf&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">  &#125;                </span><br><span class="line">  sock.Close();             </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/06/06/Linux网络编程套接字/网络1.png" alt="网络1"></p><p>两边聊天如上图</p><p>udp的传输速度快，无连接，不可靠，面向数据报这个必须牢牢记住了。</p><p>但是在代码中有个bug存在，发送的数据如果有空格，那么数据就会产生截断，分成两次发送</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;网络编程套接字&quot;&gt;&lt;a href=&quot;#网络编程套接字&quot; class=&quot;headerlink&quot; title=&quot;网络编程套接字&quot;&gt;&lt;/a&gt;网络编程套接字&lt;/h3&gt;&lt;h4 id=&quot;udp传输&quot;&gt;&lt;a href=&quot;#udp传输&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://skrskr66.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>C++-模板初了解</title>
    <link href="https://skrskr66.github.io/2019/06/04/C-%E6%A8%A1%E6%9D%BF%E5%88%9D%E4%BA%86%E8%A7%A3/"/>
    <id>https://skrskr66.github.io/2019/06/04/C-模板初了解/</id>
    <published>2019-06-04T04:57:43.000Z</published>
    <updated>2019-06-04T06:42:02.760Z</updated>
    
    <content type="html"><![CDATA[<h3 id="模板初阶"><a href="#模板初阶" class="headerlink" title="模板初阶"></a>模板初阶</h3><h4 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h4><p>在C语言的学习过程中，经常会出现这么一个场景，我们需要交换两个数，但是我们每次又在另一个场景中，所以需要立即重写一个swap()函数，这就浪费了大量的时间。</p><p>在C++的最开始我们学习了函数的重载，这解决了一些燃眉之急，但是当我们的类型多了，我们还是要不停的修改或者添加这么一类函数，时间还是被浪费了许多。这时候，新的知识就出来帮我们解决问题来了—<strong>-泛型编程</strong></p><p><strong>泛型编程：编写与类型无关的通用代码，是代码复用的一种手段。模板是泛型编程的基础</strong></p><p>模板又分为函数模板和类模板两种。</p><h4 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h4><h5 id="函数模板概念"><a href="#函数模板概念" class="headerlink" title="函数模板概念"></a>函数模板概念</h5><p>函数模板代表了一个函数家族，该模板函数与类型无关，在使用时被参数化，根据参数类型产生函数的特定类型版本。</p><h5 id="函数模板的格式"><a href="#函数模板的格式" class="headerlink" title="函数模板的格式"></a>函数模板的格式</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2,....,<span class="keyword">typename</span> Tn&gt;</span><br><span class="line">返回值类型 函数名(参数列表)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T&amp; a,T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>typename是用来定义模板参数关键字，也可以使用class，但是不能用struct代替class</strong></p><h5 id="函数模板的原理"><a href="#函数模板的原理" class="headerlink" title="函数模板的原理"></a>函数模板的原理</h5><p>模板是一个蓝图，它<strong>本身并不是一个函数，是编译器用使用方式产生特定具体类型函数的模具。所以其实模板就是将本来我们应该重复做的事交给了编译器</strong></p><p>在编译器阶段，对于函数模板的使用，编译器需要根据传入的实参类型来推演生成对应类型的函数以供调用。</p><p>比如swap函数的参数类型是double时，编译器根据传入的double将模板中的T变为double，然后产生一份专门处理double类型的代码，对于其他类型也是如此</p><h5 id="函数模板的实例化"><a href="#函数模板的实例化" class="headerlink" title="函数模板的实例化"></a>函数模板的实例化</h5><p>用不同类型的参数使用函数模板时，称为函数模板的实例化。模板参数实例化分为：<strong>隐式实例化和显式实例化</strong></p><p><strong>隐式实例化</strong></p><p>让编译器根据实参推演模板参数的实际类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">Add</span>(<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">left</span>,<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">right</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a1=<span class="number">10</span>,a2=<span class="number">20</span>;</span><br><span class="line">    Add(a1,a2);</span><br><span class="line">    <span class="keyword">double</span> d1=<span class="number">10.0</span>,d2=<span class="number">20.0</span>;</span><br><span class="line">    Add(d1,d2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Add(a1,d1);</span></span><br><span class="line">    <span class="comment">//这样书写编译会报错，因为编译器不知道此时将T转换为什么类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>显示实例化</strong></p><p>在函数名后&lt;&gt;中指定模板参数的实际类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">double</span> b=<span class="number">20</span>;</span><br><span class="line">    Add&lt;<span class="keyword">int</span>&gt;(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果类型不匹配，编译器会尝试进行隐式实例化，如果无法转换成功编译器将会报错</p><h5 id="模板参数的匹配原则"><a href="#模板参数的匹配原则" class="headerlink" title="模板参数的匹配原则"></a>模板参数的匹配原则</h5><p>1、<strong>一个非模板可以和一个同名的函数模板同时存在，而且该函数模板还可以被实例化为这个非模板函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left+right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">Add</span>(<span class="title">T</span> <span class="title">left</span>,<span class="title">T</span> <span class="title">right</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Add(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    Add&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、<strong>对于非模板函数和同名函数模板，如果条件都相同，在调动时会优先调动非模板函数而不会从该模板产生出一个实例。如果模板可以产出一个具有更好匹配的函数，那么将选择模板</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left+right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">Add</span>(<span class="title">T1</span> <span class="title">left</span>,<span class="title">T2</span> <span class="title">right</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Add(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    Add&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、<strong>模板函数不允许自动类型转换，但普通函数可以进行自动类型转换</strong></p><h4 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h4><h5 id="类模板的定义结构"><a href="#类模板的定义结构" class="headerlink" title="类模板的定义结构"></a>类模板的定义结构</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>,...,<span class="title">class</span> <span class="title">Tn</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> 类模板名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//类内定义成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>模拟实现一个类模板Demo</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Vector</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Vector(<span class="keyword">size_t</span> capacity = <span class="number">10</span>)</span><br><span class="line">    :_pData(<span class="keyword">new</span> T[capacity])</span><br><span class="line">    ,_size(<span class="number">0</span>)</span><br><span class="line">    ,_capacity(capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PushBack</span><span class="params">(<span class="keyword">const</span> T&amp; data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _pData[_size++] = data;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PopBack</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        --_size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">size_t</span> Size()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> pos)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &lt; _size);</span><br><span class="line">        <span class="keyword">return</span> _pData[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    ~Vector()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(_pData)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] _pData;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* _pDate;</span><br><span class="line">    <span class="keyword">size_t</span> _size;</span><br><span class="line">    <span class="keyword">size_t</span> _capacity;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="类模板的实例化"><a href="#类模板的实例化" class="headerlink" title="类模板的实例化"></a>类模板的实例化</h5><p><strong>类模板实例化与函数模板实例化不同，类模板实例化需要在类模板名字后跟&lt;&gt;，然后将实例化的类型放在&lt;&gt;中即可，类模板名字不是真正的名字，而实例化的结果才是真正的类。</strong></p><p>来试试上面写的类模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vector&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">s1.PushBack(<span class="number">1</span>);</span><br><span class="line">s1.PushBack(<span class="number">2</span>);</span><br><span class="line">s1.PushBack(<span class="number">3</span>);</span><br><span class="line">Vector&lt;<span class="keyword">double</span>&gt; s2;</span><br><span class="line">s2.PushBack(<span class="number">1.0</span>);</span><br><span class="line">s2.PushBack(<span class="number">2.0</span>);</span><br><span class="line">s2.PushBack(<span class="number">3.0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; s1.Size(); ++i)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;s1[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; s2.Size(); ++i)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;s2[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/06/04/C-模板初了解/模板1.png" alt="模板1"></p><p><strong>模板理解起来非常简单，主要是怎么样去限定好在何时让编译器推演参数类型的转化。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;模板初阶&quot;&gt;&lt;a href=&quot;#模板初阶&quot; class=&quot;headerlink&quot; title=&quot;模板初阶&quot;&gt;&lt;/a&gt;模板初阶&lt;/h3&gt;&lt;h4 id=&quot;泛型编程&quot;&gt;&lt;a href=&quot;#泛型编程&quot; class=&quot;headerlink&quot; title=&quot;泛型编程&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="C++" scheme="https://skrskr66.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++-类与对象(3)</title>
    <link href="https://skrskr66.github.io/2019/05/31/C-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1-3/"/>
    <id>https://skrskr66.github.io/2019/05/31/C-类与对象-3/</id>
    <published>2019-05-31T09:30:49.000Z</published>
    <updated>2019-06-02T14:30:23.712Z</updated>
    
    <content type="html"><![CDATA[<h3 id="类与对象-3"><a href="#类与对象-3" class="headerlink" title="类与对象(3)"></a>类与对象(3)</h3><h4 id="再学构造函数"><a href="#再学构造函数" class="headerlink" title="再学构造函数"></a>再学构造函数</h4><h5 id="构造函数体赋值"><a href="#构造函数体赋值" class="headerlink" title="构造函数体赋值"></a>构造函数体赋值</h5><p>先构造一个带有全缺省的日期类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Date(<span class="keyword">int</span> year,<span class="keyword">int</span> month,<span class="keyword">int</span> day)</span><br><span class="line">    &#123;</span><br><span class="line">        _year = year;</span><br><span class="line">        _month = month;</span><br><span class="line">        _day = day;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _year;</span><br><span class="line">    <span class="keyword">int</span> _month;</span><br><span class="line">    <span class="keyword">int</span> _day;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述构造函数调用之后，对象中已经有了一个初始值，但是不能将其称作为类对象成员的初始化，构造<strong>函数体中的语句只能将其称作为赋初值，而不能称作初始化。因为初始化只能初始化一次，而构造函数体内可以多次赋值。</strong> </p><h5 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Date(<span class="keyword">int</span> year,<span class="keyword">int</span> month,<span class="keyword">int</span> day)</span><br><span class="line">        :_year(year)</span><br><span class="line">        ,_month(month)</span><br><span class="line">        ,_day(day)</span><br><span class="line">    &#123;</span><br><span class="line">        _year = year;</span><br><span class="line">        _month = month;</span><br><span class="line">        _day = day;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _year;</span><br><span class="line">    <span class="keyword">int</span> _month;</span><br><span class="line">    <span class="keyword">int</span> _day;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>初始化列表以<code>:</code>开始，接着用一个<code>,</code>分隔的数据成员列表，每个“成员变量”后面跟一个放在括号内的初始值或者表达式</strong></p><p><strong>注意事项：</strong></p><p>1、每个成员变量在初始化列表中只出现一次(初始化只能初始化一次)</p><p>2、类中的成员：“引用成员变量”，“const成员变量”，“类类型成员(该类没有默认构造函数)”</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">skr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    skr(<span class="keyword">int</span> a)</span><br><span class="line">    :_a(a)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cxk</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  cxk(<span class="keyword">int</span> a,<span class="keyword">int</span> ref)</span><br><span class="line">    :_aobj(a)</span><br><span class="line">    ,_ref(ref)</span><br><span class="line">    ,_n(<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    skr _aobj;</span><br><span class="line">    <span class="keyword">int</span>&amp; _ref;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> _n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、尽可能使用初始化列表初始化，因为不管你是否使用初始化列表，对于自定义类型成员变量，一定会先使用初始化列表初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> Time(<span class="keyword">int</span> hour = <span class="number">0</span>)</span><br><span class="line"> :_hour(<span class="number">222</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">"Time()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">int</span> _hour;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> Date(<span class="keyword">int</span> day)</span><br><span class="line"> &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">int</span> _day;</span><br><span class="line"> Time <span class="keyword">_t</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="function">Date <span class="title">d</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如图</p><p><img src="/2019/05/31/C-类与对象-3/类1.png" alt="类1"></p><p>4、成员变量<strong>初始化列表的顺序</strong>按照在<strong>类中声明成员变量的顺序</strong>，与<strong>初始化列表的顺序无关</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> Array(<span class="keyword">int</span> size)</span><br><span class="line"> :_size(<span class="number">10</span>)</span><br><span class="line"> , _array((<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*_size))</span><br><span class="line"> &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">int</span>* _array;</span><br><span class="line"> <span class="keyword">int</span> _size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="explicit关键字"><a href="#explicit关键字" class="headerlink" title="explicit关键字"></a>explicit关键字</h5><p><strong>用explicit修饰构造函数，将会禁止单个参数的构造函数的隐式转换</strong></p><h4 id="static成员"><a href="#static成员" class="headerlink" title="static成员"></a>static成员</h4><p>声明为<strong>static的类成员</strong>称为<strong>类的静态成员</strong>，用<strong>static</strong>修饰的<strong>成员变量</strong>，称之为静态成员变量；</p><p><strong>用static修饰的成员函数，称之为静态成员函数。静态的成员变量一定要在类外进行初始化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  A() &#123;++_scount;&#125;</span><br><span class="line">  A(<span class="keyword">const</span> A&amp; t) &#123;++_scount;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetACount</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> _scount;&#125;</span><br><span class="line"><span class="keyword">private</span>:                                  </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> _scount;                     </span><br><span class="line">&#125;;                   </span><br><span class="line">                       </span><br><span class="line"><span class="keyword">int</span> A::_scount = <span class="number">0</span>;</span><br><span class="line">                     </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestA</span><span class="params">()</span>       </span></span><br><span class="line"><span class="function"></span>&#123;           </span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;A::GetACount()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  A a1,a2;                   </span><br><span class="line">  <span class="function">A <span class="title">a3</span><span class="params">(a1)</span></span>;                  </span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;A::GetACount()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;                               </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;         </span><br><span class="line">  TestA();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意！！</strong></p><p><strong>注意！！</strong></p><p><strong>注意！！</strong></p><p><strong>静态的成员变量一定要在类外进行初始化</strong></p><h5 id="static特性"><a href="#static特性" class="headerlink" title="static特性"></a>static特性</h5><p>1、<strong>静态成员为所有类对象所共享</strong>，不属于某个具体的实例</p><p>2、静态成员变量必须在类外定义，定义时不添加static关键字</p><p>3、类静态成员即可用<code>类名::静态成员</code>或者<code>对象.静态成员</code>来访问</p><p>4、<strong>静态成员函数没有隐藏的this指针</strong>，不能访问任何非静态成员</p><p>5、静态成员和类的普通成员一样，也有public、protected、private，3种访问级别，也可以具有返回值，const修饰符等参数。</p><h5 id="C-11的成员初始化"><a href="#C-11的成员初始化" class="headerlink" title="C++11的成员初始化"></a>C++11的成员初始化</h5><p>C++11支持非静态成员变量在声明时，直接初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; b._b&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="comment">// 非静态成员变量，可以在成员声明时，直接初始化。</span></span><br><span class="line"> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"> B b = <span class="number">20</span>;</span><br><span class="line"> <span class="keyword">int</span>* p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">4</span>);</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">int</span> n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h4><h5 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h5><p>在重载运算符中，我们没办法将operator&lt;&lt;重载成员成员函数。因为<strong>cout的输出流对象和隐含的this指针在抢占第一个参数位置</strong>。this指针默认是第一个参数也就是左操作数了。但是实际中使用cout需要是第一个形参对象，才能正常使用。所以我们要将operator&lt;&lt;重载成全局函数。但是这样的话，<strong>又会导致类外没有办法访问成员</strong>，那么这里就需要友元来解决了。operator同理。</p><p>友元函数可以直接访问类的私有成员，它是定义在类外部的普通函数，不属于任何类，但需要在类的内部声明，声明时需要加friend关键字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;    </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>    </span></span><br><span class="line"><span class="class">&#123;</span>    </span><br><span class="line">  <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; _cout, <span class="keyword">const</span> Date&amp; d);    </span><br><span class="line">  <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; _cin, Date&amp; d);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Date(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span><br><span class="line">    :_year(year)  </span><br><span class="line">    ,_month(month)   </span><br><span class="line">    ,_day(day) </span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:    </span><br><span class="line">  <span class="keyword">int</span> _year;    </span><br><span class="line">  <span class="keyword">int</span> _month;    </span><br><span class="line">  <span class="keyword">int</span> _day;    </span><br><span class="line">&#125;; </span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; _cout,<span class="keyword">const</span> Date&amp; d)    </span><br><span class="line">&#123;    </span><br><span class="line">  _cout&lt;&lt;d._year&lt;&lt;<span class="string">"-"</span>&lt;&lt;d._month&lt;&lt;<span class="string">"-"</span>&lt;&lt;d._day;    </span><br><span class="line">  <span class="keyword">return</span> _cout;    </span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">//这里不能加const，如果加了const就不能对对象d的成员变量进行修改了    </span></span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; _cin,Date&amp; d)    </span><br><span class="line">&#123;    </span><br><span class="line">  _cin&gt;&gt;d._year;    </span><br><span class="line">  _cin&gt;&gt;d._month;</span><br><span class="line">  _cin&gt;&gt;d._day;</span><br><span class="line">  <span class="keyword">return</span> _cin;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">Date <span class="title">d</span><span class="params">(<span class="number">2017</span>,<span class="number">12</span>,<span class="number">24</span>)</span></span>;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;d;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;d&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>友元函数说明：</strong></p><p>1、友元函数可访问类的私有成员，但不是类的成员函数</p><p>2、友元函数<strong>不能用const修饰</strong></p><p>3、<strong>友元函数可以在类定义的任何地方声明，不受类访问限定符限制</strong></p><p>4、一个函数可以是多个类的友元函数</p><p>5、友元函数的调用与普通函数的调用和原理相同</p><h5 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h5><p><strong>友元类的所有成员函数都可以是另一个类的友元函数，都可以访问另一个类中的非公有成员。</strong></p><ul><li><p>友元关系是单向的，不具有交换性</p><p>有A类和B类，在A中声明B类为其友元类，那么可以在B类中直接访问A类的私有成员变量，但想在A类中访问B类中私有的成员变量则不行</p></li><li><p>友元关系不能传递</p><p>如果B是A的友元，C是B的友元，则不能说明C是A的友元</p></li></ul><h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><p>如果一个类定义在另一个类的内部，这个内部类就叫做内部类。注意此时这个内部类是一个独立的类，它不属于外部类，更不能通过外部类的对象去调用内部类。外部类对内部类没有任何优越的访问权限。</p><p>内部类是外部类的友元类。</p><h5 id="内部类特性"><a href="#内部类特性" class="headerlink" title="内部类特性"></a>内部类特性</h5><p>1、内部类可以定义在外部类的public、protected、private都是可以的。 </p><p>2、注意内部类可以直接访问外部类中的static、枚举成员，不需要外部类的对象/类名。 </p><p>3、sizeof(外部类)=外部类，和内部类没有任何关系。 </p><h4 id="牛客的一道小练习"><a href="#牛客的一道小练习" class="headerlink" title="牛客的一道小练习"></a>牛客的一道小练习</h4><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 </p><p><a href="https://www.nowcoder.com/practice/7a0da8fc483247ff8800059e12d7caf1?tpId" target="_blank" rel="noopener">https://www.nowcoder.com/practice/7a0da8fc483247ff8800059e12d7caf1?tpId</a> </p><p>基本上我们能想到的方法都被限制了，那么这时候就可以考虑构造函数每次调用时都会+1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Sum</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="keyword">public</span> :Sum()</span><br><span class="line">            &#123;</span><br><span class="line">                _sum += _i;</span><br><span class="line">                _i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        _i = <span class="number">1</span>;</span><br><span class="line">        _sum = <span class="number">0</span>;</span><br><span class="line">        Sum <span class="built_in">array</span>[n];</span><br><span class="line">        <span class="keyword">return</span> _sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> _sum;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> _i;</span><br><span class="line">&#125;;</span><br><span class="line">    <span class="keyword">size_t</span> Solution::_sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> Solution::_i = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;类与对象-3&quot;&gt;&lt;a href=&quot;#类与对象-3&quot; class=&quot;headerlink&quot; title=&quot;类与对象(3)&quot;&gt;&lt;/a&gt;类与对象(3)&lt;/h3&gt;&lt;h4 id=&quot;再学构造函数&quot;&gt;&lt;a href=&quot;#再学构造函数&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="C++" scheme="https://skrskr66.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络编程</title>
    <link href="https://skrskr66.github.io/2019/05/31/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>https://skrskr66.github.io/2019/05/31/Linux网络编程/</id>
    <published>2019-05-31T09:30:21.000Z</published>
    <updated>2019-06-04T10:05:50.595Z</updated>
    
    <content type="html"><![CDATA[<h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><h4 id="了解网络名词"><a href="#了解网络名词" class="headerlink" title="了解网络名词"></a>了解网络名词</h4><p>IP地址：在网络中唯一标识的一台主机</p><p>port端口：在一台主机上标识一个进程</p><p>协议：通信双方的约定</p><p>网络协议：网络通信环境中数据的约定格式</p><p>通信协议标准：网络互联的前提</p><h4 id="协议分层"><a href="#协议分层" class="headerlink" title="协议分层"></a>协议分层</h4><p>在以往的了解知道协议具有多层，而分层就是为了协议分装，为了更好的使用。</p><p>对服务，接口，协议进行明确的划分；形成标准实现起来就容易了</p><h5 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h5><p>物理层，数据链路层，网络层，传输层，会话层，表示层，应用层</p><p>这是基础网络中的七层模型，这是一种理想的模型状态，在现代，大佬们将其划分为TCP/IP五层模型。将会话层，表示层，应用层全都规划到应用层。</p><p><img src="/2019/05/31/Linux网络编程/网络1.png" alt="网络1"></p><h5 id="TCP-IP五层模型"><a href="#TCP-IP五层模型" class="headerlink" title="TCP/IP五层模型"></a>TCP/IP五层模型</h5><p><strong>物理层，链路层，网络层，传输层，应用层</strong></p><ul><li>物理层：负责光电信号的传输；比如以太网协议</li><li>链路层：负责相邻设备之间的数据帧传输；比如Ethernet以太网协议；</li><li>网络层：负责地址管理和路由选择；IP协议，典型设备(路由器：负责路由选择，选择数据发送到哪里去)</li><li>传输层：负责端与端之间的数据传输；TCP协议，UDP协议</li><li>应用层：负责应用程序之间的数据沟通(一般交由程序员来写)；HTTP协议,FTP,SMTP,DNS,HTML</li></ul><p><img src="/2019/05/31/Linux网络编程/网络2.png" alt="网络2"></p><p>图中是我自己的理解，只能算一个初步的了解，不能算标准。</p><p><strong>不同的协议层对数据包有不同的称谓,在传输层叫做段(segment),在网络层叫做数据报 (datagram),在链路层叫做帧(frame).</strong> </p><p><strong>应用层数据通过协议栈发到网络上时,每层协议都要加上一个数据首部(header),称为封装 (Encapsulation).</strong> </p><p>数据封装的过程如下图：</p><p><img src="/2019/05/31/Linux网络编程/网络3.png" alt="网络3"></p><h4 id="网络编程套接字"><a href="#网络编程套接字" class="headerlink" title="网络编程套接字"></a>网络编程套接字</h4><h5 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h5><p>IP是在网络上唯一标识一个主机</p><p><strong>IPV4(uint32_t)</strong>：对于IPV4来说，IP地址是一个4字节，32位的整数</p><p>通常使用“点分十进制”的字符串标识IP地址，例如：192.168.0.1；用点分割的每一个数字表示一个字节，范围是0-255。</p><p><strong>IPV6(uchar ip[16])</strong>：IPV6目前还没有完全的被使用，可以先了解一下。它的地址长度128位，是IPV4地址长度的4倍。于是IPV4点分十进制不再适用，采用十六进制表示。</p><p><strong>DHCP(Dynamic Host Configuration Protocol)</strong>：动态主机配置协议是一个局域网的网络协议。DHCP服务可以自动给局域网中的主机自动分配一个IP地址。 </p><p><strong>NAT技术</strong>：因为ipv4的IP不够用，而发明的技术，<strong>实现地址转换，多人使用同一地址上网</strong>。但要区分公网IP和私网IP。</p><p>推荐一篇博客，什么是公网什么是私网：<a href="https://blog.csdn.net/gui951753/article/details/79210535" target="_blank" rel="noopener">https://blog.csdn.net/gui951753/article/details/79210535</a> </p><h5 id="port端口"><a href="#port端口" class="headerlink" title="port端口"></a>port端口</h5><p>端口的类型是(uint16，0~65535；0~1024不推荐使用，一般多为系统占用端口)</p><p>端口是再网络上唯一标识一个进程</p><p>网络程序分为了客户端和服务端，主动发起的一方是客户端，被动再指定位置接收的一方是服务端，而且服务端被动的接收地址必须是固定不变的。</p><p><strong>一个端口只能被一个进程占用；一个进程可以使用多个端口</strong></p><p>在发送数据的过程中，每条数据都一定包含了五元组：源IP，源端口，目的IP，目的端口，协议</p><h5 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h5><p>字节序：cpu在内存中对数据存取的顺序</p><p>在以往的学习中，我们了解过大端与小端这两种字节序。</p><p>简单回忆一下。小端是低地址放低位，高地址放高位；大端是低地址放高位，高地址放低位</p><p>在网络中，存在<strong>主机字节序</strong>，它是当前计算机的字节序，大小端这取决于cpu架构</p><p><strong>因此为了传输数据的我们要保证两端主机字节序相同，如果不同，那么就会造成数据二义性。所以保证一个程序的可移植性，通信双方必须使用网络字节序进行通信。在网络通信中，数据的字节序转换主要是针对数据存储大于一个字节类型的数据</strong></p><p>网络字节序，一般使用大端字节序。通过联合体判断。</p><h5 id="传输层协议-简单了解"><a href="#传输层协议-简单了解" class="headerlink" title="传输层协议(简单了解)"></a>传输层协议(简单了解)</h5><p><strong>TCP：</strong>传输控制协议，面向连接，可靠传输，面向字节流</p><p><strong>面向连接</strong>：通信之前先建立连接，确保双方在线。</p><p><strong>可靠传输</strong>：在网络正常的情况下，数据不会丢失</p><p><strong>面向字节流服务</strong>：传输灵活，但是存在tcp粘包问题，没有明显的数据约定</p><p>使用场景多为：传输文件，保证数据安全，对数据安全的要求较高</p><p><strong>UDP：</strong>用户数据协议，无连接，不可靠，面向数据报</p><p><strong>面向数据报</strong>：每条数据有长度标识，数据有明显的间隔，带有报头的整条发/收。传输不灵活。<strong>注意！！！！不存在粘包问题</strong></p><p>使用场景多为：多数据实时要求非常高的，比如看视频。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;网络编程&quot;&gt;&lt;a href=&quot;#网络编程&quot; class=&quot;headerlink&quot; title=&quot;网络编程&quot;&gt;&lt;/a&gt;网络编程&lt;/h3&gt;&lt;h4 id=&quot;了解网络名词&quot;&gt;&lt;a href=&quot;#了解网络名词&quot; class=&quot;headerlink&quot; title=&quot;了解网络名
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://skrskr66.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux多线程(3)</title>
    <link href="https://skrskr66.github.io/2019/05/17/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B-3/"/>
    <id>https://skrskr66.github.io/2019/05/17/Linux多线程-3/</id>
    <published>2019-05-17T10:28:07.000Z</published>
    <updated>2019-05-31T07:22:02.420Z</updated>
    
    <content type="html"><![CDATA[<p>线程安全的考虑关乎互斥锁和条件变量</p><h3 id="消费者与生产者模型"><a href="#消费者与生产者模型" class="headerlink" title="消费者与生产者模型"></a>消费者与生产者模型</h3><p>当我们去超市买东西时，我们都认为我们是<strong>消费者</strong>，那些生产商品的都被认为是<strong>生产者</strong>。那么超市就被当作交易市场。</p><p>这对比的我们的软件开发过程中：代码的某个模块负责生产数据，但是生产出来的数据不得不交给另一模块来对其进行处理，在这之间我们必须要有一个类似上述超市的东西来存储数据，这就抽象成了<strong>生产者与消费者模型</strong></p><p>其中，<strong>产生数据的模块</strong>，就形象地称为<strong>生产者</strong>。<strong>处理数据的模块</strong>，就形象的称为<strong>消费者</strong>。生产者和消费者之间的中介就叫做<strong>缓冲区</strong></p><h4 id="消费者与生产者模型的理解"><a href="#消费者与生产者模型的理解" class="headerlink" title="消费者与生产者模型的理解"></a>消费者与生产者模型的理解</h4><p>生产者消费者模式就是通过一个容器来解决生产者和消费者的<strong>强耦合问题</strong></p><p><strong>生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列中取，阻塞队列就相当于一个缓冲区，平衡了它们二者之间的处理能力。</strong></p><p><strong>在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这种生产消费能力不均衡的问题，所以便有了生产者和消费者模式。</strong> </p><p>参考博客：<a href="https://blog.csdn.net/xiaochendefendoushi/article/details/81160260" target="_blank" rel="noopener">https://blog.csdn.net/xiaochendefendoushi/article/details/81160260</a> </p><h4 id="模型实现"><a href="#模型实现" class="headerlink" title="模型实现"></a>模型实现</h4><h5 id="消费者与生产者的关系"><a href="#消费者与生产者的关系" class="headerlink" title="消费者与生产者的关系"></a>消费者与生产者的关系</h5><p>生产者与生产者之间应该具有<strong>互斥关系</strong></p><p>消费者与消费者之间应该具有<strong>互斥关系</strong></p><p>生产者与消费者之间应该有<strong>同步+互斥的关系</strong></p><p>可以总的来说：<strong>一个场所，两个角色，三种关系</strong></p><h5 id="消费者与生产者模型的优点"><a href="#消费者与生产者模型的优点" class="headerlink" title="消费者与生产者模型的优点"></a>消费者与生产者模型的优点</h5><p><strong>解耦和，支持忙闲不均，支持并发</strong></p><h5 id="消费者与生产者模型的代码Demo"><a href="#消费者与生产者模型的代码Demo" class="headerlink" title="消费者与生产者模型的代码Demo"></a>消费者与生产者模型的代码Demo</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">BlockQueue(<span class="keyword">int</span> cap = <span class="number">10</span>):_capacity(cap)&#123;</span><br><span class="line">    pthread_mutex_init(&amp;_mutex, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;_cond_productor, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;_cond_consumer, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">~BlockQueue()&#123;</span><br><span class="line">    pthread_mutex_destroy(&amp;_mutex);</span><br><span class="line">    pthread_cond_destroy(&amp;_cond_productor);</span><br><span class="line">    pthread_cond_destroy(&amp;_cond_consumer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueuePush</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    QueueLock();    <span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">while</span> (QueueIsFull()) &#123; <span class="comment">//队列满了</span></span><br><span class="line">ProductorWait();    <span class="comment">//生产者休眠</span></span><br><span class="line">    &#125;</span><br><span class="line">    _queue.push(data);</span><br><span class="line">    ConsumerWakeUp();    <span class="comment">//唤醒消费者</span></span><br><span class="line">    QueueUnLock();    <span class="comment">//解锁</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueuePop</span><span class="params">(<span class="keyword">int</span> *data)</span> </span>&#123;</span><br><span class="line">    QueueLock();    <span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">while</span> (QueueIsEmpty()) &#123; <span class="comment">//队列空</span></span><br><span class="line">ConsumerWait();    <span class="comment">//消费者休眠</span></span><br><span class="line">    &#125;</span><br><span class="line">    *data = _queue.front();</span><br><span class="line">    _queue.pop();</span><br><span class="line">    ProductorWakeUp();    <span class="comment">//唤醒生产者</span></span><br><span class="line">    QueueUnLock();    <span class="comment">//解锁</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueueLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueueUnLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProductorWait</span><span class="params">()</span></span>&#123;</span><br><span class="line">    pthread_cond_wait(&amp;_cond_productor, &amp;_mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProductorWakeUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pthread_cond_signal(&amp;_cond_productor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConsumerWait</span><span class="params">()</span></span>&#123;</span><br><span class="line">    pthread_cond_wait(&amp;_cond_consumer, &amp;_mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConsumerWakeUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    pthread_cond_signal(&amp;_cond_consumer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueueIsFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (_queue.size() == _capacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueueIsEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _queue.empty();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; _queue;</span><br><span class="line"><span class="keyword">int</span> _capacity;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> _mutex;</span><br><span class="line"><span class="keyword">pthread_cond_t</span>_cond_productor;</span><br><span class="line"><span class="keyword">pthread_cond_t</span>_cond_consumer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thr_consumer</span> <span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BlockQueue *q = (BlockQueue*)arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span>  data;</span><br><span class="line">     sleep(<span class="number">1</span>);</span><br><span class="line">q-&gt;QueuePop(&amp;data);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"consumer  get data:"</span>&lt;&lt;data&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thr_productor</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    BlockQueue *q = (BlockQueue*)arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"productor put data:"</span>&lt;&lt;i&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">q-&gt;QueuePush(i++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> ctid[<span class="number">4</span>], ptid[<span class="number">4</span>];</span><br><span class="line">    BlockQueue q;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">ret = pthread_create(&amp;ctid[i], <span class="literal">NULL</span>, thr_consumer, (<span class="keyword">void</span>*)&amp;q);</span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"pthread create error\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">ret = pthread_create(&amp;ptid[i], <span class="literal">NULL</span>, thr_productor, (<span class="keyword">void</span>*)&amp;q);</span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"pthread create error\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">pthread_join(ctid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">pthread_join(ptid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代码实现了消费者与生产者之间互相处理数据的过程。</p><p>当我在线程函数中添加了sleep函数，这样可以看到，在线程中生产者往队列中生产了数据之后，消费者从队列中取出数据然后处理数据。在类中处理数据的过程用锁将其保护。互相不会干扰到</p><p><img src="/2019/05/17/Linux多线程-3/线程1.png" alt="线程1"></p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><h4 id="信号量的定义"><a href="#信号量的定义" class="headerlink" title="信号量的定义"></a>信号量的定义</h4><p>百度百科定义：是在多线程环境下使用的一种设施，<strong>是可以用来保证两个或多个关键代码段不被并发调用</strong>。在<strong>进入一个关键代码段之前，线程必须获取一个信号量</strong>；<strong>一旦该关键代码段完成了，那么该线程必须释放信号量</strong>。其它想进入该关键代码段的线程必须等待直到第一个线程释放信号量。 </p><h4 id="信号量的理解"><a href="#信号量的理解" class="headerlink" title="信号量的理解"></a>信号量的理解</h4><p><strong>信号量=计数器+等待队列+等待+唤醒</strong></p><p>功能：实现线程/进程间的互斥与同步。</p><p>计数器就是判断的条件：当计数只用0/1的时候那么就可以实现互斥了</p><p><code>等待队列+等待+唤醒</code>这是实现同步的基本功能</p><h4 id="信号量的接口"><a href="#信号量的接口" class="headerlink" title="信号量的接口"></a>信号量的接口</h4><p>信号量的原语可以理解为是<code>PV操作</code>。P：阻塞；V：唤醒</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span> *sem, <span class="keyword">int</span> pshared, <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br><span class="line">    <span class="comment">//  sem:信号量变量</span></span><br><span class="line">    <span class="comment">//pshared：选项标志-决定信号量用于进程间还是线程间同步互斥</span></span><br><span class="line">    <span class="comment">//    0线程间</span></span><br><span class="line">    <span class="comment">//    !0进程间</span></span><br><span class="line">    <span class="comment">//value：信号量初始计数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line">    <span class="comment">//sem:信号量变量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line">    <span class="comment">//通过计数判断是否有资源可操作 （计数-1 + 等待）</span></span><br><span class="line">    <span class="comment">//int sem_wait(sem_t *sem);</span></span><br><span class="line">    <span class="comment">//若计数&lt;=0;则阻塞</span></span><br><span class="line">    <span class="comment">//int sem_trywait(sem_t *sem);</span></span><br><span class="line">    <span class="comment">//若计数&lt;=0;则报错返回</span></span><br><span class="line">    <span class="comment">//int sem_timedwait(sem_t*sem, struct timespec*abs_timeout);</span></span><br><span class="line">    <span class="comment">//若计数&lt;=0;则限时阻塞,超时则报错返回</span></span><br></pre></td></tr></table></figure><h4 id="信号量实现线程安全的环形队列Demo"><a href="#信号量实现线程安全的环形队列Demo" class="headerlink" title="信号量实现线程安全的环形队列Demo"></a>信号量实现线程安全的环形队列Demo</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RingQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">RingQueue(<span class="keyword">int</span> cap = <span class="number">10</span>)</span><br><span class="line">        :_queue(<span class="number">10</span>),</span><br><span class="line">        _capacity(cap),</span><br><span class="line">    _write_step(<span class="number">0</span>),</span><br><span class="line">    _read_step(<span class="number">0</span>)&#123;</span><br><span class="line">    sem_init(&amp;_sem_data, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;_sem_idle, <span class="number">0</span>, cap);</span><br><span class="line">    sem_init(&amp;_sem_lock, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">~RingQueue()&#123;</span><br><span class="line">    sem_destroy(&amp;_sem_data);</span><br><span class="line">    sem_destroy(&amp;_sem_idle);</span><br><span class="line">    sem_destroy(&amp;_sem_lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span>  <span class="title">QueuePush</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    ProductorWait();</span><br><span class="line">    QueueLock();</span><br><span class="line">    _queue[_write_step] = data;</span><br><span class="line">    _write_step = (_write_step + <span class="number">1</span>) % _capacity;</span><br><span class="line">    QueueUnLock();</span><br><span class="line">    ConsumerWakeUp();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span>  <span class="title">QueuePop</span><span class="params">(<span class="keyword">int</span> *data)</span></span>&#123;</span><br><span class="line">    ConsumerWait();</span><br><span class="line">    QueueLock();</span><br><span class="line">    *data = _queue[_read_step];</span><br><span class="line">    _read_step = (_read_step + <span class="number">1</span>) % _capacity;</span><br><span class="line">    QueueUnLock();</span><br><span class="line">    ProductorWakeUp();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueueLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sem_wait(&amp;_sem_lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueueUnLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sem_post(&amp;_sem_lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProductorWait</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sem_wait(&amp;_sem_idle);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProductorWakeUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sem_post(&amp;_sem_idle);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConsumerWait</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sem_wait(&amp;_sem_data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConsumerWakeUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sem_post(&amp;_sem_data);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; _queue;</span><br><span class="line"><span class="keyword">int</span>  _capacity;</span><br><span class="line"><span class="keyword">int</span>  _write_step;</span><br><span class="line"><span class="keyword">int</span>  _read_step;</span><br><span class="line"><span class="keyword">sem_t</span> _sem_data;<span class="comment">//数据资源计数</span></span><br><span class="line"><span class="keyword">sem_t</span> _sem_idle;<span class="comment">//空闲空间计数</span></span><br><span class="line"><span class="keyword">sem_t</span> _sem_lock;<span class="comment">//实现互斥</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thr_consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RingQueue *q = (RingQueue*)arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line">q-&gt;QueuePop(&amp;data);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"consumer thread get data:"</span>&lt;&lt;data&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thr_productor</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RingQueue *q = (RingQueue*)arg;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">q-&gt;QueuePush(i);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"productor thread put data:"</span>&lt;&lt;i&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> ctid[<span class="number">4</span>], ptid[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">int</span> ret, i;</span><br><span class="line">    RingQueue q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">ret = pthread_create(&amp;ctid[i], <span class="literal">NULL</span>, thr_consumer, (<span class="keyword">void</span>*)&amp;q);</span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"thread create error"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">ret = pthread_create(&amp;ptid[i], <span class="literal">NULL</span>, thr_productor, (<span class="keyword">void</span>*)&amp;q);</span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"thread create error"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">pthread_join(ctid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">pthread_join(ptid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/05/17/Linux多线程-3/线程2.png" alt="线程2"></p><p>在封装的加锁与解锁的操作中，有<code>sem_wait()</code>和<code>sem_post()</code>操作，这其实就是计数的+1和-1的操作。当wait时，进行了阻塞，此时另一方可以进行操作。</p><p><img src="/2019/05/17/Linux多线程-3/线程3.png" alt="线程3"></p><p>因为信号量的初始计数为10，所以空闲空间计数最开始生产者生产了10个数据，当capacity满了之后，生产者等待，消费者唤醒。此时消费者开始读取数据，读取也是读取0个开始，到10个时将不再读取数据，此时消费者等待，生产者唤醒。</p><h4 id="信号量与条件变量的区别"><a href="#信号量与条件变量的区别" class="headerlink" title="信号量与条件变量的区别"></a>信号量与条件变量的区别</h4><p>信号量拥有资源计数的功能，临界资源是否能够操作，通过自身计数判断。sem_post和sem_wait</p><p>条件变量是搭配互斥锁一起使用的</p><p>信号量还可以实现互斥，计数仅为0/1</p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="线程池概念"><a href="#线程池概念" class="headerlink" title="线程池概念"></a>线程池概念</h4><p><strong>一堆固定数量/有最大数量限制的线程+任务队列</strong></p><p><strong>可以用于并发处理任务请求</strong></p><h4 id="线程池特性"><a href="#线程池特性" class="headerlink" title="线程池特性"></a>线程池特性</h4><p><strong>避免大量频繁的线程创建销毁的时间成本</strong>，当大量的创建线程时，主线程创建完成之后要等待子进程的退出，子进程退出之后，主进程才能退出。当有了线程池之后，线程池避免峰值压力带来瞬间大量线程被创建资源耗尽，程序崩溃的危险</p><h4 id="线程池的实现"><a href="#线程池的实现" class="headerlink" title="线程池的实现"></a>线程池的实现</h4><p>线程数量固定的线程池，需要定义最大线程和当前线程数量</p><h5 id="自主实现线程池"><a href="#自主实现线程池" class="headerlink" title="自主实现线程池"></a>自主实现线程池</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*task_callback)</span><span class="params">(<span class="keyword">int</span> data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">deal_data</span><span class="params">(<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">int</span> n = rand()%<span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread:%p----deal data:%d---sleep %d sec\n"</span>, pthread_self(), data, n);</span><br><span class="line">    sleep(n);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Task()&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        ~Task()&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">SetTask</span><span class="params">(<span class="keyword">int</span> data, task_callback handle)</span></span>&#123;</span><br><span class="line">            _data = data;</span><br><span class="line">            _handle = handle;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">Run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _handle(_data);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> _data;<span class="comment">//任务处理要处理的数据</span></span><br><span class="line">        task_callback _handle;<span class="comment">//任务的处理方法</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_THR 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_QUE 10</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ThreadPool()&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        ~ThreadPool()&#123;</span><br><span class="line">            pthread_mutex_destroy(&amp;_mutex);</span><br><span class="line">            pthread_cond_destroy(&amp;_cond_con);</span><br><span class="line">            pthread_cond_destroy(&amp;_cond_pro);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">ThreadInit</span><span class="params">(<span class="keyword">int</span> max_thr = MAX_THR, <span class="keyword">int</span> max_que = MAX_QUE)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//实现变量初始化和线程创建</span></span><br><span class="line">            _quit_flag = <span class="literal">false</span>;</span><br><span class="line">            _max_thr = max_thr;</span><br><span class="line">            _cur_thr = max_thr;</span><br><span class="line">            _capacity = max_que;</span><br><span class="line">            pthread_mutex_init(&amp;_mutex, <span class="literal">NULL</span>);</span><br><span class="line">            pthread_cond_init(&amp;_cond_con, <span class="literal">NULL</span>);</span><br><span class="line">            pthread_cond_init(&amp;_cond_pro, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">int</span> ret;</span><br><span class="line">            <span class="keyword">pthread_t</span> tid;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _max_thr; i++) &#123;</span><br><span class="line">                ret=pthread_create(&amp;tid, <span class="literal">NULL</span>, thr_start, (<span class="keyword">void</span>*)<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"thread create error\n"</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pthread_detach(tid);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">PushTask</span><span class="params">(Task &amp;task)</span></span>&#123;</span><br><span class="line">            <span class="comment">//向任务队列中添加任务</span></span><br><span class="line">            <span class="keyword">if</span> (_quit_flag == <span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            QueueLock();</span><br><span class="line">            <span class="keyword">while</span> (QueueIsFull())&#123;</span><br><span class="line">                ProWait();</span><br><span class="line">            &#125;</span><br><span class="line">            _queue.push(task);</span><br><span class="line">            ConWakeUp();</span><br><span class="line">            QueueUnLock();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">ThreadQuit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//线程池退出</span></span><br><span class="line">            <span class="keyword">if</span> (_quit_flag != <span class="literal">true</span>) &#123;</span><br><span class="line">                _quit_flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(_cur_thr &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ConWakeUpAll();</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">QueueLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">            pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">QueueUnLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">ConWait</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//进入ConWait表示消费者这时候没有数据待处理，则解锁退出</span></span><br><span class="line">            <span class="keyword">if</span> (_quit_flag == <span class="literal">true</span>) &#123;</span><br><span class="line">                pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"thread:%p exit\n"</span>, pthread_self());</span><br><span class="line">                _cur_thr--;</span><br><span class="line">                pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            pthread_cond_wait(&amp;_cond_con, &amp;_mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">ConWakeUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">            pthread_cond_signal(&amp;_cond_con);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">ConWakeUpAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"wake up all\n"</span>);</span><br><span class="line">            pthread_cond_broadcast(&amp;_cond_con);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">ProWait</span><span class="params">()</span></span>&#123;</span><br><span class="line">            pthread_cond_wait(&amp;_cond_pro, &amp;_mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">ProWakeUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">            pthread_cond_signal(&amp;_cond_pro);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">QueueIsFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (_capacity == _queue.size());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">QueueIsEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _queue.empty();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">PopTask</span><span class="params">(Task *task)</span></span>&#123;</span><br><span class="line">            *task = _queue.front();</span><br><span class="line">            _queue.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_start</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">            ThreadPool *pool = (ThreadPool*)arg;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                pool-&gt;QueueLock();</span><br><span class="line">                <span class="keyword">while</span>(pool-&gt;QueueIsEmpty())&#123;</span><br><span class="line">                    pool-&gt;ConWait();</span><br><span class="line">                &#125;</span><br><span class="line">                Task task;</span><br><span class="line">                pool-&gt;PopTask(&amp;task);</span><br><span class="line">                pool-&gt;ProWakeUp();</span><br><span class="line">                pool-&gt;QueueUnLock();</span><br><span class="line">                <span class="comment">//任务处理要放到解锁之外，否则任务处理时间过程导致其它线程阻塞</span></span><br><span class="line">                task.Run();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> _max_thr;<span class="comment">//线程池中最大线程数量</span></span><br><span class="line">        <span class="keyword">int</span> _cur_thr;<span class="comment">//线程池中当前线程数量</span></span><br><span class="line">        <span class="keyword">int</span> _quit_flag;<span class="comment">//线程池中线程退出标志</span></span><br><span class="line">        <span class="keyword">int</span> _capacity;<span class="comment">//队列的最大节点数目</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;Task&gt; _queue;<span class="comment">//任务队列</span></span><br><span class="line">        <span class="keyword">pthread_mutex_t</span> _mutex;<span class="comment">//</span></span><br><span class="line">        <span class="keyword">pthread_cond_t</span> _cond_pro;<span class="comment">//生产者</span></span><br><span class="line">        <span class="keyword">pthread_cond_t</span> _cond_con;<span class="comment">//消费者</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ThreadPool pool;</span><br><span class="line"></span><br><span class="line">    pool.ThreadInit();</span><br><span class="line">    Task task[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        task[i].SetTask(i, deal_data);</span><br><span class="line">        pool.PushTask(task[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    pool.ThreadQuit();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程池的工作可以看成，安排多个线程进行工作，此时有一个任务队列，队列中的容量是有限的。</p><p>我们还是看成</p><p>1、生产者安排生产任务，加上锁，生产完后，消费者唤醒，此时解开锁。</p><p>2、消费者被唤醒之后处理数据，每处理一次数据后，任务队列数-1。</p><p>3、任务处理要放到解锁之外，否则任务处理时间过程导致其它线程阻塞</p><p>运行截图</p><p><img src="/2019/05/17/Linux多线程-3/线程4.png" alt="线程4"></p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式是设计模式中的一种：一个对象只能被实例化一次(资源只被加载一次)</p><h4 id="单例模式的类型"><a href="#单例模式的类型" class="headerlink" title="单例模式的类型"></a>单例模式的类型</h4><h5 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h5><p>程序初始化时实例化完毕，优点是不需要再初始化，不需要加载资源，因此运行速度快，流畅</p><p>缺点是：加载时间耗时比较长</p><h5 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h5><p>程序资源使用的时候再进行加载，对象使用的时候再进行实例化，初始化加载速度快，但是运行流畅度不够</p><p>但是需要注意线程安全问题</p><p>C++的总结中，会再次提到这个问题。</p><h3 id="多线程个人总结"><a href="#多线程个人总结" class="headerlink" title="多线程个人总结"></a>多线程个人总结</h3><p>关于多线程的部分总结终于结束了。跨度比较大，因为很多时候不太能理解是怎么运行的。</p><p>尤其是到了手撕模型的时候，最关键的点在于线程安全我们必须要考虑，因为线程如果再运行中丢失，那么数据有可能也会丢失或者泄漏，这带来的损失也是巨大的。</p><p>模型也多从消费者和生产者做起。其实各个特性都总结完之后，会发现，互斥锁+条件变量可以在多个地方用到，就因为要为了保护线程安全。所以这是个重点。线程池关键的在于，数据的处理过程。当数据处理时要与锁分开，否则数据处理时，如果被加锁了，那么其他进程此时在外等待，那么此时就造成了阻塞，时间上大大加长了。这就又没有开启多个线程的意义了。</p><p>queue类的使用也是一知半解，所以掌握起来比较不容易上手。C++有了一定的理解之后可以更好的去实现Demo</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;线程安全的考虑关乎互斥锁和条件变量&lt;/p&gt;
&lt;h3 id=&quot;消费者与生产者模型&quot;&gt;&lt;a href=&quot;#消费者与生产者模型&quot; class=&quot;headerlink&quot; title=&quot;消费者与生产者模型&quot;&gt;&lt;/a&gt;消费者与生产者模型&lt;/h3&gt;&lt;p&gt;当我们去超市买东西时，我们都认为我
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://skrskr66.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux多线程(2)</title>
    <link href="https://skrskr66.github.io/2019/05/15/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/"/>
    <id>https://skrskr66.github.io/2019/05/15/Linux多线程-2/</id>
    <published>2019-05-15T08:47:37.000Z</published>
    <updated>2019-05-17T10:24:23.548Z</updated>
    
    <content type="html"><![CDATA[<p>线程的知识点太多，太重要，所以分成三部分进行总结学习</p><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>多个线程并发同一段代码时，不会出现不同的结果。常见对全局变量或者静态变量进行操作，并且没有锁保护的情况下，会出现该问题。</p><p>多个线程对临界资源进行竞争操作时若不会造成数据二义性时则线程安全；否则，此时就是不安全的</p><h4 id="如何实现线程安全"><a href="#如何实现线程安全" class="headerlink" title="如何实现线程安全"></a>如何实现线程安全</h4><h5 id="常见的线程安全的情况"><a href="#常见的线程安全的情况" class="headerlink" title="常见的线程安全的情况"></a>常见的线程安全的情况</h5><ul><li>每个线程对全局变量或者静态变量只有读取的权限，而没有写入的权限，一般来说这些线程是安全的</li><li>类或者接口对于线程来说都是原子操作</li><li>多个线程之间的切换不会导致该接口的执行结果存在二义性</li></ul><h5 id="常见的线程不安全的情况"><a href="#常见的线程不安全的情况" class="headerlink" title="常见的线程不安全的情况"></a>常见的线程不安全的情况</h5><ul><li>不保护共享变量的函数</li><li>函数状态随着被调用，状态发生变化的函数</li><li>返回指向静态变量指针的函数</li><li>调用线程不安全函数的函数</li></ul><p>在网上调研过程中看到一个总结：<strong>减少对临界资源的依赖，尽量避免访问全局变量，静态变量或其它共享资源，如果必须要使用共享资源，所有使用到的地方必须要进行互斥锁 (Mutex) 保护</strong> </p><p>所以当对临界资源使用时，尽量在必须的地方使用锁的保护</p><p>对临界资源又有两种访问，分别是同步访问和互斥访问</p><p><strong>同步：临界资源的合理访问</strong></p><p><strong>异步：临界资源同一时间的唯一访问</strong></p><h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p>互斥锁的操作就是<code>1/0</code>的操作</p><p>一个0或者1的计数器。1可以表示加锁，加锁就是计数-1；操作完毕之后要解锁，解锁就是计数+1；</p><p>0表示不可以加锁，不能加锁则等待</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//互斥锁的接口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">//函数应销毁mutex引用的mutex对象</span></span><br><span class="line"><span class="comment">//注意！！！</span></span><br><span class="line"><span class="comment">//销毁已解锁的已初始化互斥体应是安全的。试图销毁锁定的互斥体会导致未定义的行为。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,<span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"><span class="comment">//mutex：互斥锁变量</span></span><br><span class="line"><span class="comment">//attr：属性，通常为NULL </span></span><br><span class="line"><span class="comment">//应使用attr指定的属性初始化mutex引用的mutex</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="comment">//宏PTHREAD_MUTEX_INITIALIZER来静态的初始化锁</span></span><br><span class="line"><span class="comment">//互斥锁变量不一定非要全局变量--只要保证要互斥的线程都能访问到就行</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">//锁定mutex引用的mutex对象。如果互斥体已被锁定，则调用线程应阻塞，直到互斥体可用。此操作将返回互斥对象引用的互斥对象处于锁定状态，调用线程作为其所有者。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">//函数应等同于pthread_mutex_lock（），但如果mutex引用的mutex对象当前被锁定（由任何线程，包括当前线程），则调用应立即返回。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">//函数应释放mutex引用的mutex对象。互斥体的释放方式取决于互斥体的type属性。如果在调用pthread_mutex_unlock（）时，mutex引用的mutex对象上有线程被阻塞，导致mutex可用，调度策略应确定哪个线程应获取mutex。</span></span><br></pre></td></tr></table></figure><p>互斥锁的操作步骤</p><ol><li>定义互斥锁变量</li><li>初始化互斥锁变量</li><li>加锁</li><li>解锁</li><li>销毁互斥锁</li></ol><p>通过一个互斥锁Demo来感受一下锁的使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟黄牛抢票，100张票，共有四个黄牛在抢票</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;<span class="comment">//定义初始化锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thr_start</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            usleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"yellow bull : %d----get ticket : %d\n"</span>,(<span class="keyword">int</span>)arg,ticket);</span><br><span class="line">            ticket--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">            pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>,ret;</span><br><span class="line">    </span><br><span class="line">    pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(;i &lt; <span class="number">4</span>; ++i)&#123;</span><br><span class="line">        ret = pthread_create(&amp;tid[i],<span class="literal">NULL</span>,thr_start,(<span class="keyword">void</span>*)i);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"yellow bull no exit!"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">4</span>;++i)&#123;</span><br><span class="line">        pthread_join(tid[i],<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/05/15/Linux多线程-2/线程1.png" alt="线程1"></p><p>这种情况黄牛抢票是比较容易的，一般只有一个黄牛能全抢到票。</p><p>但是如果把锁去掉</p><p><img src="/2019/05/15/Linux多线程-2/线程2.png" alt="线程2"></p><p>这样抢票就很混乱，因为没有了保护。所以锁的使用是在共享资源对它进行保护，换句话说加锁是为了保护资源，所以在这个代码中就将抢票的操作进行加锁保护。这样就只有一个黄牛可以抢到票。</p><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>在进行加锁的过程中很有可能发生死锁的情况下。</p><p><strong>在一组进程中的各个进程均占有不会释放的资源，但因互相申请被其他的进程所占用不会释放的资源而处于一种永久等待的状态</strong></p><h5 id="死锁的四个条件-重点"><a href="#死锁的四个条件-重点" class="headerlink" title="死锁的四个条件(重点)"></a>死锁的四个条件(重点)</h5><p>1、互斥条件：一个资源一次只能被一个执行流使用</p><p><strong>我操作的时候别人不能操作</strong></p><p>2、请求与保持条件：一个执行流因请求资源而阻塞时，对已获得的资源保持不变</p><p><strong>拿着手里的，但是请求其他的，其他的请求不到，手里拿着的也不放开</strong></p><p>3、不可剥夺条件：一个执行流已获得的资源，在未使用完之前，不能强行剥夺</p><p><strong>我的锁，别人不能释放</strong></p><p>4、循环等待条件：若干执行流之间形成一种头尾相接的循环等待资源的关系</p><p><strong>指在发生死锁时，必然存在一个进程资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，Pn正在等待已被P0占用的资源</strong></p><h5 id="死锁的产生与处理"><a href="#死锁的产生与处理" class="headerlink" title="死锁的产生与处理"></a>死锁的产生与处理</h5><p>当加锁或者解锁顺序不同时会发生死锁的情况；对锁资源的竞争以及进程/线程的加锁的推进顺序b不当</p><p>当以上四种条件被破坏时，可以<strong>预防死锁</strong>的产生</p><p>避免死锁的方法可以通过：死锁检测算法，银行家算法(推荐王道视频学习)</p><h4 id="同步的实现"><a href="#同步的实现" class="headerlink" title="同步的实现"></a>同步的实现</h4><p>条件变量是线程同步的一种手段，条件变量用来自动阻塞一个线程，直到条件满足被触发为止。通常情况下条件变量和互斥锁同时使用</p><p>条件变量使我们可以睡眠等待某种条件出现。条件变量利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：</p><p>1、一个/多个线程等待“条件变量的条件成立”而挂起；线程1如果操作条件满足，则操作，否则进行等待。</p><p>2、另一个线程使“条件成立”信号；线程2促使条件满足，唤醒等待的线程。</p><p>如果没有资源则等待(死等)，生产资源后唤醒等待。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//条件变量的接口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,<span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"><span class="comment">//条件变量初始化，一般attr默认为NULL</span></span><br><span class="line"><span class="comment">//使用attr引用的属性初始化cond引用的条件变量。如果attr为空，则使用默认条件变量属性；效果与传递默认条件变量属性对象的地址相同。初始化成功后，条件变量的状态将被初始化。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="comment">//静态初始化条件变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="comment">//销毁由cond指定的给定的条件变量</span></span><br><span class="line"><span class="comment">//销毁当前未阻塞线程的初始化条件变量是安全的。</span></span><br><span class="line"><span class="comment">//试图销毁当前阻止其他线程的条件变量会导致未定义的行为。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">const</span> struct timespec *<span class="keyword">restrict</span> abstime)</span></span>;</span><br><span class="line"><span class="comment">//abstime：限时等待时长，限时等待时长，超时后则返回</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span></span>;</span><br><span class="line"><span class="comment">//解锁后的挂起操作(原子操作)，有可能还没来得及挂起就已经有人唤醒--白唤醒--导致了死锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="comment">//唤醒至少一个等待的</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_boardcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="comment">//广播唤醒，唤醒所有等待的人</span></span><br></pre></td></tr></table></figure><p>条件变量的步骤：</p><p>1、定义条件变量</p><p>2、初始化条件变量</p><p>3、等待\唤醒定义的条件变量</p><p>4、销毁条件变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟一个skr与cxk使用比赛舞台的Demo                                  </span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;    </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;    </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;    </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;    </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;    </span></span></span><br><span class="line">     </span><br><span class="line"> <span class="keyword">int</span> have_stage = <span class="number">1</span>;    </span><br><span class="line">     </span><br><span class="line"> <span class="keyword">pthread_cond_t</span> skr;    </span><br><span class="line"> <span class="keyword">pthread_cond_t</span> cxk;    </span><br><span class="line"> <span class="keyword">pthread_mutex_t</span> mutex;    </span><br><span class="line">     </span><br><span class="line"> <span class="function"><span class="keyword">void</span>* <span class="title">thr_skr</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;<span class="comment">//skr此时要上台dancing    </span></span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)&#123;    </span><br><span class="line">     pthread_mutex_lock(&amp;mutex);    </span><br><span class="line">     <span class="comment">//若此时舞台有人用，那么skr进行等待    </span></span><br><span class="line">     <span class="keyword">while</span>(have_stage == <span class="number">1</span>)&#123;    </span><br><span class="line">       pthread_cond_wait(&amp;skr,&amp;mutex);    </span><br><span class="line">     &#125;    </span><br><span class="line">     <span class="comment">//舞台被人使用了，此时0；因为之前1，代表可以使用    </span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"skr~~ is freestyle!!!\n"</span>);    </span><br><span class="line">     sleep(<span class="number">1</span>);    </span><br><span class="line">     <span class="comment">//跳完舞后舞台空了出来    </span></span><br><span class="line">     have_stage += <span class="number">1</span>;    </span><br><span class="line">     <span class="comment">//有舞台了，叫cxk来使用    </span></span><br><span class="line">     pthread_cond_signal(&amp;cxk);    </span><br><span class="line">     pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">void</span>* <span class="title">thr_cxk</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">     pthread_mutex_lock(&amp;mutex);</span><br><span class="line">     <span class="comment">//没有舞台，那么在这里等待</span></span><br><span class="line">     <span class="keyword">while</span>(have_stage == <span class="number">0</span>)&#123;</span><br><span class="line">       pthread_cond_wait(&amp;cxk,&amp;mutex);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//有了舞台就是可以唱跳rap篮球了。。</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"cxk~~ is singing,dancing,playing rapping and basketball!!\n"</span>);</span><br><span class="line">     sleep(<span class="number">1</span>);</span><br><span class="line">     have_stage -= <span class="number">1</span>;</span><br><span class="line">     <span class="comment">//跳完还想跳。。因此叫skr快跳完换他跳。。</span></span><br><span class="line">     pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">     pthread_cond_signal(&amp;skr);<span class="comment">//唤醒skr，</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"> &#125;                                                                                               <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">   <span class="keyword">pthread_t</span> tid1,tid2;</span><br><span class="line">   <span class="keyword">int</span> ret;</span><br><span class="line">     </span><br><span class="line">   pthread_cond_init(&amp;skr,<span class="literal">NULL</span>);</span><br><span class="line">   pthread_cond_init(&amp;cxk,<span class="literal">NULL</span>);</span><br><span class="line">   pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">2</span>;i++)&#123;</span><br><span class="line">     ret = pthread_create(&amp;tid1,<span class="literal">NULL</span>,thr_skr,<span class="literal">NULL</span>);</span><br><span class="line">     <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"skr error"</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">2</span>; i++)&#123;</span><br><span class="line">     ret = pthread_create(&amp;tid2,<span class="literal">NULL</span>,thr_cxk,<span class="literal">NULL</span>);</span><br><span class="line">     <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"cxk error"</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   pthread_join(tid1,<span class="literal">NULL</span>);</span><br><span class="line">   pthread_join(tid2,<span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">   pthread_cond_destroy(&amp;skr);</span><br><span class="line">   pthread_cond_destroy(&amp;cxk);</span><br><span class="line">   pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/05/15/Linux多线程-2/线程3.png" alt="线程3"></p><p>运行结果可以看到cxk和skr交替互斥的表演节目。。。</p><p>那么互斥量(mutex)保护的是什么？其实保护的是变量条件(have_stage)，当互斥量被成功lock后我们就可以放心的去读取变量条件，这样就不用在担心在这期间变量条件会被其他线程修改。如果变量条件不满足条件，当前线程阻塞，等待其他线程释放<strong>条件成立信号</strong>，并释放已经lock的mutex。这样一来其他线程就有了修改变量条件的机会。当其他线程释放条件成立信号后，pthread_cond_wait函数返回，并再次lock</p><p><strong>pthread_cond_wait的工作流程可以总结为：unlock mutex，start waiting -&gt; lock mutex。</strong> </p><p><strong>while的作用</strong></p><p>在变量条件处为什么不用<code>if</code>做判断而是用while，这是因为pthread_cond_wait的返回不一定意味着其他线程释放了条件成立信号。也可能意外返回。这种被称为<strong>假唤醒</strong>，在Linux中带阻塞功能的system call都会在进程中收到了一个signal后返回。这就是为什么使用while来检查的原因。<strong>因为不能保证wait函数返回的一定就是条件满足，如果条件不满足，那么我们还需要继续等待</strong></p><p><strong>signal条件变量的考虑</strong></p><p>解锁互斥量mutex和发出唤醒信号是两个单独的操作，所以就存在一个顺序的问题</p><p>(1)    按照 unlock(mutex); condition_signal()顺序，当等待线程被唤醒时，因为mutex已经解锁，因此被唤醒的线程(skr)很容易就锁住了mutex然后从conditon_wait()中返回了。  </p><p>(2)    按照 condition_signal(); unlock(mutex)顺序，当等待线程被唤醒时，它试图锁住mutex,但是如果此时mutex还未解锁，则线程又进入睡眠，mutex成功解锁后，此线程在再次被唤醒并锁住mutex，从而从condition_wait()中返回。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;线程的知识点太多，太重要，所以分成三部分进行总结学习&lt;/p&gt;
&lt;h3 id=&quot;线程安全&quot;&gt;&lt;a href=&quot;#线程安全&quot; class=&quot;headerlink&quot; title=&quot;线程安全&quot;&gt;&lt;/a&gt;线程安全&lt;/h3&gt;&lt;p&gt;多个线程并发同一段代码时，不会出现不同的结果。常见对全局
      
    
    </summary>
    
    
      <category term="Linux 锁" scheme="https://skrskr66.github.io/tags/Linux-%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>C++-类与对象(2)</title>
    <link href="https://skrskr66.github.io/2019/05/15/C-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1-2/"/>
    <id>https://skrskr66.github.io/2019/05/15/C-类与对象-2/</id>
    <published>2019-05-15T08:47:09.000Z</published>
    <updated>2019-05-18T15:39:16.787Z</updated>
    
    <content type="html"><![CDATA[<h3 id="类与对象-第二部分"><a href="#类与对象-第二部分" class="headerlink" title="类与对象(第二部分)"></a>类与对象(第二部分)</h3><h4 id="类的6个默认成员函数"><a href="#类的6个默认成员函数" class="headerlink" title="类的6个默认成员函数"></a>类的6个默认成员函数</h4><p>如果一个类中什么成员都没有，简称为空类。空类并不是什么都没有，任何类在我们不写的情况下，都会自动生成6个默认成员函数</p><p><img src="/2019/05/15/C-类与对象-2/类1.png" alt="类1"></p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><h5 id="构造函数的概念"><a href="#构造函数的概念" class="headerlink" title="构造函数的概念"></a>构造函数的概念</h5><p><strong>构造函数是一个特殊的成员函数，名字与类名相同，创建类类型对象时由编译器自动调用</strong>，保证每个数据成员都有一个合适的初始值，<strong>并且在对象的声明周期内只调用一次。</strong></p><h5 id="构造函数的特性"><a href="#构造函数的特性" class="headerlink" title="构造函数的特性"></a>构造函数的特性</h5><p><strong>构造函数</strong>是特殊的成员函数，需要注意的是，构造函数虽然名称叫构造，但是它的主要任务并不是开空间创建对象，而是初始化对象。</p><p><strong>特征如下：</strong></p><p>​    1、函数名与类名相同</p><p>​    2、无返回值</p><p>​    3、对象实例化时编译器自动调用对应的构造函数</p><p>​    4、构造函数可以重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//无参构造函数</span></span><br><span class="line">    Date()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//带参构造函数</span></span><br><span class="line">    Date(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)&#123;</span><br><span class="line">        _year = year;</span><br><span class="line">        _month = month;</span><br><span class="line">        _day = day;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _year;</span><br><span class="line">    <span class="keyword">int</span> _month;</span><br><span class="line">    <span class="keyword">int</span> _day;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>5、如果类中没有显式定义构造函数，则C++编译器会自动生成一个无参的默认构造函数，一旦用户显示定义，那么编译器将不在生成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> // 如果用户显式定义了构造函数，编译器将不再生成</span></span><br><span class="line"><span class="comment"> Date (int year, int month, int day)</span></span><br><span class="line"><span class="comment"> &#123;</span></span><br><span class="line"><span class="comment"> _year = year;</span></span><br><span class="line"><span class="comment"> _month = month;</span></span><br><span class="line"><span class="comment"> _day = day;</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">int</span> _year;</span><br><span class="line"> <span class="keyword">int</span> _month;</span><br><span class="line"> <span class="keyword">int</span> _day;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">// 没有定义构造函数，对象也可以创建成功，因此此处调用的是编译器生成的默认构造函数</span></span><br><span class="line">    Date d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、默认构造函数只能有一个，不管是无参的，还是全缺省的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> Date()</span><br><span class="line"> &#123;</span><br><span class="line"> _year = <span class="number">1900</span> ;</span><br><span class="line"> _month = <span class="number">1</span> ;</span><br><span class="line"> _day = <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> Date (<span class="keyword">int</span> year = <span class="number">1900</span>, <span class="keyword">int</span> month = <span class="number">1</span>, <span class="keyword">int</span> day = <span class="number">1</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> _year = year;</span><br><span class="line"> _month = month;</span><br><span class="line"> _day = day;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line"> <span class="keyword">int</span> _year ;</span><br><span class="line"> <span class="keyword">int</span> _month ;</span><br><span class="line"> <span class="keyword">int</span> _day ;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 以下测试函数能通过编译吗？</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> Date d1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/05/15/C-类与对象-2/类2.png" alt="类2"></p><p><strong>在VS2013下可以编译通过，说明在VS内编译器对这种重载错误并不是特别在意。</strong></p><p><strong>但是在g++中，出现了编译器不知道执行哪个构造函数。</strong></p><p>7、关于编译器生成的默认成员函数，我们可能会想到这个默认的构造函数有什么用？我们直接声明一个对象，返回的<code>_year</code>值都是随机数，那么还有什么意义呢？</p><p>C++把类型分成内置类型和自定义类型。内置类型就是语法已经定义好的类型，如int/char…；自定义类型就是我们通过class/struct/union等定义的类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;                       </span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span>    </span></span><br><span class="line"><span class="class">&#123;</span>    </span><br><span class="line">  <span class="keyword">public</span>:    </span><br><span class="line">    Time()    </span><br><span class="line">    &#123;    </span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Time()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;    </span><br><span class="line">      <span class="comment">// 比特科技    </span></span><br><span class="line">      <span class="comment">//   8. 成员变量的命名风格    </span></span><br><span class="line">      _hour = <span class="number">0</span>;    </span><br><span class="line">      _minute = <span class="number">0</span>;    </span><br><span class="line">      _second = <span class="number">0</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">  <span class="keyword">private</span>:    </span><br><span class="line">    <span class="keyword">int</span> _hour;    </span><br><span class="line">    <span class="keyword">int</span> _minute;    </span><br><span class="line">    <span class="keyword">int</span> _second;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>    </span></span><br><span class="line"><span class="class">&#123;</span>    </span><br><span class="line">  <span class="keyword">private</span>:    </span><br><span class="line">    <span class="comment">// 基本类型(内置类型)    </span></span><br><span class="line">    <span class="keyword">int</span> _year;    </span><br><span class="line">    <span class="keyword">int</span> _month;    </span><br><span class="line">    <span class="keyword">int</span> _day;    </span><br><span class="line">    <span class="comment">// 自定义类型    </span></span><br><span class="line">    Time <span class="keyword">_t</span>;    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Date d;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8、成员变量风格</p><p>通过以上代码能看出，在C++中，我们一般定义成员变量时，会在成员变量之前加上一个下划线</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> _year;</span><br><span class="line"><span class="keyword">int</span> _month;</span><br><span class="line"><span class="keyword">int</span> _day;</span><br></pre></td></tr></table></figure><h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><h5 id="析构函数的概念"><a href="#析构函数的概念" class="headerlink" title="析构函数的概念"></a>析构函数的概念</h5><p>与构造函数功能相反，析构函数不是完成对象的销毁，局部对象销毁工作由编译器来完成。而对象在销毁时会自动调用析构函数，完成类的一些资源清理工作。</p><h5 id="析构函数的特性"><a href="#析构函数的特性" class="headerlink" title="析构函数的特性"></a>析构函数的特性</h5><p>1、析构函数名就是构造函数名之前加上<strong>字符~</strong>。</p><p>2、无参数无返回值</p><p>3、一个类只有一个析构函数。若未显示定义，系统会自动生成默认的析构函数</p><p>4、对象生命周期结束时，C++编译系统自动调用析构函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;    </span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> DateType;    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SeqList</span>    </span></span><br><span class="line"><span class="class">&#123;</span>                     </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">  SeqList(<span class="keyword">int</span> capacity = <span class="number">10</span>)&#123;    </span><br><span class="line">    _pData = (DateType*)<span class="built_in">malloc</span>(capacity * <span class="keyword">sizeof</span>(DateType));    </span><br><span class="line">    assert(_pData);    </span><br><span class="line">    _size = <span class="number">0</span>;    </span><br><span class="line">    _capacity = capacity;    </span><br><span class="line">  &#125;    </span><br><span class="line">  ~SeqList()    </span><br><span class="line">  &#123;    </span><br><span class="line">    <span class="keyword">if</span>(_pData)    </span><br><span class="line">    &#123;    </span><br><span class="line">      <span class="built_in">free</span>(_pData);  <span class="comment">//释放栈上资源  </span></span><br><span class="line">      _pData = <span class="literal">NULL</span>;    </span><br><span class="line">      _size = <span class="number">0</span>;    </span><br><span class="line">      _capacity = <span class="number">0</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;    </span><br><span class="line"><span class="keyword">private</span>:    </span><br><span class="line">  <span class="keyword">int</span>* _pData;    </span><br><span class="line">  <span class="keyword">size_t</span> _size;    </span><br><span class="line">  <span class="keyword">size_t</span> _capacity;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>5、编译器自动生成的默认析构函数，对会自定类型成员调用它的析构函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> String(<span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">"jack"</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> _str = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(str) + <span class="number">1</span>);</span><br><span class="line"> <span class="built_in">strcpy</span>(_str, str);</span><br><span class="line"> &#125;</span><br><span class="line"> ~String()</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">"~String()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> <span class="built_in">free</span>(_str);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">char</span>* _str;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> String _name;</span><br><span class="line"> <span class="keyword">int</span> _age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> Person p;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h4><h5 id="拷贝构造函数概念"><a href="#拷贝构造函数概念" class="headerlink" title="拷贝构造函数概念"></a>拷贝构造函数概念</h5><p>只有单个形参，该形参是对本类类型对象的引用(一般常用const修饰)，在用已存在的类类型对象创建新对象时，新对象由编译器自动调用</p><h5 id="拷贝构造函数的特征"><a href="#拷贝构造函数的特征" class="headerlink" title="拷贝构造函数的特征"></a>拷贝构造函数的特征</h5><p>1、拷贝构造函数是构造函数的一个重载</p><p>2、拷贝构造函数的参数只有<strong>一个且必须使用引用传参</strong>，使用传值的方式会引发无穷递归调用</p><p><img src="/2019/05/15/C-类与对象-2/类3.png" alt="类3"></p><p>3、<strong>若未显示定义，系统生成默认的构造拷贝函数</strong>。默认的拷贝构造函数对象按内存存储字节序完成拷贝，这种拷贝我们叫做浅拷贝，或者值拷贝</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;    </span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>    </span></span><br><span class="line"><span class="class">&#123;</span>    </span><br><span class="line">  <span class="keyword">public</span>:    </span><br><span class="line">    Date(<span class="keyword">int</span> year = <span class="number">1900</span>, <span class="keyword">int</span> month = <span class="number">1</span>, <span class="keyword">int</span> day = <span class="number">1</span>)    </span><br><span class="line">    &#123;    </span><br><span class="line">      _year = year;    </span><br><span class="line">      _month = month;    </span><br><span class="line">      _day = day;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>&#123;    </span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;_year&lt;&lt;<span class="string">"-"</span>&lt;&lt;_month&lt;&lt;<span class="string">"-"</span>&lt;&lt;_day&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">  <span class="keyword">private</span>:    </span><br><span class="line">    <span class="keyword">int</span> _year;    </span><br><span class="line">    <span class="keyword">int</span> _month;    </span><br><span class="line">    <span class="keyword">int</span> _day;    </span><br><span class="line">&#125;;                    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"></span>&#123;             </span><br><span class="line">  Date d1;    </span><br><span class="line">  <span class="comment">// 这里d2调用的默认拷贝构造完成拷贝，d2和d1的值也是一样的。    </span></span><br><span class="line">  <span class="function">Date <span class="title">d2</span><span class="params">(d1)</span></span>;                                                   </span><br><span class="line">  d2.Print();                                                    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;                                                      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h4><h5 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h5><p><strong>C++为了增强代码的可读性引入了运算符重载，运算符重载是具有特殊函数名的函数</strong>，也具有其返回值类型，函数名字以及参数列表，其返回值类型与参数列表与普通的函数类似。</p><p>函数名字为：<strong>关键字operator后面接需要重载的运算符符号</strong></p><p>函数原型：<strong>返回值类型operator操作符(参数列表)</strong></p><p>注意： </p><ul><li>不能通过连接其他符号来创建新的操作符：比如operator@  </li><li>重载操作符必须有一个类类型或者枚举类型的操作数 </li><li>用于内置类型的操作符，其含义不能改变，例如：内置的整型+，不能改变其含义 </li><li>作为类成员的重载函数时，其形参看起来比操作数数目少1成员函数的 </li><li>操作符有一个默认的形参this，限定为第一个形参 </li><li>.* 、:: 、sizeof 、?: 、. 注意以上5个运算符不能重载。这个经常在笔试选择题中出现。  </li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局的operator==</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> Date(<span class="keyword">int</span> year = <span class="number">1900</span>, <span class="keyword">int</span> month = <span class="number">1</span>, <span class="keyword">int</span> day = <span class="number">1</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> _year = year;</span><br><span class="line"> _month = month;</span><br><span class="line"> _day = day;</span><br><span class="line"> &#125; </span><br><span class="line"><span class="comment">//private:</span></span><br><span class="line"> <span class="keyword">int</span> _year;</span><br><span class="line"> <span class="keyword">int</span> _month;</span><br><span class="line"> <span class="keyword">int</span> _day;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 这里会发现运算符重载成全局的就需要成员变量是共有的，那么问题来了，封装性如何保证？</span></span><br><span class="line"><span class="comment">// 这里其实可以用我们后面学习的友元解决，或者干脆重载成成员函数。</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Date&amp; d1, <span class="keyword">const</span> Date&amp; d2)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> d1._year == d2._year;</span><br><span class="line"> &amp;&amp; d1._month == d2._month</span><br><span class="line"> &amp;&amp; d1._day == d2._day;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="function">Date <span class="title">d1</span><span class="params">(<span class="number">2018</span>, <span class="number">9</span>, <span class="number">26</span>)</span></span>;</span><br><span class="line"> <span class="function">Date <span class="title">d2</span><span class="params">(<span class="number">2018</span>, <span class="number">9</span>, <span class="number">27</span>)</span></span>;</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;(d1 == d2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> Date(<span class="keyword">int</span> year = <span class="number">1900</span>, <span class="keyword">int</span> month = <span class="number">1</span>, <span class="keyword">int</span> day = <span class="number">1</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> _year = year;</span><br><span class="line"> _month = month;</span><br><span class="line"> _day = day;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// bool operator==(Date* this, const Date&amp; d2)</span></span><br><span class="line"> <span class="comment">// 这里需要注意的是，左操作数是this指向的调用函数的对象</span></span><br><span class="line"> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Date&amp; d2)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">return</span> _year == d2._year;</span><br><span class="line">     &amp;&amp; _month == d2._month</span><br><span class="line"> &amp;&amp; _day == d2._day;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">int</span> _year;</span><br><span class="line"> <span class="keyword">int</span> _month;</span><br><span class="line"> <span class="keyword">int</span> _day;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="function">Date <span class="title">d1</span><span class="params">(<span class="number">2018</span>, <span class="number">9</span>, <span class="number">26</span>)</span></span>;</span><br><span class="line"> <span class="function">Date <span class="title">d2</span><span class="params">(<span class="number">2018</span>, <span class="number">9</span>, <span class="number">27</span>)</span></span>;</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;(d1 == d2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="赋值运算符重载-1"><a href="#赋值运算符重载-1" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"> Date(<span class="keyword">int</span> year = <span class="number">1900</span>, <span class="keyword">int</span> month = <span class="number">1</span>, <span class="keyword">int</span> day = <span class="number">1</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> _year = year;</span><br><span class="line"> _month = month;</span><br><span class="line"> _day = day;</span><br><span class="line"> &#125;</span><br><span class="line"> Date (<span class="keyword">const</span> Date&amp; d)</span><br><span class="line"> &#123;</span><br><span class="line"> _year = d._year;</span><br><span class="line"> _month = d._month;</span><br><span class="line"> _day = d._day;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> Date&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Date&amp; d)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;d)</span><br><span class="line"> &#123;</span><br><span class="line"> _year = d._year;</span><br><span class="line"> _month = d._month;</span><br><span class="line"> _day = d._day;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">int</span> _year ;</span><br><span class="line"> <span class="keyword">int</span> _month ;</span><br><span class="line"> <span class="keyword">int</span> _day ;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>赋值运算符主要有四点：</p><p><strong>1、参数类型</strong></p><p><strong>2、返回值</strong></p><p><strong>3、检测是否自己给自己赋值</strong></p><p><strong>4、返回*this</strong></p><p><strong>5、一个类如果没有显示定义赋值运算符重载，编译器也会生成一个，完成对象按字节序的值拷贝</strong></p><h5 id="const成员"><a href="#const成员" class="headerlink" title="const成员"></a>const成员</h5><p>将const修饰的类成员函数称之为<strong>const成员函数</strong>，const修饰类成员函数，实际修饰该函数隐含的this指针，<strong>表明在该成员函数中不能对类的任何成员进行修改</strong></p><h5 id="取地址及const取地址操作符重载"><a href="#取地址及const取地址操作符重载" class="headerlink" title="取地址及const取地址操作符重载"></a>取地址及const取地址操作符重载</h5><p>这两个默认成员函数一般不用重新定义，编译器默认会生成</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"> Date* <span class="keyword">operator</span>&amp;()</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">this</span> ;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">const</span> Date* <span class="keyword">operator</span>&amp;()<span class="keyword">const</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">this</span> ;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line"> <span class="keyword">int</span> _year ; <span class="comment">// 年</span></span><br><span class="line"> <span class="keyword">int</span> _month ; <span class="comment">// 月</span></span><br><span class="line"> <span class="keyword">int</span> _day ; <span class="comment">// 日</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;类与对象-第二部分&quot;&gt;&lt;a href=&quot;#类与对象-第二部分&quot; class=&quot;headerlink&quot; title=&quot;类与对象(第二部分)&quot;&gt;&lt;/a&gt;类与对象(第二部分)&lt;/h3&gt;&lt;h4 id=&quot;类的6个默认成员函数&quot;&gt;&lt;a href=&quot;#类的6个默认成员函数&quot; c
      
    
    </summary>
    
    
      <category term="C++" scheme="https://skrskr66.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++-类与对象</title>
    <link href="https://skrskr66.github.io/2019/05/09/C-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    <id>https://skrskr66.github.io/2019/05/09/C-类与对象/</id>
    <published>2019-05-08T16:10:52.000Z</published>
    <updated>2019-05-14T03:13:15.097Z</updated>
    
    <content type="html"><![CDATA[<h3 id="类与对象-第一部分"><a href="#类与对象-第一部分" class="headerlink" title="类与对象(第一部分)"></a>类与对象(第一部分)</h3><h4 id="类与对象的初步认识"><a href="#类与对象的初步认识" class="headerlink" title="类与对象的初步认识"></a>类与对象的初步认识</h4><p>很多语言都有这方面的区分，比如<strong>C语言是面向过程的语言，关注的是过程</strong>，分析出求解问题的步骤，通过函数调用逐步解决问题。但<strong>是C++是基于面向对象的，关注的是对象</strong>，将一件事情拆分成不同的对象，靠对象之间的交互完成。</p><h4 id="类的引入"><a href="#类的引入" class="headerlink" title="类的引入"></a>类的引入</h4><p>在C语言中，结构体的使用只能定义变量，但是在C++中不一样，不仅可以定义变量还可以定义函数</p><p>但在C++结构体的定义中,更喜欢用classl来代替。</p><h4 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">classname</span>&#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//类体：由成员函数和变量组成</span></span><br><span class="line"></span><br><span class="line">&#125;;<span class="comment">//非常重要的分号</span></span><br></pre></td></tr></table></figure><p><strong>class为定义类的关键字，classname为定义类的名字，{}中为类的主体，注意类定义结束时后面分号</strong></p><p>类中的元素称为类的成员：类中的数据称为<strong>类的属性</strong>或者<strong>成员变量</strong>，类中的函数称为<strong>类的方法</strong>或者<strong>成员函数。</strong></p><h5 id="类的两种定义方法"><a href="#类的两种定义方法" class="headerlink" title="类的两种定义方法"></a>类的两种定义方法</h5><p>1、声明和定义全部放在类体中，需要注意：成员函数如果在类中定义，编译器可能会当成内联函数处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">skrskr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showinfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"I like"</span>&lt;&lt;_sing&lt;&lt;<span class="string">"-"</span>&lt;&lt;_dance&lt;&lt;<span class="string">"-"</span>&lt;&lt;_rap&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span>* _rap;</span><br><span class="line">    <span class="keyword">char</span>* _sing;</span><br><span class="line">    <span class="keyword">char</span>* _dance;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2、声明放在.h文件中，类的定义放在.cpp文件中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//skrskr.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">skrskr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showinfo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    <span class="keyword">char</span>* _rap;</span><br><span class="line">    <span class="keyword">char</span>* _sing;</span><br><span class="line">    <span class="keyword">char</span>* _dance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//skrskr.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"skrskr.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> skrskr::showinfo()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"I like"</span>&lt;&lt;_sing&lt;&lt;<span class="string">"-"</span>&lt;&lt;_dance&lt;&lt;<span class="string">"-"</span>&lt;&lt;_rap&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般情况下，更期望第二种，这种分离的方式，保护性更强</p><h4 id="类的访问限定符及封装"><a href="#类的访问限定符及封装" class="headerlink" title="类的访问限定符及封装"></a>类的访问限定符及封装</h4><h5 id="类的访问限定符"><a href="#类的访问限定符" class="headerlink" title="类的访问限定符"></a>类的访问限定符</h5><p>C++实现封装的方式：<strong>用类将对象的属性与方法结合在一起，让对象更加完善，通过权限选择性的将其接口提供给外部的用户使用</strong></p><p><img src="/2019/05/09/C-类与对象/类1.png" alt="类1"></p><p>访问限定符有三种类型，分别为<strong>公有，保护，私有</strong></p><p>1、public修饰的成员在类外可以直接被访问</p><p>2、protected和private修饰的成员在类外不能直接被访问(此处的protected和private是类似的)</p><p>3、访问权限<strong>作用域从该访问限定符出现的位置开始直到下一个访问限定符出现时为止</strong></p><p>4、class的默认访问权限为private，struct为public(因为public要兼容C)</p><p><strong>注意：访问限定符只在编译时有用，当数据映射到内存后，没有任何访问限定符上的区别</strong></p><p>【面试题~~~】C++中struct和class有什么区别？</p><p>C++需要兼容C语言，所以struct等多当结构体去使用，但是在C++中struct内可以定义函数和class定义类是一样的，区别是struct的成员默认访问方式是public，class的成员默认访问方式是private</p><h5 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h5><p>【面试题~~~】面向对象的三大特性：<strong>封装、继承、多态</strong></p><p>在类和对象阶段，我们更多只了解封装</p><p><strong>封装：将数据和操作数据的方法有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互</strong></p><h4 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h4><p>类定义了一个新的作用域，类的所有成员都在类的作用域中。在类体外的定义成员，需要使用<code>::</code>作用域限制符指明成员属于哪个类域。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">skr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">skrinfo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> _cxk[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">char</span> _wyf[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">int</span> _age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//这里需要指明是属于哪个类中</span></span><br><span class="line"><span class="keyword">void</span> skr::skrinfo()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;_cxk&lt;&lt;<span class="string">"+"</span>&lt;&lt;_wyf&lt;&lt;<span class="string">"is"</span>&lt;&lt;_age&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类的实例化"><a href="#类的实例化" class="headerlink" title="类的实例化"></a>类的实例化</h4><p><strong>用类类型创建对象的过程，称为类的实例化</strong></p><p>1、<strong>类只是一个模型</strong>一样的东西，限定了类有哪些成员，定义出一个类并没有分配实际的内存空间来存储它</p><p>2、一个类可以实例化出多个对象，实例化出的对象，占用实际的物理空间，存储类的成员变量</p><p>3、类实例化出对象就像现实中使用建筑设计图建造出房子，类就像是设计图</p><h4 id="类对象模型"><a href="#类对象模型" class="headerlink" title="类对象模型"></a>类对象模型</h4><p>平时所声明的类只是一种类型定义，它本身是没有大小可言的。 我们这里指的类的大小，其实指的是类的对象所占的大小。因此，如果用sizeof运算符对一个类型名操作，得到的是具有该类型实体的大小。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;    </span></span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span>    </span></span><br><span class="line"><span class="class">&#123;</span>    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;    </span><br><span class="line">    </span><br><span class="line">  &#125;    </span><br><span class="line"><span class="keyword">private</span>:    </span><br><span class="line">  <span class="keyword">int</span> _a;    </span><br><span class="line">&#125;;    </span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span>    </span></span><br><span class="line"><span class="class">&#123;</span>    </span><br><span class="line">  <span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;&#125;    </span><br><span class="line">&#125;;    </span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A3</span>    </span></span><br><span class="line"><span class="class">&#123;</span>&#125;;    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(A1)&lt;&lt;<span class="keyword">sizeof</span>(A2)&lt;&lt;<span class="keyword">sizeof</span>(A3)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;                                                                                                             </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sizeof(A1)=4；sizeof(A2)=1；sizeof(A3)=1</p><h5 id="结构体内存对齐规则"><a href="#结构体内存对齐规则" class="headerlink" title="结构体内存对齐规则"></a>结构体内存对齐规则</h5><p>该规则在之前结构体写到过</p><p>1.第一个成员在与结构体偏移量为0的地址处。 </p><p>2.其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。 </p><p>注意：对齐数 = 编译器默认的一个对齐数 与 该成员大小的较小值。 VS中默认的对齐数为8，gcc中的对齐数为4 </p><p>3.结构体总大小为：最大对齐数（所有变量类型最大者与默认对齐参数取最小）的整数倍。 </p><p>4.如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是 所有最大对齐数（含嵌套结构体的对齐数）的整数倍。</p><h4 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h4><h5 id="this指针的引出"><a href="#this指针的引出" class="headerlink" title="this指针的引出"></a>this指针的引出</h5><p>我们先来定义一个日期类Date</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;_year&lt;&lt;<span class="string">"-"</span>&lt;&lt;_month&lt;&lt;<span class="string">"-"</span>&lt;&lt;_day&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetDate</span><span class="params">(<span class="keyword">int</span> year,<span class="keyword">int</span> month,<span class="keyword">int</span> day)</span></span>&#123;</span><br><span class="line">        _year = year;</span><br><span class="line">        _month = month;</span><br><span class="line">        _day = day;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _year;</span><br><span class="line">    <span class="keyword">int</span> _month;</span><br><span class="line">    <span class="keyword">int</span> _day;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Date d1, d2;</span><br><span class="line">    d1.SetDate(<span class="number">2018</span>,<span class="number">5</span>,<span class="number">14</span>);</span><br><span class="line">    d2.SetDate(<span class="number">2019</span>,<span class="number">5</span>,<span class="number">14</span>);</span><br><span class="line">    d1.Display();</span><br><span class="line">    d2.Display();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上述类，有这样的一个问题：</p><p>Date类中有SetDate与Display这样两个成员函数，函数体中没有关于不同对象的区分，那当d1调用SetDate函数时，该函数是如何知道设置d1对象，而不是设置d2对象呢？</p><p>C++中通过引入this指针解决该问题,即：C<strong>++编译器给每个“成员函数”增加了一个隐藏的指针参数，让该指针指向当前对象(函数运行时调用该函数的对象)，在函数体中所有成员变量的操作，都是通过该指针去访问。只不过所有的操作对用户都是透明的，即用户不需要来传递，编译器自动完成</strong></p><h5 id="this指针的特性"><a href="#this指针的特性" class="headerlink" title="this指针的特性"></a>this指针的特性</h5><p><strong>this指针的类型：类类型* const</strong></p><p>this指针只能在“成员函数”中使用</p><p><strong>this指针本质上其实是一个成员函数的形参，是对象调用成员函数时，将对象地址作为实参传递给this形参。所以对象中不存储this指针。</strong></p><p><strong>this指针是成员函数第一个隐含的指针形参，一般情况由编译器通过exc寄存器自动传递，不需要用户传递</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Display</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;_year&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内置的this指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Display</span><span class="params">(Date* <span class="keyword">this</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">this</span>-&gt;_year&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还要知道<strong>this指针参数则是存放在寄存器中。类的静态成员函数因为没有this指针这个参数，所以类的静态成员函数也就无法调用类的非静态成员变量。</strong> </p><p>那么还有最后一个问题，this指针能否为空指针呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是在某个类中的成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"test"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"change"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;_name&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们调用change()函数时就会出错</p><p>在第一个函数中，没有调用任何函数，可以执行。</p><p>但是在第二个函数中，此时为<code>this（NULL)-&gt;_name</code>，this指针此时为空，那么不能进行空指针的引用。</p><p>根据this的约定中：</p><p><strong>如果参数个数确定，this指针通过ecx传递给被调函数，如果不参数确定，this指针所在的参数被压栈后压入堆栈。</strong> </p><p>所以总结一下，this指针可以为空，当函数内部不需要使用到this指针时，就是说此时不需要通过this指向当前对象并对其进行操作时才可以为空。但是调用的函数需要指向当前对象，并进行操作，则会发生错误，这跟C中调用空指针的引用错误性质一样。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;类与对象-第一部分&quot;&gt;&lt;a href=&quot;#类与对象-第一部分&quot; class=&quot;headerlink&quot; title=&quot;类与对象(第一部分)&quot;&gt;&lt;/a&gt;类与对象(第一部分)&lt;/h3&gt;&lt;h4 id=&quot;类与对象的初步认识&quot;&gt;&lt;a href=&quot;#类与对象的初步认识&quot; cla
      
    
    </summary>
    
    
      <category term="C++" scheme="https://skrskr66.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Linux多线程</title>
    <link href="https://skrskr66.github.io/2019/05/06/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://skrskr66.github.io/2019/05/06/Linux多线程/</id>
    <published>2019-05-06T00:58:25.000Z</published>
    <updated>2019-05-15T08:45:09.612Z</updated>
    
    <content type="html"><![CDATA[<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>越深入的学习之后，经常能听到这么一个词—-多线程。之前的学习经常会提到多进程，父进程在忙不过来的情况下，会创建子进程进行帮忙，这样就是一个多进程的任务。那么什么是多线程呢？</p><h4 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h4><p>在传统的操作系统中，进程就是一个运行中程序的描述信息—-pcb，控制程序的运行。</p><p>在Linux操作系统下，pcb是进程，因为Linux下<strong>线程是以进程pcb模拟实现线程</strong>；也有人称为轻量级进程。但是Linux下没有为线程设计一个pcb来控制线程的运行。</p><p><img src="/2019/05/06/Linux多线程/线程1.png" alt="线程1"></p><p>上图介绍了线程组是个什么组合。</p><h4 id="线程组理解"><a href="#线程组理解" class="headerlink" title="线程组理解"></a>线程组理解</h4><p><strong>进程就是线程组，包含了一个或多个线程</strong></p><p>从上图来看，<strong>Linux线程是PCB，因为CPU调度程序运行是调度pcb，所以线程是CPU调度的基本单位。</strong></p><p><strong>因为进程是线程组，程序运行时，资源是分配给整个线程组的，因此线程是资源分配的基本单位。</strong></p><p>vfork()创建一个子进程共用同一个虚拟地址空间，怕出现调用栈混乱，因此子进程运行完毕或者程序替换后父进程才开始运行。</p><h4 id="多线程和多进程的比较"><a href="#多线程和多进程的比较" class="headerlink" title="多线程和多进程的比较"></a>多线程和多进程的比较</h4><p>多线程和多进程都可以并行多任务，那么哪个执行起来比较好呢</p><p><strong>从线程的角度来看，优点：</strong></p><p>1、一个进程中的线程共用同一个虚拟地址空间</p><p>2、线程间通信更为方便</p><p>3、线程的创建/销毁成本更低</p><p>4、同一个进程间的线程调度成本要更低</p><p>5、执行力度更加细致</p><p><strong>缺点：</strong></p><p>线程缺乏访问控制—-健壮性低。</p><p>比如exit(),异常针对的是整个进程，进程退出，那么线程也就不存在了。这样的话线程的可控性比较低</p><p><strong>共同优点：都可以并发/并行处理任务，提高处理效率</strong></p><p><strong>多进程/多线程进行多任务处理的优势体现与细节：</strong></p><p>CPU密集型程序：程序中都是大量的运算操作</p><p>IO密集型程序：程序中都是大量的IO操作</p><p><strong>共同缺点：对临界资源操作需要考虑的更多，编码更加复杂</strong></p><h4 id="线程创建，线程终止，线程等待，线程分离"><a href="#线程创建，线程终止，线程等待，线程分离" class="headerlink" title="线程创建，线程终止，线程等待，线程分离"></a>线程创建，线程终止，线程等待，线程分离</h4><p>先回顾一下进程创建。在之前的总结中我们通过fork()函数和vfork()函数创建子进程。</p><ul><li><p>fork 是 创建一个子进程，并把父进程的内存数据copy到子进程中。</p></li><li><p>vfork是 创建一个子进程，并和父进程的内存数据share一起用。</p><p>这两个的区别是，一个是copy，一个是share。</p><p>fork函数是在父进程执行到子进程创建的位置，将内存数据拷贝进入，等待子进程执行，子进程执行完后，退出后父进程在继续执行。</p><p>vfork函数是保证子进程先执行，当子进程调用exit()或exec()后，父进程往下执行</p></li></ul><p>操作系统并没有为用户提供直接创建线程的系统调用接口。但是大佬封装了一套库线程控制</p><p>用户创建的进程是一个用户态线程，在内核中对应了一个轻量级进程实现程序的调度运行</p><h5 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">//注意！！！</span></span><br><span class="line"><span class="comment">//注意！！！</span></span><br><span class="line"><span class="comment">//注意！！！</span></span><br><span class="line">因为是库函数，所以编译链接的时候需要加上-pthread/-lpthread链接线程库</span><br><span class="line">pthread_create(<span class="keyword">pthread_t</span> *thread, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr,</span><br><span class="line">                          <span class="keyword">void</span> (start_routine) (<span class="keyword">void</span> *), <span class="keyword">void</span> *arg);</span><br><span class="line"><span class="keyword">pthread_t</span> *thread<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> 输出型参数，获取线程的PID</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr,线程属性，大部分时间都设为<span class="literal">NULL</span></span><br><span class="line"><span class="keyword">void</span>(start_routine)(<span class="keyword">void</span>*)线程入口函数</span><br><span class="line"><span class="keyword">void</span>* arg通过线程入口函数传递给线程的参数作为实参传给函数</span><br><span class="line">返回值：成功返回 <span class="number">0</span>，失败返回 errno&gt;<span class="number">0</span></span><br><span class="line">    </span><br><span class="line">pthread_create（）函数在调用过程中启动一个新线程。新线程通过调用start_routine（）开始执行，arg作为start_routine（）的唯一参数传递。</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_t</span> pthread_self(<span class="keyword">void</span>);</span><br><span class="line">返回调用线程ID；</span><br></pre></td></tr></table></figure><p>线程创建Demo，最近正好学习了C++，将代码都改成了C++的风格</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;                      </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;             </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;                                               </span></span></span><br><span class="line">                 </span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">thr_start</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"I am child thread-----"</span>&lt;&lt;(<span class="keyword">char</span>*)arg&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    sleep(<span class="number">1</span>);   </span><br><span class="line">  &#125;                                  </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;      </span><br><span class="line">&#125;                                                               </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">  <span class="keyword">pthread_t</span> tid;                                                   </span><br><span class="line">  <span class="keyword">int</span> ret = pthread_create(&amp;tid,<span class="literal">NULL</span>,thr_start,(<span class="keyword">void</span>*)<span class="string">"I am hujun!"</span>);</span><br><span class="line">  <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="string">"thread create error"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  sleep(<span class="number">5</span>);      </span><br><span class="line">  pthread_cancel(tid);</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"I am main thread "</span>&lt;&lt; tid &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    sleep(<span class="number">1</span>);    </span><br><span class="line">  &#125;                   </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/05/06/Linux多线程/线程2.png" alt="线程2"></p><p>如图为运行结果</p><p>在新线程创建之后，执行线程函数中的操作。父进程休眠上五秒，此时在这五秒内，线程不断执行操作。在这之后，时间结束后，线程退出，父进程继续执行操作。</p><p>在打印结果中可以看到tid打印的是一串数字，为什么不是地址呢？</p><p>其实打印的<strong>tid是线程地址空间的首地址</strong>，也有其他的说法称为<strong>该线程的真实pid</strong></p><p>通过指令<code>ps -L</code>查看轻量级进程</p><p><img src="/2019/05/06/Linux多线程/线程3.png" alt="线程3"></p><p>可以看到PID和LWP是相同的，这是因为</p><p>此处的PID是线程组ID—-tgid(thread group ID),可以理解为线程组中主线程pid</p><p>此处的LWP显示的就是线程ID，也可以说是tid。</p><p><img src="/2019/05/06/Linux多线程/线程4.png" alt="线程4"></p><h5 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h5><p><strong>在线程入口函数中return；main函数中不能return，否则退出的是进程</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span>* retval)</span></span>;</span><br><span class="line">退出调用线程，retval作为返回值；</span><br><span class="line">主动退出，谁调用谁退出；</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br><span class="line">取消一个指定的线程，被动退出；</span><br></pre></td></tr></table></figure><p><strong>主线程退出，进程并不会退出，线程退出也会成为僵尸线程。线程地址空间无法被回收再利用，造成内存泄漏。</strong></p><p>线程退出Demo</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;                          </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;     </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;             </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thr_start</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;    </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;      </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"child thread----\n"</span>);    </span><br><span class="line">  sleep(<span class="number">1</span>);    </span><br><span class="line">  pthread_exit(<span class="literal">NULL</span>);    </span><br><span class="line">  &#125;      </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;      </span><br><span class="line">  &#125;    </span><br><span class="line">      </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc , <span class="keyword">char</span> *argv[])</span></span>&#123;    </span><br><span class="line">    <span class="keyword">pthread_t</span> tid;    </span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, thr_start,<span class="literal">NULL</span>);    </span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;    </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"thread create error\n"</span>);    </span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//使指定的线程退出tid == thread    </span></span><br><span class="line">    pthread_cancel(tid);    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;    </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"main thread -------\n"</span>);    </span><br><span class="line">      sleep(<span class="number">1</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                      </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/05/06/Linux多线程/线程5.png" alt="线程5"></p><p>打印的结果如上。</p><p>如果根据代码来看，可能会认为线程创建完之后，应该先打印child pthread。但是却不是这样，这是因为对于主函数来说线程创建完成后，它将继续往下走，而重新创建的新线程需要去创建或寻找接口函数等一系列操作。当这些执行完成之后，才打印线程的操作。</p><p>在代码中有pthread_cancel这个函数的使用。<strong>线程取消的方法是向目标线程发Cancel信号（pthread_cancel函数发送Cancel信号），但如何处理Cancel信号则由目标线程自己决定，或者忽略、或者立即终止、或者继续运行至Cancelation-point（取消点），由不同的Cancelation状态（pthread_setcancelstate函数设置状态）决定。</strong> </p><p>所以目标线程选择了退出，之后继续执行主函数的操作</p><h5 id="线程等待"><a href="#线程等待" class="headerlink" title="线程等待"></a>线程等待</h5><p>功能：等待线程退出，获取指定线程的返回值，允许系统回收线程资源</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pthread_join(<span class="keyword">pthread_t</span>, <span class="keyword">void</span> **retval);</span><br><span class="line">要等待的线程id</span><br><span class="line">retval输出型参数-用于获取退出线程的返回值成功返回<span class="number">0</span>，失败返回一个非<span class="number">0</span>值</span><br><span class="line">返回值：<span class="number">0</span>失败：!<span class="number">0</span>---errno</span><br></pre></td></tr></table></figure><p><strong>一个线程创建起来，默认有一个属性：joinable。**</strong>关键！！！！**</p><p>说明:</p><ul><li><p>调用线程将一直阻塞, 直到指定的线程调用pthread_exit, 从启动例程返回或被取消.</p></li><li><p>如果线程从它的启动例程返回, rval_ptr包含返回码.</p></li><li><p>如果线程被取消, 由rval_ptr指定的内存单元置为: PTHREAD_CANCELED.</p></li><li><p>如果对返回值不关心, 可把rval_ptr设为NULL.</p></li></ul><h5 id="线程分离"><a href="#线程分离" class="headerlink" title="线程分离"></a>线程分离</h5><p><strong>将线程的一个属性从joinable设置为detach属性</strong></p><p>功能：分离一个线程，线程退出后系统将自动回收资源；被分离的线程无法被等待，若是非要pthread_join则会直接报错</p><p>man手册说明：<strong>将线程标识的线程标记为已分离。当分离的线程终止时，其资源将自动释放回系统，而不需要另一个线程与终止的线程联接。</strong></p><p><strong>处于detach属性的线程，退出后资源直接自动被回收，这类线程不能被等待</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br><span class="line"><span class="comment">//thread 要被分离的线程ID</span></span><br><span class="line"><span class="comment">//功能：分离一个线程(设置线程的属性从joinable-&gt;detach属性)，线程退出后系统将自动回收资源，被分离的线程无法被等待，若是非要pthread_join则会直接报错返回</span></span><br><span class="line">注意：线程被分离的前提是用户不关心，线程的退出返回值</span><br></pre></td></tr></table></figure><p><strong>线程的分离，对于一个线程来说，任意线程再任意位置调用都可以！！！</strong></p><p><strong>用法：通常如果用户对线程的返回值并不关心，则在创建线程之后直接分离线程或者在线程入口函数中第一时间分离自己</strong></p><p><strong>处于joinable状态的线程退出后不会自动释放资源需要被等待</strong></p><p><strong>处于detach状态的线程退出后系统会自动回收资源并且不需要等待</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个线程等待和线程分离的Demo</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> *<span class="title">thr_start</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="comment">//pthread_detach(pthread_self());</span></span><br><span class="line">    <span class="comment">//pthread_exit((void*)"leihou");</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">"i am thread"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;    </span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, thr_start, <span class="literal">NULL</span>);    </span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;    </span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">"pthread create error"</span>&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">    sleep(<span class="number">1</span>);    </span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, thr_start, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">"pthread create error"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">char</span>* retval = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> err = pthread_join(tid,(<span class="keyword">void</span>**)&amp;retval);</span><br><span class="line">    <span class="keyword">if</span>(err == EINVAL)&#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">"thread can not be waited"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;retval&lt;&lt;endl;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"retval:%s\n"</span>,retval);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">"i am main thread"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>首先将线程创建函数的两个接口注释掉。</p><p>当线程没有退出时，pthread_join函数没有立即返回，主函数继续执行，而且没有retval返回值。</p><p>当添加pthread_exit()函数后，此时线程等待结束退出后立即返回retval返回值“leihou”</p><p>当添加pthread_detach()函数后，此时线程分离当前线程，此时将不再有线程等待这么一个操作，返回值retval此时为NULL，并且分离后资源交由系统回收，此时主函数继续循环执行。</p><p>下一篇好好分析线程安全和各种锁和消费者与生产者模型</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;多线程&quot;&gt;&lt;a href=&quot;#多线程&quot; class=&quot;headerlink&quot; title=&quot;多线程&quot;&gt;&lt;/a&gt;多线程&lt;/h3&gt;&lt;p&gt;越深入的学习之后，经常能听到这么一个词—-多线程。之前的学习经常会提到多进程，父进程在忙不过来的情况下，会创建子进程进行帮忙，这样就
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://skrskr66.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>C++入门</title>
    <link href="https://skrskr66.github.io/2019/05/01/C-%E5%85%A5%E9%97%A8/"/>
    <id>https://skrskr66.github.io/2019/05/01/C-入门/</id>
    <published>2019-05-01T13:13:22.000Z</published>
    <updated>2019-05-07T14:13:36.861Z</updated>
    
    <content type="html"><![CDATA[<p>终于进入了C++的学习。正所谓学好C++，走遍全天下。C++可以说为我打开了新世界。不过数据结构的知识还是得不断地复习啊</p><h4 id="C-关键字"><a href="#C-关键字" class="headerlink" title="C++关键字"></a>C++关键字</h4><p>关键字在C语言中就已经见过了许多比如最常见的if-else，for，int，double等等。只不过在C++中还会遇到更多的，以后会慢慢学习</p><h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p>C++引入命名空间这个概念是因为在我们编程中可能写到大量的函数，比如我在某个头文件中写了abc()这样一个函数，但是在我的另一个库文件中本身就存在abc()这样一个函数。那么我一旦调用就会发生冲突</p><p>所以使用命名空间的目的<strong>是对标识符的名称进行本地化，以避免命名冲突或名字污染</strong>，namespace关键字的出现就是针对这个问题的</p><h5 id="命名空间的定义"><a href="#命名空间的定义" class="headerlink" title="命名空间的定义"></a>命名空间的定义</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通的命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> N1&#123;<span class="comment">//N1为命名空间的名称</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="comment">//命名空间的内容，既可以定义变量，也可以定义函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b + c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//命名空间也可以嵌套</span></span><br><span class="line"><span class="keyword">namespace</span> N1&#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b + c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">namespace</span> N2&#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> b + c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同一个工程中允许存在多个相同名称的命名空间</span></span><br><span class="line"><span class="comment">//编译器最后会合成同一个命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> N1&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Mul</span><span class="params">(<span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b * c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：一定命名空间定义了一个新的作用域，命名空间中的所有内容都局限于该命名空间中</strong></p><h5 id="命名空间的使用"><a href="#命名空间的使用" class="headerlink" title="命名空间的使用"></a>命名空间的使用</h5><p><strong>1、加命名空间名称及作用域限定符</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d/n"</span>,N1::a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、使用using将命名空间中成员引入</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> N1::a;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、使用using namespace命名空间引入</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> N1;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a);</span><br><span class="line">    add(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="C-输入和输出"><a href="#C-输入和输出" class="headerlink" title="C++输入和输出"></a>C++输入和输出</h4><p>学习一门语言最先开始要进行的打招呼仪式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="string">"hello,world"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>cout标准输出</code>和<code>cin标准输入时</code>，必须包含<code>&lt;iostream&gt;</code>头文件以及<strong>std标准命名空间</strong>。</p><p>关于<code>.h</code>：早期标准库将所有功能在全局域中实现，声明在<code>.h</code>的后缀的头文件中，使用时只需要包含对应的头文件即可，后来将其实现在std命名空间下，为了和C头文件区分，也为了正确使用命名空间，规定C++头文件不带<code>.h</code>；旧编译器(VC++6.0)还支持，后续不再支持。现在推荐使用<code>&lt;iostream&gt; + std</code>的方式</p><p>使用c++输入输出更方便，不需增加数据格式控制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;b&gt;&gt;c;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; a &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; b &lt;&lt;<span class="string">" "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/05/01/C-入门/入门1.png" alt="入门1"></p><h4 id="缺省参数"><a href="#缺省参数" class="headerlink" title="缺省参数"></a>缺省参数</h4><p>缺省参数可以理解为备用值。</p><h5 id="缺省参数概念"><a href="#缺省参数概念" class="headerlink" title="缺省参数概念"></a>缺省参数概念</h5><p>缺省参数是声明或定义函数时为函数的参数指定一个默认值。在调用该函数时，如果没有指定实参则采用该默认值，否则使用指定的实参。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;    </span></span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;    </span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(<span class="keyword">int</span> a = <span class="number">9</span>)</span></span>&#123;    </span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">&#125;    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </span><br><span class="line">    </span><br><span class="line">  Func();    </span><br><span class="line">  Func(<span class="number">100</span>);    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;                                                                                                             </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/05/01/C-入门/入门2.png" alt="入门2"></p><h5 id="缺省参数的分类"><a href="#缺省参数的分类" class="headerlink" title="缺省参数的分类"></a>缺省参数的分类</h5><p><strong>全缺省参数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testfunc</span><span class="params">(<span class="keyword">int</span> a = <span class="number">10</span>,<span class="keyword">int</span> b = <span class="number">20</span>,<span class="keyword">int</span> c = <span class="number">30</span>)</span></span>&#123;    </span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"a = "</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"b = "</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"c = "</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>半缺省参数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testfunc2</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b = <span class="number">20</span>,<span class="keyword">int</span> c = <span class="number">30</span>)</span></span>&#123;    </span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"a = "</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"b = "</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"c = "</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>半缺省参数的函数在调用时，必须加上参数a的赋值，否则会报错。</p><p>半缺省参数必须从右往左依次来给，不能间隔着给</p><p>缺省参数不能在函数声明和定义中同时出现，因为当声明与定义位置同时出现，恰巧两个位置提供的值不同，那编译器就无法确认到底该用哪个缺省值</p><p>缺省值必须是常量或者全局变量</p><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><h5 id="函数重载的概念"><a href="#函数重载的概念" class="headerlink" title="函数重载的概念"></a>函数重载的概念</h5><p>函数重载是函数的一种特殊情况，C++允许在同一作用域中声明几个功能类似的同名函数，这些同名函数的形参列表(参数个数 或 类型 或 顺序)必须不同，常用来处理实现功能类似数据类型不同的问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;    </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;    </span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;    </span><br><span class="line">  <span class="keyword">return</span> a + b;    </span><br><span class="line">&#125;    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span>&#123;    </span><br><span class="line">  <span class="keyword">return</span> a + b;    </span><br><span class="line">&#125;    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> a,<span class="keyword">long</span> b)</span></span>&#123;    </span><br><span class="line">  <span class="keyword">return</span> a +b;    </span><br><span class="line">&#125;    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;add(<span class="number">10</span>,<span class="number">20</span>)&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;add(<span class="number">10.0</span>,<span class="number">20.0</span>)&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;add(<span class="number">10L</span>,<span class="number">20L</span>)&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;                      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然函数名都是一样的，但是参数传参的类型不同。当在调用的时候，编译器检查到参数的不同，对应到相应的函数中，这样就可以实现不同类型的计算了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面两个函数，虽然参数不同，但是函数类型已经确定了返回值，这样的话函数不管参数给什么都没法实现不同类型的计算，就不存在重载的意义了</span></span><br><span class="line"><span class="function"><span class="keyword">short</span> <span class="title">Add</span><span class="params">(<span class="keyword">short</span> left, <span class="keyword">short</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> left+right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">short</span> left, <span class="keyword">short</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> left+right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="名字修饰"><a href="#名字修饰" class="headerlink" title="名字修饰"></a>名字修饰</h5><p>在C++中，一个程序要运行起来，需要经历以下几个阶段：<strong>预处理，编译，汇编，链接</strong></p><p><strong>而名字修饰是一种在编译过程中，将函数、变量的名称重新改编的机制，简单来说就是编译器为了区分各个函数，将函数通过某种算法，重新修饰为一个全局唯一的名称</strong></p><p>C语言的名字修饰比较简单，就直接在函数名前面加了一个下划线。比如<code>add</code>修饰为<code>_add</code></p><p>但C++不同，由于C++要支持重载，命名空间等，使得其修饰规则比较复杂，不同编译器在底层的实现方式可能都有差异</p><p>名字的修饰过程不必深入了解，只需知道被重新修饰后的名字中包含了：<strong>函数的名字以及参数类型</strong>，这就是为什么函数重载中几个同名函数要求其参数列表不同。</p><p>Linux下我们通过指令反汇编来查看<code>objdump -d a.out &gt;log.txt</code></p><p><img src="/2019/05/01/C-入门/入门3.png" alt="入门3"></p><p>我们可以看到三个很相似的名字，<code>_Z3addii</code>，<code>_Z3adddd</code>,<code>_Z3addll</code></p><p>但是仔细观察它们的最后两个字母都不相同，这代表了参数类型不同。分别是int，double，long</p><p>但是它们的规制是一样的”<strong>返回类型+函数名+参数列表</strong>“</p><p>这也可以解释了为什么C语言中不支持函数重载，因为在函数编译过程中，C语言并不能将同名不同参数的函数<strong>名字修饰</strong>，所以它没法支持函数重载。</p><h5 id="extern“C”"><a href="#extern“C”" class="headerlink" title="extern“C”"></a>extern“C”</h5><p>有时候在C++工程中可能需要<strong>将某些函数按照C的风格来编译</strong>，在函数前加extern “C”，意思是告诉编译器，将该函数按照C语言规则来编译。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> Add(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以编译通过，但是链接时出现错误</span></span><br></pre></td></tr></table></figure><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><h5 id="引用的概念"><a href="#引用的概念" class="headerlink" title="引用的概念"></a>引用的概念</h5><p><strong>引用不是新定义一个变量，而是给已存在的变量取了一个别名，编译器不会为引用变量开辟内存空间，它和引用的变量共用同一块内存空间</strong></p><p><code>类型&amp; 引用变量名(对象名) = 引用实体</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestRef</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; ra = a;<span class="comment">//&lt;====定义引用类型</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;ra);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>引用类型必须和引用实体是同种类型的</strong></p><h5 id="引用特性"><a href="#引用特性" class="headerlink" title="引用特性"></a>引用特性</h5><p>1、引用在定义时必须初始化</p><p>2、一个变量可以有多个引用</p><p>3、引用一旦引用一个实体，再不能引用其他实体</p><h5 id="常引用"><a href="#常引用" class="headerlink" title="常引用"></a>常引用</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestConstRef</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//int&amp; ra = a;   // 该语句编译时会出错，a为常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; ra = a;</span><br><span class="line"><span class="comment">// int&amp; b = 10; // 该语句编译时会出错，b为常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; b = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">12.34</span>;</span><br><span class="line"><span class="comment">//int&amp; rd = d; // 该语句编译时会出错，类型不同</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; rd = d;<span class="comment">//这样引用类型可以，但是返回值是int类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>int const&amp;表示此引用所代表的int类型变量无法使用此引用修改.</strong></p><p><strong>const int&amp;表示此引用所代表的是const int类型变量,同样也无法用此引用修改.</strong> </p><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>&amp; ret = Add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    Add(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Add(1, 2) is :"</span>&lt;&lt; ret &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行这段代码时，输出应该是3，但是输出的结果是7</p><p><img src="/2019/05/01/C-入门/入门4.png" alt="入门4"></p><p><strong>这是因为再函数返回时，离开函数作用域后，其栈上空间已经还给了系统，因此不能用栈上的空间作为引用类型返回。如果以引用类型返回，返回值的生命周期必须不受函数的限制(即比函数生命周期长)</strong></p><p>再来看这段代码，ret第一次引用之后为3，但是函数离开了作用域后，栈上的空间被归还了。但此时又调用了一次这个函数，栈上的空间可能还为上一次使用的区域，此时ret就为7了。</p><h5 id="引用和指针的区别"><a href="#引用和指针的区别" class="headerlink" title="引用和指针的区别"></a>引用和指针的区别</h5><p>在语法概念上引用就是一个别名，没有独立空间，和其引用实体共用同一块空间</p><p>但是在底层实现上实际是有空间的，因为引用按照指针方式实现的</p><p><strong>引用和指针的不同点</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1. </span>引用在定义时必须初始化，指针没有要求</span><br><span class="line"><span class="bullet">2. </span>引用在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向任何一个同类型实</span><br><span class="line">体</span><br><span class="line"><span class="bullet">3. </span>没有NULL引用，但有NULL指针</span><br><span class="line"><span class="bullet">4. </span>在sizeof中含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节个数(32位平台下占4</span><br><span class="line">个字节)</span><br><span class="line"><span class="bullet">5. </span>引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小</span><br><span class="line"><span class="bullet">6. </span>有多级指针，但是没有多级引用</span><br><span class="line"><span class="bullet">7. </span>访问实体方式不同，指针需要显式解引用，引用编译器自己处理</span><br><span class="line"><span class="bullet">8. </span>引用比指针使用起来相对更安全</span><br></pre></td></tr></table></figure><h4 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h4><p>以<strong>inline修饰</strong>的函数叫做内联函数，编译时C++编译器会在调用内联函数的地方展开，没有函数压栈的开销，内联函数提升程序运行的效率。</p><p>内联是一种空间换时间的做法，省去调用函数额开销。所以代码很长或者有循环/递归的函数不适宜使用作为内联函数。</p><p><img src="/2019/05/01/C-入门/入门5.png" alt="入门5"></p><p>如果在上述函数前增加inline关键字将其改成内联函数，在编译期间编译器会用函数体替换函数的调用。 </p><p>编译器在不同的模式下查看有区别：</p><p>在release模式下，查看编译器生成的汇编代码中是否存在call Add </p><p>在debug模式下，需要对编译器进行设置，否则不会展开 </p><h4 id="auto关键字"><a href="#auto关键字" class="headerlink" title="auto关键字"></a>auto关键字</h4><p>C++11中，标准委员会赋予了auto全新的含义：<strong>auto不再是一个存储类型指示符，而是作为一个新的类型指示符来指示编译器，auto声明的变量必须由编译器在编译时期推导而得</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//simple demo</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">auto</span> b = a;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="string">"b is "</span>&lt;&lt; b &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意！！</strong></p><p><strong>注意！！</strong></p><p><strong>注意！！</strong></p><p><strong>使用auto定义变量时必须对其进行初始化，在编译阶段编译器需要根据初始化表达式来推导auto的实际类型。因此auto并非是一种“类型”声明，而是一个类型声明时的“占位符”，编译器在编译期间会将auto替换为变量实际的类型</strong></p><h5 id="auto使用规则"><a href="#auto使用规则" class="headerlink" title="auto使用规则"></a>auto使用规则</h5><p><strong>1、auto与指针和引用结合起来使用</strong></p><p>用auto声明指针类型时，用auto和auto*没有任何区别，但用auto声明引用类型时，则必须加&amp;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> b = a;</span><br><span class="line"><span class="keyword">auto</span>* c = &amp;a;</span><br><span class="line"><span class="keyword">auto</span>&amp; d = a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"b is "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、在同一行定义多个变量</strong></p><p>当在同一行声明多个变量时，这些变量必须是相同的类型，否则编译器将会报错，因为编译器实际只对第一个类型进行推导，然后用推导出来的类型其他变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> a = <span class="number">1</span>,b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">auto</span> c = <span class="number">3</span>,d = <span class="number">4.0</span>;<span class="comment">//编译会失败，因为c和d的初始化表达式类型不同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>auto不能推导的场景</strong></p><p>1、auto不能作为函数的参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestAuto</span><span class="params">(<span class="keyword">auto</span> a)</span></span>&#123;</span><br><span class="line">    pass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>上面代码是不能编译通过的，auto不能作为形参类型，因为编译器无法对a的实际类型进行推导</strong></p><p>2、auto不能直接用来声明数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestAuto</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> b[] = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、auto不能定义类的非静态成员变量</p><p>4、实例化模板时不能使用auto作为模板参数</p><h4 id="基于范围的for循环-C-11"><a href="#基于范围的for循环-C-11" class="headerlink" title="基于范围的for循环(C++11)"></a>基于范围的for循环(C++11)</h4><h5 id="范围for的语法"><a href="#范围for的语法" class="headerlink" title="范围for的语法"></a>范围for的语法</h5><p>在C++98如果要遍历一个数组，可以按照以下方式进行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestFor</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="keyword">sizeof</span>(<span class="built_in">array</span>)/<span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]);++p)&#123;</span><br><span class="line">        <span class="built_in">array</span>[i] *= <span class="number">2</span>；</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>* p = <span class="built_in">array</span>;p &lt; <span class="built_in">array</span> + <span class="keyword">sizeof</span>(<span class="built_in">array</span>)/<span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]);++p)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; *p &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++是一个追求极致性能的语言，在有范围的数组中，由程序员来说明循环的范围是多余的，有时还会容易犯错误。<strong>for循环后的括号由冒号”:”分为两部分，第一部分是范围内用于迭代的变量，第二部分则表示被迭代的范围</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestFor</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; e : <span class="built_in">array</span>)</span><br><span class="line">        e *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> e : <span class="built_in">array</span>)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; e &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="范围for的使用条件"><a href="#范围for的使用条件" class="headerlink" title="范围for的使用条件"></a>范围for的使用条件</h5><p><strong>1、for循环迭代的范围必须是确定的</strong></p><p><strong>对于数组而言，就是数组中第一个元素和最后一个元素的范围</strong>；对于类而言，应该提供begin和end的方法，begin和end就是for循环迭代的范围</p><p>比如如下代码，数组作为形参传入时，这时候的循环条件是不确定的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestFor</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; e : <span class="built_in">array</span>)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; e &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、迭代的对象要实现++和==的操作</p><h4 id="指针空值nullptr"><a href="#指针空值nullptr" class="headerlink" title="指针空值nullptr"></a>指针空值nullptr</h4><p>在C语言中，我们一般定义一个空指针是<code>int *p = NULL</code>或者<code>int *p = 0</code></p><p>两者的意思基本上是相似的。不过NULL实际上是一个宏</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL ((void*) 0)</span></span><br></pre></td></tr></table></figure><p>在头文件的定义中，一般是这样的。可以看到，NULL可能被定义为字面常量0，或者被定义为无类型指针(void*)0)</p><p>比如在函数中想调用int*的函数，但是NULL被定义成0，因此与程序的初衷相悖</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;<span class="string">"f(int)"</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>*)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;<span class="string">"f(int*)"</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> f(<span class="number">0</span>); </span><br><span class="line"> f(<span class="literal">NULL</span>); </span><br><span class="line"> f((<span class="keyword">int</span>*)<span class="literal">NULL</span>); </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="nullptr和nullptr-t"><a href="#nullptr和nullptr-t" class="headerlink" title="nullptr和nullptr_t"></a>nullptr和nullptr_t</h5><p>为了考虑兼容性，C++11并没有消除常量0的二义性，C++11给出了全新的nullptr表示空值指针。C++11为什么 </p><p>不在NULL的基础上进行扩展，这是因为NULL以前就是一个宏，而且不同的编译器厂商对于NULL的实现可能 </p><p>不太相同，而且直接扩展NULL，可能会影响以前旧的程序。因此：为了避免混淆，C++11提供了nullptr， </p><p>即：nullptr代表一个指针空值常量。nullptr是有类型的，其类型为nullptr_t，仅仅可以被隐式转化为指针类 </p><p>型，nullptr_t被定义在头文件中： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(<span class="literal">nullptr</span>)</span> nullptr_t</span>;</span><br></pre></td></tr></table></figure><p><strong>注意！！！</strong> </p><p><strong>注意！！！</strong> </p><p><strong>注意！！！</strong> </p><p><strong>1.在使用nullptr表示指针空值时，不需要包含头文件，因为nullptr是C++11作为新关键字引入的。</strong> </p><p><strong>2.在C++11中，sizeof(nullptr) 与 sizeof((void*)0)所占的字节数相同。</strong> </p><p><strong>3.为了提高代码的健壮性，在后续表示指针空值时建议最好使用nullptr</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;终于进入了C++的学习。正所谓学好C++，走遍全天下。C++可以说为我打开了新世界。不过数据结构的知识还是得不断地复习啊&lt;/p&gt;
&lt;h4 id=&quot;C-关键字&quot;&gt;&lt;a href=&quot;#C-关键字&quot; class=&quot;headerlink&quot; title=&quot;C++关键字&quot;&gt;&lt;/a&gt;C+
      
    
    </summary>
    
    
      <category term="C++" scheme="https://skrskr66.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程信号</title>
    <link href="https://skrskr66.github.io/2019/04/23/Linux%E8%BF%9B%E7%A8%8B%E4%BF%A1%E5%8F%B7/"/>
    <id>https://skrskr66.github.io/2019/04/23/Linux进程信号/</id>
    <published>2019-04-23T10:26:30.000Z</published>
    <updated>2019-04-30T16:28:36.282Z</updated>
    
    <content type="html"><![CDATA[<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><h4 id="信号概念"><a href="#信号概念" class="headerlink" title="信号概念"></a>信号概念</h4><p>通知进程发生了某件事情导致了软件中断—-会打断当前的阻塞操作，去处理事情</p><h4 id="信号的种类"><a href="#信号的种类" class="headerlink" title="信号的种类"></a>信号的种类</h4><p>信号有不同的种类，每个信号都对应了不同的事件</p><p>通过命令行<code>kill -l</code>可以查看信号的种类</p><p><img src="/2019/04/23/Linux进程信号/信号1.png" alt="信号1"></p><p>在图中可以看到这些都是信号的种类，总共有62个种信号</p><p>1-31—-&gt;每个都有各自对应的事件        非可靠信号/非实时信号</p><p>34-64—-&gt;后续添加的信号                可靠信号/非可靠信号</p><p>信号的生命周期：产生—–&gt;注册(注册在进程当中)—–&gt;注销(在进程中注销)—–&gt;处理</p><p><strong>信号是在软件层次上对中断机制的一种模拟，在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。信号是异步的，一个进程不必通过任何操作来等待信号的到达，事实上，进程也不知道信号到底什么时候到达。</strong></p><p>信号是进程间通信机制中唯一的异步通信机制，可以看作是异步通知，通知接收信号的进程有哪些事情发生了。信号机制经过POSIX实时扩展后，功能更加强大，除了基本通知功能外，还可以传递附加信息。</p><h5 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h5><p>我自己也是在写的过程中才发觉不了解同步与异步，所以也补充一下</p><p><strong>同步：就是发出一个功能调用时，在没有得到结果之前，该调用就不返回或继续执行后续操作</strong></p><p><strong>异步：当一个异步过程调用发出后，调用者在没有得到结果之前，就可以继续执行后续操作。当这个调用完成后，一般通过状态、通知和回调来通知调用者。对于异步调用，调用的返回并不受调用者控制</strong></p><h5 id="信号的产生"><a href="#信号的产生" class="headerlink" title="信号的产生"></a>信号的产生</h5><p>硬件产生：ctrl+c，ctrl+|，ctrl+z。通过键盘强行关闭，比如在一个无限循环中，使用键盘组合按键将该进程强行停掉。</p><p>软件产生：kill -signo pid 命令 产生一个信号</p><p>比如利用while写上一个死循环程序</p><p><img src="/2019/04/23/Linux进程信号/信号2.png" alt="信号2"></p><p>查询到进程的pid，利用软件产生的方法杀死这个进程</p><p><img src="/2019/04/23/Linux进程信号/信号4.png" alt="信号4"></p><p>当杀死之后就可以看到程序终止</p><p><img src="/2019/04/23/Linux进程信号/信号3.png" alt="信号3"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid，<span class="keyword">int</span> sig)</span></span></span><br><span class="line">给指定进程发送指定信号</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line">给调用进程发送信号</span><br><span class="line">这两个函数都是成功返回<span class="number">0</span>,错误返回<span class="number">-1</span>。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">abort</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line">给调用进程发送SIGABRT</span><br><span class="line">就像<span class="built_in">exit</span>函数一样,<span class="built_in">abort</span>函数总是会成功的,所以没有返回值。</span><br><span class="line"></span><br><span class="line">unsigned int alarm(unsigned int sconds)；</span><br><span class="line">sconds秒之后给调用进程发送SIGALRM信号</span><br><span class="line">返回值上一个定时器剩余的时间或<span class="number">0</span>，参数为<span class="number">0</span>，取消定时器，返回剩余的时间</span><br><span class="line">可以结合 sleep() 来使用</span><br></pre></td></tr></table></figure><h4 id="信号的注册"><a href="#信号的注册" class="headerlink" title="信号的注册"></a>信号的注册</h4><p>信号的记录在pcb中。在操作系统中有一个结构体叫<code>sigset_t{}</code> ,它是一个位图。</p><p><img src="/2019/04/23/Linux进程信号/信号5.png" alt="信号5"></p><p>如图，在pcb中专门有一个pending结构体存储当前收到的信号，还有一个结构体block结构体专门存储现在都有哪些信号要被阻塞。handler是用户自定义信号的处理方式</p><h5 id="信号注册"><a href="#信号注册" class="headerlink" title="信号注册"></a>信号注册</h5><p>通过修改pending未决信号集合(位图)中对应信号位+添加信号sigqueue节点</p><p>sigqueue是信号发送函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigqueue</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig, <span class="keyword">const</span> <span class="keyword">union</span> sigval val)</span></span></span><br><span class="line">调用成功返回 0；否则，返回 -1。</span><br><span class="line"></span><br><span class="line">sigqueue()是比较新的发送信号系统调用，主要是针对实时信号提出的（当然也支持前<span class="number">32</span>种），支持信号带有参数，与函数sigaction()配合使用。</span><br><span class="line"></span><br><span class="line">sigqueue的第一个参数是指定接收信号的进程ID，第二个参数确定即将发送的信号，第三个参数是一个联合数据结构<span class="keyword">union</span> sigval，指定了信号传递的参数，即通常所说的<span class="number">4</span>字节值。</span><br></pre></td></tr></table></figure><p><strong>非可靠信号注册</strong>：判断信号集合位图相应位是否为1；若为0，为信号组织sigqueue节点添加到链表中，并且pending位图置1；若为1(信号已经注册过还没有被处理)，则什么都不做(等于丢弃)。</p><p>判断是否有相同的未决信号，若有，则什么也不做(事件丢失)；否则，修改位图(sigset_t)，添加节点</p><p><img src="/2019/04/23/Linux进程信号/信号6.png" alt="信号6"></p><hr><p><strong>可靠信号注册</strong>：不管信号是否为1，阻止节点，添加到sigqueue链表中，并且位图置1(信号不会丢弃)</p><p>判断是否有相同未决信号，若没有，修改位图(sigset_t)，添加到节点，否则直接添加节点</p><p>可靠信号的注册跟上图的模式是相似的，只是不管是否为1，都阻止节点</p><h4 id="信号的注销"><a href="#信号的注销" class="headerlink" title="信号的注销"></a>信号的注销</h4><p>删除信号的sigqueue节点，并且修改pending位图。</p><p><strong>非可靠信号的注销</strong>：因为非可靠信号的信号节点只有一个，因此删除节点，位图直接置0。</p><p>直接删除节点，修改位图(非可靠信号只会注册一次)</p><p><strong>可靠信号的注销</strong>：因为可靠信号的信号节点可能会有多个，若还有相同信号节点，则位图依然置1，否则置0</p><p>删除节点，判断是否还有相同节点。若有，则位图依然置1，否则修改位图置0</p><p>也可以这样理解，只要存在相同的信号节点，那么位图永远置1。只要没有相同的，则置为0</p><h4 id="信号的处理"><a href="#信号的处理" class="headerlink" title="信号的处理"></a>信号的处理</h4><p>信号的处理有三种方式：</p><h5 id="默认处理方式"><a href="#默认处理方式" class="headerlink" title="默认处理方式"></a>默认处理方式</h5><p>操作系统(内核)既定的处理方式—-SIG_DFL，可能是以下的某种类型：</p><p><strong>Treminate</strong>：进程被终止(杀死)</p><p><strong>Dump</strong>：进程被终止(杀死)，如果可能，创建包含进程执行上下文的核心转储文件(core dump)</p><p><strong>Ignore</strong>：信号被忽略</p><p><strong>Stop</strong>：进程被停止，即把进程置为TASK_STOPPED状态</p><p><strong>Continue</strong>：如果进程被禁止，就把它设置为TASK_RUNNING状态</p><h5 id="忽略处理方式"><a href="#忽略处理方式" class="headerlink" title="忽略处理方式"></a>忽略处理方式</h5><p>这与默认中的忽略是不同的，该处理方式处理了信号，但是什么都没有做。</p><h5 id="自定义处理方式"><a href="#自定义处理方式" class="headerlink" title="自定义处理方式"></a>自定义处理方式</h5><p>通过调用相应的信号处理函数捕捉信号。</p><p><strong>注意！！</strong></p><p><strong>注意！！</strong></p><p><strong>注意！！</strong></p><p><strong>有两个信号SIGKILL -9 SIGSTOP -19 无法被阻塞，无法自定义，无法被忽略</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">信号的捕捉初识</span><br><span class="line">      <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">sighandler_t</span> signal(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler);</span><br><span class="line">      signum: 信号编号</span><br><span class="line">      handler：   函数指针</span><br><span class="line">              SIG_DFL     默认处理方式</span><br><span class="line">              SIG_IGN     忽略处理方式</span><br><span class="line">      使用handler函数替换signum信号的处理方式</span><br></pre></td></tr></table></figure><p>我们利用man手册来了解该函数的用处</p><p><strong>函数的作用是:从三种方式中选择一种接收信号sig的方式。如果func的值是SIG_DFL，则将对该信号进行默认处理。如果func的值为SIG_IGN，则忽略该信号。否则，应用程序应确保func指向信号发生时要调用的函数。由于信号而调用这样一个函数，或者(递归地)调用该调用的任何其他函数(标准库中的函数除外)，称为“信号处理程序”。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#inlcude <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigcb</span><span class="params">(<span class="keyword">int</span> signo)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"---------\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    signal(SIGINT, sigcb);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"hello ~~~"</span>\n);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/23/Linux进程信号/信号7.png" alt="信号7"></p><p>通过调用signal函数来改变信号的处理方式。平时使用<code>ctrl+c</code>将强制退出软件，但是当这次使用将不在执行</p><p>SIGINT： 程序中止信号，在用户键入INTR字符（通常是Ctrl+C）时发出。 </p><p>此时信号的处理将SIGINT改变成打印一段———，所以最后退出用了<code>ctrl+|</code>才得以退出</p><h5 id="信号自定义处理方式的流程"><a href="#信号自定义处理方式的流程" class="headerlink" title="信号自定义处理方式的流程"></a>信号自定义处理方式的流程</h5><p>用户态切换到内核态运行，完毕后准备从内核态切换到用户态运行的时候，去处理信号。若信号为默认/忽略处理，则在内核中直接完成，但是如果是自定义处理方式，则需要返回用户态执行信号回调函数，完毕后回到内核态，没有信号了则回到程序主流程</p><p><img src="/2019/04/23/Linux进程信号/信号8.png" alt="信号8"></p><p>还有一个处理函数</p><p><code>int sigaction(int sig, const struct sigaction *restrict act,struct sigaction *restrict oact)</code></p><p>sigaction参数结构如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line"><span class="keyword">void</span> (*sa_handler)(<span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">void</span> (*sa_sigaction)(<span class="keyword">int</span>, <span class="keyword">siginfo_t</span> *, <span class="keyword">void</span> *);</span><br><span class="line"><span class="keyword">sigset_t</span> sa_mask;</span><br><span class="line"><span class="keyword">int</span> sa_flags;</span><br><span class="line"><span class="keyword">void</span> (*sa_restorer)(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>函数的作用是:允许调用过程检查指定与特定信号相关联的操作</strong></p><p>使用act动作替换原有的处理动作，并且将原有处理动作拷贝到oldact中。不过这个需要等一下再说</p><h4 id="信号的阻塞"><a href="#信号的阻塞" class="headerlink" title="信号的阻塞"></a>信号的阻塞</h4><h5 id="信号的一些其他概念"><a href="#信号的一些其他概念" class="headerlink" title="信号的一些其他概念"></a>信号的一些其他概念</h5><p>信号递达：实际执行信号的处理动作</p><p>信号未决：信号从产生到递达之间的状态</p><h5 id="信号阻塞概念"><a href="#信号阻塞概念" class="headerlink" title="信号阻塞概念"></a>信号阻塞概念</h5><p>暂时阻止信号被递达(处理)。<strong>信号依然可以注册，只是暂时不处理，解除阻塞之后才会处理</strong></p><h5 id="信号阻塞的过程"><a href="#信号阻塞的过程" class="headerlink" title="信号阻塞的过程"></a>信号阻塞的过程</h5><p>在pcb的block-信号阻塞集合中(程序初始化的时候)标记要阻塞的信号，到来之后暂不处理,将blocked位图集合中对应的位-置1，表示阻塞这个信号，直到被解除阻塞(从block集合中移除)</p><h5 id="信号阻塞的接口"><a href="#信号阻塞的接口" class="headerlink" title="信号阻塞的接口"></a>信号阻塞的接口</h5><p><strong>sigprocmask：阻塞/解除阻塞信号</strong></p><p>sigprocmask()用于获取 (与/或) 更改调用线程的信号掩码。信号掩码是一组信号，它的传递目前被调用方阻塞</p><p>SET_BLOCK 将信号添加到阻塞集合中 block = block | set</p><p>SET_UNBLOCK 将信号从阻塞集合中移出 block = block &amp; ~set</p><p>SET_SETMASK 被阻塞的信号集被设置为参数集。block = set</p><p><strong>sigemptyset：清空信号集合</strong></p><p><strong>sigfillset：向集合中添加所有信号</strong></p><p><strong>sigaddset：向集合中添加指定的信号</strong></p><p><strong>sigismember：判断信号是否在集合中</strong></p><p><strong>sigdelset：从集合中移除执行信号</strong></p><p><strong>sigpending：后获取未决信号</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>,  <span class="title">oldact</span>;</span>    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigcb</span><span class="params">(<span class="keyword">int</span> signo)</span></span>&#123;    </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"revc signo:%d\n"</span>, signo);    </span><br><span class="line">  sigaction(signo, &amp;oldact, <span class="literal">NULL</span>);                                                                                      </span><br><span class="line">&#125;    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </span><br><span class="line">  act.sa_handler = sigcb;    </span><br><span class="line">  act.sa_flags = <span class="number">0</span>;    </span><br><span class="line">    </span><br><span class="line">  sigemptyset(&amp;act.sa_mask);    </span><br><span class="line">  sigaction(SIGINT, &amp;act, &amp;oldact);    </span><br><span class="line">    </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"---------\n"</span>);    </span><br><span class="line">    sleep(<span class="number">2</span>);    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/23/Linux进程信号/信号9.png" alt="信号9"></p><p>接着之前的另一个处理信号的方法，先将sigaction中参数结构的成员都设置完，之后将信号集合中的信号全部清空。act动作是handler自定义函数，这时候替换了<code>ctrl+c</code>操作。在sigcb函数中再次调用sigaction，此时act动作将继续执行SIGINT。执行结果如上图</p><h4 id="可重入和不可重入函数"><a href="#可重入和不可重入函数" class="headerlink" title="可重入和不可重入函数"></a>可重入和不可重入函数</h4><h5 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h5><p>在并发编程中，这种由于不恰当的执行时序而出现不正确的结果是一种非常严重的情况。因为运行时序而造成的数据竞争，导致数据的二义性。这样的情况，我们称为竞态条件。</p><h5 id="函数的重入和不可重入"><a href="#函数的重入和不可重入" class="headerlink" title="函数的重入和不可重入"></a>函数的重入和不可重入</h5><p>一个函数是否可以在多个运行时序中重复调用而不会出现任何问题，在一个函数中是否进行了对全局数据的非原子性操作。</p><p><strong>重入函数：</strong>在多个时序的运行中重复调用，不会造成异常影响。比如在某个函数的调用中，还没有返回时就再次进入该函数，就称为重入。</p><p><strong>不可重入函数：</strong>不能再多个时序中重复调用，比如malloc和free函数。如果随意的调用则会发生内存泄漏。</p><h4 id="SIGCHLD信号"><a href="#SIGCHLD信号" class="headerlink" title="SIGCHLD信号"></a>SIGCHLD信号</h4><p>子进程退出，通知父进程的信号。</p><p>在僵尸进程中，我们之前设置的是通过wait/waitpid函数去设置怎么避免僵尸进程产生，但是这样父进程就必须一直等待，无法做其他的事情了。所以这时候采用信号机制，非阻塞地查询是否有子进程结束等待清理。</p><p>在子进程终止时会给父进程发SIGCHLD信号，该信号的默认处理动作是忽略，父进程可以自定义SIGCHLD信号的处理函数，这样父进程只需专心处理自己的工作，不必关心子进程了，子进程终止时会通知父进程，父进程在信号处理函数中调用wait函数清理子进程即可。</p><p>用户需要循环非阻塞处理子进程退出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sigcb()&#123;</span><br><span class="line">    <span class="keyword">while</span>(waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WONOHANG) &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为SIGCHLD信号是一个非可靠信号，大量子进程同时退出的情况下，有可能丢失事件，因此要在一次调用中，把能处理掉的僵尸进程都处理掉。</p><p>代码测试</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;                   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> sig)</span>    </span></span><br><span class="line"><span class="function">  </span>&#123;    </span><br><span class="line">    <span class="keyword">pid_t</span> id;    </span><br><span class="line">    <span class="keyword">while</span>( (id = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG)) &gt; <span class="number">0</span> )&#123;    </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"wait child success: %d\n"</span>, id);    </span><br><span class="line">      </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child is quit! %d\n"</span>, getpid());    </span><br><span class="line">      </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function">  </span>&#123;    </span><br><span class="line">    signal(SIGCHLD, handler);    </span><br><span class="line">    <span class="keyword">pid_t</span> cid;    </span><br><span class="line">    <span class="keyword">if</span>((cid = fork()) == <span class="number">0</span>)&#123;<span class="comment">//child    </span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"child : %d\n"</span>, getpid());    </span><br><span class="line">      sleep(<span class="number">3</span>);    </span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;    </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"father proc is doing some thing!\n"</span>);    </span><br><span class="line">      sleep(<span class="number">1</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;信号&quot;&gt;&lt;a href=&quot;#信号&quot; class=&quot;headerlink&quot; title=&quot;信号&quot;&gt;&lt;/a&gt;信号&lt;/h3&gt;&lt;h4 id=&quot;信号概念&quot;&gt;&lt;a href=&quot;#信号概念&quot; class=&quot;headerlink&quot; title=&quot;信号概念&quot;&gt;&lt;/a&gt;信号概念&lt;/h
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://skrskr66.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程间通信</title>
    <link href="https://skrskr66.github.io/2019/04/20/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>https://skrskr66.github.io/2019/04/20/Linux进程间通信/</id>
    <published>2019-04-20T08:27:21.000Z</published>
    <updated>2019-04-22T06:57:26.043Z</updated>
    
    <content type="html"><![CDATA[<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>一般简称为IPC—-InterProcess Communication。是指在不同进程之间传播或交换信息。</p><p>进程间通信有这么几个方式：管道（命名管道/匿名管道），共享队列，消息队列，信号量</p><p><strong>进程间为什么要通信呢？</strong></p><p>因为进程的独立性，因此想要通信必须能够共同访问一个相同的媒介。</p><p><strong>进程间通信的目的</strong>：数据传输，数据共享，进程间的访问控制。</p><p>也正因为通信的目的不同，使用场景不同，因此操作系统提供了多种进程间通信方式：</p><p><strong>管道—-传输数据</strong></p><p><strong>共享内存—-共享数据</strong></p><p><strong>消息队列—-传输数据</strong></p><p><strong>信号量—-进程间的访问控制</strong></p><h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>管道是半双工通信，双向选择的单向通信（即数据只能在一个方向上流动），具有固定的读端和写端</p><p>它是<strong>进程间的数据资料传输</strong>。在通信过程中，<strong>先将数据放到buf中，在将数据拷贝到自己的buf中在进行操作</strong></p><p><img src="/2019/04/20/Linux进程间通信/通信1.png" alt="通信1"></p><p><strong>管道生命周期随进程，如果进程消亡了，那么通信也就结束了</strong></p><h5 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> pipefd[<span class="number">2</span>])</span></span>;</span><br><span class="line"><span class="comment">//pipefd输出型参数</span></span><br><span class="line"><span class="comment">//数组pipefd用于返回引用结尾的两个文件描述符。</span></span><br><span class="line"></span><br><span class="line">pipefd[<span class="number">0</span>] 从管道读数据</span><br><span class="line">pipefd[<span class="number">1</span>] 从管道写数据</span><br><span class="line"></span><br><span class="line">如果成功，则返回 <span class="number">0</span>；不成功，则返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p><strong>只能用于具有亲缘关系的进程间通信</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;    </span></span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </span><br><span class="line">  <span class="keyword">int</span> pipefd[<span class="number">2</span>];    </span><br><span class="line">  <span class="keyword">int</span> ret = pipe(pipefd);    </span><br><span class="line">  <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;    </span><br><span class="line">    perror(<span class="string">"pipe error"</span>);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="keyword">int</span> pid = fork();    </span><br><span class="line">  <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;    </span><br><span class="line">    perror(<span class="string">"fork error"</span>);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;    </span><br><span class="line">    close(pipefd[<span class="number">1</span>]);    </span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;    </span><br><span class="line">    sleep(<span class="number">1</span>);    </span><br><span class="line">    close(pipefd[<span class="number">1</span>]);    </span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;    </span><br><span class="line">    <span class="keyword">int</span> ret = read(pipefd[<span class="number">0</span>], buf, <span class="number">1023</span>);    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"read buf:[%d - %s]\n"</span>,ret, buf);    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先建立管道，之后再创建子进程。这个时候就要考虑到管道的读写特性了</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">若管道中没有数据，则read会阻塞，直到读到数据返回</span><br><span class="line">若管道中数据写满了，则write会阻塞，直到数据被读取，管道中有空闲位置，写入数据后返回</span><br><span class="line"></span><br><span class="line">若管道中所有的读端都被关闭，则write会触发异常----SIGPIPE(信号标志)----导致进程退出</span><br><span class="line">若管道中的所有写有写端都被关闭，则read返回0----通知用户没人写了</span><br><span class="line"></span><br><span class="line">父子进程两端都要进行关闭</span><br></pre></td></tr></table></figure><p>所以代码中将管道中写端关闭了，所以读端返回的是0.</p><p><img src="/2019/04/20/Linux进程间通信/通信2.png" alt="通信2"></p><p><strong>虽然管道提供了双向选择，但是如果我们没有用到某一端，就把这一端关闭掉</strong></p><h5 id="管道同步与互斥特性"><a href="#管道同步与互斥特性" class="headerlink" title="管道同步与互斥特性"></a>管道同步与互斥特性</h5><p>当读写数据的大小&lt;管道pipe_buf ，是保证操作原子性—–这时操作不可被打断</p><p>互斥：保证对一个临界资源（公共资源，比如全局变量）同一时间的唯一访问性（我操作的时候你不能操作）</p><p>同步：保证对一个临界资源访问的时序可控性（我操作完了你才能操作）</p><p><code>|</code>管道符就是匿名访问</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;                               </span><br><span class="line">  <span class="keyword">int</span> pipefd[<span class="number">2</span>];                          </span><br><span class="line">  <span class="keyword">int</span> ret = pipe(pipefd);                 </span><br><span class="line">  <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;                            </span><br><span class="line">    perror(<span class="string">"pipe error"</span>);                 </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;                            </span><br><span class="line">  &#125;                                       </span><br><span class="line">  <span class="keyword">int</span> pid1 = fork();                      </span><br><span class="line">  <span class="keyword">if</span>(pid1 == <span class="number">0</span>)&#123;                          </span><br><span class="line">    close(pipefd[<span class="number">0</span>]);<span class="comment">//关闭从管道读数据    </span></span><br><span class="line">    dup2(pipefd[<span class="number">1</span>],<span class="number">1</span>);<span class="comment">//将文件描述符表中 向管道写数据 替换 标准输出    </span></span><br><span class="line">    execlp(<span class="string">"ps"</span>,<span class="string">"ps"</span>,<span class="string">"-ef"</span>,<span class="literal">NULL</span>);<span class="comment">//程序替换    </span></span><br><span class="line">  &#125;                                       </span><br><span class="line">  <span class="keyword">int</span> pid2 = fork();                      </span><br><span class="line">  <span class="keyword">if</span>(pid2 == <span class="number">0</span>)&#123;                          </span><br><span class="line">    close(pipefd[<span class="number">1</span>]);                     </span><br><span class="line">    dup2(pipefd[<span class="number">0</span>],<span class="number">0</span>);                    </span><br><span class="line">    execlp(<span class="string">"grep"</span>,<span class="string">"grep"</span>,<span class="string">"ssh"</span>,<span class="literal">NULL</span>);     </span><br><span class="line">  &#125;                                       </span><br><span class="line">  close(pipefd[<span class="number">0</span>]);<span class="comment">//不用的时候将读端和写端都关闭    </span></span><br><span class="line">  close(pipefd[<span class="number">1</span>]);    </span><br><span class="line">  waitpid(pid1,<span class="literal">NULL</span>,<span class="number">0</span>);    </span><br><span class="line">  waitpid(pid2,<span class="literal">NULL</span>,<span class="number">0</span>);    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>grep读数据时不知道自己需要多少数据，过滤之后再次读取。</p><p>代码用图示来解答一下</p><p><img src="/2019/04/20/Linux进程间通信/通信3.png" alt="通信3"></p><h5 id="命名管道-FIFO"><a href="#命名管道-FIFO" class="headerlink" title="命名管道(FIFO)"></a>命名管道(FIFO)</h5><p>FIFO是一种文件类型，可以用于任意进程间通信。</p><p>可见于文件系统，因为创建命名管道会随之在文件系统中创建一个命名管道文件</p><p>类似于在进程中使用文件来传输数据，只不过FIFO类型文件同时具有管道的特性</p><p>因为所有的进程都能够通过打开管道文件，进而获取管道的操作句柄，因此命名管道可以用于同一主机上任意进程间通信</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line">pathname:管道文件名</span><br><span class="line">mode:创建权限 <span class="number">0664</span></span><br></pre></td></tr></table></figure><p>fifo_read.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;    </span></span></span><br><span class="line">      </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </span><br><span class="line">  <span class="keyword">char</span> *file = <span class="string">"./test.fifo"</span>;    </span><br><span class="line">  umask(<span class="number">0</span>);    </span><br><span class="line">  <span class="keyword">int</span> ret = mkfifo(file, <span class="number">0664</span>);    </span><br><span class="line">  <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;    </span><br><span class="line">    <span class="keyword">if</span>(errno != EEXIST)&#123;    </span><br><span class="line">      perror(<span class="string">"mkfifo errno"</span>);    </span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"open file\n"</span>);    </span><br><span class="line">  <span class="keyword">int</span> fd = open(file, O_RDWR);    </span><br><span class="line">  <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;    </span><br><span class="line">    perror(<span class="string">"open error"</span>);                </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"open success!!\n"</span>);    </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;    </span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;    </span><br><span class="line">    <span class="keyword">int</span> ret = read(fd, buf, <span class="number">1023</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"read buf:[%s]\n"</span>, buf);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"write closed~~~\n"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      perror(<span class="string">"read error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"---------\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  close(fd);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fifo_write.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *file = <span class="string">"./test.fifo"</span>;</span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = mkfifo(file,<span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ret != EEXIST)&#123;</span><br><span class="line">            perror(<span class="string">"mkfifo error"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"open file\n"</span>);</span><br><span class="line">    <span class="keyword">int</span> fd = open(file, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">"open error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"open success!!\n"</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, buf);</span><br><span class="line">        write(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/20/Linux进程间通信/通信4.png" alt="通信4"></p><p>这有点类似于服务器–客户端之间建立连接</p><p>fifo_write类似于客服端发送一个请求 fifo_read类似于服务器返回一个请求</p><p>命名管道利用了文件系统创建文件进行通信。当write写入了数据，将数据从自己的buf写到test.fifo文件中，之后read在将数据从test.fifo中读取到自己的buf中，最后输出。</p><h5 id="命名管道的读写特性"><a href="#命名管道的读写特性" class="headerlink" title="命名管道的读写特性"></a>命名管道的读写特性</h5><p>若管道没有被以写的方式打开，这时如果只读打开则会阻塞，直到文件被以写的方式打开</p><p>若管道没有被以读的方式打开，这时如果只写打开则会阻塞，直到文件被以读的方式打开</p><p>若管道以读写的方式打开，则不会阻塞    </p><h5 id="匿名管道和命名管道的区别"><a href="#匿名管道和命名管道的区别" class="headerlink" title="匿名管道和命名管道的区别"></a>匿名管道和命名管道的区别</h5><p>匿名管道：速度慢，容量有限，只有父进程进程能通讯</p><p>命名管道：任何进程间都能通讯，但速度慢</p><h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p>共享内存的定义：在物理上开辟一块空间，<strong>内存直接映射到虚拟内存中，如果一块内存被多个进程映射，那么多个进程访问同一块内存，则可以实现通信。</strong> 是<strong>最快的</strong>进程间通信。因为相较于其他进程间通信方式(将数据从用户态拷贝到内核态，用的时候，从内核态拷贝到用户态)，共享内存直接将一块内存映射到用户空间，用户可以直接通过地址对内存进行操作，并反馈到其他进程，少了两步数据拷贝的过程。</p><h5 id="共享内存使用流程"><a href="#共享内存使用流程" class="headerlink" title="共享内存使用流程"></a>共享内存使用流程</h5><p>1、创建/打开共享内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> shmflg)</span></span>;</span><br><span class="line">    key:    共享内存标识符</span><br><span class="line">    size：  共享内存大小</span><br><span class="line">    shmflg：打开方式/创建权限</span><br><span class="line">    IPC_CREAT 共享内存不存在则创建</span><br><span class="line">    IPC_EXCL 与IPC_CREAT同用，若存在则报错，不存在则创建</span><br><span class="line">    返回值：操作句柄shmid失败：<span class="number">-1</span></span><br><span class="line"><span class="keyword">key_t</span> ftok(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> proj_id);</span><br><span class="line">    pathname:   文件名</span><br><span class="line">    proj_id：   数字</span><br><span class="line">    通过文件的 inode节点号 和 proj_id 共同得出一个key值</span><br></pre></td></tr></table></figure><p>2、将共享内存映射到虚拟地址空间(建立映射关系)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span> *shmaddr, <span class="keyword">int</span> shmflg)</span></span>;</span><br><span class="line">shmid:创建共享内存返回的操作句柄</span><br><span class="line">shmaddr：用于指定映射在虚拟空间的首地址通常置<span class="literal">NULL</span></span><br><span class="line">    shmflg：<span class="number">0</span>----可读可写</span><br><span class="line">    返回值：映射首地址（通过这个地址对共享内存进行操作)失败：（<span class="keyword">void</span>*)<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>3、对共享内存进行基本的内存操作，memcpy</p><p>4、解除映射关系    shmdt</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *shmaddr)</span></span></span><br><span class="line">shamddr:映射返回的首地址</span><br></pre></td></tr></table></figure><p>5、删除共享内存    shmctl</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">int</span> cmd, struct shmid_ds *buf)</span></span>;</span><br><span class="line">shmid:操作句柄</span><br><span class="line">cmd：IPC_RMID删除共享内存</span><br><span class="line">buf：设置或者获取共享内存信息，用不着置<span class="literal">NULL</span></span><br><span class="line">共享内存并不是立即删除的，只是拒绝后续映射连接，当共享内存</span><br><span class="line">映射连接数为<span class="number">0</span>时，则删除共享内存</span><br></pre></td></tr></table></figure><p>shm_read.c</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPC_KEY 0x12345678</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROJ_ID 12345</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHM_SIZE  4096</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> shmid;    </span><br><span class="line">  <span class="comment">//1、创建共享内存    </span></span><br><span class="line">  shmid = shmget(IPC_KEY, SHM_SIZE, IPC_CREAT|<span class="number">0666</span>);    </span><br><span class="line">  <span class="keyword">if</span>(shmid &lt; <span class="number">0</span>)&#123;    </span><br><span class="line">    perror(<span class="string">"shmget error"</span>);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="comment">//2、将共享内存映射到虚拟地址空间    </span></span><br><span class="line">  <span class="keyword">char</span> *shm_start = (<span class="keyword">char</span>*)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);    </span><br><span class="line">  <span class="keyword">if</span>(shm_start == (<span class="keyword">void</span>*)<span class="number">-1</span>)&#123;    </span><br><span class="line">    perror(<span class="string">"shmat error"</span>);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, shm_start);    </span><br><span class="line">    sleep(<span class="number">1</span>);    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="comment">//4、解除映射    </span></span><br><span class="line">  shmdt(shm_start);    </span><br><span class="line">  <span class="comment">//5、删除共享内存    </span></span><br><span class="line">  shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>shm_write.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPC_KEY 0x12345678    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROJ_ID 12345    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHM_SIZE  4096    </span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </span><br><span class="line">  <span class="keyword">int</span> shmid;    </span><br><span class="line">  <span class="comment">//1、创建共享内存    </span></span><br><span class="line">  shmid = shmget(IPC_KEY, SHM_SIZE, IPC_CREAT|<span class="number">0666</span>);    </span><br><span class="line">  <span class="keyword">if</span>(shmid &lt; <span class="number">0</span>)&#123;    </span><br><span class="line">    perror(<span class="string">"shmget error"</span>);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="comment">//2、将共享内存映射到虚拟地址空间    </span></span><br><span class="line">  <span class="keyword">char</span> *shm_start = (<span class="keyword">char</span>*)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);    </span><br><span class="line">  <span class="keyword">if</span>(shm_start == (<span class="keyword">void</span>*)<span class="number">-1</span>)&#123;    </span><br><span class="line">    perror(<span class="string">"shmat error"</span>);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;    </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;    </span><br><span class="line">    <span class="built_in">sprintf</span>(shm_start, <span class="string">"明天又是可以学习的一天！！！+%d\n"</span>,i++);    </span><br><span class="line">    sleep(<span class="number">1</span>);    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//4、解除映射</span></span><br><span class="line">  shmdt(shm_start);</span><br><span class="line">  <span class="comment">//5、删除共享内存</span></span><br><span class="line">  shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/20/Linux进程间通信/通信5.png" alt="通信5"></p><p>共享内存双方都可以修改</p><p>共享内存没有同步与互斥</p><p>删除一块共享内存，并不会立即删除，而是判断映射连接数，若为0则删除，不为0则拒绝后续连接，直到为0删除</p><h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p>消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。 </p><p>消息队列的建立过程为</p><p>创建消息队列—-&gt;添加数据节点—-&gt;获取数据节点—-&gt;删除</p><p>msgget—-&gt;msgsnd—-&gt;msgrcv(接收数据)—-&gt;msgctl</p><p>消息队列传输的是有类型的数据块，用户可以根据自己的需要选择性的获取某些数据类型</p><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>内核中的一个计数器—-具有等待队列(PCB等待队列)，具有等待和唤醒功能</p><p>用于资源计数，若计数小于等于0，表示没有资源，则需要等待</p><p>若计数大于0，表示有资源，则可以获取资源，然后计数-1</p><p>如果放置了资源，则计数+1，并且唤醒等待的进程</p><p>实现进程间的同步和互斥（资源计数为0或1的时候才具有互斥）</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>消息队列和信号量现在的使用不是特别多，了解一下就可以。重点还是共享内存和管道的学习。</p><p>在代码过程中，我们应该可以感觉到，这种通信方式有点类似于服务器和客户端之间的处理过程。但是具体的实现是不同的。</p><p>匿名管道是通过对读端和写端的关闭和开启，在buf缓存区对数据进行拷贝和使用。</p><p>而命名管道是通过文件系统的打开和关闭，将数据进行读写。读写必须同时打开，否则另一端会被阻塞。</p><p>而共享内存是在同一个地址映射的一块虚拟地址被多个进程访问，这时也就是多个进程同时访问同一个内存。此时共享内存直接映射一块内存到用户空间，用户直接通过地址对内存进行操作，并反馈到其他进程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;进程间通信&quot;&gt;&lt;a href=&quot;#进程间通信&quot; class=&quot;headerlink&quot; title=&quot;进程间通信&quot;&gt;&lt;/a&gt;进程间通信&lt;/h3&gt;&lt;p&gt;一般简称为IPC—-InterProcess Communication。是指在不同进程之间传播或交换信息。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://skrskr66.github.io/tags/Linux/"/>
    
  </entry>
  
</feed>
