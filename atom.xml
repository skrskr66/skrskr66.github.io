<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>程序程</title>
  
  <subtitle>为了梦想的skr</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://skrskr66.github.io/"/>
  <updated>2019-06-06T07:31:29.343Z</updated>
  <id>https://skrskr66.github.io/</id>
  
  <author>
    <name>Lyc</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux网络套接字编程(2)</title>
    <link href="https://skrskr66.github.io/2019/06/06/Linux%E7%BD%91%E7%BB%9C%E5%A5%97%E6%8E%A5%E5%AD%97%E7%BC%96%E7%A8%8B-2/"/>
    <id>https://skrskr66.github.io/2019/06/06/Linux网络套接字编程-2/</id>
    <published>2019-06-06T07:18:12.000Z</published>
    <updated>2019-06-06T07:31:29.343Z</updated>
    
    <content type="html"><![CDATA[<h3 id="TCP传输"><a href="#TCP传输" class="headerlink" title="TCP传输"></a>TCP传输</h3><h4 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;TCP传输&quot;&gt;&lt;a href=&quot;#TCP传输&quot; class=&quot;headerlink&quot; title=&quot;TCP传输&quot;&gt;&lt;/a&gt;TCP传输&lt;/h3&gt;&lt;h4 id=&quot;TCP的三次握手&quot;&gt;&lt;a href=&quot;#TCP的三次握手&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://skrskr66.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络编程套接字</title>
    <link href="https://skrskr66.github.io/2019/06/06/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%A5%97%E6%8E%A5%E5%AD%97/"/>
    <id>https://skrskr66.github.io/2019/06/06/Linux网络编程套接字/</id>
    <published>2019-06-06T03:49:33.000Z</published>
    <updated>2019-06-06T07:16:35.616Z</updated>
    
    <content type="html"><![CDATA[<h3 id="网络编程套接字"><a href="#网络编程套接字" class="headerlink" title="网络编程套接字"></a>网络编程套接字</h3><h4 id="udp传输"><a href="#udp传输" class="headerlink" title="udp传输"></a>udp传输</h4><h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h5><p>1、创建套接字 socket()</p><p>2、为套接字绑定地址 bind()</p><p>3、发送数据（如果socket还没有绑定地址，这时候操作系统会选择一个合适的地址端口进行绑定）</p><p>4、接收数据</p><p>5、关闭套接字</p><h5 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h5><p>1、创建套接字，通过创建套接字使进程与网卡建立联系，创建struct socket{…}</p><p>2、为套接字绑定地址信息</p><p>3、接收数据</p><p>4、发送数据</p><p>5、关闭套接字</p><h4 id="创建套接字"><a href="#创建套接字" class="headerlink" title="创建套接字"></a>创建套接字</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line">domin: 地址域</span><br><span class="line"><span class="function">AF_INET             IPv4 Internet protocols          <span class="title">ip</span><span class="params">(<span class="number">7</span>)</span></span></span><br><span class="line"><span class="function">AF_INET6            IPv6 Internet protocols          <span class="title">ipv6</span><span class="params">(<span class="number">7</span>)</span></span></span><br><span class="line">type：套接字类型</span><br><span class="line">SOCK_STREAM流式套接字，默认协议TCP，不支持UDP</span><br><span class="line">SOCK_DGRAM数据报套接字，默认协议UDP，不支持TCP</span><br><span class="line">protocol:协议类型</span><br><span class="line"><span class="number">0</span>：使用默认套接字协议</span><br><span class="line"><span class="number">6</span>/IPPOTO_TCPTCP协议</span><br><span class="line"><span class="number">17</span>/IPPOTO_UDPUDP协议</span><br><span class="line">返回值：套接字操作句柄-文件描述符失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><h4 id="为套接字绑定地址"><a href="#为套接字绑定地址" class="headerlink" title="为套接字绑定地址"></a>为套接字绑定地址</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> socket, <span class="keyword">const</span> struct sockaddr *address,<span class="keyword">socklen_t</span> address_len)</span></span>;</span><br><span class="line">bind（）函数应将本地套接字地址地址分配给由描述符套接字标识的套接字，该套接字没有分配本地套接字地址.使用socket（）函数创建的套接字最初是未命名的;它们仅由其地址族标识。</span><br><span class="line"></span><br><span class="line">socket:套接字文件描述符</span><br><span class="line">sockaddr：地址信息</span><br><span class="line">addrlen：地址信息长度</span><br><span class="line"></span><br><span class="line">返回值：<span class="number">0</span>失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><h5 id="详细了解地址家族"><a href="#详细了解地址家族" class="headerlink" title="详细了解地址家族"></a>详细了解地址家族</h5><p>在bind函数中我们看到了sockaddr这个关键的地址家族。通过man手册只能找到少量的描述。通过查找资料找到了一些，再此做出总结</p><p>一般我们使用<strong>struct sockaddr</strong>和<strong>struct sockaddr_in</strong>这两个结构体用来处理网络通信的地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> sa_family;    <span class="comment">//2 </span></span><br><span class="line">    <span class="keyword">char</span> sa_data[<span class="number">14</span>];     <span class="comment">//14</span></span><br><span class="line">&#125;;  </span><br><span class="line">该结构体的缺陷为sa_data[]把目标地址和端口信息混在一起了</span><br><span class="line">上面是通用的socket地址，具体到Internet socket，用下面的结构，二者可以进行类型转换</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span>sin_family;<span class="comment">//地址族</span></span><br><span class="line">    <span class="keyword">uint16_t</span>sin_port;<span class="comment">//16位TCP/UCP端口号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span><span class="title">sin_addr</span>;</span><span class="comment">//32位IP地址</span></span><br><span class="line">    <span class="keyword">char</span>sin_zero[<span class="number">8</span>];<span class="comment">//不使用</span></span><br><span class="line">&#125;</span><br><span class="line">在这个结构体中存在另一个结构体，该结构体一般用来存放<span class="number">32</span>位IP地址</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    In_addr_ts_addr;<span class="comment">//32位IPV4地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sin_port和sin_addr都必须是网络字节序（NBO），一般可视化的数字都是主机字节序（HBO）。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">一般用法</span><br><span class="line"><span class="keyword">int</span> sockfd;  </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>   <span class="title">my_addr</span>;</span>  <span class="comment">//赋值时用这个结构</span></span><br><span class="line">sockfd = socket(AF_INET,   SOCK_STREAM,   <span class="number">0</span>);      </span><br><span class="line">my_addr.sin_family   =   AF_INET;     </span><br><span class="line">my_addr.sin_port   =   htons(MYPORT);     </span><br><span class="line">my_addr.sin_addr.s_addr   =   inet_addr(<span class="string">"192.168.0.1"</span>);     </span><br><span class="line">bzero(&amp;(my_addr.sin_zero),   <span class="number">8</span>);         </span><br><span class="line">bind(sockfd,   (struct   sockaddr   *)&amp;my_addr,   <span class="keyword">sizeof</span>(struct   sockaddr));</span><br><span class="line"><span class="comment">//用(struct   sockaddr   *)转换即满足要求</span></span><br></pre></td></tr></table></figure><p>还有网络上另一个其他解释</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr 是一个通用地址结构，这是为了统一地址结构的表示方法，统一接口函数，使不同的地址结构可以被bind() , connect() 等函数调用；struct sockaddr<span class="emphasis">_in中的in 表示internet，就是网络地址，这只是我们比较常用的地址结构，属于AF_</span>INET地址族，他非常的常用，以至于我们都开始讨论它与 struct sockaddr通用地址结构的区别。</span><br></pre></td></tr></table></figure><h4 id="接收数据"><a href="#接收数据" class="headerlink" title="接收数据"></a>接收数据</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> recvfrom(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</span><br><span class="line">                        struct sockaddr *src_addr, <span class="keyword">socklen_t</span> *addrlen);</span><br><span class="line"></span><br><span class="line">sockfd:套接字文件描述符</span><br><span class="line">buf:用buf存储接收的数据</span><br><span class="line">len:想要接收的数据长度</span><br><span class="line">flags：<span class="number">0</span>---默认阻塞接收</span><br><span class="line">src_addr：发送端地址信息</span><br><span class="line">addrlen：地址信息长度，不但要指定想接收多长，还要保存实际接受了多长</span><br><span class="line">返回值：实际接收的长度失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><h4 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> sendto(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags,</span><br><span class="line">                      <span class="keyword">const</span> struct sockaddr *dest_addr, <span class="keyword">socklen_t</span> addrlen);</span><br><span class="line">sockfd:套接字文件描述符</span><br><span class="line">buf:要发送的数据</span><br><span class="line">len:要发送的数据长度</span><br><span class="line">flags:<span class="number">0</span>---默认阻塞发送</span><br><span class="line">dest_addr:目的段地址信息--标识数据要发送到哪里去</span><br><span class="line">addrlen:地址信息长度</span><br><span class="line">返回值：实际发送的长度失败返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><h4 id="关闭套接字"><a href="#关闭套接字" class="headerlink" title="关闭套接字"></a>关闭套接字</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line">这个在Linux文件操作符中已经了解到了，文件描述符用完之后需要被关闭</span><br></pre></td></tr></table></figure><h4 id="UDP传输Demo"><a href="#UDP传输Demo" class="headerlink" title="UDP传输Demo"></a>UDP传输Demo</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//UdpSocket.hpp</span></span><br><span class="line"><span class="comment">//实现以UdpSocket类封装udp常用操作 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UdpSocket</span>&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        UdpSocket():_sock(<span class="number">-1</span>)&#123;&#125;</span><br><span class="line">        ~UdpSocket()&#123;&#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">Socket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            _sock = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);</span><br><span class="line">            <span class="keyword">if</span> (_sock &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                perror(<span class="string">"socket error"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">Bind</span><span class="params">(<span class="built_in">string</span> &amp;ip, <span class="keyword">uint16_t</span> port)</span> </span>&#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">addr</span>;</span><span class="comment">//定义一个结构体名称为addr，是socket地址</span></span><br><span class="line">            <span class="comment">//in 表示internet，就是网络地址</span></span><br><span class="line">            <span class="comment">//sin_family指代协议族，在socket编程中只能是AF_INET</span></span><br><span class="line">            <span class="comment">//sin_port存储端口号（使用网络字节顺序）</span></span><br><span class="line">            <span class="comment">//sin_addr存储IP地址，使用in_addr这个数据结构</span></span><br><span class="line">            </span><br><span class="line">            addr.sin_family = AF_INET;<span class="comment">//ipv4</span></span><br><span class="line">            <span class="comment">//uint16_t htons(uint16_t hostshort);</span></span><br><span class="line">            </span><br><span class="line">            addr.sin_port = htons(port);<span class="comment">//htons是将整型变量从主机字节顺序转变成网络字节顺序， </span></span><br><span class="line">                                <span class="comment">//就是整数在地址空间存储方式变为高位字节存放在内存的低地址处。</span></span><br><span class="line">            <span class="comment">//in_addr_t inet_addr(const char *cp);</span></span><br><span class="line">            </span><br><span class="line">            addr.sin_addr.s_addr = inet_addr(ip.c_str());<span class="comment">//inet_addr是一个计算机函数，</span></span><br><span class="line">            <span class="comment">//addr.sin_addr.s_addr = INADDR_ANY;</span></span><br><span class="line">            <span class="comment">//      功能是将一个点分十进制的IP转换成一个长整数型数（u_long类型）等同于inet_addr()。</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">            <span class="comment">//int bind(int sockfd, struct sockaddr *addr, </span></span><br><span class="line">            <span class="comment">//  socklen_t addrlen);</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> ret = bind(_sock, (struct sockaddr*)&amp;addr, len);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                perror(<span class="string">"bind error"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">Recv</span><span class="params">(<span class="built_in">string</span> &amp;buf, struct sockaddr_in *saddr)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//ssize_t recvfrom(int sockfd, void *buf, size_t len, </span></span><br><span class="line">            <span class="comment">//int flags, struct sockaddr *src_addr, socklen_t *addrlen);</span></span><br><span class="line">            <span class="keyword">char</span> tmp[<span class="number">1500</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">            <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(struct sockaddr_in);</span><br><span class="line">            <span class="keyword">int</span> ret = recvfrom(_sock, tmp, <span class="number">1500</span>, <span class="number">0</span>, </span><br><span class="line">                    (struct sockaddr*)saddr, &amp;len);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                perror(<span class="string">"recvfrom error"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            buf.assign(tmp, ret);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">Send</span><span class="params">(<span class="built_in">string</span> &amp;buf, struct sockaddr_in *daddr)</span></span>&#123;</span><br><span class="line">            <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(struct  sockaddr_in);</span><br><span class="line">            <span class="keyword">int</span> ret = sendto(_sock, buf.c_str(), buf.size(), <span class="number">0</span>, </span><br><span class="line">                    (struct sockaddr*)daddr, len);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                perror(<span class="string">"sendto error"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">Close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            close(_sock);</span><br><span class="line">            _sock = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> _sock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这之外，上面的头文件中还有几个其他接口函数，需要了解</p><p><strong>htons()作用是将端口号由主机字节序转换为网络字节序的整数值。(host to net)</strong> </p><p><strong>inet_addr()作用是将一个IP字符串转化为一个网络字节序的整数值，用于sockaddr_in.sin_addr.s_addr。</strong> </p><p>数字的字节序转换：</p><p>​    主机字节序转换为网络字节序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span>htonl(<span class="keyword">uint32_t</span>hostlong)</span><br><span class="line"><span class="keyword">uint16_t</span>htons(<span class="keyword">uint16_t</span>hostshort)</span><br></pre></td></tr></table></figure><p>​    网络字节序转换为主机字节序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span>ntohl(<span class="keyword">uint32_t</span>hostlong)</span><br><span class="line"><span class="keyword">uint16_t</span>ntohs(<span class="keyword">uint16_t</span>hostshort)</span><br></pre></td></tr></table></figure><p>将点分十进制ip地址转换为网络字节序ip地址：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">in_addr <span class="title">inet_addr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> af,<span class="keyword">const</span> <span class="keyword">char</span> *src,<span class="keyword">void</span> *dst)</span></span></span><br></pre></td></tr></table></figure><p>将网络字节序IP地址转换为点分十进制IP地址：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> af,<span class="keyword">const</span> <span class="keyword">void</span>* src,<span class="keyword">char</span> *dst,<span class="keyword">socklen_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">inet_ntoa</span><span class="params">(struct in_addr in)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="udp服务端"><a href="#udp服务端" class="headerlink" title="udp服务端"></a>udp服务端</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"udpsocket.hpp"</span>    </span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHECK_RET(q) <span class="meta-keyword">if</span>((q) == false)&#123;return -1;&#125;    </span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">  <span class="keyword">if</span>(argc != <span class="number">3</span>)    </span><br><span class="line">  &#123;    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"./udp_server ip port:"</span>&lt;&lt;<span class="built_in">endl</span>;                                                                                </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="built_in">string</span> ip = argv[<span class="number">1</span>];    </span><br><span class="line">  <span class="keyword">uint16_t</span> port = atoi(argv[<span class="number">2</span>]);    </span><br><span class="line">    </span><br><span class="line">  UdpSocket sock;    </span><br><span class="line">  CHECK_RET(sock.Socket());    </span><br><span class="line">  CHECK_RET(sock.Bind(ip,port));    </span><br><span class="line">    </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)    </span><br><span class="line">  &#123;    </span><br><span class="line">    <span class="built_in">string</span> buf;    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">cli_addr</span>;</span>    </span><br><span class="line">    CHECK_RET(sock.Recv(buf,&amp;cli_addr));    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"client say:"</span>&lt;&lt;buf&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"server say:"</span>;    </span><br><span class="line">    fflush(<span class="built_in">stdout</span>);    </span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;buf;                               </span><br><span class="line">    CHECK_RET(sock.Send(buf,&amp;cli_addr));</span><br><span class="line">  &#125; </span><br><span class="line">  sock.Close();             </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="udp客户端"><a href="#udp客户端" class="headerlink" title="udp客户端"></a>udp客户端</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"udpsocket.hpp"</span>    </span></span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHECK_RET(q) <span class="meta-keyword">if</span>((q) == false)&#123;return -1;&#125;    </span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[])</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">  <span class="keyword">if</span>(argc != <span class="number">3</span>)    </span><br><span class="line">  &#123;    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"./udp_client ip port"</span>&lt;&lt;<span class="built_in">endl</span>;                                                                                 </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="built_in">string</span> ip = argv[<span class="number">1</span>];    </span><br><span class="line">  <span class="keyword">uint16_t</span> port = atoi(argv[<span class="number">2</span>]);    </span><br><span class="line">    </span><br><span class="line">  UdpSocket sock;    </span><br><span class="line">  CHECK_RET(sock.Socket());    </span><br><span class="line">    </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">srv_addr</span>;</span>    </span><br><span class="line">  srv_addr.sin_family = AF_INET;    </span><br><span class="line">  srv_addr.sin_port = htons(port);    </span><br><span class="line">  srv_addr.sin_addr.s_addr = inet_addr(ip.c_str());    </span><br><span class="line">    </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)    </span><br><span class="line">  &#123;    </span><br><span class="line">    <span class="built_in">string</span> buf;    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"client say:"</span>;    </span><br><span class="line">    fflush(<span class="built_in">stdout</span>);    </span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;buf;                         </span><br><span class="line">    CHECK_RET(sock.Send(buf,&amp;srv_addr));               </span><br><span class="line">    CHECK_RET(sock.Recv(buf,&amp;srv_addr));</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"server say"</span>&lt;&lt;buf&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">  &#125;                </span><br><span class="line">  sock.Close();             </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/06/06/Linux网络编程套接字/网络1.png" alt="网络1"></p><p>两边聊天如上图</p><p>udp的传输速度快，无连接，不可靠，面向数据报这个必须牢牢记住了。</p><p>但是在代码中有个bug存在，发送的数据如果有空格，那么数据就会产生截断，分成两次发送</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;网络编程套接字&quot;&gt;&lt;a href=&quot;#网络编程套接字&quot; class=&quot;headerlink&quot; title=&quot;网络编程套接字&quot;&gt;&lt;/a&gt;网络编程套接字&lt;/h3&gt;&lt;h4 id=&quot;udp传输&quot;&gt;&lt;a href=&quot;#udp传输&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://skrskr66.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>C++-模板初了解</title>
    <link href="https://skrskr66.github.io/2019/06/04/C-%E6%A8%A1%E6%9D%BF%E5%88%9D%E4%BA%86%E8%A7%A3/"/>
    <id>https://skrskr66.github.io/2019/06/04/C-模板初了解/</id>
    <published>2019-06-04T04:57:43.000Z</published>
    <updated>2019-06-04T06:42:02.760Z</updated>
    
    <content type="html"><![CDATA[<h3 id="模板初阶"><a href="#模板初阶" class="headerlink" title="模板初阶"></a>模板初阶</h3><h4 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h4><p>在C语言的学习过程中，经常会出现这么一个场景，我们需要交换两个数，但是我们每次又在另一个场景中，所以需要立即重写一个swap()函数，这就浪费了大量的时间。</p><p>在C++的最开始我们学习了函数的重载，这解决了一些燃眉之急，但是当我们的类型多了，我们还是要不停的修改或者添加这么一类函数，时间还是被浪费了许多。这时候，新的知识就出来帮我们解决问题来了—<strong>-泛型编程</strong></p><p><strong>泛型编程：编写与类型无关的通用代码，是代码复用的一种手段。模板是泛型编程的基础</strong></p><p>模板又分为函数模板和类模板两种。</p><h4 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h4><h5 id="函数模板概念"><a href="#函数模板概念" class="headerlink" title="函数模板概念"></a>函数模板概念</h5><p>函数模板代表了一个函数家族，该模板函数与类型无关，在使用时被参数化，根据参数类型产生函数的特定类型版本。</p><h5 id="函数模板的格式"><a href="#函数模板的格式" class="headerlink" title="函数模板的格式"></a>函数模板的格式</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1,<span class="keyword">typename</span> T2,....,<span class="keyword">typename</span> Tn&gt;</span><br><span class="line">返回值类型 函数名(参数列表)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(T&amp; a,T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = a;</span><br><span class="line">    a = b;</span><br><span class="line">    b = tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>typename是用来定义模板参数关键字，也可以使用class，但是不能用struct代替class</strong></p><h5 id="函数模板的原理"><a href="#函数模板的原理" class="headerlink" title="函数模板的原理"></a>函数模板的原理</h5><p>模板是一个蓝图，它<strong>本身并不是一个函数，是编译器用使用方式产生特定具体类型函数的模具。所以其实模板就是将本来我们应该重复做的事交给了编译器</strong></p><p>在编译器阶段，对于函数模板的使用，编译器需要根据传入的实参类型来推演生成对应类型的函数以供调用。</p><p>比如swap函数的参数类型是double时，编译器根据传入的double将模板中的T变为double，然后产生一份专门处理double类型的代码，对于其他类型也是如此</p><h5 id="函数模板的实例化"><a href="#函数模板的实例化" class="headerlink" title="函数模板的实例化"></a>函数模板的实例化</h5><p>用不同类型的参数使用函数模板时，称为函数模板的实例化。模板参数实例化分为：<strong>隐式实例化和显式实例化</strong></p><p><strong>隐式实例化</strong></p><p>让编译器根据实参推演模板参数的实际类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">Add</span>(<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">left</span>,<span class="title">const</span> <span class="title">T</span>&amp; <span class="title">right</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a1=<span class="number">10</span>,a2=<span class="number">20</span>;</span><br><span class="line">    Add(a1,a2);</span><br><span class="line">    <span class="keyword">double</span> d1=<span class="number">10.0</span>,d2=<span class="number">20.0</span>;</span><br><span class="line">    Add(d1,d2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//Add(a1,d1);</span></span><br><span class="line">    <span class="comment">//这样书写编译会报错，因为编译器不知道此时将T转换为什么类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>显示实例化</strong></p><p>在函数名后&lt;&gt;中指定模板参数的实际类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">double</span> b=<span class="number">20</span>;</span><br><span class="line">    Add&lt;<span class="keyword">int</span>&gt;(a,b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果类型不匹配，编译器会尝试进行隐式实例化，如果无法转换成功编译器将会报错</p><h5 id="模板参数的匹配原则"><a href="#模板参数的匹配原则" class="headerlink" title="模板参数的匹配原则"></a>模板参数的匹配原则</h5><p>1、<strong>一个非模板可以和一个同名的函数模板同时存在，而且该函数模板还可以被实例化为这个非模板函数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left+right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">Add</span>(<span class="title">T</span> <span class="title">left</span>,<span class="title">T</span> <span class="title">right</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Add(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    Add&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、<strong>对于非模板函数和同名函数模板，如果条件都相同，在调动时会优先调动非模板函数而不会从该模板产生出一个实例。如果模板可以产出一个具有更好匹配的函数，那么将选择模板</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> left,<span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> left+right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">T</span> <span class="title">Add</span>(<span class="title">T1</span> <span class="title">left</span>,<span class="title">T2</span> <span class="title">right</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">return</span> left + right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Add(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    Add&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、<strong>模板函数不允许自动类型转换，但普通函数可以进行自动类型转换</strong></p><h4 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h4><h5 id="类模板的定义结构"><a href="#类模板的定义结构" class="headerlink" title="类模板的定义结构"></a>类模板的定义结构</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>,<span class="title">class</span> <span class="title">T2</span>,...,<span class="title">class</span> <span class="title">Tn</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> 类模板名</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">//类内定义成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>模拟实现一个类模板Demo</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Vector</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Vector(<span class="keyword">size_t</span> capacity = <span class="number">10</span>)</span><br><span class="line">    :_pData(<span class="keyword">new</span> T[capacity])</span><br><span class="line">    ,_size(<span class="number">0</span>)</span><br><span class="line">    ,_capacity(capacity)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PushBack</span><span class="params">(<span class="keyword">const</span> T&amp; data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _pData[_size++] = data;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">PopBack</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        --_size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">size_t</span> Size()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> _size;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> pos)</span><br><span class="line">    &#123;</span><br><span class="line">        assert(pos &lt; _size);</span><br><span class="line">        <span class="keyword">return</span> _pData[pos];</span><br><span class="line">    &#125;</span><br><span class="line">    ~Vector()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(_pData)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] _pData;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* _pDate;</span><br><span class="line">    <span class="keyword">size_t</span> _size;</span><br><span class="line">    <span class="keyword">size_t</span> _capacity;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="类模板的实例化"><a href="#类模板的实例化" class="headerlink" title="类模板的实例化"></a>类模板的实例化</h5><p><strong>类模板实例化与函数模板实例化不同，类模板实例化需要在类模板名字后跟&lt;&gt;，然后将实例化的类型放在&lt;&gt;中即可，类模板名字不是真正的名字，而实例化的结果才是真正的类。</strong></p><p>来试试上面写的类模板</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Vector&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">s1.PushBack(<span class="number">1</span>);</span><br><span class="line">s1.PushBack(<span class="number">2</span>);</span><br><span class="line">s1.PushBack(<span class="number">3</span>);</span><br><span class="line">Vector&lt;<span class="keyword">double</span>&gt; s2;</span><br><span class="line">s2.PushBack(<span class="number">1.0</span>);</span><br><span class="line">s2.PushBack(<span class="number">2.0</span>);</span><br><span class="line">s2.PushBack(<span class="number">3.0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; s1.Size(); ++i)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;s1[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; s2.Size(); ++i)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;s2[i]&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/06/04/C-模板初了解/模板1.png" alt="模板1"></p><p><strong>模板理解起来非常简单，主要是怎么样去限定好在何时让编译器推演参数类型的转化。</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;模板初阶&quot;&gt;&lt;a href=&quot;#模板初阶&quot; class=&quot;headerlink&quot; title=&quot;模板初阶&quot;&gt;&lt;/a&gt;模板初阶&lt;/h3&gt;&lt;h4 id=&quot;泛型编程&quot;&gt;&lt;a href=&quot;#泛型编程&quot; class=&quot;headerlink&quot; title=&quot;泛型编程&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="C++" scheme="https://skrskr66.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++-类与对象(3)</title>
    <link href="https://skrskr66.github.io/2019/05/31/C-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1-3/"/>
    <id>https://skrskr66.github.io/2019/05/31/C-类与对象-3/</id>
    <published>2019-05-31T09:30:49.000Z</published>
    <updated>2019-06-02T14:30:23.712Z</updated>
    
    <content type="html"><![CDATA[<h3 id="类与对象-3"><a href="#类与对象-3" class="headerlink" title="类与对象(3)"></a>类与对象(3)</h3><h4 id="再学构造函数"><a href="#再学构造函数" class="headerlink" title="再学构造函数"></a>再学构造函数</h4><h5 id="构造函数体赋值"><a href="#构造函数体赋值" class="headerlink" title="构造函数体赋值"></a>构造函数体赋值</h5><p>先构造一个带有全缺省的日期类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Date(<span class="keyword">int</span> year,<span class="keyword">int</span> month,<span class="keyword">int</span> day)</span><br><span class="line">    &#123;</span><br><span class="line">        _year = year;</span><br><span class="line">        _month = month;</span><br><span class="line">        _day = day;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _year;</span><br><span class="line">    <span class="keyword">int</span> _month;</span><br><span class="line">    <span class="keyword">int</span> _day;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述构造函数调用之后，对象中已经有了一个初始值，但是不能将其称作为类对象成员的初始化，构造<strong>函数体中的语句只能将其称作为赋初值，而不能称作初始化。因为初始化只能初始化一次，而构造函数体内可以多次赋值。</strong> </p><h5 id="初始化列表"><a href="#初始化列表" class="headerlink" title="初始化列表"></a>初始化列表</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Date(<span class="keyword">int</span> year,<span class="keyword">int</span> month,<span class="keyword">int</span> day)</span><br><span class="line">        :_year(year)</span><br><span class="line">        ,_month(month)</span><br><span class="line">        ,_day(day)</span><br><span class="line">    &#123;</span><br><span class="line">        _year = year;</span><br><span class="line">        _month = month;</span><br><span class="line">        _day = day;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _year;</span><br><span class="line">    <span class="keyword">int</span> _month;</span><br><span class="line">    <span class="keyword">int</span> _day;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>初始化列表以<code>:</code>开始，接着用一个<code>,</code>分隔的数据成员列表，每个“成员变量”后面跟一个放在括号内的初始值或者表达式</strong></p><p><strong>注意事项：</strong></p><p>1、每个成员变量在初始化列表中只出现一次(初始化只能初始化一次)</p><p>2、类中的成员：“引用成员变量”，“const成员变量”，“类类型成员(该类没有默认构造函数)”</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">skr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    skr(<span class="keyword">int</span> a)</span><br><span class="line">    :_a(a)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _a;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cxk</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">  cxk(<span class="keyword">int</span> a,<span class="keyword">int</span> ref)</span><br><span class="line">    :_aobj(a)</span><br><span class="line">    ,_ref(ref)</span><br><span class="line">    ,_n(<span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    skr _aobj;</span><br><span class="line">    <span class="keyword">int</span>&amp; _ref;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> _n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、尽可能使用初始化列表初始化，因为不管你是否使用初始化列表，对于自定义类型成员变量，一定会先使用初始化列表初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> Time(<span class="keyword">int</span> hour = <span class="number">0</span>)</span><br><span class="line"> :_hour(<span class="number">222</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">"Time()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">int</span> _hour;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> Date(<span class="keyword">int</span> day)</span><br><span class="line"> &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">int</span> _day;</span><br><span class="line"> Time <span class="keyword">_t</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="function">Date <span class="title">d</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如图</p><p><img src="/2019/05/31/C-类与对象-3/类1.png" alt="类1"></p><p>4、成员变量<strong>初始化列表的顺序</strong>按照在<strong>类中声明成员变量的顺序</strong>，与<strong>初始化列表的顺序无关</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Array</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> Array(<span class="keyword">int</span> size)</span><br><span class="line"> :_size(<span class="number">10</span>)</span><br><span class="line"> , _array((<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*_size))</span><br><span class="line"> &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">int</span>* _array;</span><br><span class="line"> <span class="keyword">int</span> _size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="explicit关键字"><a href="#explicit关键字" class="headerlink" title="explicit关键字"></a>explicit关键字</h5><p><strong>用explicit修饰构造函数，将会禁止单个参数的构造函数的隐式转换</strong></p><h4 id="static成员"><a href="#static成员" class="headerlink" title="static成员"></a>static成员</h4><p>声明为<strong>static的类成员</strong>称为<strong>类的静态成员</strong>，用<strong>static</strong>修饰的<strong>成员变量</strong>，称之为静态成员变量；</p><p><strong>用static修饰的成员函数，称之为静态成员函数。静态的成员变量一定要在类外进行初始化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span>  <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  A() &#123;++_scount;&#125;</span><br><span class="line">  A(<span class="keyword">const</span> A&amp; t) &#123;++_scount;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">GetACount</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> _scount;&#125;</span><br><span class="line"><span class="keyword">private</span>:                                  </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> _scount;                     </span><br><span class="line">&#125;;                   </span><br><span class="line">                       </span><br><span class="line"><span class="keyword">int</span> A::_scount = <span class="number">0</span>;</span><br><span class="line">                     </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestA</span><span class="params">()</span>       </span></span><br><span class="line"><span class="function"></span>&#123;           </span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;A::GetACount()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  A a1,a2;                   </span><br><span class="line">  <span class="function">A <span class="title">a3</span><span class="params">(a1)</span></span>;                  </span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;A::GetACount()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;                               </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;         </span><br><span class="line">  TestA();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意！！</strong></p><p><strong>注意！！</strong></p><p><strong>注意！！</strong></p><p><strong>静态的成员变量一定要在类外进行初始化</strong></p><h5 id="static特性"><a href="#static特性" class="headerlink" title="static特性"></a>static特性</h5><p>1、<strong>静态成员为所有类对象所共享</strong>，不属于某个具体的实例</p><p>2、静态成员变量必须在类外定义，定义时不添加static关键字</p><p>3、类静态成员即可用<code>类名::静态成员</code>或者<code>对象.静态成员</code>来访问</p><p>4、<strong>静态成员函数没有隐藏的this指针</strong>，不能访问任何非静态成员</p><p>5、静态成员和类的普通成员一样，也有public、protected、private，3种访问级别，也可以具有返回值，const修饰符等参数。</p><h5 id="C-11的成员初始化"><a href="#C-11的成员初始化" class="headerlink" title="C++11的成员初始化"></a>C++11的成员初始化</h5><p>C++11支持非静态成员变量在声明时，直接初始化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span></span><br><span class="line"><span class="function"> </span>&#123;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; b._b&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="comment">// 非静态成员变量，可以在成员声明时，直接初始化。</span></span><br><span class="line"> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"> B b = <span class="number">20</span>;</span><br><span class="line"> <span class="keyword">int</span>* p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">4</span>);</span><br><span class="line"> <span class="keyword">static</span> <span class="keyword">int</span> n;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h4><h5 id="友元函数"><a href="#友元函数" class="headerlink" title="友元函数"></a>友元函数</h5><p>在重载运算符中，我们没办法将operator&lt;&lt;重载成员成员函数。因为<strong>cout的输出流对象和隐含的this指针在抢占第一个参数位置</strong>。this指针默认是第一个参数也就是左操作数了。但是实际中使用cout需要是第一个形参对象，才能正常使用。所以我们要将operator&lt;&lt;重载成全局函数。但是这样的话，<strong>又会导致类外没有办法访问成员</strong>，那么这里就需要友元来解决了。operator同理。</p><p>友元函数可以直接访问类的私有成员，它是定义在类外部的普通函数，不属于任何类，但需要在类的内部声明，声明时需要加friend关键字。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;    </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>    </span></span><br><span class="line"><span class="class">&#123;</span>    </span><br><span class="line">  <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; _cout, <span class="keyword">const</span> Date&amp; d);    </span><br><span class="line">  <span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; _cin, Date&amp; d);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  Date(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)</span><br><span class="line">    :_year(year)  </span><br><span class="line">    ,_month(month)   </span><br><span class="line">    ,_day(day) </span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:    </span><br><span class="line">  <span class="keyword">int</span> _year;    </span><br><span class="line">  <span class="keyword">int</span> _month;    </span><br><span class="line">  <span class="keyword">int</span> _day;    </span><br><span class="line">&#125;; </span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; _cout,<span class="keyword">const</span> Date&amp; d)    </span><br><span class="line">&#123;    </span><br><span class="line">  _cout&lt;&lt;d._year&lt;&lt;<span class="string">"-"</span>&lt;&lt;d._month&lt;&lt;<span class="string">"-"</span>&lt;&lt;d._day;    </span><br><span class="line">  <span class="keyword">return</span> _cout;    </span><br><span class="line">&#125;    </span><br><span class="line"><span class="comment">//这里不能加const，如果加了const就不能对对象d的成员变量进行修改了    </span></span><br><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; _cin,Date&amp; d)    </span><br><span class="line">&#123;    </span><br><span class="line">  _cin&gt;&gt;d._year;    </span><br><span class="line">  _cin&gt;&gt;d._month;</span><br><span class="line">  _cin&gt;&gt;d._day;</span><br><span class="line">  <span class="keyword">return</span> _cin;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">Date <span class="title">d</span><span class="params">(<span class="number">2017</span>,<span class="number">12</span>,<span class="number">24</span>)</span></span>;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;d;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;d&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>友元函数说明：</strong></p><p>1、友元函数可访问类的私有成员，但不是类的成员函数</p><p>2、友元函数<strong>不能用const修饰</strong></p><p>3、<strong>友元函数可以在类定义的任何地方声明，不受类访问限定符限制</strong></p><p>4、一个函数可以是多个类的友元函数</p><p>5、友元函数的调用与普通函数的调用和原理相同</p><h5 id="友元类"><a href="#友元类" class="headerlink" title="友元类"></a>友元类</h5><p><strong>友元类的所有成员函数都可以是另一个类的友元函数，都可以访问另一个类中的非公有成员。</strong></p><ul><li><p>友元关系是单向的，不具有交换性</p><p>有A类和B类，在A中声明B类为其友元类，那么可以在B类中直接访问A类的私有成员变量，但想在A类中访问B类中私有的成员变量则不行</p></li><li><p>友元关系不能传递</p><p>如果B是A的友元，C是B的友元，则不能说明C是A的友元</p></li></ul><h4 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h4><p>如果一个类定义在另一个类的内部，这个内部类就叫做内部类。注意此时这个内部类是一个独立的类，它不属于外部类，更不能通过外部类的对象去调用内部类。外部类对内部类没有任何优越的访问权限。</p><p>内部类是外部类的友元类。</p><h5 id="内部类特性"><a href="#内部类特性" class="headerlink" title="内部类特性"></a>内部类特性</h5><p>1、内部类可以定义在外部类的public、protected、private都是可以的。 </p><p>2、注意内部类可以直接访问外部类中的static、枚举成员，不需要外部类的对象/类名。 </p><p>3、sizeof(外部类)=外部类，和内部类没有任何关系。 </p><h4 id="牛客的一道小练习"><a href="#牛客的一道小练习" class="headerlink" title="牛客的一道小练习"></a>牛客的一道小练习</h4><p>求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 </p><p><a href="https://www.nowcoder.com/practice/7a0da8fc483247ff8800059e12d7caf1?tpId" target="_blank" rel="noopener">https://www.nowcoder.com/practice/7a0da8fc483247ff8800059e12d7caf1?tpId</a> </p><p>基本上我们能想到的方法都被限制了，那么这时候就可以考虑构造函数每次调用时都会+1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Sum</span></span></span><br><span class="line"><span class="class">        &#123;</span></span><br><span class="line">            <span class="keyword">public</span> :Sum()</span><br><span class="line">            &#123;</span><br><span class="line">                _sum += _i;</span><br><span class="line">                _i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        _i = <span class="number">1</span>;</span><br><span class="line">        _sum = <span class="number">0</span>;</span><br><span class="line">        Sum <span class="built_in">array</span>[n];</span><br><span class="line">        <span class="keyword">return</span> _sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> _sum;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> _i;</span><br><span class="line">&#125;;</span><br><span class="line">    <span class="keyword">size_t</span> Solution::_sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> Solution::_i = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;类与对象-3&quot;&gt;&lt;a href=&quot;#类与对象-3&quot; class=&quot;headerlink&quot; title=&quot;类与对象(3)&quot;&gt;&lt;/a&gt;类与对象(3)&lt;/h3&gt;&lt;h4 id=&quot;再学构造函数&quot;&gt;&lt;a href=&quot;#再学构造函数&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="C++" scheme="https://skrskr66.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Linux网络编程</title>
    <link href="https://skrskr66.github.io/2019/05/31/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <id>https://skrskr66.github.io/2019/05/31/Linux网络编程/</id>
    <published>2019-05-31T09:30:21.000Z</published>
    <updated>2019-06-04T10:05:50.595Z</updated>
    
    <content type="html"><![CDATA[<h3 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h3><h4 id="了解网络名词"><a href="#了解网络名词" class="headerlink" title="了解网络名词"></a>了解网络名词</h4><p>IP地址：在网络中唯一标识的一台主机</p><p>port端口：在一台主机上标识一个进程</p><p>协议：通信双方的约定</p><p>网络协议：网络通信环境中数据的约定格式</p><p>通信协议标准：网络互联的前提</p><h4 id="协议分层"><a href="#协议分层" class="headerlink" title="协议分层"></a>协议分层</h4><p>在以往的了解知道协议具有多层，而分层就是为了协议分装，为了更好的使用。</p><p>对服务，接口，协议进行明确的划分；形成标准实现起来就容易了</p><h5 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h5><p>物理层，数据链路层，网络层，传输层，会话层，表示层，应用层</p><p>这是基础网络中的七层模型，这是一种理想的模型状态，在现代，大佬们将其划分为TCP/IP五层模型。将会话层，表示层，应用层全都规划到应用层。</p><p><img src="/2019/05/31/Linux网络编程/网络1.png" alt="网络1"></p><h5 id="TCP-IP五层模型"><a href="#TCP-IP五层模型" class="headerlink" title="TCP/IP五层模型"></a>TCP/IP五层模型</h5><p><strong>物理层，链路层，网络层，传输层，应用层</strong></p><ul><li>物理层：负责光电信号的传输；比如以太网协议</li><li>链路层：负责相邻设备之间的数据帧传输；比如Ethernet以太网协议；</li><li>网络层：负责地址管理和路由选择；IP协议，典型设备(路由器：负责路由选择，选择数据发送到哪里去)</li><li>传输层：负责端与端之间的数据传输；TCP协议，UDP协议</li><li>应用层：负责应用程序之间的数据沟通(一般交由程序员来写)；HTTP协议,FTP,SMTP,DNS,HTML</li></ul><p><img src="/2019/05/31/Linux网络编程/网络2.png" alt="网络2"></p><p>图中是我自己的理解，只能算一个初步的了解，不能算标准。</p><p><strong>不同的协议层对数据包有不同的称谓,在传输层叫做段(segment),在网络层叫做数据报 (datagram),在链路层叫做帧(frame).</strong> </p><p><strong>应用层数据通过协议栈发到网络上时,每层协议都要加上一个数据首部(header),称为封装 (Encapsulation).</strong> </p><p>数据封装的过程如下图：</p><p><img src="/2019/05/31/Linux网络编程/网络3.png" alt="网络3"></p><h4 id="网络编程套接字"><a href="#网络编程套接字" class="headerlink" title="网络编程套接字"></a>网络编程套接字</h4><h5 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h5><p>IP是在网络上唯一标识一个主机</p><p><strong>IPV4(uint32_t)</strong>：对于IPV4来说，IP地址是一个4字节，32位的整数</p><p>通常使用“点分十进制”的字符串标识IP地址，例如：192.168.0.1；用点分割的每一个数字表示一个字节，范围是0-255。</p><p><strong>IPV6(uchar ip[16])</strong>：IPV6目前还没有完全的被使用，可以先了解一下。它的地址长度128位，是IPV4地址长度的4倍。于是IPV4点分十进制不再适用，采用十六进制表示。</p><p><strong>DHCP(Dynamic Host Configuration Protocol)</strong>：动态主机配置协议是一个局域网的网络协议。DHCP服务可以自动给局域网中的主机自动分配一个IP地址。 </p><p><strong>NAT技术</strong>：因为ipv4的IP不够用，而发明的技术，<strong>实现地址转换，多人使用同一地址上网</strong>。但要区分公网IP和私网IP。</p><p>推荐一篇博客，什么是公网什么是私网：<a href="https://blog.csdn.net/gui951753/article/details/79210535" target="_blank" rel="noopener">https://blog.csdn.net/gui951753/article/details/79210535</a> </p><h5 id="port端口"><a href="#port端口" class="headerlink" title="port端口"></a>port端口</h5><p>端口的类型是(uint16，0~65535；0~1024不推荐使用，一般多为系统占用端口)</p><p>端口是再网络上唯一标识一个进程</p><p>网络程序分为了客户端和服务端，主动发起的一方是客户端，被动再指定位置接收的一方是服务端，而且服务端被动的接收地址必须是固定不变的。</p><p><strong>一个端口只能被一个进程占用；一个进程可以使用多个端口</strong></p><p>在发送数据的过程中，每条数据都一定包含了五元组：源IP，源端口，目的IP，目的端口，协议</p><h5 id="网络字节序"><a href="#网络字节序" class="headerlink" title="网络字节序"></a>网络字节序</h5><p>字节序：cpu在内存中对数据存取的顺序</p><p>在以往的学习中，我们了解过大端与小端这两种字节序。</p><p>简单回忆一下。小端是低地址放低位，高地址放高位；大端是低地址放高位，高地址放低位</p><p>在网络中，存在<strong>主机字节序</strong>，它是当前计算机的字节序，大小端这取决于cpu架构</p><p><strong>因此为了传输数据的我们要保证两端主机字节序相同，如果不同，那么就会造成数据二义性。所以保证一个程序的可移植性，通信双方必须使用网络字节序进行通信。在网络通信中，数据的字节序转换主要是针对数据存储大于一个字节类型的数据</strong></p><p>网络字节序，一般使用大端字节序。通过联合体判断。</p><h5 id="传输层协议-简单了解"><a href="#传输层协议-简单了解" class="headerlink" title="传输层协议(简单了解)"></a>传输层协议(简单了解)</h5><p><strong>TCP：</strong>传输控制协议，面向连接，可靠传输，面向字节流</p><p><strong>面向连接</strong>：通信之前先建立连接，确保双方在线。</p><p><strong>可靠传输</strong>：在网络正常的情况下，数据不会丢失</p><p><strong>面向字节流服务</strong>：传输灵活，但是存在tcp粘包问题，没有明显的数据约定</p><p>使用场景多为：传输文件，保证数据安全，对数据安全的要求较高</p><p><strong>UDP：</strong>用户数据协议，无连接，不可靠，面向数据报</p><p><strong>面向数据报</strong>：每条数据有长度标识，数据有明显的间隔，带有报头的整条发/收。传输不灵活。<strong>注意！！！！不存在粘包问题</strong></p><p>使用场景多为：多数据实时要求非常高的，比如看视频。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;网络编程&quot;&gt;&lt;a href=&quot;#网络编程&quot; class=&quot;headerlink&quot; title=&quot;网络编程&quot;&gt;&lt;/a&gt;网络编程&lt;/h3&gt;&lt;h4 id=&quot;了解网络名词&quot;&gt;&lt;a href=&quot;#了解网络名词&quot; class=&quot;headerlink&quot; title=&quot;了解网络名
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://skrskr66.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux多线程(3)</title>
    <link href="https://skrskr66.github.io/2019/05/17/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B-3/"/>
    <id>https://skrskr66.github.io/2019/05/17/Linux多线程-3/</id>
    <published>2019-05-17T10:28:07.000Z</published>
    <updated>2019-05-31T07:22:02.420Z</updated>
    
    <content type="html"><![CDATA[<p>线程安全的考虑关乎互斥锁和条件变量</p><h3 id="消费者与生产者模型"><a href="#消费者与生产者模型" class="headerlink" title="消费者与生产者模型"></a>消费者与生产者模型</h3><p>当我们去超市买东西时，我们都认为我们是<strong>消费者</strong>，那些生产商品的都被认为是<strong>生产者</strong>。那么超市就被当作交易市场。</p><p>这对比的我们的软件开发过程中：代码的某个模块负责生产数据，但是生产出来的数据不得不交给另一模块来对其进行处理，在这之间我们必须要有一个类似上述超市的东西来存储数据，这就抽象成了<strong>生产者与消费者模型</strong></p><p>其中，<strong>产生数据的模块</strong>，就形象地称为<strong>生产者</strong>。<strong>处理数据的模块</strong>，就形象的称为<strong>消费者</strong>。生产者和消费者之间的中介就叫做<strong>缓冲区</strong></p><h4 id="消费者与生产者模型的理解"><a href="#消费者与生产者模型的理解" class="headerlink" title="消费者与生产者模型的理解"></a>消费者与生产者模型的理解</h4><p>生产者消费者模式就是通过一个容器来解决生产者和消费者的<strong>强耦合问题</strong></p><p><strong>生产者和消费者彼此之间不直接通讯，而通过阻塞队列来进行通讯，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列中取，阻塞队列就相当于一个缓冲区，平衡了它们二者之间的处理能力。</strong></p><p><strong>在线程世界里，生产者就是生产数据的线程，消费者就是消费数据的线程。在多线程开发当中，如果生产者处理速度很快，而消费者处理速度很慢，那么生产者就必须等待消费者处理完，才能继续生产数据。同样的道理，如果消费者的处理能力大于生产者，那么消费者就必须等待生产者。为了解决这种生产消费能力不均衡的问题，所以便有了生产者和消费者模式。</strong> </p><p>参考博客：<a href="https://blog.csdn.net/xiaochendefendoushi/article/details/81160260" target="_blank" rel="noopener">https://blog.csdn.net/xiaochendefendoushi/article/details/81160260</a> </p><h4 id="模型实现"><a href="#模型实现" class="headerlink" title="模型实现"></a>模型实现</h4><h5 id="消费者与生产者的关系"><a href="#消费者与生产者的关系" class="headerlink" title="消费者与生产者的关系"></a>消费者与生产者的关系</h5><p>生产者与生产者之间应该具有<strong>互斥关系</strong></p><p>消费者与消费者之间应该具有<strong>互斥关系</strong></p><p>生产者与消费者之间应该有<strong>同步+互斥的关系</strong></p><p>可以总的来说：<strong>一个场所，两个角色，三种关系</strong></p><h5 id="消费者与生产者模型的优点"><a href="#消费者与生产者模型的优点" class="headerlink" title="消费者与生产者模型的优点"></a>消费者与生产者模型的优点</h5><p><strong>解耦和，支持忙闲不均，支持并发</strong></p><h5 id="消费者与生产者模型的代码Demo"><a href="#消费者与生产者模型的代码Demo" class="headerlink" title="消费者与生产者模型的代码Demo"></a>消费者与生产者模型的代码Demo</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BlockQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">BlockQueue(<span class="keyword">int</span> cap = <span class="number">10</span>):_capacity(cap)&#123;</span><br><span class="line">    pthread_mutex_init(&amp;_mutex, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;_cond_productor, <span class="literal">NULL</span>);</span><br><span class="line">    pthread_cond_init(&amp;_cond_consumer, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line">~BlockQueue()&#123;</span><br><span class="line">    pthread_mutex_destroy(&amp;_mutex);</span><br><span class="line">    pthread_cond_destroy(&amp;_cond_productor);</span><br><span class="line">    pthread_cond_destroy(&amp;_cond_consumer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueuePush</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    QueueLock();    <span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">while</span> (QueueIsFull()) &#123; <span class="comment">//队列满了</span></span><br><span class="line">ProductorWait();    <span class="comment">//生产者休眠</span></span><br><span class="line">    &#125;</span><br><span class="line">    _queue.push(data);</span><br><span class="line">    ConsumerWakeUp();    <span class="comment">//唤醒消费者</span></span><br><span class="line">    QueueUnLock();    <span class="comment">//解锁</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueuePop</span><span class="params">(<span class="keyword">int</span> *data)</span> </span>&#123;</span><br><span class="line">    QueueLock();    <span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">while</span> (QueueIsEmpty()) &#123; <span class="comment">//队列空</span></span><br><span class="line">ConsumerWait();    <span class="comment">//消费者休眠</span></span><br><span class="line">    &#125;</span><br><span class="line">    *data = _queue.front();</span><br><span class="line">    _queue.pop();</span><br><span class="line">    ProductorWakeUp();    <span class="comment">//唤醒生产者</span></span><br><span class="line">    QueueUnLock();    <span class="comment">//解锁</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueueLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueueUnLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProductorWait</span><span class="params">()</span></span>&#123;</span><br><span class="line">    pthread_cond_wait(&amp;_cond_productor, &amp;_mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProductorWakeUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pthread_cond_signal(&amp;_cond_productor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConsumerWait</span><span class="params">()</span></span>&#123;</span><br><span class="line">    pthread_cond_wait(&amp;_cond_consumer, &amp;_mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConsumerWakeUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    pthread_cond_signal(&amp;_cond_consumer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueueIsFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (_queue.size() == _capacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueueIsEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _queue.empty();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; _queue;</span><br><span class="line"><span class="keyword">int</span> _capacity;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> _mutex;</span><br><span class="line"><span class="keyword">pthread_cond_t</span>_cond_productor;</span><br><span class="line"><span class="keyword">pthread_cond_t</span>_cond_consumer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thr_consumer</span> <span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BlockQueue *q = (BlockQueue*)arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span>  data;</span><br><span class="line">     sleep(<span class="number">1</span>);</span><br><span class="line">q-&gt;QueuePop(&amp;data);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"consumer  get data:"</span>&lt;&lt;data&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thr_productor</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    BlockQueue *q = (BlockQueue*)arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"productor put data:"</span>&lt;&lt;i&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">q-&gt;QueuePush(i++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> ctid[<span class="number">4</span>], ptid[<span class="number">4</span>];</span><br><span class="line">    BlockQueue q;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">ret = pthread_create(&amp;ctid[i], <span class="literal">NULL</span>, thr_consumer, (<span class="keyword">void</span>*)&amp;q);</span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"pthread create error\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">ret = pthread_create(&amp;ptid[i], <span class="literal">NULL</span>, thr_productor, (<span class="keyword">void</span>*)&amp;q);</span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"pthread create error\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">pthread_join(ctid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">pthread_join(ptid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该代码实现了消费者与生产者之间互相处理数据的过程。</p><p>当我在线程函数中添加了sleep函数，这样可以看到，在线程中生产者往队列中生产了数据之后，消费者从队列中取出数据然后处理数据。在类中处理数据的过程用锁将其保护。互相不会干扰到</p><p><img src="/2019/05/17/Linux多线程-3/线程1.png" alt="线程1"></p><h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><h4 id="信号量的定义"><a href="#信号量的定义" class="headerlink" title="信号量的定义"></a>信号量的定义</h4><p>百度百科定义：是在多线程环境下使用的一种设施，<strong>是可以用来保证两个或多个关键代码段不被并发调用</strong>。在<strong>进入一个关键代码段之前，线程必须获取一个信号量</strong>；<strong>一旦该关键代码段完成了，那么该线程必须释放信号量</strong>。其它想进入该关键代码段的线程必须等待直到第一个线程释放信号量。 </p><h4 id="信号量的理解"><a href="#信号量的理解" class="headerlink" title="信号量的理解"></a>信号量的理解</h4><p><strong>信号量=计数器+等待队列+等待+唤醒</strong></p><p>功能：实现线程/进程间的互斥与同步。</p><p>计数器就是判断的条件：当计数只用0/1的时候那么就可以实现互斥了</p><p><code>等待队列+等待+唤醒</code>这是实现同步的基本功能</p><h4 id="信号量的接口"><a href="#信号量的接口" class="headerlink" title="信号量的接口"></a>信号量的接口</h4><p>信号量的原语可以理解为是<code>PV操作</code>。P：阻塞；V：唤醒</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span> *sem, <span class="keyword">int</span> pshared, <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br><span class="line">    <span class="comment">//  sem:信号量变量</span></span><br><span class="line">    <span class="comment">//pshared：选项标志-决定信号量用于进程间还是线程间同步互斥</span></span><br><span class="line">    <span class="comment">//    0线程间</span></span><br><span class="line">    <span class="comment">//    !0进程间</span></span><br><span class="line">    <span class="comment">//value：信号量初始计数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line">    <span class="comment">//sem:信号量变量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span> *sem)</span></span>;</span><br><span class="line">    <span class="comment">//通过计数判断是否有资源可操作 （计数-1 + 等待）</span></span><br><span class="line">    <span class="comment">//int sem_wait(sem_t *sem);</span></span><br><span class="line">    <span class="comment">//若计数&lt;=0;则阻塞</span></span><br><span class="line">    <span class="comment">//int sem_trywait(sem_t *sem);</span></span><br><span class="line">    <span class="comment">//若计数&lt;=0;则报错返回</span></span><br><span class="line">    <span class="comment">//int sem_timedwait(sem_t*sem, struct timespec*abs_timeout);</span></span><br><span class="line">    <span class="comment">//若计数&lt;=0;则限时阻塞,超时则报错返回</span></span><br></pre></td></tr></table></figure><h4 id="信号量实现线程安全的环形队列Demo"><a href="#信号量实现线程安全的环形队列Demo" class="headerlink" title="信号量实现线程安全的环形队列Demo"></a>信号量实现线程安全的环形队列Demo</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RingQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">RingQueue(<span class="keyword">int</span> cap = <span class="number">10</span>)</span><br><span class="line">        :_queue(<span class="number">10</span>),</span><br><span class="line">        _capacity(cap),</span><br><span class="line">    _write_step(<span class="number">0</span>),</span><br><span class="line">    _read_step(<span class="number">0</span>)&#123;</span><br><span class="line">    sem_init(&amp;_sem_data, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;_sem_idle, <span class="number">0</span>, cap);</span><br><span class="line">    sem_init(&amp;_sem_lock, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">~RingQueue()&#123;</span><br><span class="line">    sem_destroy(&amp;_sem_data);</span><br><span class="line">    sem_destroy(&amp;_sem_idle);</span><br><span class="line">    sem_destroy(&amp;_sem_lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span>  <span class="title">QueuePush</span><span class="params">(<span class="keyword">int</span> data)</span></span>&#123;</span><br><span class="line">    ProductorWait();</span><br><span class="line">    QueueLock();</span><br><span class="line">    _queue[_write_step] = data;</span><br><span class="line">    _write_step = (_write_step + <span class="number">1</span>) % _capacity;</span><br><span class="line">    QueueUnLock();</span><br><span class="line">    ConsumerWakeUp();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span>  <span class="title">QueuePop</span><span class="params">(<span class="keyword">int</span> *data)</span></span>&#123;</span><br><span class="line">    ConsumerWait();</span><br><span class="line">    QueueLock();</span><br><span class="line">    *data = _queue[_read_step];</span><br><span class="line">    _read_step = (_read_step + <span class="number">1</span>) % _capacity;</span><br><span class="line">    QueueUnLock();</span><br><span class="line">    ProductorWakeUp();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueueLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sem_wait(&amp;_sem_lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">QueueUnLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sem_post(&amp;_sem_lock);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProductorWait</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sem_wait(&amp;_sem_idle);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ProductorWakeUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sem_post(&amp;_sem_idle);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConsumerWait</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sem_wait(&amp;_sem_data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConsumerWakeUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">    sem_post(&amp;_sem_data);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; _queue;</span><br><span class="line"><span class="keyword">int</span>  _capacity;</span><br><span class="line"><span class="keyword">int</span>  _write_step;</span><br><span class="line"><span class="keyword">int</span>  _read_step;</span><br><span class="line"><span class="keyword">sem_t</span> _sem_data;<span class="comment">//数据资源计数</span></span><br><span class="line"><span class="keyword">sem_t</span> _sem_idle;<span class="comment">//空闲空间计数</span></span><br><span class="line"><span class="keyword">sem_t</span> _sem_lock;<span class="comment">//实现互斥</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thr_consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RingQueue *q = (RingQueue*)arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line">q-&gt;QueuePop(&amp;data);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"consumer thread get data:"</span>&lt;&lt;data&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thr_productor</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RingQueue *q = (RingQueue*)arg;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">q-&gt;QueuePush(i);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"productor thread put data:"</span>&lt;&lt;i&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> ctid[<span class="number">4</span>], ptid[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">int</span> ret, i;</span><br><span class="line">    RingQueue q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">ret = pthread_create(&amp;ctid[i], <span class="literal">NULL</span>, thr_consumer, (<span class="keyword">void</span>*)&amp;q);</span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"thread create error"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">ret = pthread_create(&amp;ptid[i], <span class="literal">NULL</span>, thr_productor, (<span class="keyword">void</span>*)&amp;q);</span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"thread create error"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">pthread_join(ctid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">pthread_join(ptid[i], <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/05/17/Linux多线程-3/线程2.png" alt="线程2"></p><p>在封装的加锁与解锁的操作中，有<code>sem_wait()</code>和<code>sem_post()</code>操作，这其实就是计数的+1和-1的操作。当wait时，进行了阻塞，此时另一方可以进行操作。</p><p><img src="/2019/05/17/Linux多线程-3/线程3.png" alt="线程3"></p><p>因为信号量的初始计数为10，所以空闲空间计数最开始生产者生产了10个数据，当capacity满了之后，生产者等待，消费者唤醒。此时消费者开始读取数据，读取也是读取0个开始，到10个时将不再读取数据，此时消费者等待，生产者唤醒。</p><h4 id="信号量与条件变量的区别"><a href="#信号量与条件变量的区别" class="headerlink" title="信号量与条件变量的区别"></a>信号量与条件变量的区别</h4><p>信号量拥有资源计数的功能，临界资源是否能够操作，通过自身计数判断。sem_post和sem_wait</p><p>条件变量是搭配互斥锁一起使用的</p><p>信号量还可以实现互斥，计数仅为0/1</p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="线程池概念"><a href="#线程池概念" class="headerlink" title="线程池概念"></a>线程池概念</h4><p><strong>一堆固定数量/有最大数量限制的线程+任务队列</strong></p><p><strong>可以用于并发处理任务请求</strong></p><h4 id="线程池特性"><a href="#线程池特性" class="headerlink" title="线程池特性"></a>线程池特性</h4><p><strong>避免大量频繁的线程创建销毁的时间成本</strong>，当大量的创建线程时，主线程创建完成之后要等待子进程的退出，子进程退出之后，主进程才能退出。当有了线程池之后，线程池避免峰值压力带来瞬间大量线程被创建资源耗尽，程序崩溃的危险</p><h4 id="线程池的实现"><a href="#线程池的实现" class="headerlink" title="线程池的实现"></a>线程池的实现</h4><p>线程数量固定的线程池，需要定义最大线程和当前线程数量</p><h5 id="自主实现线程池"><a href="#自主实现线程池" class="headerlink" title="自主实现线程池"></a>自主实现线程池</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*task_callback)</span><span class="params">(<span class="keyword">int</span> data)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">deal_data</span><span class="params">(<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">int</span> n = rand()%<span class="number">5</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"thread:%p----deal data:%d---sleep %d sec\n"</span>, pthread_self(), data, n);</span><br><span class="line">    sleep(n);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        Task()&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        ~Task()&#123;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">SetTask</span><span class="params">(<span class="keyword">int</span> data, task_callback handle)</span></span>&#123;</span><br><span class="line">            _data = data;</span><br><span class="line">            _handle = handle;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">Run</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _handle(_data);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> _data;<span class="comment">//任务处理要处理的数据</span></span><br><span class="line">        task_callback _handle;<span class="comment">//任务的处理方法</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_THR 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_QUE 10</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ThreadPool()&#123;</span><br><span class="line">        &#125;</span><br><span class="line">        ~ThreadPool()&#123;</span><br><span class="line">            pthread_mutex_destroy(&amp;_mutex);</span><br><span class="line">            pthread_cond_destroy(&amp;_cond_con);</span><br><span class="line">            pthread_cond_destroy(&amp;_cond_pro);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">ThreadInit</span><span class="params">(<span class="keyword">int</span> max_thr = MAX_THR, <span class="keyword">int</span> max_que = MAX_QUE)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//实现变量初始化和线程创建</span></span><br><span class="line">            _quit_flag = <span class="literal">false</span>;</span><br><span class="line">            _max_thr = max_thr;</span><br><span class="line">            _cur_thr = max_thr;</span><br><span class="line">            _capacity = max_que;</span><br><span class="line">            pthread_mutex_init(&amp;_mutex, <span class="literal">NULL</span>);</span><br><span class="line">            pthread_cond_init(&amp;_cond_con, <span class="literal">NULL</span>);</span><br><span class="line">            pthread_cond_init(&amp;_cond_pro, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">int</span> ret;</span><br><span class="line">            <span class="keyword">pthread_t</span> tid;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; _max_thr; i++) &#123;</span><br><span class="line">                ret=pthread_create(&amp;tid, <span class="literal">NULL</span>, thr_start, (<span class="keyword">void</span>*)<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">"thread create error\n"</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pthread_detach(tid);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">PushTask</span><span class="params">(Task &amp;task)</span></span>&#123;</span><br><span class="line">            <span class="comment">//向任务队列中添加任务</span></span><br><span class="line">            <span class="keyword">if</span> (_quit_flag == <span class="literal">true</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            QueueLock();</span><br><span class="line">            <span class="keyword">while</span> (QueueIsFull())&#123;</span><br><span class="line">                ProWait();</span><br><span class="line">            &#125;</span><br><span class="line">            _queue.push(task);</span><br><span class="line">            ConWakeUp();</span><br><span class="line">            QueueUnLock();</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">ThreadQuit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">//线程池退出</span></span><br><span class="line">            <span class="keyword">if</span> (_quit_flag != <span class="literal">true</span>) &#123;</span><br><span class="line">                _quit_flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span>(_cur_thr &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ConWakeUpAll();</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">QueueLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">            pthread_mutex_lock(&amp;_mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">QueueUnLock</span><span class="params">()</span></span>&#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">ConWait</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//进入ConWait表示消费者这时候没有数据待处理，则解锁退出</span></span><br><span class="line">            <span class="keyword">if</span> (_quit_flag == <span class="literal">true</span>) &#123;</span><br><span class="line">                pthread_mutex_unlock(&amp;_mutex);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"thread:%p exit\n"</span>, pthread_self());</span><br><span class="line">                _cur_thr--;</span><br><span class="line">                pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            pthread_cond_wait(&amp;_cond_con, &amp;_mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">ConWakeUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">            pthread_cond_signal(&amp;_cond_con);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">ConWakeUpAll</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"wake up all\n"</span>);</span><br><span class="line">            pthread_cond_broadcast(&amp;_cond_con);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">ProWait</span><span class="params">()</span></span>&#123;</span><br><span class="line">            pthread_cond_wait(&amp;_cond_pro, &amp;_mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">ProWakeUp</span><span class="params">()</span></span>&#123;</span><br><span class="line">            pthread_cond_signal(&amp;_cond_pro);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">QueueIsFull</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (_capacity == _queue.size());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">QueueIsEmpty</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> _queue.empty();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">PopTask</span><span class="params">(Task *task)</span></span>&#123;</span><br><span class="line">            *task = _queue.front();</span><br><span class="line">            _queue.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">thr_start</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">            ThreadPool *pool = (ThreadPool*)arg;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">                pool-&gt;QueueLock();</span><br><span class="line">                <span class="keyword">while</span>(pool-&gt;QueueIsEmpty())&#123;</span><br><span class="line">                    pool-&gt;ConWait();</span><br><span class="line">                &#125;</span><br><span class="line">                Task task;</span><br><span class="line">                pool-&gt;PopTask(&amp;task);</span><br><span class="line">                pool-&gt;ProWakeUp();</span><br><span class="line">                pool-&gt;QueueUnLock();</span><br><span class="line">                <span class="comment">//任务处理要放到解锁之外，否则任务处理时间过程导致其它线程阻塞</span></span><br><span class="line">                task.Run();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> _max_thr;<span class="comment">//线程池中最大线程数量</span></span><br><span class="line">        <span class="keyword">int</span> _cur_thr;<span class="comment">//线程池中当前线程数量</span></span><br><span class="line">        <span class="keyword">int</span> _quit_flag;<span class="comment">//线程池中线程退出标志</span></span><br><span class="line">        <span class="keyword">int</span> _capacity;<span class="comment">//队列的最大节点数目</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;Task&gt; _queue;<span class="comment">//任务队列</span></span><br><span class="line">        <span class="keyword">pthread_mutex_t</span> _mutex;<span class="comment">//</span></span><br><span class="line">        <span class="keyword">pthread_cond_t</span> _cond_pro;<span class="comment">//生产者</span></span><br><span class="line">        <span class="keyword">pthread_cond_t</span> _cond_con;<span class="comment">//消费者</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ThreadPool pool;</span><br><span class="line"></span><br><span class="line">    pool.ThreadInit();</span><br><span class="line">    Task task[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        task[i].SetTask(i, deal_data);</span><br><span class="line">        pool.PushTask(task[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    pool.ThreadQuit();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程池的工作可以看成，安排多个线程进行工作，此时有一个任务队列，队列中的容量是有限的。</p><p>我们还是看成</p><p>1、生产者安排生产任务，加上锁，生产完后，消费者唤醒，此时解开锁。</p><p>2、消费者被唤醒之后处理数据，每处理一次数据后，任务队列数-1。</p><p>3、任务处理要放到解锁之外，否则任务处理时间过程导致其它线程阻塞</p><p>运行截图</p><p><img src="/2019/05/17/Linux多线程-3/线程4.png" alt="线程4"></p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式是设计模式中的一种：一个对象只能被实例化一次(资源只被加载一次)</p><h4 id="单例模式的类型"><a href="#单例模式的类型" class="headerlink" title="单例模式的类型"></a>单例模式的类型</h4><h5 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h5><p>程序初始化时实例化完毕，优点是不需要再初始化，不需要加载资源，因此运行速度快，流畅</p><p>缺点是：加载时间耗时比较长</p><h5 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h5><p>程序资源使用的时候再进行加载，对象使用的时候再进行实例化，初始化加载速度快，但是运行流畅度不够</p><p>但是需要注意线程安全问题</p><p>C++的总结中，会再次提到这个问题。</p><h3 id="多线程个人总结"><a href="#多线程个人总结" class="headerlink" title="多线程个人总结"></a>多线程个人总结</h3><p>关于多线程的部分总结终于结束了。跨度比较大，因为很多时候不太能理解是怎么运行的。</p><p>尤其是到了手撕模型的时候，最关键的点在于线程安全我们必须要考虑，因为线程如果再运行中丢失，那么数据有可能也会丢失或者泄漏，这带来的损失也是巨大的。</p><p>模型也多从消费者和生产者做起。其实各个特性都总结完之后，会发现，互斥锁+条件变量可以在多个地方用到，就因为要为了保护线程安全。所以这是个重点。线程池关键的在于，数据的处理过程。当数据处理时要与锁分开，否则数据处理时，如果被加锁了，那么其他进程此时在外等待，那么此时就造成了阻塞，时间上大大加长了。这就又没有开启多个线程的意义了。</p><p>queue类的使用也是一知半解，所以掌握起来比较不容易上手。C++有了一定的理解之后可以更好的去实现Demo</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;线程安全的考虑关乎互斥锁和条件变量&lt;/p&gt;
&lt;h3 id=&quot;消费者与生产者模型&quot;&gt;&lt;a href=&quot;#消费者与生产者模型&quot; class=&quot;headerlink&quot; title=&quot;消费者与生产者模型&quot;&gt;&lt;/a&gt;消费者与生产者模型&lt;/h3&gt;&lt;p&gt;当我们去超市买东西时，我们都认为我
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://skrskr66.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux多线程(2)</title>
    <link href="https://skrskr66.github.io/2019/05/15/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/"/>
    <id>https://skrskr66.github.io/2019/05/15/Linux多线程-2/</id>
    <published>2019-05-15T08:47:37.000Z</published>
    <updated>2019-05-17T10:24:23.548Z</updated>
    
    <content type="html"><![CDATA[<p>线程的知识点太多，太重要，所以分成三部分进行总结学习</p><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>多个线程并发同一段代码时，不会出现不同的结果。常见对全局变量或者静态变量进行操作，并且没有锁保护的情况下，会出现该问题。</p><p>多个线程对临界资源进行竞争操作时若不会造成数据二义性时则线程安全；否则，此时就是不安全的</p><h4 id="如何实现线程安全"><a href="#如何实现线程安全" class="headerlink" title="如何实现线程安全"></a>如何实现线程安全</h4><h5 id="常见的线程安全的情况"><a href="#常见的线程安全的情况" class="headerlink" title="常见的线程安全的情况"></a>常见的线程安全的情况</h5><ul><li>每个线程对全局变量或者静态变量只有读取的权限，而没有写入的权限，一般来说这些线程是安全的</li><li>类或者接口对于线程来说都是原子操作</li><li>多个线程之间的切换不会导致该接口的执行结果存在二义性</li></ul><h5 id="常见的线程不安全的情况"><a href="#常见的线程不安全的情况" class="headerlink" title="常见的线程不安全的情况"></a>常见的线程不安全的情况</h5><ul><li>不保护共享变量的函数</li><li>函数状态随着被调用，状态发生变化的函数</li><li>返回指向静态变量指针的函数</li><li>调用线程不安全函数的函数</li></ul><p>在网上调研过程中看到一个总结：<strong>减少对临界资源的依赖，尽量避免访问全局变量，静态变量或其它共享资源，如果必须要使用共享资源，所有使用到的地方必须要进行互斥锁 (Mutex) 保护</strong> </p><p>所以当对临界资源使用时，尽量在必须的地方使用锁的保护</p><p>对临界资源又有两种访问，分别是同步访问和互斥访问</p><p><strong>同步：临界资源的合理访问</strong></p><p><strong>异步：临界资源同一时间的唯一访问</strong></p><h4 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h4><p>互斥锁的操作就是<code>1/0</code>的操作</p><p>一个0或者1的计数器。1可以表示加锁，加锁就是计数-1；操作完毕之后要解锁，解锁就是计数+1；</p><p>0表示不可以加锁，不能加锁则等待</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//互斥锁的接口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">//函数应销毁mutex引用的mutex对象</span></span><br><span class="line"><span class="comment">//注意！！！</span></span><br><span class="line"><span class="comment">//销毁已解锁的已初始化互斥体应是安全的。试图销毁锁定的互斥体会导致未定义的行为。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,<span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"><span class="comment">//mutex：互斥锁变量</span></span><br><span class="line"><span class="comment">//attr：属性，通常为NULL </span></span><br><span class="line"><span class="comment">//应使用attr指定的属性初始化mutex引用的mutex</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"><span class="comment">//宏PTHREAD_MUTEX_INITIALIZER来静态的初始化锁</span></span><br><span class="line"><span class="comment">//互斥锁变量不一定非要全局变量--只要保证要互斥的线程都能访问到就行</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">//锁定mutex引用的mutex对象。如果互斥体已被锁定，则调用线程应阻塞，直到互斥体可用。此操作将返回互斥对象引用的互斥对象处于锁定状态，调用线程作为其所有者。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">//函数应等同于pthread_mutex_lock（），但如果mutex引用的mutex对象当前被锁定（由任何线程，包括当前线程），则调用应立即返回。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class="line"><span class="comment">//函数应释放mutex引用的mutex对象。互斥体的释放方式取决于互斥体的type属性。如果在调用pthread_mutex_unlock（）时，mutex引用的mutex对象上有线程被阻塞，导致mutex可用，调度策略应确定哪个线程应获取mutex。</span></span><br></pre></td></tr></table></figure><p>互斥锁的操作步骤</p><ol><li>定义互斥锁变量</li><li>初始化互斥锁变量</li><li>加锁</li><li>解锁</li><li>销毁互斥锁</li></ol><p>通过一个互斥锁Demo来感受一下锁的使用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟黄牛抢票，100张票，共有四个黄牛在抢票</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;<span class="comment">//定义初始化锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">thr_start</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;mutex);</span><br><span class="line">        <span class="keyword">if</span>(ticket &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            usleep(<span class="number">1000</span>);</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"yellow bull : %d----get ticket : %d\n"</span>,(<span class="keyword">int</span>)arg,ticket);</span><br><span class="line">            ticket--;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">            pthread_exit(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>,ret;</span><br><span class="line">    </span><br><span class="line">    pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(;i &lt; <span class="number">4</span>; ++i)&#123;</span><br><span class="line">        ret = pthread_create(&amp;tid[i],<span class="literal">NULL</span>,thr_start,(<span class="keyword">void</span>*)i);</span><br><span class="line">        <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"yellow bull no exit!"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">4</span>;++i)&#123;</span><br><span class="line">        pthread_join(tid[i],<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/05/15/Linux多线程-2/线程1.png" alt="线程1"></p><p>这种情况黄牛抢票是比较容易的，一般只有一个黄牛能全抢到票。</p><p>但是如果把锁去掉</p><p><img src="/2019/05/15/Linux多线程-2/线程2.png" alt="线程2"></p><p>这样抢票就很混乱，因为没有了保护。所以锁的使用是在共享资源对它进行保护，换句话说加锁是为了保护资源，所以在这个代码中就将抢票的操作进行加锁保护。这样就只有一个黄牛可以抢到票。</p><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>在进行加锁的过程中很有可能发生死锁的情况下。</p><p><strong>在一组进程中的各个进程均占有不会释放的资源，但因互相申请被其他的进程所占用不会释放的资源而处于一种永久等待的状态</strong></p><h5 id="死锁的四个条件-重点"><a href="#死锁的四个条件-重点" class="headerlink" title="死锁的四个条件(重点)"></a>死锁的四个条件(重点)</h5><p>1、互斥条件：一个资源一次只能被一个执行流使用</p><p><strong>我操作的时候别人不能操作</strong></p><p>2、请求与保持条件：一个执行流因请求资源而阻塞时，对已获得的资源保持不变</p><p><strong>拿着手里的，但是请求其他的，其他的请求不到，手里拿着的也不放开</strong></p><p>3、不可剥夺条件：一个执行流已获得的资源，在未使用完之前，不能强行剥夺</p><p><strong>我的锁，别人不能释放</strong></p><p>4、循环等待条件：若干执行流之间形成一种头尾相接的循环等待资源的关系</p><p><strong>指在发生死锁时，必然存在一个进程资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，Pn正在等待已被P0占用的资源</strong></p><h5 id="死锁的产生与处理"><a href="#死锁的产生与处理" class="headerlink" title="死锁的产生与处理"></a>死锁的产生与处理</h5><p>当加锁或者解锁顺序不同时会发生死锁的情况；对锁资源的竞争以及进程/线程的加锁的推进顺序b不当</p><p>当以上四种条件被破坏时，可以<strong>预防死锁</strong>的产生</p><p>避免死锁的方法可以通过：死锁检测算法，银行家算法(推荐王道视频学习)</p><h4 id="同步的实现"><a href="#同步的实现" class="headerlink" title="同步的实现"></a>同步的实现</h4><p>条件变量是线程同步的一种手段，条件变量用来自动阻塞一个线程，直到条件满足被触发为止。通常情况下条件变量和互斥锁同时使用</p><p>条件变量使我们可以睡眠等待某种条件出现。条件变量利用线程间共享的全局变量进行同步的一种机制，主要包括两个动作：</p><p>1、一个/多个线程等待“条件变量的条件成立”而挂起；线程1如果操作条件满足，则操作，否则进行等待。</p><p>2、另一个线程使“条件成立”信号；线程2促使条件满足，唤醒等待的线程。</p><p>如果没有资源则等待(死等)，生产资源后唤醒等待。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//条件变量的接口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,<span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span> *<span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"><span class="comment">//条件变量初始化，一般attr默认为NULL</span></span><br><span class="line"><span class="comment">//使用attr引用的属性初始化cond引用的条件变量。如果attr为空，则使用默认条件变量属性；效果与传递默认条件变量属性对象的地址相同。初始化成功后，条件变量的状态将被初始化。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_cond_t</span> cond = PTHREAD_COND_INITIALIZER;</span><br><span class="line"><span class="comment">//静态初始化条件变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="comment">//销毁由cond指定的给定的条件变量</span></span><br><span class="line"><span class="comment">//销毁当前未阻塞线程的初始化条件变量是安全的。</span></span><br><span class="line"><span class="comment">//试图销毁当前阻止其他线程的条件变量会导致未定义的行为。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">const</span> struct timespec *<span class="keyword">restrict</span> abstime)</span></span>;</span><br><span class="line"><span class="comment">//abstime：限时等待时长，限时等待时长，超时后则返回</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,<span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex)</span></span>;</span><br><span class="line"><span class="comment">//解锁后的挂起操作(原子操作)，有可能还没来得及挂起就已经有人唤醒--白唤醒--导致了死锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="comment">//唤醒至少一个等待的</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_boardcast</span><span class="params">(<span class="keyword">pthread_cond_t</span> *cond)</span></span>;</span><br><span class="line"><span class="comment">//广播唤醒，唤醒所有等待的人</span></span><br></pre></td></tr></table></figure><p>条件变量的步骤：</p><p>1、定义条件变量</p><p>2、初始化条件变量</p><p>3、等待\唤醒定义的条件变量</p><p>4、销毁条件变量</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模拟一个skr与cxk使用比赛舞台的Demo                                  </span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;    </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;    </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;    </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;    </span></span></span><br><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;    </span></span></span><br><span class="line">     </span><br><span class="line"> <span class="keyword">int</span> have_stage = <span class="number">1</span>;    </span><br><span class="line">     </span><br><span class="line"> <span class="keyword">pthread_cond_t</span> skr;    </span><br><span class="line"> <span class="keyword">pthread_cond_t</span> cxk;    </span><br><span class="line"> <span class="keyword">pthread_mutex_t</span> mutex;    </span><br><span class="line">     </span><br><span class="line"> <span class="function"><span class="keyword">void</span>* <span class="title">thr_skr</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;<span class="comment">//skr此时要上台dancing    </span></span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)&#123;    </span><br><span class="line">     pthread_mutex_lock(&amp;mutex);    </span><br><span class="line">     <span class="comment">//若此时舞台有人用，那么skr进行等待    </span></span><br><span class="line">     <span class="keyword">while</span>(have_stage == <span class="number">1</span>)&#123;    </span><br><span class="line">       pthread_cond_wait(&amp;skr,&amp;mutex);    </span><br><span class="line">     &#125;    </span><br><span class="line">     <span class="comment">//舞台被人使用了，此时0；因为之前1，代表可以使用    </span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"skr~~ is freestyle!!!\n"</span>);    </span><br><span class="line">     sleep(<span class="number">1</span>);    </span><br><span class="line">     <span class="comment">//跳完舞后舞台空了出来    </span></span><br><span class="line">     have_stage += <span class="number">1</span>;    </span><br><span class="line">     <span class="comment">//有舞台了，叫cxk来使用    </span></span><br><span class="line">     pthread_cond_signal(&amp;cxk);    </span><br><span class="line">     pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="function"><span class="keyword">void</span>* <span class="title">thr_cxk</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">   <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">     pthread_mutex_lock(&amp;mutex);</span><br><span class="line">     <span class="comment">//没有舞台，那么在这里等待</span></span><br><span class="line">     <span class="keyword">while</span>(have_stage == <span class="number">0</span>)&#123;</span><br><span class="line">       pthread_cond_wait(&amp;cxk,&amp;mutex);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//有了舞台就是可以唱跳rap篮球了。。</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">"cxk~~ is singing,dancing,playing rapping and basketball!!\n"</span>);</span><br><span class="line">     sleep(<span class="number">1</span>);</span><br><span class="line">     have_stage -= <span class="number">1</span>;</span><br><span class="line">     <span class="comment">//跳完还想跳。。因此叫skr快跳完换他跳。。</span></span><br><span class="line">     pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">     pthread_cond_signal(&amp;skr);<span class="comment">//唤醒skr，</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"> &#125;                                                                                               <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span> * argv[])</span></span>&#123;</span><br><span class="line">   <span class="keyword">pthread_t</span> tid1,tid2;</span><br><span class="line">   <span class="keyword">int</span> ret;</span><br><span class="line">     </span><br><span class="line">   pthread_cond_init(&amp;skr,<span class="literal">NULL</span>);</span><br><span class="line">   pthread_cond_init(&amp;cxk,<span class="literal">NULL</span>);</span><br><span class="line">   pthread_mutex_init(&amp;mutex,<span class="literal">NULL</span>);</span><br><span class="line">   <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">2</span>;i++)&#123;</span><br><span class="line">     ret = pthread_create(&amp;tid1,<span class="literal">NULL</span>,thr_skr,<span class="literal">NULL</span>);</span><br><span class="line">     <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"skr error"</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">2</span>; i++)&#123;</span><br><span class="line">     ret = pthread_create(&amp;tid2,<span class="literal">NULL</span>,thr_cxk,<span class="literal">NULL</span>);</span><br><span class="line">     <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">"cxk error"</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   pthread_join(tid1,<span class="literal">NULL</span>);</span><br><span class="line">   pthread_join(tid2,<span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">   pthread_cond_destroy(&amp;skr);</span><br><span class="line">   pthread_cond_destroy(&amp;cxk);</span><br><span class="line">   pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/05/15/Linux多线程-2/线程3.png" alt="线程3"></p><p>运行结果可以看到cxk和skr交替互斥的表演节目。。。</p><p>那么互斥量(mutex)保护的是什么？其实保护的是变量条件(have_stage)，当互斥量被成功lock后我们就可以放心的去读取变量条件，这样就不用在担心在这期间变量条件会被其他线程修改。如果变量条件不满足条件，当前线程阻塞，等待其他线程释放<strong>条件成立信号</strong>，并释放已经lock的mutex。这样一来其他线程就有了修改变量条件的机会。当其他线程释放条件成立信号后，pthread_cond_wait函数返回，并再次lock</p><p><strong>pthread_cond_wait的工作流程可以总结为：unlock mutex，start waiting -&gt; lock mutex。</strong> </p><p><strong>while的作用</strong></p><p>在变量条件处为什么不用<code>if</code>做判断而是用while，这是因为pthread_cond_wait的返回不一定意味着其他线程释放了条件成立信号。也可能意外返回。这种被称为<strong>假唤醒</strong>，在Linux中带阻塞功能的system call都会在进程中收到了一个signal后返回。这就是为什么使用while来检查的原因。<strong>因为不能保证wait函数返回的一定就是条件满足，如果条件不满足，那么我们还需要继续等待</strong></p><p><strong>signal条件变量的考虑</strong></p><p>解锁互斥量mutex和发出唤醒信号是两个单独的操作，所以就存在一个顺序的问题</p><p>(1)    按照 unlock(mutex); condition_signal()顺序，当等待线程被唤醒时，因为mutex已经解锁，因此被唤醒的线程(skr)很容易就锁住了mutex然后从conditon_wait()中返回了。  </p><p>(2)    按照 condition_signal(); unlock(mutex)顺序，当等待线程被唤醒时，它试图锁住mutex,但是如果此时mutex还未解锁，则线程又进入睡眠，mutex成功解锁后，此线程在再次被唤醒并锁住mutex，从而从condition_wait()中返回。  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;线程的知识点太多，太重要，所以分成三部分进行总结学习&lt;/p&gt;
&lt;h3 id=&quot;线程安全&quot;&gt;&lt;a href=&quot;#线程安全&quot; class=&quot;headerlink&quot; title=&quot;线程安全&quot;&gt;&lt;/a&gt;线程安全&lt;/h3&gt;&lt;p&gt;多个线程并发同一段代码时，不会出现不同的结果。常见对全局
      
    
    </summary>
    
    
      <category term="Linux 锁" scheme="https://skrskr66.github.io/tags/Linux-%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>C++-类与对象(2)</title>
    <link href="https://skrskr66.github.io/2019/05/15/C-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1-2/"/>
    <id>https://skrskr66.github.io/2019/05/15/C-类与对象-2/</id>
    <published>2019-05-15T08:47:09.000Z</published>
    <updated>2019-05-18T15:39:16.787Z</updated>
    
    <content type="html"><![CDATA[<h3 id="类与对象-第二部分"><a href="#类与对象-第二部分" class="headerlink" title="类与对象(第二部分)"></a>类与对象(第二部分)</h3><h4 id="类的6个默认成员函数"><a href="#类的6个默认成员函数" class="headerlink" title="类的6个默认成员函数"></a>类的6个默认成员函数</h4><p>如果一个类中什么成员都没有，简称为空类。空类并不是什么都没有，任何类在我们不写的情况下，都会自动生成6个默认成员函数</p><p><img src="/2019/05/15/C-类与对象-2/类1.png" alt="类1"></p><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><h5 id="构造函数的概念"><a href="#构造函数的概念" class="headerlink" title="构造函数的概念"></a>构造函数的概念</h5><p><strong>构造函数是一个特殊的成员函数，名字与类名相同，创建类类型对象时由编译器自动调用</strong>，保证每个数据成员都有一个合适的初始值，<strong>并且在对象的声明周期内只调用一次。</strong></p><h5 id="构造函数的特性"><a href="#构造函数的特性" class="headerlink" title="构造函数的特性"></a>构造函数的特性</h5><p><strong>构造函数</strong>是特殊的成员函数，需要注意的是，构造函数虽然名称叫构造，但是它的主要任务并不是开空间创建对象，而是初始化对象。</p><p><strong>特征如下：</strong></p><p>​    1、函数名与类名相同</p><p>​    2、无返回值</p><p>​    3、对象实例化时编译器自动调用对应的构造函数</p><p>​    4、构造函数可以重载</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//无参构造函数</span></span><br><span class="line">    Date()&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//带参构造函数</span></span><br><span class="line">    Date(<span class="keyword">int</span> year, <span class="keyword">int</span> month, <span class="keyword">int</span> day)&#123;</span><br><span class="line">        _year = year;</span><br><span class="line">        _month = month;</span><br><span class="line">        _day = day;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _year;</span><br><span class="line">    <span class="keyword">int</span> _month;</span><br><span class="line">    <span class="keyword">int</span> _day;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>5、如果类中没有显式定义构造函数，则C++编译器会自动生成一个无参的默认构造函数，一旦用户显示定义，那么编译器将不在生成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"> // 如果用户显式定义了构造函数，编译器将不再生成</span></span><br><span class="line"><span class="comment"> Date (int year, int month, int day)</span></span><br><span class="line"><span class="comment"> &#123;</span></span><br><span class="line"><span class="comment"> _year = year;</span></span><br><span class="line"><span class="comment"> _month = month;</span></span><br><span class="line"><span class="comment"> _day = day;</span></span><br><span class="line"><span class="comment"> &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">int</span> _year;</span><br><span class="line"> <span class="keyword">int</span> _month;</span><br><span class="line"> <span class="keyword">int</span> _day;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="comment">// 没有定义构造函数，对象也可以创建成功，因此此处调用的是编译器生成的默认构造函数</span></span><br><span class="line">    Date d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、默认构造函数只能有一个，不管是无参的，还是全缺省的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> Date()</span><br><span class="line"> &#123;</span><br><span class="line"> _year = <span class="number">1900</span> ;</span><br><span class="line"> _month = <span class="number">1</span> ;</span><br><span class="line"> _day = <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> Date (<span class="keyword">int</span> year = <span class="number">1900</span>, <span class="keyword">int</span> month = <span class="number">1</span>, <span class="keyword">int</span> day = <span class="number">1</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> _year = year;</span><br><span class="line"> _month = month;</span><br><span class="line"> _day = day;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line"> <span class="keyword">int</span> _year ;</span><br><span class="line"> <span class="keyword">int</span> _month ;</span><br><span class="line"> <span class="keyword">int</span> _day ;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 以下测试函数能通过编译吗？</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> Date d1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/05/15/C-类与对象-2/类2.png" alt="类2"></p><p><strong>在VS2013下可以编译通过，说明在VS内编译器对这种重载错误并不是特别在意。</strong></p><p><strong>但是在g++中，出现了编译器不知道执行哪个构造函数。</strong></p><p>7、关于编译器生成的默认成员函数，我们可能会想到这个默认的构造函数有什么用？我们直接声明一个对象，返回的<code>_year</code>值都是随机数，那么还有什么意义呢？</p><p>C++把类型分成内置类型和自定义类型。内置类型就是语法已经定义好的类型，如int/char…；自定义类型就是我们通过class/struct/union等定义的类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;                       </span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Time</span>    </span></span><br><span class="line"><span class="class">&#123;</span>    </span><br><span class="line">  <span class="keyword">public</span>:    </span><br><span class="line">    Time()    </span><br><span class="line">    &#123;    </span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Time()"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;    </span><br><span class="line">      <span class="comment">// 比特科技    </span></span><br><span class="line">      <span class="comment">//   8. 成员变量的命名风格    </span></span><br><span class="line">      _hour = <span class="number">0</span>;    </span><br><span class="line">      _minute = <span class="number">0</span>;    </span><br><span class="line">      _second = <span class="number">0</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">  <span class="keyword">private</span>:    </span><br><span class="line">    <span class="keyword">int</span> _hour;    </span><br><span class="line">    <span class="keyword">int</span> _minute;    </span><br><span class="line">    <span class="keyword">int</span> _second;    </span><br><span class="line">&#125;;    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>    </span></span><br><span class="line"><span class="class">&#123;</span>    </span><br><span class="line">  <span class="keyword">private</span>:    </span><br><span class="line">    <span class="comment">// 基本类型(内置类型)    </span></span><br><span class="line">    <span class="keyword">int</span> _year;    </span><br><span class="line">    <span class="keyword">int</span> _month;    </span><br><span class="line">    <span class="keyword">int</span> _day;    </span><br><span class="line">    <span class="comment">// 自定义类型    </span></span><br><span class="line">    Time <span class="keyword">_t</span>;    </span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  Date d;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8、成员变量风格</p><p>通过以上代码能看出，在C++中，我们一般定义成员变量时，会在成员变量之前加上一个下划线</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> _year;</span><br><span class="line"><span class="keyword">int</span> _month;</span><br><span class="line"><span class="keyword">int</span> _day;</span><br></pre></td></tr></table></figure><h4 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h4><h5 id="析构函数的概念"><a href="#析构函数的概念" class="headerlink" title="析构函数的概念"></a>析构函数的概念</h5><p>与构造函数功能相反，析构函数不是完成对象的销毁，局部对象销毁工作由编译器来完成。而对象在销毁时会自动调用析构函数，完成类的一些资源清理工作。</p><h5 id="析构函数的特性"><a href="#析构函数的特性" class="headerlink" title="析构函数的特性"></a>析构函数的特性</h5><p>1、析构函数名就是构造函数名之前加上<strong>字符~</strong>。</p><p>2、无参数无返回值</p><p>3、一个类只有一个析构函数。若未显示定义，系统会自动生成默认的析构函数</p><p>4、对象生命周期结束时，C++编译系统自动调用析构函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;    </span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> DateType;    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SeqList</span>    </span></span><br><span class="line"><span class="class">&#123;</span>                     </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">  SeqList(<span class="keyword">int</span> capacity = <span class="number">10</span>)&#123;    </span><br><span class="line">    _pData = (DateType*)<span class="built_in">malloc</span>(capacity * <span class="keyword">sizeof</span>(DateType));    </span><br><span class="line">    assert(_pData);    </span><br><span class="line">    _size = <span class="number">0</span>;    </span><br><span class="line">    _capacity = capacity;    </span><br><span class="line">  &#125;    </span><br><span class="line">  ~SeqList()    </span><br><span class="line">  &#123;    </span><br><span class="line">    <span class="keyword">if</span>(_pData)    </span><br><span class="line">    &#123;    </span><br><span class="line">      <span class="built_in">free</span>(_pData);  <span class="comment">//释放栈上资源  </span></span><br><span class="line">      _pData = <span class="literal">NULL</span>;    </span><br><span class="line">      _size = <span class="number">0</span>;    </span><br><span class="line">      _capacity = <span class="number">0</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;    </span><br><span class="line"><span class="keyword">private</span>:    </span><br><span class="line">  <span class="keyword">int</span>* _pData;    </span><br><span class="line">  <span class="keyword">size_t</span> _size;    </span><br><span class="line">  <span class="keyword">size_t</span> _capacity;    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>5、编译器自动生成的默认析构函数，对会自定类型成员调用它的析构函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">String</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> String(<span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">"jack"</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> _str = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(str) + <span class="number">1</span>);</span><br><span class="line"> <span class="built_in">strcpy</span>(_str, str);</span><br><span class="line"> &#125;</span><br><span class="line"> ~String()</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="built_in">cout</span> &lt;&lt; <span class="string">"~String()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"> <span class="built_in">free</span>(_str);</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">char</span>* _str;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> String _name;</span><br><span class="line"> <span class="keyword">int</span> _age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> Person p;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="拷贝构造函数"><a href="#拷贝构造函数" class="headerlink" title="拷贝构造函数"></a>拷贝构造函数</h4><h5 id="拷贝构造函数概念"><a href="#拷贝构造函数概念" class="headerlink" title="拷贝构造函数概念"></a>拷贝构造函数概念</h5><p>只有单个形参，该形参是对本类类型对象的引用(一般常用const修饰)，在用已存在的类类型对象创建新对象时，新对象由编译器自动调用</p><h5 id="拷贝构造函数的特征"><a href="#拷贝构造函数的特征" class="headerlink" title="拷贝构造函数的特征"></a>拷贝构造函数的特征</h5><p>1、拷贝构造函数是构造函数的一个重载</p><p>2、拷贝构造函数的参数只有<strong>一个且必须使用引用传参</strong>，使用传值的方式会引发无穷递归调用</p><p><img src="/2019/05/15/C-类与对象-2/类3.png" alt="类3"></p><p>3、<strong>若未显示定义，系统生成默认的构造拷贝函数</strong>。默认的拷贝构造函数对象按内存存储字节序完成拷贝，这种拷贝我们叫做浅拷贝，或者值拷贝</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;    </span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span>    </span></span><br><span class="line"><span class="class">&#123;</span>    </span><br><span class="line">  <span class="keyword">public</span>:    </span><br><span class="line">    Date(<span class="keyword">int</span> year = <span class="number">1900</span>, <span class="keyword">int</span> month = <span class="number">1</span>, <span class="keyword">int</span> day = <span class="number">1</span>)    </span><br><span class="line">    &#123;    </span><br><span class="line">      _year = year;    </span><br><span class="line">      _month = month;    </span><br><span class="line">      _day = day;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>&#123;    </span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;_year&lt;&lt;<span class="string">"-"</span>&lt;&lt;_month&lt;&lt;<span class="string">"-"</span>&lt;&lt;_day&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">  <span class="keyword">private</span>:    </span><br><span class="line">    <span class="keyword">int</span> _year;    </span><br><span class="line">    <span class="keyword">int</span> _month;    </span><br><span class="line">    <span class="keyword">int</span> _day;    </span><br><span class="line">&#125;;                    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"></span>&#123;             </span><br><span class="line">  Date d1;    </span><br><span class="line">  <span class="comment">// 这里d2调用的默认拷贝构造完成拷贝，d2和d1的值也是一样的。    </span></span><br><span class="line">  <span class="function">Date <span class="title">d2</span><span class="params">(d1)</span></span>;                                                   </span><br><span class="line">  d2.Print();                                                    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;                                                      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="赋值运算符重载"><a href="#赋值运算符重载" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h4><h5 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h5><p><strong>C++为了增强代码的可读性引入了运算符重载，运算符重载是具有特殊函数名的函数</strong>，也具有其返回值类型，函数名字以及参数列表，其返回值类型与参数列表与普通的函数类似。</p><p>函数名字为：<strong>关键字operator后面接需要重载的运算符符号</strong></p><p>函数原型：<strong>返回值类型operator操作符(参数列表)</strong></p><p>注意： </p><ul><li>不能通过连接其他符号来创建新的操作符：比如operator@  </li><li>重载操作符必须有一个类类型或者枚举类型的操作数 </li><li>用于内置类型的操作符，其含义不能改变，例如：内置的整型+，不能改变其含义 </li><li>作为类成员的重载函数时，其形参看起来比操作数数目少1成员函数的 </li><li>操作符有一个默认的形参this，限定为第一个形参 </li><li>.* 、:: 、sizeof 、?: 、. 注意以上5个运算符不能重载。这个经常在笔试选择题中出现。  </li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局的operator==</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> Date(<span class="keyword">int</span> year = <span class="number">1900</span>, <span class="keyword">int</span> month = <span class="number">1</span>, <span class="keyword">int</span> day = <span class="number">1</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> _year = year;</span><br><span class="line"> _month = month;</span><br><span class="line"> _day = day;</span><br><span class="line"> &#125; </span><br><span class="line"><span class="comment">//private:</span></span><br><span class="line"> <span class="keyword">int</span> _year;</span><br><span class="line"> <span class="keyword">int</span> _month;</span><br><span class="line"> <span class="keyword">int</span> _day;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 这里会发现运算符重载成全局的就需要成员变量是共有的，那么问题来了，封装性如何保证？</span></span><br><span class="line"><span class="comment">// 这里其实可以用我们后面学习的友元解决，或者干脆重载成成员函数。</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Date&amp; d1, <span class="keyword">const</span> Date&amp; d2)</span><br><span class="line">&#123;</span><br><span class="line"> <span class="keyword">return</span> d1._year == d2._year;</span><br><span class="line"> &amp;&amp; d1._month == d2._month</span><br><span class="line"> &amp;&amp; d1._day == d2._day;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="function">Date <span class="title">d1</span><span class="params">(<span class="number">2018</span>, <span class="number">9</span>, <span class="number">26</span>)</span></span>;</span><br><span class="line"> <span class="function">Date <span class="title">d2</span><span class="params">(<span class="number">2018</span>, <span class="number">9</span>, <span class="number">27</span>)</span></span>;</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;(d1 == d2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"> Date(<span class="keyword">int</span> year = <span class="number">1900</span>, <span class="keyword">int</span> month = <span class="number">1</span>, <span class="keyword">int</span> day = <span class="number">1</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> _year = year;</span><br><span class="line"> _month = month;</span><br><span class="line"> _day = day;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// bool operator==(Date* this, const Date&amp; d2)</span></span><br><span class="line"> <span class="comment">// 这里需要注意的是，左操作数是this指向的调用函数的对象</span></span><br><span class="line"> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Date&amp; d2)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">return</span> _year == d2._year;</span><br><span class="line">     &amp;&amp; _month == d2._month</span><br><span class="line"> &amp;&amp; _day == d2._day;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">int</span> _year;</span><br><span class="line"> <span class="keyword">int</span> _month;</span><br><span class="line"> <span class="keyword">int</span> _day;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="function">Date <span class="title">d1</span><span class="params">(<span class="number">2018</span>, <span class="number">9</span>, <span class="number">26</span>)</span></span>;</span><br><span class="line"> <span class="function">Date <span class="title">d2</span><span class="params">(<span class="number">2018</span>, <span class="number">9</span>, <span class="number">27</span>)</span></span>;</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;(d1 == d2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="赋值运算符重载-1"><a href="#赋值运算符重载-1" class="headerlink" title="赋值运算符重载"></a>赋值运算符重载</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span> </span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"> Date(<span class="keyword">int</span> year = <span class="number">1900</span>, <span class="keyword">int</span> month = <span class="number">1</span>, <span class="keyword">int</span> day = <span class="number">1</span>)</span><br><span class="line"> &#123;</span><br><span class="line"> _year = year;</span><br><span class="line"> _month = month;</span><br><span class="line"> _day = day;</span><br><span class="line"> &#125;</span><br><span class="line"> Date (<span class="keyword">const</span> Date&amp; d)</span><br><span class="line"> &#123;</span><br><span class="line"> _year = d._year;</span><br><span class="line"> _month = d._month;</span><br><span class="line"> _day = d._day;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> Date&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Date&amp; d)</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;d)</span><br><span class="line"> &#123;</span><br><span class="line"> _year = d._year;</span><br><span class="line"> _month = d._month;</span><br><span class="line"> _day = d._day;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"> <span class="keyword">int</span> _year ;</span><br><span class="line"> <span class="keyword">int</span> _month ;</span><br><span class="line"> <span class="keyword">int</span> _day ;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>赋值运算符主要有四点：</p><p><strong>1、参数类型</strong></p><p><strong>2、返回值</strong></p><p><strong>3、检测是否自己给自己赋值</strong></p><p><strong>4、返回*this</strong></p><p><strong>5、一个类如果没有显示定义赋值运算符重载，编译器也会生成一个，完成对象按字节序的值拷贝</strong></p><h5 id="const成员"><a href="#const成员" class="headerlink" title="const成员"></a>const成员</h5><p>将const修饰的类成员函数称之为<strong>const成员函数</strong>，const修饰类成员函数，实际修饰该函数隐含的this指针，<strong>表明在该成员函数中不能对类的任何成员进行修改</strong></p><h5 id="取地址及const取地址操作符重载"><a href="#取地址及const取地址操作符重载" class="headerlink" title="取地址及const取地址操作符重载"></a>取地址及const取地址操作符重载</h5><p>这两个默认成员函数一般不用重新定义，编译器默认会生成</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"> Date* <span class="keyword">operator</span>&amp;()</span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">this</span> ;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">const</span> Date* <span class="keyword">operator</span>&amp;()<span class="keyword">const</span></span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">this</span> ;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="keyword">private</span> :</span><br><span class="line"> <span class="keyword">int</span> _year ; <span class="comment">// 年</span></span><br><span class="line"> <span class="keyword">int</span> _month ; <span class="comment">// 月</span></span><br><span class="line"> <span class="keyword">int</span> _day ; <span class="comment">// 日</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;类与对象-第二部分&quot;&gt;&lt;a href=&quot;#类与对象-第二部分&quot; class=&quot;headerlink&quot; title=&quot;类与对象(第二部分)&quot;&gt;&lt;/a&gt;类与对象(第二部分)&lt;/h3&gt;&lt;h4 id=&quot;类的6个默认成员函数&quot;&gt;&lt;a href=&quot;#类的6个默认成员函数&quot; c
      
    
    </summary>
    
    
      <category term="C++" scheme="https://skrskr66.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++-类与对象</title>
    <link href="https://skrskr66.github.io/2019/05/09/C-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
    <id>https://skrskr66.github.io/2019/05/09/C-类与对象/</id>
    <published>2019-05-08T16:10:52.000Z</published>
    <updated>2019-05-14T03:13:15.097Z</updated>
    
    <content type="html"><![CDATA[<h3 id="类与对象-第一部分"><a href="#类与对象-第一部分" class="headerlink" title="类与对象(第一部分)"></a>类与对象(第一部分)</h3><h4 id="类与对象的初步认识"><a href="#类与对象的初步认识" class="headerlink" title="类与对象的初步认识"></a>类与对象的初步认识</h4><p>很多语言都有这方面的区分，比如<strong>C语言是面向过程的语言，关注的是过程</strong>，分析出求解问题的步骤，通过函数调用逐步解决问题。但<strong>是C++是基于面向对象的，关注的是对象</strong>，将一件事情拆分成不同的对象，靠对象之间的交互完成。</p><h4 id="类的引入"><a href="#类的引入" class="headerlink" title="类的引入"></a>类的引入</h4><p>在C语言中，结构体的使用只能定义变量，但是在C++中不一样，不仅可以定义变量还可以定义函数</p><p>但在C++结构体的定义中,更喜欢用classl来代替。</p><h4 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">classname</span>&#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//类体：由成员函数和变量组成</span></span><br><span class="line"></span><br><span class="line">&#125;;<span class="comment">//非常重要的分号</span></span><br></pre></td></tr></table></figure><p><strong>class为定义类的关键字，classname为定义类的名字，{}中为类的主体，注意类定义结束时后面分号</strong></p><p>类中的元素称为类的成员：类中的数据称为<strong>类的属性</strong>或者<strong>成员变量</strong>，类中的函数称为<strong>类的方法</strong>或者<strong>成员函数。</strong></p><h5 id="类的两种定义方法"><a href="#类的两种定义方法" class="headerlink" title="类的两种定义方法"></a>类的两种定义方法</h5><p>1、声明和定义全部放在类体中，需要注意：成员函数如果在类中定义，编译器可能会当成内联函数处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">skrskr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showinfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"I like"</span>&lt;&lt;_sing&lt;&lt;<span class="string">"-"</span>&lt;&lt;_dance&lt;&lt;<span class="string">"-"</span>&lt;&lt;_rap&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">char</span>* _rap;</span><br><span class="line">    <span class="keyword">char</span>* _sing;</span><br><span class="line">    <span class="keyword">char</span>* _dance;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>2、声明放在.h文件中，类的定义放在.cpp文件中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//skrskr.h</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">skrskr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showinfo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>：</span><br><span class="line">    <span class="keyword">char</span>* _rap;</span><br><span class="line">    <span class="keyword">char</span>* _sing;</span><br><span class="line">    <span class="keyword">char</span>* _dance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//skrskr.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"skrskr.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> skrskr::showinfo()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"I like"</span>&lt;&lt;_sing&lt;&lt;<span class="string">"-"</span>&lt;&lt;_dance&lt;&lt;<span class="string">"-"</span>&lt;&lt;_rap&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般情况下，更期望第二种，这种分离的方式，保护性更强</p><h4 id="类的访问限定符及封装"><a href="#类的访问限定符及封装" class="headerlink" title="类的访问限定符及封装"></a>类的访问限定符及封装</h4><h5 id="类的访问限定符"><a href="#类的访问限定符" class="headerlink" title="类的访问限定符"></a>类的访问限定符</h5><p>C++实现封装的方式：<strong>用类将对象的属性与方法结合在一起，让对象更加完善，通过权限选择性的将其接口提供给外部的用户使用</strong></p><p><img src="/2019/05/09/C-类与对象/类1.png" alt="类1"></p><p>访问限定符有三种类型，分别为<strong>公有，保护，私有</strong></p><p>1、public修饰的成员在类外可以直接被访问</p><p>2、protected和private修饰的成员在类外不能直接被访问(此处的protected和private是类似的)</p><p>3、访问权限<strong>作用域从该访问限定符出现的位置开始直到下一个访问限定符出现时为止</strong></p><p>4、class的默认访问权限为private，struct为public(因为public要兼容C)</p><p><strong>注意：访问限定符只在编译时有用，当数据映射到内存后，没有任何访问限定符上的区别</strong></p><p>【面试题~~~】C++中struct和class有什么区别？</p><p>C++需要兼容C语言，所以struct等多当结构体去使用，但是在C++中struct内可以定义函数和class定义类是一样的，区别是struct的成员默认访问方式是public，class的成员默认访问方式是private</p><h5 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h5><p>【面试题~~~】面向对象的三大特性：<strong>封装、继承、多态</strong></p><p>在类和对象阶段，我们更多只了解封装</p><p><strong>封装：将数据和操作数据的方法有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互</strong></p><h4 id="类的作用域"><a href="#类的作用域" class="headerlink" title="类的作用域"></a>类的作用域</h4><p>类定义了一个新的作用域，类的所有成员都在类的作用域中。在类体外的定义成员，需要使用<code>::</code>作用域限制符指明成员属于哪个类域。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">skr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">skrinfo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> _cxk[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">char</span> _wyf[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">int</span> _age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//这里需要指明是属于哪个类中</span></span><br><span class="line"><span class="keyword">void</span> skr::skrinfo()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;_cxk&lt;&lt;<span class="string">"+"</span>&lt;&lt;_wyf&lt;&lt;<span class="string">"is"</span>&lt;&lt;_age&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类的实例化"><a href="#类的实例化" class="headerlink" title="类的实例化"></a>类的实例化</h4><p><strong>用类类型创建对象的过程，称为类的实例化</strong></p><p>1、<strong>类只是一个模型</strong>一样的东西，限定了类有哪些成员，定义出一个类并没有分配实际的内存空间来存储它</p><p>2、一个类可以实例化出多个对象，实例化出的对象，占用实际的物理空间，存储类的成员变量</p><p>3、类实例化出对象就像现实中使用建筑设计图建造出房子，类就像是设计图</p><h4 id="类对象模型"><a href="#类对象模型" class="headerlink" title="类对象模型"></a>类对象模型</h4><p>平时所声明的类只是一种类型定义，它本身是没有大小可言的。 我们这里指的类的大小，其实指的是类的对象所占的大小。因此，如果用sizeof运算符对一个类型名操作，得到的是具有该类型实体的大小。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;    </span></span></span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span>    </span></span><br><span class="line"><span class="class">&#123;</span>    </span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>&#123;    </span><br><span class="line">    </span><br><span class="line">  &#125;    </span><br><span class="line"><span class="keyword">private</span>:    </span><br><span class="line">  <span class="keyword">int</span> _a;    </span><br><span class="line">&#125;;    </span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span>    </span></span><br><span class="line"><span class="class">&#123;</span>    </span><br><span class="line">  <span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>&#123;&#125;    </span><br><span class="line">&#125;;    </span><br><span class="line">    </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A3</span>    </span></span><br><span class="line"><span class="class">&#123;</span>&#125;;    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="keyword">sizeof</span>(A1)&lt;&lt;<span class="keyword">sizeof</span>(A2)&lt;&lt;<span class="keyword">sizeof</span>(A3)&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;                                                                                                             </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sizeof(A1)=4；sizeof(A2)=1；sizeof(A3)=1</p><h5 id="结构体内存对齐规则"><a href="#结构体内存对齐规则" class="headerlink" title="结构体内存对齐规则"></a>结构体内存对齐规则</h5><p>该规则在之前结构体写到过</p><p>1.第一个成员在与结构体偏移量为0的地址处。 </p><p>2.其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。 </p><p>注意：对齐数 = 编译器默认的一个对齐数 与 该成员大小的较小值。 VS中默认的对齐数为8，gcc中的对齐数为4 </p><p>3.结构体总大小为：最大对齐数（所有变量类型最大者与默认对齐参数取最小）的整数倍。 </p><p>4.如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是 所有最大对齐数（含嵌套结构体的对齐数）的整数倍。</p><h4 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h4><h5 id="this指针的引出"><a href="#this指针的引出" class="headerlink" title="this指针的引出"></a>this指针的引出</h5><p>我们先来定义一个日期类Date</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Date</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Display</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;_year&lt;&lt;<span class="string">"-"</span>&lt;&lt;_month&lt;&lt;<span class="string">"-"</span>&lt;&lt;_day&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetDate</span><span class="params">(<span class="keyword">int</span> year,<span class="keyword">int</span> month,<span class="keyword">int</span> day)</span></span>&#123;</span><br><span class="line">        _year = year;</span><br><span class="line">        _month = month;</span><br><span class="line">        _day = day;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _year;</span><br><span class="line">    <span class="keyword">int</span> _month;</span><br><span class="line">    <span class="keyword">int</span> _day;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Date d1, d2;</span><br><span class="line">    d1.SetDate(<span class="number">2018</span>,<span class="number">5</span>,<span class="number">14</span>);</span><br><span class="line">    d2.SetDate(<span class="number">2019</span>,<span class="number">5</span>,<span class="number">14</span>);</span><br><span class="line">    d1.Display();</span><br><span class="line">    d2.Display();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上述类，有这样的一个问题：</p><p>Date类中有SetDate与Display这样两个成员函数，函数体中没有关于不同对象的区分，那当d1调用SetDate函数时，该函数是如何知道设置d1对象，而不是设置d2对象呢？</p><p>C++中通过引入this指针解决该问题,即：C<strong>++编译器给每个“成员函数”增加了一个隐藏的指针参数，让该指针指向当前对象(函数运行时调用该函数的对象)，在函数体中所有成员变量的操作，都是通过该指针去访问。只不过所有的操作对用户都是透明的，即用户不需要来传递，编译器自动完成</strong></p><h5 id="this指针的特性"><a href="#this指针的特性" class="headerlink" title="this指针的特性"></a>this指针的特性</h5><p><strong>this指针的类型：类类型* const</strong></p><p>this指针只能在“成员函数”中使用</p><p><strong>this指针本质上其实是一个成员函数的形参，是对象调用成员函数时，将对象地址作为实参传递给this形参。所以对象中不存储this指针。</strong></p><p><strong>this指针是成员函数第一个隐含的指针形参，一般情况由编译器通过exc寄存器自动传递，不需要用户传递</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Display</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;_year&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内置的this指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Display</span><span class="params">(Date* <span class="keyword">this</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="keyword">this</span>-&gt;_year&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还要知道<strong>this指针参数则是存放在寄存器中。类的静态成员函数因为没有this指针这个参数，所以类的静态成员函数也就无法调用类的非静态成员变量。</strong> </p><p>那么还有最后一个问题，this指针能否为空指针呢？</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这是在某个类中的成员函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"test"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"change"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;_name&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们调用change()函数时就会出错</p><p>在第一个函数中，没有调用任何函数，可以执行。</p><p>但是在第二个函数中，此时为<code>this（NULL)-&gt;_name</code>，this指针此时为空，那么不能进行空指针的引用。</p><p>根据this的约定中：</p><p><strong>如果参数个数确定，this指针通过ecx传递给被调函数，如果不参数确定，this指针所在的参数被压栈后压入堆栈。</strong> </p><p>所以总结一下，this指针可以为空，当函数内部不需要使用到this指针时，就是说此时不需要通过this指向当前对象并对其进行操作时才可以为空。但是调用的函数需要指向当前对象，并进行操作，则会发生错误，这跟C中调用空指针的引用错误性质一样。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;类与对象-第一部分&quot;&gt;&lt;a href=&quot;#类与对象-第一部分&quot; class=&quot;headerlink&quot; title=&quot;类与对象(第一部分)&quot;&gt;&lt;/a&gt;类与对象(第一部分)&lt;/h3&gt;&lt;h4 id=&quot;类与对象的初步认识&quot;&gt;&lt;a href=&quot;#类与对象的初步认识&quot; cla
      
    
    </summary>
    
    
      <category term="C++" scheme="https://skrskr66.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Linux多线程</title>
    <link href="https://skrskr66.github.io/2019/05/06/Linux%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://skrskr66.github.io/2019/05/06/Linux多线程/</id>
    <published>2019-05-06T00:58:25.000Z</published>
    <updated>2019-05-15T08:45:09.612Z</updated>
    
    <content type="html"><![CDATA[<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>越深入的学习之后，经常能听到这么一个词—-多线程。之前的学习经常会提到多进程，父进程在忙不过来的情况下，会创建子进程进行帮忙，这样就是一个多进程的任务。那么什么是多线程呢？</p><h4 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h4><p>在传统的操作系统中，进程就是一个运行中程序的描述信息—-pcb，控制程序的运行。</p><p>在Linux操作系统下，pcb是进程，因为Linux下<strong>线程是以进程pcb模拟实现线程</strong>；也有人称为轻量级进程。但是Linux下没有为线程设计一个pcb来控制线程的运行。</p><p><img src="/2019/05/06/Linux多线程/线程1.png" alt="线程1"></p><p>上图介绍了线程组是个什么组合。</p><h4 id="线程组理解"><a href="#线程组理解" class="headerlink" title="线程组理解"></a>线程组理解</h4><p><strong>进程就是线程组，包含了一个或多个线程</strong></p><p>从上图来看，<strong>Linux线程是PCB，因为CPU调度程序运行是调度pcb，所以线程是CPU调度的基本单位。</strong></p><p><strong>因为进程是线程组，程序运行时，资源是分配给整个线程组的，因此线程是资源分配的基本单位。</strong></p><p>vfork()创建一个子进程共用同一个虚拟地址空间，怕出现调用栈混乱，因此子进程运行完毕或者程序替换后父进程才开始运行。</p><h4 id="多线程和多进程的比较"><a href="#多线程和多进程的比较" class="headerlink" title="多线程和多进程的比较"></a>多线程和多进程的比较</h4><p>多线程和多进程都可以并行多任务，那么哪个执行起来比较好呢</p><p><strong>从线程的角度来看，优点：</strong></p><p>1、一个进程中的线程共用同一个虚拟地址空间</p><p>2、线程间通信更为方便</p><p>3、线程的创建/销毁成本更低</p><p>4、同一个进程间的线程调度成本要更低</p><p>5、执行力度更加细致</p><p><strong>缺点：</strong></p><p>线程缺乏访问控制—-健壮性低。</p><p>比如exit(),异常针对的是整个进程，进程退出，那么线程也就不存在了。这样的话线程的可控性比较低</p><p><strong>共同优点：都可以并发/并行处理任务，提高处理效率</strong></p><p><strong>多进程/多线程进行多任务处理的优势体现与细节：</strong></p><p>CPU密集型程序：程序中都是大量的运算操作</p><p>IO密集型程序：程序中都是大量的IO操作</p><p><strong>共同缺点：对临界资源操作需要考虑的更多，编码更加复杂</strong></p><h4 id="线程创建，线程终止，线程等待，线程分离"><a href="#线程创建，线程终止，线程等待，线程分离" class="headerlink" title="线程创建，线程终止，线程等待，线程分离"></a>线程创建，线程终止，线程等待，线程分离</h4><p>先回顾一下进程创建。在之前的总结中我们通过fork()函数和vfork()函数创建子进程。</p><ul><li><p>fork 是 创建一个子进程，并把父进程的内存数据copy到子进程中。</p></li><li><p>vfork是 创建一个子进程，并和父进程的内存数据share一起用。</p><p>这两个的区别是，一个是copy，一个是share。</p><p>fork函数是在父进程执行到子进程创建的位置，将内存数据拷贝进入，等待子进程执行，子进程执行完后，退出后父进程在继续执行。</p><p>vfork函数是保证子进程先执行，当子进程调用exit()或exec()后，父进程往下执行</p></li></ul><p>操作系统并没有为用户提供直接创建线程的系统调用接口。但是大佬封装了一套库线程控制</p><p>用户创建的进程是一个用户态线程，在内核中对应了一个轻量级进程实现程序的调度运行</p><h5 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="comment">//注意！！！</span></span><br><span class="line"><span class="comment">//注意！！！</span></span><br><span class="line"><span class="comment">//注意！！！</span></span><br><span class="line">因为是库函数，所以编译链接的时候需要加上-pthread/-lpthread链接线程库</span><br><span class="line">pthread_create(<span class="keyword">pthread_t</span> *thread, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr,</span><br><span class="line">                          <span class="keyword">void</span> (start_routine) (<span class="keyword">void</span> *), <span class="keyword">void</span> *arg);</span><br><span class="line"><span class="keyword">pthread_t</span> *thread<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> 输出型参数，获取线程的PID</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">pthread_attr_t</span> *attr,线程属性，大部分时间都设为<span class="literal">NULL</span></span><br><span class="line"><span class="keyword">void</span>(start_routine)(<span class="keyword">void</span>*)线程入口函数</span><br><span class="line"><span class="keyword">void</span>* arg通过线程入口函数传递给线程的参数作为实参传给函数</span><br><span class="line">返回值：成功返回 <span class="number">0</span>，失败返回 errno&gt;<span class="number">0</span></span><br><span class="line">    </span><br><span class="line">pthread_create（）函数在调用过程中启动一个新线程。新线程通过调用start_routine（）开始执行，arg作为start_routine（）的唯一参数传递。</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_t</span> pthread_self(<span class="keyword">void</span>);</span><br><span class="line">返回调用线程ID；</span><br></pre></td></tr></table></figure><p>线程创建Demo，最近正好学习了C++，将代码都改成了C++的风格</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;                      </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;             </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;                                               </span></span></span><br><span class="line">                 </span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">thr_start</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"I am child thread-----"</span>&lt;&lt;(<span class="keyword">char</span>*)arg&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    sleep(<span class="number">1</span>);   </span><br><span class="line">  &#125;                                  </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;      </span><br><span class="line">&#125;                                                               </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">  <span class="keyword">pthread_t</span> tid;                                                   </span><br><span class="line">  <span class="keyword">int</span> ret = pthread_create(&amp;tid,<span class="literal">NULL</span>,thr_start,(<span class="keyword">void</span>*)<span class="string">"I am hujun!"</span>);</span><br><span class="line">  <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt; <span class="string">"thread create error"</span>&lt;&lt;<span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">  &#125;</span><br><span class="line">  sleep(<span class="number">5</span>);      </span><br><span class="line">  pthread_cancel(tid);</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span>&lt;&lt;<span class="string">"I am main thread "</span>&lt;&lt; tid &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    sleep(<span class="number">1</span>);    </span><br><span class="line">  &#125;                   </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/05/06/Linux多线程/线程2.png" alt="线程2"></p><p>如图为运行结果</p><p>在新线程创建之后，执行线程函数中的操作。父进程休眠上五秒，此时在这五秒内，线程不断执行操作。在这之后，时间结束后，线程退出，父进程继续执行操作。</p><p>在打印结果中可以看到tid打印的是一串数字，为什么不是地址呢？</p><p>其实打印的<strong>tid是线程地址空间的首地址</strong>，也有其他的说法称为<strong>该线程的真实pid</strong></p><p>通过指令<code>ps -L</code>查看轻量级进程</p><p><img src="/2019/05/06/Linux多线程/线程3.png" alt="线程3"></p><p>可以看到PID和LWP是相同的，这是因为</p><p>此处的PID是线程组ID—-tgid(thread group ID),可以理解为线程组中主线程pid</p><p>此处的LWP显示的就是线程ID，也可以说是tid。</p><p><img src="/2019/05/06/Linux多线程/线程4.png" alt="线程4"></p><h5 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h5><p><strong>在线程入口函数中return；main函数中不能return，否则退出的是进程</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span>* retval)</span></span>;</span><br><span class="line">退出调用线程，retval作为返回值；</span><br><span class="line">主动退出，谁调用谁退出；</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br><span class="line">取消一个指定的线程，被动退出；</span><br></pre></td></tr></table></figure><p><strong>主线程退出，进程并不会退出，线程退出也会成为僵尸线程。线程地址空间无法被回收再利用，造成内存泄漏。</strong></p><p>线程退出Demo</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;                          </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;     </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;             </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thr_start</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;    </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;      </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"child thread----\n"</span>);    </span><br><span class="line">  sleep(<span class="number">1</span>);    </span><br><span class="line">  pthread_exit(<span class="literal">NULL</span>);    </span><br><span class="line">  &#125;      </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;      </span><br><span class="line">  &#125;    </span><br><span class="line">      </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc , <span class="keyword">char</span> *argv[])</span></span>&#123;    </span><br><span class="line">    <span class="keyword">pthread_t</span> tid;    </span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, thr_start,<span class="literal">NULL</span>);    </span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;    </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"thread create error\n"</span>);    </span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="comment">//使指定的线程退出tid == thread    </span></span><br><span class="line">    pthread_cancel(tid);    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;    </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"main thread -------\n"</span>);    </span><br><span class="line">      sleep(<span class="number">1</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                      </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/05/06/Linux多线程/线程5.png" alt="线程5"></p><p>打印的结果如上。</p><p>如果根据代码来看，可能会认为线程创建完之后，应该先打印child pthread。但是却不是这样，这是因为对于主函数来说线程创建完成后，它将继续往下走，而重新创建的新线程需要去创建或寻找接口函数等一系列操作。当这些执行完成之后，才打印线程的操作。</p><p>在代码中有pthread_cancel这个函数的使用。<strong>线程取消的方法是向目标线程发Cancel信号（pthread_cancel函数发送Cancel信号），但如何处理Cancel信号则由目标线程自己决定，或者忽略、或者立即终止、或者继续运行至Cancelation-point（取消点），由不同的Cancelation状态（pthread_setcancelstate函数设置状态）决定。</strong> </p><p>所以目标线程选择了退出，之后继续执行主函数的操作</p><h5 id="线程等待"><a href="#线程等待" class="headerlink" title="线程等待"></a>线程等待</h5><p>功能：等待线程退出，获取指定线程的返回值，允许系统回收线程资源</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pthread_join(<span class="keyword">pthread_t</span>, <span class="keyword">void</span> **retval);</span><br><span class="line">要等待的线程id</span><br><span class="line">retval输出型参数-用于获取退出线程的返回值成功返回<span class="number">0</span>，失败返回一个非<span class="number">0</span>值</span><br><span class="line">返回值：<span class="number">0</span>失败：!<span class="number">0</span>---errno</span><br></pre></td></tr></table></figure><p><strong>一个线程创建起来，默认有一个属性：joinable。**</strong>关键！！！！**</p><p>说明:</p><ul><li><p>调用线程将一直阻塞, 直到指定的线程调用pthread_exit, 从启动例程返回或被取消.</p></li><li><p>如果线程从它的启动例程返回, rval_ptr包含返回码.</p></li><li><p>如果线程被取消, 由rval_ptr指定的内存单元置为: PTHREAD_CANCELED.</p></li><li><p>如果对返回值不关心, 可把rval_ptr设为NULL.</p></li></ul><h5 id="线程分离"><a href="#线程分离" class="headerlink" title="线程分离"></a>线程分离</h5><p><strong>将线程的一个属性从joinable设置为detach属性</strong></p><p>功能：分离一个线程，线程退出后系统将自动回收资源；被分离的线程无法被等待，若是非要pthread_join则会直接报错</p><p>man手册说明：<strong>将线程标识的线程标记为已分离。当分离的线程终止时，其资源将自动释放回系统，而不需要另一个线程与终止的线程联接。</strong></p><p><strong>处于detach属性的线程，退出后资源直接自动被回收，这类线程不能被等待</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br><span class="line"><span class="comment">//thread 要被分离的线程ID</span></span><br><span class="line"><span class="comment">//功能：分离一个线程(设置线程的属性从joinable-&gt;detach属性)，线程退出后系统将自动回收资源，被分离的线程无法被等待，若是非要pthread_join则会直接报错返回</span></span><br><span class="line">注意：线程被分离的前提是用户不关心，线程的退出返回值</span><br></pre></td></tr></table></figure><p><strong>线程的分离，对于一个线程来说，任意线程再任意位置调用都可以！！！</strong></p><p><strong>用法：通常如果用户对线程的返回值并不关心，则在创建线程之后直接分离线程或者在线程入口函数中第一时间分离自己</strong></p><p><strong>处于joinable状态的线程退出后不会自动释放资源需要被等待</strong></p><p><strong>处于detach状态的线程退出后系统会自动回收资源并且不需要等待</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个线程等待和线程分离的Demo</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> *<span class="title">thr_start</span><span class="params">(<span class="keyword">void</span>* arg)</span></span>&#123;</span><br><span class="line">    <span class="comment">//pthread_detach(pthread_self());</span></span><br><span class="line">    <span class="comment">//pthread_exit((void*)"leihou");</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">"i am thread"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;    </span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, thr_start, <span class="literal">NULL</span>);    </span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;    </span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">"pthread create error"</span>&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">    sleep(<span class="number">1</span>);    </span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid;</span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, thr_start, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">"pthread create error"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">char</span>* retval = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> err = pthread_join(tid,(<span class="keyword">void</span>**)&amp;retval);</span><br><span class="line">    <span class="keyword">if</span>(err == EINVAL)&#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">"thread can not be waited"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//cout&lt;&lt;retval&lt;&lt;endl;</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"retval:%s\n"</span>,retval);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="built_in">cout</span>&lt;&lt;<span class="string">"i am main thread"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">      sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>首先将线程创建函数的两个接口注释掉。</p><p>当线程没有退出时，pthread_join函数没有立即返回，主函数继续执行，而且没有retval返回值。</p><p>当添加pthread_exit()函数后，此时线程等待结束退出后立即返回retval返回值“leihou”</p><p>当添加pthread_detach()函数后，此时线程分离当前线程，此时将不再有线程等待这么一个操作，返回值retval此时为NULL，并且分离后资源交由系统回收，此时主函数继续循环执行。</p><p>下一篇好好分析线程安全和各种锁和消费者与生产者模型</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;多线程&quot;&gt;&lt;a href=&quot;#多线程&quot; class=&quot;headerlink&quot; title=&quot;多线程&quot;&gt;&lt;/a&gt;多线程&lt;/h3&gt;&lt;p&gt;越深入的学习之后，经常能听到这么一个词—-多线程。之前的学习经常会提到多进程，父进程在忙不过来的情况下，会创建子进程进行帮忙，这样就
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://skrskr66.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>C++入门</title>
    <link href="https://skrskr66.github.io/2019/05/01/C-%E5%85%A5%E9%97%A8/"/>
    <id>https://skrskr66.github.io/2019/05/01/C-入门/</id>
    <published>2019-05-01T13:13:22.000Z</published>
    <updated>2019-05-07T14:13:36.861Z</updated>
    
    <content type="html"><![CDATA[<p>终于进入了C++的学习。正所谓学好C++，走遍全天下。C++可以说为我打开了新世界。不过数据结构的知识还是得不断地复习啊</p><h4 id="C-关键字"><a href="#C-关键字" class="headerlink" title="C++关键字"></a>C++关键字</h4><p>关键字在C语言中就已经见过了许多比如最常见的if-else，for，int，double等等。只不过在C++中还会遇到更多的，以后会慢慢学习</p><h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p>C++引入命名空间这个概念是因为在我们编程中可能写到大量的函数，比如我在某个头文件中写了abc()这样一个函数，但是在我的另一个库文件中本身就存在abc()这样一个函数。那么我一旦调用就会发生冲突</p><p>所以使用命名空间的目的<strong>是对标识符的名称进行本地化，以避免命名冲突或名字污染</strong>，namespace关键字的出现就是针对这个问题的</p><h5 id="命名空间的定义"><a href="#命名空间的定义" class="headerlink" title="命名空间的定义"></a>命名空间的定义</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通的命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> N1&#123;<span class="comment">//N1为命名空间的名称</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="comment">//命名空间的内容，既可以定义变量，也可以定义函数</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b + c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//命名空间也可以嵌套</span></span><br><span class="line"><span class="keyword">namespace</span> N1&#123;</span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b + c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">namespace</span> N2&#123;</span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> b + c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//同一个工程中允许存在多个相同名称的命名空间</span></span><br><span class="line"><span class="comment">//编译器最后会合成同一个命名空间</span></span><br><span class="line"><span class="keyword">namespace</span> N1&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">Mul</span><span class="params">(<span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b * c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：一定命名空间定义了一个新的作用域，命名空间中的所有内容都局限于该命名空间中</strong></p><h5 id="命名空间的使用"><a href="#命名空间的使用" class="headerlink" title="命名空间的使用"></a>命名空间的使用</h5><p><strong>1、加命名空间名称及作用域限定符</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d/n"</span>,N1::a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、使用using将命名空间中成员引入</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> N1::a;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3、使用using namespace命名空间引入</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> N1;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a);</span><br><span class="line">    add(<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="C-输入和输出"><a href="#C-输入和输出" class="headerlink" title="C++输入和输出"></a>C++输入和输出</h4><p>学习一门语言最先开始要进行的打招呼仪式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="string">"hello,world"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>cout标准输出</code>和<code>cin标准输入时</code>，必须包含<code>&lt;iostream&gt;</code>头文件以及<strong>std标准命名空间</strong>。</p><p>关于<code>.h</code>：早期标准库将所有功能在全局域中实现，声明在<code>.h</code>的后缀的头文件中，使用时只需要包含对应的头文件即可，后来将其实现在std命名空间下，为了和C头文件区分，也为了正确使用命名空间，规定C++头文件不带<code>.h</code>；旧编译器(VC++6.0)还支持，后续不再支持。现在推荐使用<code>&lt;iostream&gt; + std</code>的方式</p><p>使用c++输入输出更方便，不需增加数据格式控制</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;b&gt;&gt;c;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; a &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; b &lt;&lt;<span class="string">" "</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/05/01/C-入门/入门1.png" alt="入门1"></p><h4 id="缺省参数"><a href="#缺省参数" class="headerlink" title="缺省参数"></a>缺省参数</h4><p>缺省参数可以理解为备用值。</p><h5 id="缺省参数概念"><a href="#缺省参数概念" class="headerlink" title="缺省参数概念"></a>缺省参数概念</h5><p>缺省参数是声明或定义函数时为函数的参数指定一个默认值。在调用该函数时，如果没有指定实参则采用该默认值，否则使用指定的实参。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;    </span></span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;    </span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Func</span><span class="params">(<span class="keyword">int</span> a = <span class="number">9</span>)</span></span>&#123;    </span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">&#125;    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </span><br><span class="line">    </span><br><span class="line">  Func();    </span><br><span class="line">  Func(<span class="number">100</span>);    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;                                                                                                             </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/05/01/C-入门/入门2.png" alt="入门2"></p><h5 id="缺省参数的分类"><a href="#缺省参数的分类" class="headerlink" title="缺省参数的分类"></a>缺省参数的分类</h5><p><strong>全缺省参数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testfunc</span><span class="params">(<span class="keyword">int</span> a = <span class="number">10</span>,<span class="keyword">int</span> b = <span class="number">20</span>,<span class="keyword">int</span> c = <span class="number">30</span>)</span></span>&#123;    </span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"a = "</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"b = "</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"c = "</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>半缺省参数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testfunc2</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b = <span class="number">20</span>,<span class="keyword">int</span> c = <span class="number">30</span>)</span></span>&#123;    </span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"a = "</span>&lt;&lt;a&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"b = "</span>&lt;&lt;b&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"c = "</span>&lt;&lt;c&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>半缺省参数的函数在调用时，必须加上参数a的赋值，否则会报错。</p><p>半缺省参数必须从右往左依次来给，不能间隔着给</p><p>缺省参数不能在函数声明和定义中同时出现，因为当声明与定义位置同时出现，恰巧两个位置提供的值不同，那编译器就无法确认到底该用哪个缺省值</p><p>缺省值必须是常量或者全局变量</p><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><h5 id="函数重载的概念"><a href="#函数重载的概念" class="headerlink" title="函数重载的概念"></a>函数重载的概念</h5><p>函数重载是函数的一种特殊情况，C++允许在同一作用域中声明几个功能类似的同名函数，这些同名函数的形参列表(参数个数 或 类型 或 顺序)必须不同，常用来处理实现功能类似数据类型不同的问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;    </span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;    </span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;    </span><br><span class="line">  <span class="keyword">return</span> a + b;    </span><br><span class="line">&#125;    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">add</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span></span>&#123;    </span><br><span class="line">  <span class="keyword">return</span> a + b;    </span><br><span class="line">&#125;    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> a,<span class="keyword">long</span> b)</span></span>&#123;    </span><br><span class="line">  <span class="keyword">return</span> a +b;    </span><br><span class="line">&#125;    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;add(<span class="number">10</span>,<span class="number">20</span>)&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;add(<span class="number">10.0</span>,<span class="number">20.0</span>)&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;add(<span class="number">10L</span>,<span class="number">20L</span>)&lt;&lt;<span class="built_in">endl</span>;    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;                      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然函数名都是一样的，但是参数传参的类型不同。当在调用的时候，编译器检查到参数的不同，对应到相应的函数中，这样就可以实现不同类型的计算了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面两个函数，虽然参数不同，但是函数类型已经确定了返回值，这样的话函数不管参数给什么都没法实现不同类型的计算，就不存在重载的意义了</span></span><br><span class="line"><span class="function"><span class="keyword">short</span> <span class="title">Add</span><span class="params">(<span class="keyword">short</span> left, <span class="keyword">short</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> left+right;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">short</span> left, <span class="keyword">short</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> left+right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="名字修饰"><a href="#名字修饰" class="headerlink" title="名字修饰"></a>名字修饰</h5><p>在C++中，一个程序要运行起来，需要经历以下几个阶段：<strong>预处理，编译，汇编，链接</strong></p><p><strong>而名字修饰是一种在编译过程中，将函数、变量的名称重新改编的机制，简单来说就是编译器为了区分各个函数，将函数通过某种算法，重新修饰为一个全局唯一的名称</strong></p><p>C语言的名字修饰比较简单，就直接在函数名前面加了一个下划线。比如<code>add</code>修饰为<code>_add</code></p><p>但C++不同，由于C++要支持重载，命名空间等，使得其修饰规则比较复杂，不同编译器在底层的实现方式可能都有差异</p><p>名字的修饰过程不必深入了解，只需知道被重新修饰后的名字中包含了：<strong>函数的名字以及参数类型</strong>，这就是为什么函数重载中几个同名函数要求其参数列表不同。</p><p>Linux下我们通过指令反汇编来查看<code>objdump -d a.out &gt;log.txt</code></p><p><img src="/2019/05/01/C-入门/入门3.png" alt="入门3"></p><p>我们可以看到三个很相似的名字，<code>_Z3addii</code>，<code>_Z3adddd</code>,<code>_Z3addll</code></p><p>但是仔细观察它们的最后两个字母都不相同，这代表了参数类型不同。分别是int，double，long</p><p>但是它们的规制是一样的”<strong>返回类型+函数名+参数列表</strong>“</p><p>这也可以解释了为什么C语言中不支持函数重载，因为在函数编译过程中，C语言并不能将同名不同参数的函数<strong>名字修饰</strong>，所以它没法支持函数重载。</p><h5 id="extern“C”"><a href="#extern“C”" class="headerlink" title="extern“C”"></a>extern“C”</h5><p>有时候在C++工程中可能需要<strong>将某些函数按照C的风格来编译</strong>，在函数前加extern “C”，意思是告诉编译器，将该函数按照C语言规则来编译。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">int</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> Add(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以编译通过，但是链接时出现错误</span></span><br></pre></td></tr></table></figure><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><h5 id="引用的概念"><a href="#引用的概念" class="headerlink" title="引用的概念"></a>引用的概念</h5><p><strong>引用不是新定义一个变量，而是给已存在的变量取了一个别名，编译器不会为引用变量开辟内存空间，它和引用的变量共用同一块内存空间</strong></p><p><code>类型&amp; 引用变量名(对象名) = 引用实体</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestRef</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span>&amp; ra = a;<span class="comment">//&lt;====定义引用类型</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>, &amp;ra);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>引用类型必须和引用实体是同种类型的</strong></p><h5 id="引用特性"><a href="#引用特性" class="headerlink" title="引用特性"></a>引用特性</h5><p>1、引用在定义时必须初始化</p><p>2、一个变量可以有多个引用</p><p>3、引用一旦引用一个实体，再不能引用其他实体</p><h5 id="常引用"><a href="#常引用" class="headerlink" title="常引用"></a>常引用</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestConstRef</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//int&amp; ra = a;   // 该语句编译时会出错，a为常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; ra = a;</span><br><span class="line"><span class="comment">// int&amp; b = 10; // 该语句编译时会出错，b为常量</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; b = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">double</span> d = <span class="number">12.34</span>;</span><br><span class="line"><span class="comment">//int&amp; rd = d; // 该语句编译时会出错，类型不同</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; rd = d;<span class="comment">//这样引用类型可以，但是返回值是int类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>int const&amp;表示此引用所代表的int类型变量无法使用此引用修改.</strong></p><p><strong>const int&amp;表示此引用所代表的是const int类型变量,同样也无法用此引用修改.</strong> </p><h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">Add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = a + b;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>&amp; ret = Add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">    Add(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Add(1, 2) is :"</span>&lt;&lt; ret &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当执行这段代码时，输出应该是3，但是输出的结果是7</p><p><img src="/2019/05/01/C-入门/入门4.png" alt="入门4"></p><p><strong>这是因为再函数返回时，离开函数作用域后，其栈上空间已经还给了系统，因此不能用栈上的空间作为引用类型返回。如果以引用类型返回，返回值的生命周期必须不受函数的限制(即比函数生命周期长)</strong></p><p>再来看这段代码，ret第一次引用之后为3，但是函数离开了作用域后，栈上的空间被归还了。但此时又调用了一次这个函数，栈上的空间可能还为上一次使用的区域，此时ret就为7了。</p><h5 id="引用和指针的区别"><a href="#引用和指针的区别" class="headerlink" title="引用和指针的区别"></a>引用和指针的区别</h5><p>在语法概念上引用就是一个别名，没有独立空间，和其引用实体共用同一块空间</p><p>但是在底层实现上实际是有空间的，因为引用按照指针方式实现的</p><p><strong>引用和指针的不同点</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1. </span>引用在定义时必须初始化，指针没有要求</span><br><span class="line"><span class="bullet">2. </span>引用在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向任何一个同类型实</span><br><span class="line">体</span><br><span class="line"><span class="bullet">3. </span>没有NULL引用，但有NULL指针</span><br><span class="line"><span class="bullet">4. </span>在sizeof中含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节个数(32位平台下占4</span><br><span class="line">个字节)</span><br><span class="line"><span class="bullet">5. </span>引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小</span><br><span class="line"><span class="bullet">6. </span>有多级指针，但是没有多级引用</span><br><span class="line"><span class="bullet">7. </span>访问实体方式不同，指针需要显式解引用，引用编译器自己处理</span><br><span class="line"><span class="bullet">8. </span>引用比指针使用起来相对更安全</span><br></pre></td></tr></table></figure><h4 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h4><p>以<strong>inline修饰</strong>的函数叫做内联函数，编译时C++编译器会在调用内联函数的地方展开，没有函数压栈的开销，内联函数提升程序运行的效率。</p><p>内联是一种空间换时间的做法，省去调用函数额开销。所以代码很长或者有循环/递归的函数不适宜使用作为内联函数。</p><p><img src="/2019/05/01/C-入门/入门5.png" alt="入门5"></p><p>如果在上述函数前增加inline关键字将其改成内联函数，在编译期间编译器会用函数体替换函数的调用。 </p><p>编译器在不同的模式下查看有区别：</p><p>在release模式下，查看编译器生成的汇编代码中是否存在call Add </p><p>在debug模式下，需要对编译器进行设置，否则不会展开 </p><h4 id="auto关键字"><a href="#auto关键字" class="headerlink" title="auto关键字"></a>auto关键字</h4><p>C++11中，标准委员会赋予了auto全新的含义：<strong>auto不再是一个存储类型指示符，而是作为一个新的类型指示符来指示编译器，auto声明的变量必须由编译器在编译时期推导而得</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//simple demo</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">auto</span> b = a;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="string">"b is "</span>&lt;&lt; b &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意！！</strong></p><p><strong>注意！！</strong></p><p><strong>注意！！</strong></p><p><strong>使用auto定义变量时必须对其进行初始化，在编译阶段编译器需要根据初始化表达式来推导auto的实际类型。因此auto并非是一种“类型”声明，而是一个类型声明时的“占位符”，编译器在编译期间会将auto替换为变量实际的类型</strong></p><h5 id="auto使用规则"><a href="#auto使用规则" class="headerlink" title="auto使用规则"></a>auto使用规则</h5><p><strong>1、auto与指针和引用结合起来使用</strong></p><p>用auto声明指针类型时，用auto和auto*没有任何区别，但用auto声明引用类型时，则必须加&amp;</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">auto</span> b = a;</span><br><span class="line"><span class="keyword">auto</span>* c = &amp;a;</span><br><span class="line"><span class="keyword">auto</span>&amp; d = a;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"b is "</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *c &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、在同一行定义多个变量</strong></p><p>当在同一行声明多个变量时，这些变量必须是相同的类型，否则编译器将会报错，因为编译器实际只对第一个类型进行推导，然后用推导出来的类型其他变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> a = <span class="number">1</span>,b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">auto</span> c = <span class="number">3</span>,d = <span class="number">4.0</span>;<span class="comment">//编译会失败，因为c和d的初始化表达式类型不同</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>auto不能推导的场景</strong></p><p>1、auto不能作为函数的参数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestAuto</span><span class="params">(<span class="keyword">auto</span> a)</span></span>&#123;</span><br><span class="line">    pass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>上面代码是不能编译通过的，auto不能作为形参类型，因为编译器无法对a的实际类型进行推导</strong></p><p>2、auto不能直接用来声明数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestAuto</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">auto</span> b[] = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、auto不能定义类的非静态成员变量</p><p>4、实例化模板时不能使用auto作为模板参数</p><h4 id="基于范围的for循环-C-11"><a href="#基于范围的for循环-C-11" class="headerlink" title="基于范围的for循环(C++11)"></a>基于范围的for循环(C++11)</h4><h5 id="范围for的语法"><a href="#范围for的语法" class="headerlink" title="范围for的语法"></a>范围for的语法</h5><p>在C++98如果要遍历一个数组，可以按照以下方式进行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestFor</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="keyword">sizeof</span>(<span class="built_in">array</span>)/<span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]);++p)&#123;</span><br><span class="line">        <span class="built_in">array</span>[i] *= <span class="number">2</span>；</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span>* p = <span class="built_in">array</span>;p &lt; <span class="built_in">array</span> + <span class="keyword">sizeof</span>(<span class="built_in">array</span>)/<span class="keyword">sizeof</span>(<span class="built_in">array</span>[<span class="number">0</span>]);++p)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; *p &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++是一个追求极致性能的语言，在有范围的数组中，由程序员来说明循环的范围是多余的，有时还会容易犯错误。<strong>for循环后的括号由冒号”:”分为两部分，第一部分是范围内用于迭代的变量，第二部分则表示被迭代的范围</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestFor</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; e : <span class="built_in">array</span>)</span><br><span class="line">        e *= <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> e : <span class="built_in">array</span>)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; e &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="范围for的使用条件"><a href="#范围for的使用条件" class="headerlink" title="范围for的使用条件"></a>范围for的使用条件</h5><p><strong>1、for循环迭代的范围必须是确定的</strong></p><p><strong>对于数组而言，就是数组中第一个元素和最后一个元素的范围</strong>；对于类而言，应该提供begin和end的方法，begin和end就是for循环迭代的范围</p><p>比如如下代码，数组作为形参传入时，这时候的循环条件是不确定的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TestFor</span><span class="params">(<span class="keyword">int</span> <span class="built_in">array</span>[])</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span>&amp; e : <span class="built_in">array</span>)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt; e &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、迭代的对象要实现++和==的操作</p><h4 id="指针空值nullptr"><a href="#指针空值nullptr" class="headerlink" title="指针空值nullptr"></a>指针空值nullptr</h4><p>在C语言中，我们一般定义一个空指针是<code>int *p = NULL</code>或者<code>int *p = 0</code></p><p>两者的意思基本上是相似的。不过NULL实际上是一个宏</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULL ((void*) 0)</span></span><br></pre></td></tr></table></figure><p>在头文件的定义中，一般是这样的。可以看到，NULL可能被定义为字面常量0，或者被定义为无类型指针(void*)0)</p><p>比如在函数中想调用int*的函数，但是NULL被定义成0，因此与程序的初衷相悖</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;<span class="string">"f(int)"</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>*)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;<span class="string">"f(int*)"</span>&lt;&lt;<span class="built_in">endl</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"> f(<span class="number">0</span>); </span><br><span class="line"> f(<span class="literal">NULL</span>); </span><br><span class="line"> f((<span class="keyword">int</span>*)<span class="literal">NULL</span>); </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="nullptr和nullptr-t"><a href="#nullptr和nullptr-t" class="headerlink" title="nullptr和nullptr_t"></a>nullptr和nullptr_t</h5><p>为了考虑兼容性，C++11并没有消除常量0的二义性，C++11给出了全新的nullptr表示空值指针。C++11为什么 </p><p>不在NULL的基础上进行扩展，这是因为NULL以前就是一个宏，而且不同的编译器厂商对于NULL的实现可能 </p><p>不太相同，而且直接扩展NULL，可能会影响以前旧的程序。因此：为了避免混淆，C++11提供了nullptr， </p><p>即：nullptr代表一个指针空值常量。nullptr是有类型的，其类型为nullptr_t，仅仅可以被隐式转化为指针类 </p><p>型，nullptr_t被定义在头文件中： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(<span class="literal">nullptr</span>)</span> nullptr_t</span>;</span><br></pre></td></tr></table></figure><p><strong>注意！！！</strong> </p><p><strong>注意！！！</strong> </p><p><strong>注意！！！</strong> </p><p><strong>1.在使用nullptr表示指针空值时，不需要包含头文件，因为nullptr是C++11作为新关键字引入的。</strong> </p><p><strong>2.在C++11中，sizeof(nullptr) 与 sizeof((void*)0)所占的字节数相同。</strong> </p><p><strong>3.为了提高代码的健壮性，在后续表示指针空值时建议最好使用nullptr</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;终于进入了C++的学习。正所谓学好C++，走遍全天下。C++可以说为我打开了新世界。不过数据结构的知识还是得不断地复习啊&lt;/p&gt;
&lt;h4 id=&quot;C-关键字&quot;&gt;&lt;a href=&quot;#C-关键字&quot; class=&quot;headerlink&quot; title=&quot;C++关键字&quot;&gt;&lt;/a&gt;C+
      
    
    </summary>
    
    
      <category term="C++" scheme="https://skrskr66.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程信号</title>
    <link href="https://skrskr66.github.io/2019/04/23/Linux%E8%BF%9B%E7%A8%8B%E4%BF%A1%E5%8F%B7/"/>
    <id>https://skrskr66.github.io/2019/04/23/Linux进程信号/</id>
    <published>2019-04-23T10:26:30.000Z</published>
    <updated>2019-04-30T16:28:36.282Z</updated>
    
    <content type="html"><![CDATA[<h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><h4 id="信号概念"><a href="#信号概念" class="headerlink" title="信号概念"></a>信号概念</h4><p>通知进程发生了某件事情导致了软件中断—-会打断当前的阻塞操作，去处理事情</p><h4 id="信号的种类"><a href="#信号的种类" class="headerlink" title="信号的种类"></a>信号的种类</h4><p>信号有不同的种类，每个信号都对应了不同的事件</p><p>通过命令行<code>kill -l</code>可以查看信号的种类</p><p><img src="/2019/04/23/Linux进程信号/信号1.png" alt="信号1"></p><p>在图中可以看到这些都是信号的种类，总共有62个种信号</p><p>1-31—-&gt;每个都有各自对应的事件        非可靠信号/非实时信号</p><p>34-64—-&gt;后续添加的信号                可靠信号/非可靠信号</p><p>信号的生命周期：产生—–&gt;注册(注册在进程当中)—–&gt;注销(在进程中注销)—–&gt;处理</p><p><strong>信号是在软件层次上对中断机制的一种模拟，在原理上，一个进程收到一个信号与处理器收到一个中断请求可以说是一样的。信号是异步的，一个进程不必通过任何操作来等待信号的到达，事实上，进程也不知道信号到底什么时候到达。</strong></p><p>信号是进程间通信机制中唯一的异步通信机制，可以看作是异步通知，通知接收信号的进程有哪些事情发生了。信号机制经过POSIX实时扩展后，功能更加强大，除了基本通知功能外，还可以传递附加信息。</p><h5 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h5><p>我自己也是在写的过程中才发觉不了解同步与异步，所以也补充一下</p><p><strong>同步：就是发出一个功能调用时，在没有得到结果之前，该调用就不返回或继续执行后续操作</strong></p><p><strong>异步：当一个异步过程调用发出后，调用者在没有得到结果之前，就可以继续执行后续操作。当这个调用完成后，一般通过状态、通知和回调来通知调用者。对于异步调用，调用的返回并不受调用者控制</strong></p><h5 id="信号的产生"><a href="#信号的产生" class="headerlink" title="信号的产生"></a>信号的产生</h5><p>硬件产生：ctrl+c，ctrl+|，ctrl+z。通过键盘强行关闭，比如在一个无限循环中，使用键盘组合按键将该进程强行停掉。</p><p>软件产生：kill -signo pid 命令 产生一个信号</p><p>比如利用while写上一个死循环程序</p><p><img src="/2019/04/23/Linux进程信号/信号2.png" alt="信号2"></p><p>查询到进程的pid，利用软件产生的方法杀死这个进程</p><p><img src="/2019/04/23/Linux进程信号/信号4.png" alt="信号4"></p><p>当杀死之后就可以看到程序终止</p><p><img src="/2019/04/23/Linux进程信号/信号3.png" alt="信号3"></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid，<span class="keyword">int</span> sig)</span></span></span><br><span class="line">给指定进程发送指定信号</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">raise</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line">给调用进程发送信号</span><br><span class="line">这两个函数都是成功返回<span class="number">0</span>,错误返回<span class="number">-1</span>。</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">abort</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line">给调用进程发送SIGABRT</span><br><span class="line">就像<span class="built_in">exit</span>函数一样,<span class="built_in">abort</span>函数总是会成功的,所以没有返回值。</span><br><span class="line"></span><br><span class="line">unsigned int alarm(unsigned int sconds)；</span><br><span class="line">sconds秒之后给调用进程发送SIGALRM信号</span><br><span class="line">返回值上一个定时器剩余的时间或<span class="number">0</span>，参数为<span class="number">0</span>，取消定时器，返回剩余的时间</span><br><span class="line">可以结合 sleep() 来使用</span><br></pre></td></tr></table></figure><h4 id="信号的注册"><a href="#信号的注册" class="headerlink" title="信号的注册"></a>信号的注册</h4><p>信号的记录在pcb中。在操作系统中有一个结构体叫<code>sigset_t{}</code> ,它是一个位图。</p><p><img src="/2019/04/23/Linux进程信号/信号5.png" alt="信号5"></p><p>如图，在pcb中专门有一个pending结构体存储当前收到的信号，还有一个结构体block结构体专门存储现在都有哪些信号要被阻塞。handler是用户自定义信号的处理方式</p><h5 id="信号注册"><a href="#信号注册" class="headerlink" title="信号注册"></a>信号注册</h5><p>通过修改pending未决信号集合(位图)中对应信号位+添加信号sigqueue节点</p><p>sigqueue是信号发送函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigqueue</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> sig, <span class="keyword">const</span> <span class="keyword">union</span> sigval val)</span></span></span><br><span class="line">调用成功返回 0；否则，返回 -1。</span><br><span class="line"></span><br><span class="line">sigqueue()是比较新的发送信号系统调用，主要是针对实时信号提出的（当然也支持前<span class="number">32</span>种），支持信号带有参数，与函数sigaction()配合使用。</span><br><span class="line"></span><br><span class="line">sigqueue的第一个参数是指定接收信号的进程ID，第二个参数确定即将发送的信号，第三个参数是一个联合数据结构<span class="keyword">union</span> sigval，指定了信号传递的参数，即通常所说的<span class="number">4</span>字节值。</span><br></pre></td></tr></table></figure><p><strong>非可靠信号注册</strong>：判断信号集合位图相应位是否为1；若为0，为信号组织sigqueue节点添加到链表中，并且pending位图置1；若为1(信号已经注册过还没有被处理)，则什么都不做(等于丢弃)。</p><p>判断是否有相同的未决信号，若有，则什么也不做(事件丢失)；否则，修改位图(sigset_t)，添加节点</p><p><img src="/2019/04/23/Linux进程信号/信号6.png" alt="信号6"></p><hr><p><strong>可靠信号注册</strong>：不管信号是否为1，阻止节点，添加到sigqueue链表中，并且位图置1(信号不会丢弃)</p><p>判断是否有相同未决信号，若没有，修改位图(sigset_t)，添加到节点，否则直接添加节点</p><p>可靠信号的注册跟上图的模式是相似的，只是不管是否为1，都阻止节点</p><h4 id="信号的注销"><a href="#信号的注销" class="headerlink" title="信号的注销"></a>信号的注销</h4><p>删除信号的sigqueue节点，并且修改pending位图。</p><p><strong>非可靠信号的注销</strong>：因为非可靠信号的信号节点只有一个，因此删除节点，位图直接置0。</p><p>直接删除节点，修改位图(非可靠信号只会注册一次)</p><p><strong>可靠信号的注销</strong>：因为可靠信号的信号节点可能会有多个，若还有相同信号节点，则位图依然置1，否则置0</p><p>删除节点，判断是否还有相同节点。若有，则位图依然置1，否则修改位图置0</p><p>也可以这样理解，只要存在相同的信号节点，那么位图永远置1。只要没有相同的，则置为0</p><h4 id="信号的处理"><a href="#信号的处理" class="headerlink" title="信号的处理"></a>信号的处理</h4><p>信号的处理有三种方式：</p><h5 id="默认处理方式"><a href="#默认处理方式" class="headerlink" title="默认处理方式"></a>默认处理方式</h5><p>操作系统(内核)既定的处理方式—-SIG_DFL，可能是以下的某种类型：</p><p><strong>Treminate</strong>：进程被终止(杀死)</p><p><strong>Dump</strong>：进程被终止(杀死)，如果可能，创建包含进程执行上下文的核心转储文件(core dump)</p><p><strong>Ignore</strong>：信号被忽略</p><p><strong>Stop</strong>：进程被停止，即把进程置为TASK_STOPPED状态</p><p><strong>Continue</strong>：如果进程被禁止，就把它设置为TASK_RUNNING状态</p><h5 id="忽略处理方式"><a href="#忽略处理方式" class="headerlink" title="忽略处理方式"></a>忽略处理方式</h5><p>这与默认中的忽略是不同的，该处理方式处理了信号，但是什么都没有做。</p><h5 id="自定义处理方式"><a href="#自定义处理方式" class="headerlink" title="自定义处理方式"></a>自定义处理方式</h5><p>通过调用相应的信号处理函数捕捉信号。</p><p><strong>注意！！</strong></p><p><strong>注意！！</strong></p><p><strong>注意！！</strong></p><p><strong>有两个信号SIGKILL -9 SIGSTOP -19 无法被阻塞，无法自定义，无法被忽略</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">信号的捕捉初识</span><br><span class="line">      <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">sighandler_t</span> signal(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler);</span><br><span class="line">      signum: 信号编号</span><br><span class="line">      handler：   函数指针</span><br><span class="line">              SIG_DFL     默认处理方式</span><br><span class="line">              SIG_IGN     忽略处理方式</span><br><span class="line">      使用handler函数替换signum信号的处理方式</span><br></pre></td></tr></table></figure><p>我们利用man手册来了解该函数的用处</p><p><strong>函数的作用是:从三种方式中选择一种接收信号sig的方式。如果func的值是SIG_DFL，则将对该信号进行默认处理。如果func的值为SIG_IGN，则忽略该信号。否则，应用程序应确保func指向信号发生时要调用的函数。由于信号而调用这样一个函数，或者(递归地)调用该调用的任何其他函数(标准库中的函数除外)，称为“信号处理程序”。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#inlcude <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigcb</span><span class="params">(<span class="keyword">int</span> signo)</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"---------\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    signal(SIGINT, sigcb);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"hello ~~~"</span>\n);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/23/Linux进程信号/信号7.png" alt="信号7"></p><p>通过调用signal函数来改变信号的处理方式。平时使用<code>ctrl+c</code>将强制退出软件，但是当这次使用将不在执行</p><p>SIGINT： 程序中止信号，在用户键入INTR字符（通常是Ctrl+C）时发出。 </p><p>此时信号的处理将SIGINT改变成打印一段———，所以最后退出用了<code>ctrl+|</code>才得以退出</p><h5 id="信号自定义处理方式的流程"><a href="#信号自定义处理方式的流程" class="headerlink" title="信号自定义处理方式的流程"></a>信号自定义处理方式的流程</h5><p>用户态切换到内核态运行，完毕后准备从内核态切换到用户态运行的时候，去处理信号。若信号为默认/忽略处理，则在内核中直接完成，但是如果是自定义处理方式，则需要返回用户态执行信号回调函数，完毕后回到内核态，没有信号了则回到程序主流程</p><p><img src="/2019/04/23/Linux进程信号/信号8.png" alt="信号8"></p><p>还有一个处理函数</p><p><code>int sigaction(int sig, const struct sigaction *restrict act,struct sigaction *restrict oact)</code></p><p>sigaction参数结构如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line"><span class="keyword">void</span> (*sa_handler)(<span class="keyword">int</span>);</span><br><span class="line"><span class="keyword">void</span> (*sa_sigaction)(<span class="keyword">int</span>, <span class="keyword">siginfo_t</span> *, <span class="keyword">void</span> *);</span><br><span class="line"><span class="keyword">sigset_t</span> sa_mask;</span><br><span class="line"><span class="keyword">int</span> sa_flags;</span><br><span class="line"><span class="keyword">void</span> (*sa_restorer)(<span class="keyword">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>函数的作用是:允许调用过程检查指定与特定信号相关联的操作</strong></p><p>使用act动作替换原有的处理动作，并且将原有处理动作拷贝到oldact中。不过这个需要等一下再说</p><h4 id="信号的阻塞"><a href="#信号的阻塞" class="headerlink" title="信号的阻塞"></a>信号的阻塞</h4><h5 id="信号的一些其他概念"><a href="#信号的一些其他概念" class="headerlink" title="信号的一些其他概念"></a>信号的一些其他概念</h5><p>信号递达：实际执行信号的处理动作</p><p>信号未决：信号从产生到递达之间的状态</p><h5 id="信号阻塞概念"><a href="#信号阻塞概念" class="headerlink" title="信号阻塞概念"></a>信号阻塞概念</h5><p>暂时阻止信号被递达(处理)。<strong>信号依然可以注册，只是暂时不处理，解除阻塞之后才会处理</strong></p><h5 id="信号阻塞的过程"><a href="#信号阻塞的过程" class="headerlink" title="信号阻塞的过程"></a>信号阻塞的过程</h5><p>在pcb的block-信号阻塞集合中(程序初始化的时候)标记要阻塞的信号，到来之后暂不处理,将blocked位图集合中对应的位-置1，表示阻塞这个信号，直到被解除阻塞(从block集合中移除)</p><h5 id="信号阻塞的接口"><a href="#信号阻塞的接口" class="headerlink" title="信号阻塞的接口"></a>信号阻塞的接口</h5><p><strong>sigprocmask：阻塞/解除阻塞信号</strong></p><p>sigprocmask()用于获取 (与/或) 更改调用线程的信号掩码。信号掩码是一组信号，它的传递目前被调用方阻塞</p><p>SET_BLOCK 将信号添加到阻塞集合中 block = block | set</p><p>SET_UNBLOCK 将信号从阻塞集合中移出 block = block &amp; ~set</p><p>SET_SETMASK 被阻塞的信号集被设置为参数集。block = set</p><p><strong>sigemptyset：清空信号集合</strong></p><p><strong>sigfillset：向集合中添加所有信号</strong></p><p><strong>sigaddset：向集合中添加指定的信号</strong></p><p><strong>sigismember：判断信号是否在集合中</strong></p><p><strong>sigdelset：从集合中移除执行信号</strong></p><p><strong>sigpending：后获取未决信号</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">act</span>,  <span class="title">oldact</span>;</span>    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sigcb</span><span class="params">(<span class="keyword">int</span> signo)</span></span>&#123;    </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"revc signo:%d\n"</span>, signo);    </span><br><span class="line">  sigaction(signo, &amp;oldact, <span class="literal">NULL</span>);                                                                                      </span><br><span class="line">&#125;    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </span><br><span class="line">  act.sa_handler = sigcb;    </span><br><span class="line">  act.sa_flags = <span class="number">0</span>;    </span><br><span class="line">    </span><br><span class="line">  sigemptyset(&amp;act.sa_mask);    </span><br><span class="line">  sigaction(SIGINT, &amp;act, &amp;oldact);    </span><br><span class="line">    </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"---------\n"</span>);    </span><br><span class="line">    sleep(<span class="number">2</span>);    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/23/Linux进程信号/信号9.png" alt="信号9"></p><p>接着之前的另一个处理信号的方法，先将sigaction中参数结构的成员都设置完，之后将信号集合中的信号全部清空。act动作是handler自定义函数，这时候替换了<code>ctrl+c</code>操作。在sigcb函数中再次调用sigaction，此时act动作将继续执行SIGINT。执行结果如上图</p><h4 id="可重入和不可重入函数"><a href="#可重入和不可重入函数" class="headerlink" title="可重入和不可重入函数"></a>可重入和不可重入函数</h4><h5 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h5><p>在并发编程中，这种由于不恰当的执行时序而出现不正确的结果是一种非常严重的情况。因为运行时序而造成的数据竞争，导致数据的二义性。这样的情况，我们称为竞态条件。</p><h5 id="函数的重入和不可重入"><a href="#函数的重入和不可重入" class="headerlink" title="函数的重入和不可重入"></a>函数的重入和不可重入</h5><p>一个函数是否可以在多个运行时序中重复调用而不会出现任何问题，在一个函数中是否进行了对全局数据的非原子性操作。</p><p><strong>重入函数：</strong>在多个时序的运行中重复调用，不会造成异常影响。比如在某个函数的调用中，还没有返回时就再次进入该函数，就称为重入。</p><p><strong>不可重入函数：</strong>不能再多个时序中重复调用，比如malloc和free函数。如果随意的调用则会发生内存泄漏。</p><h4 id="SIGCHLD信号"><a href="#SIGCHLD信号" class="headerlink" title="SIGCHLD信号"></a>SIGCHLD信号</h4><p>子进程退出，通知父进程的信号。</p><p>在僵尸进程中，我们之前设置的是通过wait/waitpid函数去设置怎么避免僵尸进程产生，但是这样父进程就必须一直等待，无法做其他的事情了。所以这时候采用信号机制，非阻塞地查询是否有子进程结束等待清理。</p><p>在子进程终止时会给父进程发SIGCHLD信号，该信号的默认处理动作是忽略，父进程可以自定义SIGCHLD信号的处理函数，这样父进程只需专心处理自己的工作，不必关心子进程了，子进程终止时会通知父进程，父进程在信号处理函数中调用wait函数清理子进程即可。</p><p>用户需要循环非阻塞处理子进程退出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sigcb()&#123;</span><br><span class="line">    <span class="keyword">while</span>(waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WONOHANG) &gt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为SIGCHLD信号是一个非可靠信号，大量子进程同时退出的情况下，有可能丢失事件，因此要在一次调用中，把能处理掉的僵尸进程都处理掉。</p><p>代码测试</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;                   </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handler</span><span class="params">(<span class="keyword">int</span> sig)</span>    </span></span><br><span class="line"><span class="function">  </span>&#123;    </span><br><span class="line">    <span class="keyword">pid_t</span> id;    </span><br><span class="line">    <span class="keyword">while</span>( (id = waitpid(<span class="number">-1</span>, <span class="literal">NULL</span>, WNOHANG)) &gt; <span class="number">0</span> )&#123;    </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"wait child success: %d\n"</span>, id);    </span><br><span class="line">      </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child is quit! %d\n"</span>, getpid());    </span><br><span class="line">      </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function">  </span>&#123;    </span><br><span class="line">    signal(SIGCHLD, handler);    </span><br><span class="line">    <span class="keyword">pid_t</span> cid;    </span><br><span class="line">    <span class="keyword">if</span>((cid = fork()) == <span class="number">0</span>)&#123;<span class="comment">//child    </span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"child : %d\n"</span>, getpid());    </span><br><span class="line">      sleep(<span class="number">3</span>);    </span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;    </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"father proc is doing some thing!\n"</span>);    </span><br><span class="line">      sleep(<span class="number">1</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;信号&quot;&gt;&lt;a href=&quot;#信号&quot; class=&quot;headerlink&quot; title=&quot;信号&quot;&gt;&lt;/a&gt;信号&lt;/h3&gt;&lt;h4 id=&quot;信号概念&quot;&gt;&lt;a href=&quot;#信号概念&quot; class=&quot;headerlink&quot; title=&quot;信号概念&quot;&gt;&lt;/a&gt;信号概念&lt;/h
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://skrskr66.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程间通信</title>
    <link href="https://skrskr66.github.io/2019/04/20/Linux%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    <id>https://skrskr66.github.io/2019/04/20/Linux进程间通信/</id>
    <published>2019-04-20T08:27:21.000Z</published>
    <updated>2019-04-22T06:57:26.043Z</updated>
    
    <content type="html"><![CDATA[<h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><p>一般简称为IPC—-InterProcess Communication。是指在不同进程之间传播或交换信息。</p><p>进程间通信有这么几个方式：管道（命名管道/匿名管道），共享队列，消息队列，信号量</p><p><strong>进程间为什么要通信呢？</strong></p><p>因为进程的独立性，因此想要通信必须能够共同访问一个相同的媒介。</p><p><strong>进程间通信的目的</strong>：数据传输，数据共享，进程间的访问控制。</p><p>也正因为通信的目的不同，使用场景不同，因此操作系统提供了多种进程间通信方式：</p><p><strong>管道—-传输数据</strong></p><p><strong>共享内存—-共享数据</strong></p><p><strong>消息队列—-传输数据</strong></p><p><strong>信号量—-进程间的访问控制</strong></p><h4 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h4><p>管道是半双工通信，双向选择的单向通信（即数据只能在一个方向上流动），具有固定的读端和写端</p><p>它是<strong>进程间的数据资料传输</strong>。在通信过程中，<strong>先将数据放到buf中，在将数据拷贝到自己的buf中在进行操作</strong></p><p><img src="/2019/04/20/Linux进程间通信/通信1.png" alt="通信1"></p><p><strong>管道生命周期随进程，如果进程消亡了，那么通信也就结束了</strong></p><h5 id="匿名管道"><a href="#匿名管道" class="headerlink" title="匿名管道"></a>匿名管道</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> pipefd[<span class="number">2</span>])</span></span>;</span><br><span class="line"><span class="comment">//pipefd输出型参数</span></span><br><span class="line"><span class="comment">//数组pipefd用于返回引用结尾的两个文件描述符。</span></span><br><span class="line"></span><br><span class="line">pipefd[<span class="number">0</span>] 从管道读数据</span><br><span class="line">pipefd[<span class="number">1</span>] 从管道写数据</span><br><span class="line"></span><br><span class="line">如果成功，则返回 <span class="number">0</span>；不成功，则返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p><strong>只能用于具有亲缘关系的进程间通信</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;    </span></span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </span><br><span class="line">  <span class="keyword">int</span> pipefd[<span class="number">2</span>];    </span><br><span class="line">  <span class="keyword">int</span> ret = pipe(pipefd);    </span><br><span class="line">  <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;    </span><br><span class="line">    perror(<span class="string">"pipe error"</span>);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="keyword">int</span> pid = fork();    </span><br><span class="line">  <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;    </span><br><span class="line">    perror(<span class="string">"fork error"</span>);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;    </span><br><span class="line">    close(pipefd[<span class="number">1</span>]);    </span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;    </span><br><span class="line">    sleep(<span class="number">1</span>);    </span><br><span class="line">    close(pipefd[<span class="number">1</span>]);    </span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;    </span><br><span class="line">    <span class="keyword">int</span> ret = read(pipefd[<span class="number">0</span>], buf, <span class="number">1023</span>);    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"read buf:[%d - %s]\n"</span>,ret, buf);    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先建立管道，之后再创建子进程。这个时候就要考虑到管道的读写特性了</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">若管道中没有数据，则read会阻塞，直到读到数据返回</span><br><span class="line">若管道中数据写满了，则write会阻塞，直到数据被读取，管道中有空闲位置，写入数据后返回</span><br><span class="line"></span><br><span class="line">若管道中所有的读端都被关闭，则write会触发异常----SIGPIPE(信号标志)----导致进程退出</span><br><span class="line">若管道中的所有写有写端都被关闭，则read返回0----通知用户没人写了</span><br><span class="line"></span><br><span class="line">父子进程两端都要进行关闭</span><br></pre></td></tr></table></figure><p>所以代码中将管道中写端关闭了，所以读端返回的是0.</p><p><img src="/2019/04/20/Linux进程间通信/通信2.png" alt="通信2"></p><p><strong>虽然管道提供了双向选择，但是如果我们没有用到某一端，就把这一端关闭掉</strong></p><h5 id="管道同步与互斥特性"><a href="#管道同步与互斥特性" class="headerlink" title="管道同步与互斥特性"></a>管道同步与互斥特性</h5><p>当读写数据的大小&lt;管道pipe_buf ，是保证操作原子性—–这时操作不可被打断</p><p>互斥：保证对一个临界资源（公共资源，比如全局变量）同一时间的唯一访问性（我操作的时候你不能操作）</p><p>同步：保证对一个临界资源访问的时序可控性（我操作完了你才能操作）</p><p><code>|</code>管道符就是匿名访问</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;                               </span><br><span class="line">  <span class="keyword">int</span> pipefd[<span class="number">2</span>];                          </span><br><span class="line">  <span class="keyword">int</span> ret = pipe(pipefd);                 </span><br><span class="line">  <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;                            </span><br><span class="line">    perror(<span class="string">"pipe error"</span>);                 </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;                            </span><br><span class="line">  &#125;                                       </span><br><span class="line">  <span class="keyword">int</span> pid1 = fork();                      </span><br><span class="line">  <span class="keyword">if</span>(pid1 == <span class="number">0</span>)&#123;                          </span><br><span class="line">    close(pipefd[<span class="number">0</span>]);<span class="comment">//关闭从管道读数据    </span></span><br><span class="line">    dup2(pipefd[<span class="number">1</span>],<span class="number">1</span>);<span class="comment">//将文件描述符表中 向管道写数据 替换 标准输出    </span></span><br><span class="line">    execlp(<span class="string">"ps"</span>,<span class="string">"ps"</span>,<span class="string">"-ef"</span>,<span class="literal">NULL</span>);<span class="comment">//程序替换    </span></span><br><span class="line">  &#125;                                       </span><br><span class="line">  <span class="keyword">int</span> pid2 = fork();                      </span><br><span class="line">  <span class="keyword">if</span>(pid2 == <span class="number">0</span>)&#123;                          </span><br><span class="line">    close(pipefd[<span class="number">1</span>]);                     </span><br><span class="line">    dup2(pipefd[<span class="number">0</span>],<span class="number">0</span>);                    </span><br><span class="line">    execlp(<span class="string">"grep"</span>,<span class="string">"grep"</span>,<span class="string">"ssh"</span>,<span class="literal">NULL</span>);     </span><br><span class="line">  &#125;                                       </span><br><span class="line">  close(pipefd[<span class="number">0</span>]);<span class="comment">//不用的时候将读端和写端都关闭    </span></span><br><span class="line">  close(pipefd[<span class="number">1</span>]);    </span><br><span class="line">  waitpid(pid1,<span class="literal">NULL</span>,<span class="number">0</span>);    </span><br><span class="line">  waitpid(pid2,<span class="literal">NULL</span>,<span class="number">0</span>);    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>grep读数据时不知道自己需要多少数据，过滤之后再次读取。</p><p>代码用图示来解答一下</p><p><img src="/2019/04/20/Linux进程间通信/通信3.png" alt="通信3"></p><h5 id="命名管道-FIFO"><a href="#命名管道-FIFO" class="headerlink" title="命名管道(FIFO)"></a>命名管道(FIFO)</h5><p>FIFO是一种文件类型，可以用于任意进程间通信。</p><p>可见于文件系统，因为创建命名管道会随之在文件系统中创建一个命名管道文件</p><p>类似于在进程中使用文件来传输数据，只不过FIFO类型文件同时具有管道的特性</p><p>因为所有的进程都能够通过打开管道文件，进而获取管道的操作句柄，因此命名管道可以用于同一主机上任意进程间通信</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line">pathname:管道文件名</span><br><span class="line">mode:创建权限 <span class="number">0664</span></span><br></pre></td></tr></table></figure><p>fifo_read.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;    </span></span></span><br><span class="line">      </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </span><br><span class="line">  <span class="keyword">char</span> *file = <span class="string">"./test.fifo"</span>;    </span><br><span class="line">  umask(<span class="number">0</span>);    </span><br><span class="line">  <span class="keyword">int</span> ret = mkfifo(file, <span class="number">0664</span>);    </span><br><span class="line">  <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;    </span><br><span class="line">    <span class="keyword">if</span>(errno != EEXIST)&#123;    </span><br><span class="line">      perror(<span class="string">"mkfifo errno"</span>);    </span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"open file\n"</span>);    </span><br><span class="line">  <span class="keyword">int</span> fd = open(file, O_RDWR);    </span><br><span class="line">  <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;    </span><br><span class="line">    perror(<span class="string">"open error"</span>);                </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"open success!!\n"</span>);    </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;    </span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;    </span><br><span class="line">    <span class="keyword">int</span> ret = read(fd, buf, <span class="number">1023</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"read buf:[%s]\n"</span>, buf);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"write closed~~~\n"</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      perror(<span class="string">"read error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"---------\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  close(fd);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fifo_write.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *file = <span class="string">"./test.fifo"</span>;</span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> ret = mkfifo(file,<span class="number">0664</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(ret != EEXIST)&#123;</span><br><span class="line">            perror(<span class="string">"mkfifo error"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"open file\n"</span>);</span><br><span class="line">    <span class="keyword">int</span> fd = open(file, O_WRONLY);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        perror(<span class="string">"open error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"open success!!\n"</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s"</span>, buf);</span><br><span class="line">        write(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/20/Linux进程间通信/通信4.png" alt="通信4"></p><p>这有点类似于服务器–客户端之间建立连接</p><p>fifo_write类似于客服端发送一个请求 fifo_read类似于服务器返回一个请求</p><p>命名管道利用了文件系统创建文件进行通信。当write写入了数据，将数据从自己的buf写到test.fifo文件中，之后read在将数据从test.fifo中读取到自己的buf中，最后输出。</p><h5 id="命名管道的读写特性"><a href="#命名管道的读写特性" class="headerlink" title="命名管道的读写特性"></a>命名管道的读写特性</h5><p>若管道没有被以写的方式打开，这时如果只读打开则会阻塞，直到文件被以写的方式打开</p><p>若管道没有被以读的方式打开，这时如果只写打开则会阻塞，直到文件被以读的方式打开</p><p>若管道以读写的方式打开，则不会阻塞    </p><h5 id="匿名管道和命名管道的区别"><a href="#匿名管道和命名管道的区别" class="headerlink" title="匿名管道和命名管道的区别"></a>匿名管道和命名管道的区别</h5><p>匿名管道：速度慢，容量有限，只有父进程进程能通讯</p><p>命名管道：任何进程间都能通讯，但速度慢</p><h4 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h4><p>共享内存的定义：在物理上开辟一块空间，<strong>内存直接映射到虚拟内存中，如果一块内存被多个进程映射，那么多个进程访问同一块内存，则可以实现通信。</strong> 是<strong>最快的</strong>进程间通信。因为相较于其他进程间通信方式(将数据从用户态拷贝到内核态，用的时候，从内核态拷贝到用户态)，共享内存直接将一块内存映射到用户空间，用户可以直接通过地址对内存进行操作，并反馈到其他进程，少了两步数据拷贝的过程。</p><h5 id="共享内存使用流程"><a href="#共享内存使用流程" class="headerlink" title="共享内存使用流程"></a>共享内存使用流程</h5><p>1、创建/打开共享内存</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key, <span class="keyword">size_t</span> size, <span class="keyword">int</span> shmflg)</span></span>;</span><br><span class="line">    key:    共享内存标识符</span><br><span class="line">    size：  共享内存大小</span><br><span class="line">    shmflg：打开方式/创建权限</span><br><span class="line">    IPC_CREAT 共享内存不存在则创建</span><br><span class="line">    IPC_EXCL 与IPC_CREAT同用，若存在则报错，不存在则创建</span><br><span class="line">    返回值：操作句柄shmid失败：<span class="number">-1</span></span><br><span class="line"><span class="keyword">key_t</span> ftok(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> proj_id);</span><br><span class="line">    pathname:   文件名</span><br><span class="line">    proj_id：   数字</span><br><span class="line">    通过文件的 inode节点号 和 proj_id 共同得出一个key值</span><br></pre></td></tr></table></figure><p>2、将共享内存映射到虚拟地址空间(建立映射关系)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">const</span> <span class="keyword">void</span> *shmaddr, <span class="keyword">int</span> shmflg)</span></span>;</span><br><span class="line">shmid:创建共享内存返回的操作句柄</span><br><span class="line">shmaddr：用于指定映射在虚拟空间的首地址通常置<span class="literal">NULL</span></span><br><span class="line">    shmflg：<span class="number">0</span>----可读可写</span><br><span class="line">    返回值：映射首地址（通过这个地址对共享内存进行操作)失败：（<span class="keyword">void</span>*)<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>3、对共享内存进行基本的内存操作，memcpy</p><p>4、解除映射关系    shmdt</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *shmaddr)</span></span></span><br><span class="line">shamddr:映射返回的首地址</span><br></pre></td></tr></table></figure><p>5、删除共享内存    shmctl</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shmid, <span class="keyword">int</span> cmd, struct shmid_ds *buf)</span></span>;</span><br><span class="line">shmid:操作句柄</span><br><span class="line">cmd：IPC_RMID删除共享内存</span><br><span class="line">buf：设置或者获取共享内存信息，用不着置<span class="literal">NULL</span></span><br><span class="line">共享内存并不是立即删除的，只是拒绝后续映射连接，当共享内存</span><br><span class="line">映射连接数为<span class="number">0</span>时，则删除共享内存</span><br></pre></td></tr></table></figure><p>shm_read.c</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPC_KEY 0x12345678</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROJ_ID 12345</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHM_SIZE  4096</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> shmid;    </span><br><span class="line">  <span class="comment">//1、创建共享内存    </span></span><br><span class="line">  shmid = shmget(IPC_KEY, SHM_SIZE, IPC_CREAT|<span class="number">0666</span>);    </span><br><span class="line">  <span class="keyword">if</span>(shmid &lt; <span class="number">0</span>)&#123;    </span><br><span class="line">    perror(<span class="string">"shmget error"</span>);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="comment">//2、将共享内存映射到虚拟地址空间    </span></span><br><span class="line">  <span class="keyword">char</span> *shm_start = (<span class="keyword">char</span>*)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);    </span><br><span class="line">  <span class="keyword">if</span>(shm_start == (<span class="keyword">void</span>*)<span class="number">-1</span>)&#123;    </span><br><span class="line">    perror(<span class="string">"shmat error"</span>);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, shm_start);    </span><br><span class="line">    sleep(<span class="number">1</span>);    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="comment">//4、解除映射    </span></span><br><span class="line">  shmdt(shm_start);    </span><br><span class="line">  <span class="comment">//5、删除共享内存    </span></span><br><span class="line">  shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>shm_write.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IPC_KEY 0x12345678    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROJ_ID 12345    </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHM_SIZE  4096    </span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </span><br><span class="line">  <span class="keyword">int</span> shmid;    </span><br><span class="line">  <span class="comment">//1、创建共享内存    </span></span><br><span class="line">  shmid = shmget(IPC_KEY, SHM_SIZE, IPC_CREAT|<span class="number">0666</span>);    </span><br><span class="line">  <span class="keyword">if</span>(shmid &lt; <span class="number">0</span>)&#123;    </span><br><span class="line">    perror(<span class="string">"shmget error"</span>);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="comment">//2、将共享内存映射到虚拟地址空间    </span></span><br><span class="line">  <span class="keyword">char</span> *shm_start = (<span class="keyword">char</span>*)shmat(shmid, <span class="literal">NULL</span>, <span class="number">0</span>);    </span><br><span class="line">  <span class="keyword">if</span>(shm_start == (<span class="keyword">void</span>*)<span class="number">-1</span>)&#123;    </span><br><span class="line">    perror(<span class="string">"shmat error"</span>);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;    </span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;    </span><br><span class="line">    <span class="built_in">sprintf</span>(shm_start, <span class="string">"明天又是可以学习的一天！！！+%d\n"</span>,i++);    </span><br><span class="line">    sleep(<span class="number">1</span>);    </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//4、解除映射</span></span><br><span class="line">  shmdt(shm_start);</span><br><span class="line">  <span class="comment">//5、删除共享内存</span></span><br><span class="line">  shmctl(shmid, IPC_RMID, <span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/20/Linux进程间通信/通信5.png" alt="通信5"></p><p>共享内存双方都可以修改</p><p>共享内存没有同步与互斥</p><p>删除一块共享内存，并不会立即删除，而是判断映射连接数，若为0则删除，不为0则拒绝后续连接，直到为0删除</p><h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><p>消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。 </p><p>消息队列的建立过程为</p><p>创建消息队列—-&gt;添加数据节点—-&gt;获取数据节点—-&gt;删除</p><p>msgget—-&gt;msgsnd—-&gt;msgrcv(接收数据)—-&gt;msgctl</p><p>消息队列传输的是有类型的数据块，用户可以根据自己的需要选择性的获取某些数据类型</p><h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>内核中的一个计数器—-具有等待队列(PCB等待队列)，具有等待和唤醒功能</p><p>用于资源计数，若计数小于等于0，表示没有资源，则需要等待</p><p>若计数大于0，表示有资源，则可以获取资源，然后计数-1</p><p>如果放置了资源，则计数+1，并且唤醒等待的进程</p><p>实现进程间的同步和互斥（资源计数为0或1的时候才具有互斥）</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>消息队列和信号量现在的使用不是特别多，了解一下就可以。重点还是共享内存和管道的学习。</p><p>在代码过程中，我们应该可以感觉到，这种通信方式有点类似于服务器和客户端之间的处理过程。但是具体的实现是不同的。</p><p>匿名管道是通过对读端和写端的关闭和开启，在buf缓存区对数据进行拷贝和使用。</p><p>而命名管道是通过文件系统的打开和关闭，将数据进行读写。读写必须同时打开，否则另一端会被阻塞。</p><p>而共享内存是在同一个地址映射的一块虚拟地址被多个进程访问，这时也就是多个进程同时访问同一个内存。此时共享内存直接映射一块内存到用户空间，用户直接通过地址对内存进行操作，并反馈到其他进程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;进程间通信&quot;&gt;&lt;a href=&quot;#进程间通信&quot; class=&quot;headerlink&quot; title=&quot;进程间通信&quot;&gt;&lt;/a&gt;进程间通信&lt;/h3&gt;&lt;p&gt;一般简称为IPC—-InterProcess Communication。是指在不同进程之间传播或交换信息。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://skrskr66.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux-基础IO</title>
    <link href="https://skrskr66.github.io/2019/04/12/Linux-%E5%9F%BA%E7%A1%80IO/"/>
    <id>https://skrskr66.github.io/2019/04/12/Linux-基础IO/</id>
    <published>2019-04-12T05:02:15.000Z</published>
    <updated>2019-04-15T16:24:08.402Z</updated>
    
    <content type="html"><![CDATA[<p>文件的输入输出在c语言之前了解过。比如标准库的IO接口</p><h4 id="回顾C语言的库函数"><a href="#回顾C语言的库函数" class="headerlink" title="回顾C语言的库函数"></a>回顾C语言的库函数</h4><p>fopen，fread，fwrite，fseek，fclose这几个函数。关键在于参数的使用。</p><p>例如fopen，<code>FILE *fopen(const char *path, const char *mode)</code>,在不同的模式下打开文件所能作的操作也不同。</p><table><thead><tr><th style="text-align:center">文件使用方式</th><th style="text-align:center">含义</th><th style="text-align:center">如果指定文件不存在</th></tr></thead><tbody><tr><td style="text-align:center">r–只读</td><td style="text-align:center">为了输入数据，打开一个已经存在的文本</td><td style="text-align:center">文件出错</td></tr><tr><td style="text-align:center">w–只写</td><td style="text-align:center">为了输出数据，打开一个文本文件</td><td style="text-align:center">建立一个新文件</td></tr><tr><td style="text-align:center">a–追加</td><td style="text-align:center">向文本文件尾添加数据</td><td style="text-align:center">出错</td></tr><tr><td style="text-align:center">rb–只读</td><td style="text-align:center">为了输入数据，打开一个二进制文件</td><td style="text-align:center">出错</td></tr><tr><td style="text-align:center">wb–只写</td><td style="text-align:center">为了输出数据，打开一个二进制文件</td><td style="text-align:center">建立一个新文件</td></tr><tr><td style="text-align:center">ab–追加</td><td style="text-align:center">向一个二进制文件<strong>尾</strong>添加数据</td><td style="text-align:center">出错</td></tr><tr><td style="text-align:center">r+–读写</td><td style="text-align:center">为了读和写，打开一个文本文件</td><td style="text-align:center">出错</td></tr><tr><td style="text-align:center">w+–读写</td><td style="text-align:center">为了读和写，建立一个新的文件</td><td style="text-align:center">建立一个新文件</td></tr><tr><td style="text-align:center">a+–读写</td><td style="text-align:center">打开一个文件，在文件尾进行读写</td><td style="text-align:center">建立一个新的文件</td></tr><tr><td style="text-align:center">rb+–读写</td><td style="text-align:center">为了读和写打开一个二进制文件</td><td style="text-align:center">出错</td></tr><tr><td style="text-align:center">wb+–读写</td><td style="text-align:center">为了读和写，新建一个新的二进制文件</td><td style="text-align:center">建立一个新的文件</td></tr><tr><td style="text-align:center">ab+–读写</td><td style="text-align:center">打开一个二进制文件，在文件尾进行读和写</td><td style="text-align:center">建立一个新的文件</td></tr></tbody></table><p>先回顾一下C语言中的文件操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;    </span></span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> ret;    </span><br><span class="line">    FILE *fp = <span class="literal">NULL</span>;    </span><br><span class="line">    fp = fopen(<span class="string">"./tmp.txt"</span>,<span class="string">"r+"</span>);    </span><br><span class="line">    <span class="keyword">if</span>(fp == <span class="literal">NULL</span>)&#123;    </span><br><span class="line">      perror(<span class="string">"打开失败"</span>);                                                                                               </span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">    &#125;    </span><br><span class="line">  fseek(fp, <span class="number">5</span>, SEEK_END);    </span><br><span class="line">      </span><br><span class="line">  <span class="keyword">char</span> *ptr = <span class="string">"nihao---\n"</span>;    </span><br><span class="line">      </span><br><span class="line">  ret = fwrite(ptr, <span class="number">1</span>, <span class="built_in">strlen</span>(ptr), fp);    </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"write item:%d\n"</span>,ret);    </span><br><span class="line">      </span><br><span class="line">  fseek(fp, <span class="number">0</span>, SEEK_SET);    </span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;    </span><br><span class="line">      </span><br><span class="line">  ret = fread(buf, <span class="number">1</span>, <span class="number">1023</span>, fp);    </span><br><span class="line">  perror(<span class="string">"读取失败"</span>);    </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"read buf[%s]-[%d]"</span>,buf,ret);    </span><br><span class="line">      </span><br><span class="line">  fclose(fp);    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>先打开当前路径下的tmp.txt文件以读写的方式打开，之后利用fseek函数跳转读写位置从当前文件位置的末尾开始向后五个位置跳转。然后写入数据，一个字节写入，写入长度为*ptr的字符串长度，然后再跳转到文件的开头开始读取数据读取到buf中。fread返回值是读取的数据长度。最后关闭文件。</strong></p><p>这是C语言库函数中的使用方法。</p><h4 id="系统调用IO接口"><a href="#系统调用IO接口" class="headerlink" title="系统调用IO接口"></a>系统调用IO接口</h4><h5 id="文件描述符和文件流指针"><a href="#文件描述符和文件流指针" class="headerlink" title="文件描述符和文件流指针"></a>文件描述符和文件流指针</h5><p><strong>标准库接口使用文件流指针 <code>*FILE</code></strong></p><p><strong>系统调用接口使用文件描述符 比如 int fd</strong></p><p>进程中使用open函数打开某个文件，前提是需要我们将进程与文件联系起来。所以进程PCB中就有一个 <code>*FILE</code>指针，这个<code>*FILE</code>指针指向一个数组files_struct，这个数组内每个元素都对应了一个文件指针，文件指针指向各个FILE结构体。</p><p><strong>文件流指针这个结构体中就包含了文件描述符，当使用标准库接口进行io，则最终是通过文件流指针找到文件描述符进而对文件进行操作</strong></p><p>文件描述符是一个正整型数字。文件描述符实际上就是一个数组下标，当进程每打开一个文件，都会使用struct file描述这个文件，并且将描述信息添加到struct file这个结构中的file结构体数组中，并且向用户返回数组下标作为文件描述符，用户通过文件描述符对文件进行操作，再内核实际上是通过文件描述符找到文件描述信息，进而操作文件。</p><p>​    标准输入        标准输出        标准错误</p><p>​    stdin        stdout        stderr</p><p>​    0            1            2</p><p><img src="/2019/04/12/Linux-基础IO/基础IO1.png" alt="基础IO1"></p><p><strong>文件描述符分配规则：最小未使用</strong></p><h5 id="系统调用函数"><a href="#系统调用函数" class="headerlink" title="系统调用函数"></a>系统调用函数</h5><p>open write read close lseek</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br><span class="line"><span class="keyword">off_t</span> lseek(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line">pathname：文件路径名</span><br><span class="line">flags：选项标志</span><br><span class="line">必选项：</span><br><span class="line">O_RDONLY 只读</span><br><span class="line">O_WRONLY 只写</span><br><span class="line">O_REWR 可读可写</span><br><span class="line">可选项：</span><br><span class="line">O_CREAT 文化不存在则创建，存在则打开</span><br><span class="line">O_EXCL 与O_CREAT同用时，若文件存在则报错</span><br><span class="line">O_APPEND 写追加模式</span><br><span class="line">mode：创建文件时给定权限 （八进制数字）</span><br><span class="line">mode &amp; （~umask)</span><br><span class="line">返回值：文件描述符-正整数错误：<span class="number">-1</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br><span class="line">fd:打开文件所返回的文件描述符</span><br><span class="line">buf：要向文件写入数据</span><br><span class="line">count：要写入的数据长度</span><br><span class="line">返回值：实际的写入字节数错误：<span class="number">-1</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br><span class="line">fd:打开文件所返回的文件描述符</span><br><span class="line">buf：对读取到的数据进行存储的位置</span><br><span class="line">count：要读取的数据长度</span><br><span class="line">返回值：实际的读取字节数错误：<span class="number">-1</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">off_t</span> lseek(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence);</span><br><span class="line">fd:打开文件所返回的文件描述符</span><br><span class="line">offset：偏移量</span><br><span class="line">whence：偏移位置</span><br><span class="line">SEEK_SET</span><br><span class="line">SEEK_CUR</span><br><span class="line">SEEK_END</span><br><span class="line">返回值：返回当前位置到文件起始位置的偏移量</span><br></pre></td></tr></table></figure><p>掌握知识的最好办法还是结合代码！！！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#inlcude <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//mode_t umask</span></span><br><span class="line">    <span class="comment">//修改调用进程的文件创建权限掩码</span></span><br><span class="line">    umask(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> fd = open(<span class="string">"./tmp.txt"</span>,O_RDWR | O_CREAT | O_APPEND,<span class="number">0777</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      perror(<span class="string">"open error"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>] = <span class="string">"nihaoa~~!!"</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = write(fd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      perror(<span class="string">"write error"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    lseek(fd, <span class="number">0</span>, SEEK_SET);</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0x00</span>, <span class="number">1024</span>);<span class="comment">//对buf数组所在的内存空间全部初始化为0，初始化的长度为1024</span></span><br><span class="line">    ret = read(fd, buf, <span class="number">1023</span>);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">      perror(<span class="string">"read error"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"read buf:[%s]\n"</span>, buf);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/12/Linux-基础IO/基础IO2.png" alt="基础IO2"></p><p>运行如图，系统调用函数还是比较简单的。</p><h5 id="标准输入输出的重定向"><a href="#标准输入输出的重定向" class="headerlink" title="标准输入输出的重定向"></a>标准输入输出的重定向</h5><p>这里要学习一个dup2函数。</p><p>函数dup和dup2提供了复制文件描述符的功能。他们通常用于stdin,stdout或进程的stderr的重定向。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">int</span> newfd)</span></span>;</span><br></pre></td></tr></table></figure><p>dup2用来复制参数oldfd所指的文件描述符，并将oldfd拷贝到参数newfd后一起返回。若参数newfd为一个打开的文件描述符，则newfd所指的文件会先被关闭，若newfd等于oldfd，则返回newfd，而不关闭newfd所指的文件。dup2所复制的文件描述符与原来的文件描述符共享各种文件状态。共享所有的锁定，读写位置和各项权限或flags。</p><p>返回值：如果成功则返回新的文件描述符，否则出错返回-1.</p><p>由dup2函数返回的新文件描述符一定是当前文件描述符可用的最小值</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;    </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </span><br><span class="line">  <span class="keyword">int</span> fd = open(<span class="string">"./tmp.txt"</span>,O_RDWR,<span class="number">0777</span>);                                                                               </span><br><span class="line">    </span><br><span class="line">  dup2(fd, <span class="number">1</span>);    </span><br><span class="line">    </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,fd);    </span><br><span class="line">    </span><br><span class="line">  fflush(<span class="built_in">stdout</span>);    </span><br><span class="line">  close(fd);    </span><br><span class="line">    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时输出的结果为1，因为oldfd为打开文件的文件描述符，本应该为3，但是调用了dup2函数，此时stdout关闭了，将oldfd复制进去此时在返回新的文件描述符即为1。</p><p><img src="/2019/04/12/Linux-基础IO/基础IO3.png" alt="基础IO3"></p><h5 id="模拟实现minishell重定向"><a href="#模拟实现minishell重定向" class="headerlink" title="模拟实现minishell重定向"></a>模拟实现minishell重定向</h5><p>1、接收标准输入数据</p><p>2、解析命令（判断是否包含重定向符号 &gt;   \   &gt;&gt;）</p><p>3、如果包含，则认为需要输出重定向，这时候获取重定向符号后边的文件名将重定向符号替换成’\0’</p><p>4、在子进程中打开文件，将标准输出重定向到这个文件，进行程序替换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wait.h&gt;                                                                                                       </span></span></span><br><span class="line"><span class="comment">//之前写过一个关于minishell的文件，先对之前的一些进行封装函数    </span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;    </span><br><span class="line"><span class="keyword">char</span> *argv[<span class="number">32</span>];    </span><br><span class="line"><span class="keyword">int</span> argc = <span class="number">0</span>;    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_face</span><span class="params">()</span></span>&#123;    </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"[liuyucheng@localhost]$ "</span>);    </span><br><span class="line">  fflush(<span class="built_in">stdout</span>);    </span><br><span class="line">  <span class="built_in">memset</span>(buf, <span class="number">0x00</span>, <span class="number">1024</span>);    </span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">scanf</span>(<span class="string">"%[^\n]"</span>,buf) != <span class="number">1</span>)&#123;    </span><br><span class="line">    getchar();    </span><br><span class="line">  &#125;    </span><br><span class="line">&#125;    </span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_parse</span><span class="params">()</span></span>&#123;    </span><br><span class="line">  <span class="keyword">char</span> *ptr = buf;    </span><br><span class="line">  argc = <span class="number">0</span>;    </span><br><span class="line">  <span class="keyword">while</span>(*ptr != <span class="string">'\0'</span>)&#123;    </span><br><span class="line">   <span class="keyword">if</span>(!<span class="built_in">isspace</span>(*ptr))&#123;</span><br><span class="line">     argv[argc++] = ptr; </span><br><span class="line">     <span class="keyword">while</span>(!<span class="built_in">isspace</span>(*ptr) &amp;&amp; *ptr != <span class="string">'\0'</span>)&#123;</span><br><span class="line">       ptr++;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      *ptr = <span class="string">'\0'</span>;</span><br><span class="line">      ptr++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  argv[argc] = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  do_face();</span><br><span class="line">  <span class="keyword">int</span> redirect = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">char</span> *file = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">char</span> *ptr = buf;</span><br><span class="line">  <span class="keyword">while</span>(*ptr != <span class="string">'\0'</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(*ptr == <span class="string">'&gt;'</span>)&#123;                                                                                                    </span><br><span class="line">      redirect = <span class="number">1</span>;<span class="comment">//清空重定向</span></span><br><span class="line">      *ptr++ = <span class="string">'\0'</span>;</span><br><span class="line">      <span class="keyword">if</span>(*ptr == <span class="string">'&gt;'</span>)&#123;</span><br><span class="line">        redirect = <span class="number">2</span>;</span><br><span class="line">        *ptr++ = <span class="string">'\0'</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">while</span>(<span class="built_in">isspace</span>(*ptr) &amp;&amp; *ptr != <span class="string">'\0'</span>)&#123;</span><br><span class="line">        ptr++;</span><br><span class="line">      &#125;</span><br><span class="line">      file = ptr;</span><br><span class="line">      <span class="keyword">while</span>(!<span class="built_in">isspace</span>(*ptr) &amp;&amp; *ptr != <span class="string">'\0'</span>)&#123;</span><br><span class="line">        ptr++;</span><br><span class="line">      &#125;</span><br><span class="line">      *ptr = <span class="string">'\0'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ptr++;</span><br><span class="line">  &#125;</span><br><span class="line">  do_parse();</span><br><span class="line">  <span class="keyword">int</span> pid = fork();</span><br><span class="line">  <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(redirect == <span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">int</span> fd = open(file, O_CREAT | O_WRONLY | O_TRUNC, <span class="number">0664</span>);</span><br><span class="line">      dup2(fd, <span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(redirect == <span class="number">2</span>)&#123;</span><br><span class="line">      <span class="keyword">int</span> fd = open(file, O_CREAT | O_WRONLY | O_TRUNC, <span class="number">0664</span>);                                                          </span><br><span class="line">      dup2(fd, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    execvp(argv[<span class="number">0</span>], argv);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  wait(<span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Linux-ext2文件系统"><a href="#Linux-ext2文件系统" class="headerlink" title="Linux ext2文件系统"></a>Linux ext2文件系统</h4><p>注：图中应为inode。</p><p><img src="/2019/04/12/Linux-基础IO/基础IO4.png" alt="基础IO4"></p><p>上图是一个磁盘文件系统的内置。</p><p>每个分区都有一个文件系统，不同的分区拥有不同的文件系统。</p><p>什么是inode？<strong>inode里面包含了大小，权限，用户，时间，块位置</strong></p><p>利用指令<code>ls -i</code>可以查看inode节点号</p><h5 id="存储文件的流程"><a href="#存储文件的流程" class="headerlink" title="存储文件的流程"></a>存储文件的流程</h5><p>通过inode bitmap在inode table(表结构)找到空闲的inode节点，通过data bitmap在数据块区域找到空闲数据块，将数据块位置信息，记录到inode节点中，将文件数据写入到数据块中；将文件名和inode节点名写入父目录中。</p><p>目录文件中：存放了一张目录下有什么文件的表，表中记录了文件名。<strong>inode节点号—&gt;目录项</strong></p><p>当我们 <code>cat ./a.txt</code>输出文件内容时，在当前目录文件中查找文件名信息，通过文件名获取inode节点号，通过inode节点号，找到inode节点，进而访问数据块，读取数据进行打印。</p><h4 id="软硬链接"><a href="#软硬链接" class="headerlink" title="软硬链接"></a>软硬链接</h4><p>创建硬链接：<code>ln a.txt b.txt</code></p><p>创建软链接：<code>ln -s a.txt a.soft</code></p><p><strong>硬链接是一个文件的另一个名字，跟源文件并没有什么区别，—-inode节点号相同</strong></p><p><strong>软链接是一个独立的文件，像是一个文件的快捷方式，—-inode节点号不同</strong></p><p>删除源文件，软链接失效—-&gt;通过记录的源文件名路径查找源文件数据；</p><p>硬链接无影响—-&gt;通过inode节点找文件只是链接数-1</p><p>软链接可以针对目录进行创建，硬链接不可以</p><p>软链接可以跨分区建立，硬链接不可以</p><h4 id="静态库与动态库"><a href="#静态库与动态库" class="headerlink" title="静态库与动态库"></a>静态库与动态库</h4><p>静态库：<strong>名字一般为libxxx.a</strong>，编译时会整合到可执行程序中。程序在编译链接的时候把库的代码链接到可执行文件中。程序运行的时候将不再需要静态库 。<strong>优点是运行时不需要外部函数库支持，缺点是编译后程序较大，一旦静态库改变，程序需要重新编译。</strong> </p><p>动态库：<strong>名字一般为libxxx.M.N.so,M为主版本号，N为副版本号</strong> ，程序在运行的时候才去链接动态库的代码，多个程序共享使用库的代码。优点是运行时，有需要时才动态调用外部库中的函数，节省空间，缺点是运行环境中必须提供相应的库，动态库更新升级方便。 </p><h5 id="建立静态库"><a href="#建立静态库" class="headerlink" title="建立静态库"></a>建立静态库</h5><p>​    <code>gcc -fPIC -c b.c -o b.o</code>产生位置无关代码</p><p>​    生成静态库gcc -c b.c -o b.o</p><p>​    <code>ar -cr libmytest.a b.o</code>生成静态库</p><p>gcc选项:</p><p>​        -fPIC：产生位置无关代码</p><p>​        –share：生成一个共享库而不是可执行程序</p><p>​    ar：静态库打包所有命令</p><p>​        -c 创建</p><p>​        -r 替换</p><h5 id="建立动态库"><a href="#建立动态库" class="headerlink" title="建立动态库"></a>建立动态库</h5><p>生成动态库gcc -fPIC -c b.c -o b.o    </p><p><code>gcc --share b.o -o libmytest.so</code>生成动态库</p><h5 id="库的使用"><a href="#库的使用" class="headerlink" title="库的使用"></a>库的使用</h5><p>动态库—&gt;libmytest.so        静态库—&gt;libmytest.a</p><p><strong>同名动态和静态库，先链接动态库</strong></p><p>链接库的时候：gcc a.c -o main -lmytest。如果报错，找不到库(链接库的查找路径—-库的查找路径)</p><p>库链接的时候和运行加载的时候都需要在指定目录下</p><p>库文件的默认查找路径/lib64    /usr/lib64</p><p>设置环境变量：LIBRARY_PATH=.(库的链接路径)——&gt;使用选项 ’-L‘</p><p>因为gcc默认是动态链接—因此优先使用动态库生成可执行程序</p><p><strong>注意！</strong></p><p>通常我们自己链接静态库生成可执行程序的时候，并不是使用-static静态链接，而是将静态库放到指定路径下，然后直接使用gcc -L选项指定库的链接路径链接静态库生成可执行程序</p><p>-static：作用是可执行程序使用静态链接生成，不依赖任何动态库</p><h4 id="关于基础IO的总结"><a href="#关于基础IO的总结" class="headerlink" title="关于基础IO的总结"></a>关于基础IO的总结</h4><p>最重要的还是区分系统调用和库函数调用的区别和用法。在不同的语言中有着不同的用法，Linux下的使用可能还要考虑到进程的创建，程序替换等操作。</p><p>还有就是文件系统的理解与inode节点的作用，磁盘的分配有着独特的规则，通过inode来调用分配空间的使用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;文件的输入输出在c语言之前了解过。比如标准库的IO接口&lt;/p&gt;
&lt;h4 id=&quot;回顾C语言的库函数&quot;&gt;&lt;a href=&quot;#回顾C语言的库函数&quot; class=&quot;headerlink&quot; title=&quot;回顾C语言的库函数&quot;&gt;&lt;/a&gt;回顾C语言的库函数&lt;/h4&gt;&lt;p&gt;fopen，f
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://skrskr66.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程控制</title>
    <link href="https://skrskr66.github.io/2019/04/08/Linux%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <id>https://skrskr66.github.io/2019/04/08/Linux进程控制/</id>
    <published>2019-04-08T11:53:27.000Z</published>
    <updated>2019-04-21T09:22:30.897Z</updated>
    
    <content type="html"><![CDATA[<p>在之前的Linux进程概念中提到了一些关于进程的创建。进程的创建通过fork函数创建子进程。</p><h4 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h4><p>进程终止顾名思义，进程结束。但是结束有各种可能，可能成功，可能失败，也可能异常。</p><h5 id="进程常见退出方法"><a href="#进程常见退出方法" class="headerlink" title="进程常见退出方法"></a>进程常见退出方法</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">正常退出</span><br><span class="line">1、从main返回 return</span><br><span class="line">2、调用exit</span><br><span class="line">3、_exit</span><br><span class="line">异常退出</span><br><span class="line">ctrl + c</span><br></pre></td></tr></table></figure><h5 id="exit函数"><a href="#exit函数" class="headerlink" title="exit函数"></a>exit函数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; </span></span></span><br><span class="line"><span class="keyword">void</span> _exit(<span class="keyword">int</span> status);</span><br><span class="line">参数：status 定义了进程的终止状态，父进程通过wait来获取该值 </span><br><span class="line">说明：虽然status是<span class="keyword">int</span>，但是仅有低<span class="number">8</span>位可以被父进程所用。</span><br><span class="line">所以_exit(<span class="number">-1</span>)时，在终端执行$?发现返回值 是<span class="number">255</span>。</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;    </span></span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </span><br><span class="line">  <span class="keyword">int</span> pid = fork();    </span><br><span class="line">  <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;    </span><br><span class="line">    perror(<span class="string">"fork error"</span>);    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"fork error:%s\n"</span>,strerror(errno));    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;    </span><br><span class="line">  <span class="keyword">for</span>( ;i &lt; <span class="number">256</span>; i++)&#123;    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"errno:[%s]\n"</span>,strerror(i));    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"hello bit"</span>);    </span><br><span class="line">  sleep(<span class="number">1</span>);    </span><br><span class="line">  _exit(<span class="number">257</span>);            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这之中调用的是_exit函数，关于这两个函数，并没有什么太大的区别，<code>exit()</code>就是对<code>-exit</code>进行的一个分装。通过man手册可以详细了解。</p><p>_ exit()的退出是简单粗暴的，exit()还做了一些其他的工作。可自行查看</p><p>他们俩的共同点就是都会关闭文件描述符，都会清空内存，但是exit还会额外地清空输入输出流缓存，移除临时创建的文件，调用注册好的出口函数等等。 </p><h4 id="进程等待"><a href="#进程等待" class="headerlink" title="进程等待"></a>进程等待</h4><p>为什么要进行进程等待？</p><p>之前写过僵尸进程的危害，一个僵尸进程对内存的资源泄漏是积少成多的。一个两个倒没啥，但是如果多了将无法再创建新的进程，并且就连最强大的杀死进程<code>kill -9</code>也无法将其杀死，所以进程等待的必要性是很重要的。当父进程创建一个子进程时，通过进程等待，回收子进程资源，获取子进程的退出信息，而不让其保存在操作系统中。</p><p>总的来说：因为父进程不知道子进程什么时候退出，因此只能在子进程进程创建之后调用wait()，进行进程等待。因为调用wait就是一直在等待子进程的退出。</p><h5 id="进程等待的方法"><a href="#进程等待的方法" class="headerlink" title="进程等待的方法"></a>进程等待的方法</h5><p>wait()接口是一个阻塞函数，功能是等待子进程退出，如果子进程没有退出，一直等待到有子进程退出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span> *status);</span><br><span class="line">函数的返回值：成功返回等待的pid，失败返回<span class="number">-1</span></span><br><span class="line">参数：输出型参数，获取子进程的状态，不关心则可以设置为<span class="literal">NULL</span></span><br></pre></td></tr></table></figure><p>waitpid()函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *status,<span class="keyword">int</span> options);</span><br><span class="line">返回值：    </span><br><span class="line">当正常返回的时候waitpid返回收集到的子进程的进程ID；    </span><br><span class="line">如果设置了选项WNOHANG,而调用中waitpid发现没有已退出的子进程可收集,则返回<span class="number">0</span>；    </span><br><span class="line">如果调用中出错,则返回<span class="number">-1</span>,这时errno会被设置成相应的值以指示错误所在； </span><br><span class="line"></span><br><span class="line">参数：    pid：        </span><br><span class="line">Pid=<span class="number">-1</span>,等待任一个子进程。与wait等效。        </span><br><span class="line">Pid&gt;<span class="number">0.</span>等待其进程ID与pid相等的子进程。    </span><br><span class="line">status:        </span><br><span class="line">WIFEXITED(status): 若为正常终止子进程返回的状态，则为真。（查看进程是否是正常退出）       WEXITSTATUS(status): 若WIFEXITED非零，提取子进程退出码。（查看进程的退出码）    </span><br><span class="line">options:        </span><br><span class="line">WNOHANG: 若pid指定的子进程没有结束，则waitpid()函数返回<span class="number">0</span>，不予以等待。若正常结束，则返回该子进 程的ID。</span><br></pre></td></tr></table></figure><p>第二种wait还是一种封装方式。只不过需要讨论以下status的参数获取。</p><p>status是输出型参数，由操作系统填充。status的使用只在低16位上(因为int类型为4个字节，只用后两个字节，所以用低16位)<img src="/2019/04/08/Linux进程控制/进程控制1.png" alt="进程控制1"></p><p>从图片可以看出status低八位中的低七位保存异常的情况，高八位保存的是我们的数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*进程等待-避免产生建时进程demo*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">"fork error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">255</span>);<span class="comment">//此时返回的是1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line">    <span class="keyword">while</span> (waitpid(pid, &amp;status, WNOHANG) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"no exit~~~smoking~~\n"</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//低7位为0则正常退出</span></span><br><span class="line">    <span class="keyword">if</span> (!(status &amp; <span class="number">0x7f</span>))  &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child exit code:%d\n"</span>, (status &gt;&gt; <span class="number">8</span>) &amp; <span class="number">0xff</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//man 2 wait 自行查看这个WIFEXITED的参数返回设置</span></span><br><span class="line">    <span class="keyword">if</span> (WIFEXITED(status)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"child exit code:%d\n"</span>, WEXITSTATUS(status));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (WIFSIGNALED(status)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"exit signal:%d\n"</span>, WTERMSIG(status));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"打麻将~~~\n"</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>但是waitpid第三个参数可以将waitpid设置为非阻塞，没有子进程退出则立即报错返回0.</strong></p><p><strong>阻塞：为了完成某个功能发起调用，如果当前不具备完成条件，一直等待，直到完成后返回</strong></p><p><strong>非阻塞：为了完成某个功能发起调用，如果当前不具备完成条件，直接报错返回</strong></p><p><img src="/2019/04/08/Linux进程控制/进程控制2.png" alt="进程控制2"></p><p>当自己进程没有退出正在执行sleep函数时，waitpid()一直在运行等待子进程的退出。退出成功后，输出此时status此时右移到低八位的数值—–就是exit()的返回值。然后判断子进程是否正常退出，如果非正常退出将有退出信号。</p><h4 id="进程替换"><a href="#进程替换" class="headerlink" title="进程替换"></a>进程替换</h4><p>父进程创建了子进程，子进程如果总是做着和父进程相同的工作，那么子进程没有太大的意义。所以这时候可以调用exec函数来执行另一个程序。<strong>当进程调用一种exec函数时，该进程的用户空间代码和数据完全被新程序替换</strong>，从新程序的启动例程开始执行。调用exec并不创建新进程，所以调用exec前后该进程的id并未改变。</p><p>也可以这样认为：替换的是程序所运行的程序，将另一段程序加载到内存中，通过页表将原先进程的映射关系，重新建立到新程序在内存中的地址，相当于替换了进程所运行的程序以及所要处理的数据，因此，替换了代码段，重新初始化数据段。</p><p><strong>替换进程正在运行的程序（替换代码段以及运行数据，更行页表，从main函数重新运行）</strong></p><h5 id="替换函数"><a href="#替换函数" class="headerlink" title="替换函数"></a>替换函数</h5><p>通过exec函数群来实现</p><p>execve是系统调用接口，以下是函数群</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ..., <span class="keyword">char</span> * <span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvpe</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure><p>execl(ls,ls,-a,-l,-i,null)    参数是平铺赋予</p><p>execv(/bin/ls,argv)    参数是通过参数数组赋予argv[0]=ls,argv[1]=-a,argv[2]=-l…argv[4]=NULL</p><p><strong>execl与execv区别：参数的赋予是以指针数组赋予还是以不定参数形式赋予</strong></p><p><strong>最后必须将null写入！！！</strong></p><p><strong>最后必须将null写入！！！</strong></p><p><strong>最后必须将null写入！！！</strong></p><p><strong>有无p的区别：是否自动到PATH所制定的路径下找程序文件</strong></p><p><strong>有无e的区别：是否自定义环境变量的区别</strong></p><p><strong>如果带e的话将当前进程的环境变量也将会发生改变。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">    execl(<span class="string">"./env"</span>,<span class="string">"env"</span>,<span class="string">"-l"</span>,<span class="literal">NULL</span>);<span class="comment">//谁调用就对谁进行程序替换</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果 execl() 执行成功，下面执行不到，因为当前进程已经被执行的 ./env 替换了</span></span><br><span class="line">    <span class="comment">//所以执行之后一直都是第一个printf循环执行</span></span><br><span class="line">    <span class="keyword">char</span> *env[<span class="number">32</span>];</span><br><span class="line">    env[<span class="number">0</span>] = <span class="string">"MYENV=10000"</span>;</span><br><span class="line">    env[<span class="number">1</span>] = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">char</span> **environ;<span class="comment">//保存环境变量</span></span><br><span class="line">    execle(<span class="string">"./env"</span>,<span class="string">"env"</span>,<span class="string">"-l"</span>,<span class="literal">NULL</span>,environ);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world~~\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>exec 只是用另一个新程序替换了当前进程的正文、数据、堆和栈段（进程替换）</strong> </p><p>不断的强调这句话因为，exec的替换的理解：我们可以想象为我们在当前内存空间中执行的程序替换到一个新的内存空间中。程序将在新的空间中执行</p><p>这里的理解感觉有些繁琐，但是进程替换之后，执行成功之后不会返回，而且exec函数族下面的代码执行不到，只有调用失败了，才会返回-1，失败后从原程序的调用点接着往下执行。</p><p>从物理角度来理解：<strong>将进程的虚拟地址空间所映射在物理内存的区域进行改变，改编成另一个程序中在内存中的位置，更新页表信息，重新初始化虚拟地址空间，为了让进程运行另一个程序</strong></p><h5 id="自主minishell的实现"><a href="#自主minishell的实现" class="headerlink" title="自主minishell的实现"></a>自主minishell的实现</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[liuyucheng@localhost]$ "</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">scanf</span>(<span class="string">"%[^\n]%*c"</span>, buf) != <span class="number">1</span>)&#123;</span><br><span class="line">      getchar();</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取出空白字符，获取程序名称和参数</span></span><br><span class="line">    <span class="keyword">char</span> *argv[<span class="number">32</span>];<span class="comment">//将自己定义的缓冲区的字符放入该数组中</span></span><br><span class="line">    <span class="keyword">int</span> argc = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> *ptr = buf;</span><br><span class="line">    <span class="keyword">while</span>(*ptr != <span class="string">'\0'</span>)&#123;</span><br><span class="line">      <span class="comment">//若参数c为空格字符，则返回TRUE，否则返回NULL(0)。</span></span><br><span class="line">      <span class="keyword">if</span>(!<span class="built_in">isspace</span>(*ptr))&#123;</span><br><span class="line">        argv[argc++] = ptr;</span><br><span class="line">        <span class="keyword">while</span>(!<span class="built_in">isspace</span>(*ptr) &amp;&amp; *ptr != <span class="string">'\0'</span>)&#123;</span><br><span class="line">          ptr++;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        *ptr = <span class="string">'\0'</span>;            </span><br><span class="line">        ptr++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    argv[argc] = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">int</span> pid = fork();</span><br><span class="line">  <span class="comment">//创建子进程</span></span><br><span class="line">  <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);<span class="comment">//退出返回-1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;<span class="comment">//如果子进程创建成功</span></span><br><span class="line">    execvp(argv[<span class="number">0</span>], argv);<span class="comment">//程序替换,此时argv保存了指令的字符串，替换到argv[0]中，这样execvp自动在当前PATH路径下寻找指令，例如ls，ll</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  wait(<span class="literal">NULL</span>);<span class="comment">//等待子进程退出</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/08/Linux进程控制/进程控制3.png" alt="进程控制3"></p><p>如图则为程序运行。不过cd指令不行。不能跳到另一个文件夹中。</p><p>将所学的几个进程都用到了，很有帮助。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在之前的Linux进程概念中提到了一些关于进程的创建。进程的创建通过fork函数创建子进程。&lt;/p&gt;
&lt;h4 id=&quot;进程终止&quot;&gt;&lt;a href=&quot;#进程终止&quot; class=&quot;headerlink&quot; title=&quot;进程终止&quot;&gt;&lt;/a&gt;进程终止&lt;/h4&gt;&lt;p&gt;进程终止顾名思义
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://skrskr66.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>数据结构之二叉树</title>
    <link href="https://skrskr66.github.io/2019/04/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://skrskr66.github.io/2019/04/04/数据结构之二叉树/</id>
    <published>2019-04-04T08:13:39.000Z</published>
    <updated>2019-04-20T08:23:33.569Z</updated>
    
    <content type="html"><![CDATA[<h4 id="树的概念"><a href="#树的概念" class="headerlink" title="树的概念"></a>树的概念</h4><p>树是一种<strong>非线性</strong>的结构，它是由n(n&gt;0)个有限结点组成一个具有层次关系的集合。把他叫做树是因为它看起来像一个倒挂的树，它的根是朝上的，但是它的叶是朝下的。</p><p>它具有以下特点：每个节点有零个或多个子结点；没有父结点的称为根节点；每一个非根节点有且只有一个父结点；除了根节点外，每个子节点可以分为多个不相交的子树。</p><p>关于树，还有一些相关知识，我们需要了解。</p><p>节点的度：一个节点含有的子树的个数称为该节点的度。</p><p>双亲节点或父节点：若一个节点含有子节点，那么这个节点就是该子节点的父节点</p><p>孩子节点或子节点：一个节点含有的子树的根节点称为该节点的子节点</p><p>节点的层次：从根节点开始定义，根为第一次，根的子节点为第二层，以此类推</p><p>树的高度或深度：树中节点的最大层次</p><h4 id="二叉树的概念"><a href="#二叉树的概念" class="headerlink" title="二叉树的概念"></a>二叉树的概念</h4><p>一棵二叉树是节点的一个有限集合，该集合或者为空，或者是由一个根节点加上两棵被称为左子树和右子树的二叉树组成</p><h5 id="二叉树的特点"><a href="#二叉树的特点" class="headerlink" title="二叉树的特点"></a>二叉树的特点</h5><p>1、每个节点最多有两棵子树，即二叉树不存在度大于2的节点。</p><p>2、二叉树的子树有左右之分，其子树的次序不能颠倒。</p><h5 id="二叉树的链式存储"><a href="#二叉树的链式存储" class="headerlink" title="二叉树的链式存储"></a>二叉树的链式存储</h5><p>二叉树的链式存储结构是指，用链表来表示一棵二叉树，即用链来指示元素的逻辑关系。通常的方法是链表中每个节点由三个域组成，数据域和左右指针域，左右指针分别用来给出该节点左孩子和右孩子所在的链节点的存储地址。</p><h5 id="二叉树的代码实现"><a href="#二叉树的代码实现" class="headerlink" title="二叉树的代码实现"></a>二叉树的代码实现</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//定义一个二叉树节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">left</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">right</span>;</span></span><br><span class="line">    <span class="keyword">char</span> value;</span><br><span class="line">&#125; Node;</span><br></pre></td></tr></table></figure><p>树的枝干是向外不断地延伸出去的，那么二叉树的节点链接也是。有三种方式可以遍历二叉树，也就是我们常说的前序遍历，中序遍历，后序遍历。</p><p><img src="/2019/04/04/数据结构之二叉树/二叉树1.png" alt="二叉树1"></p><p>以前的我对于二叉树的遍历也不是很懂，但是学完之后，我就记住了这一个方法。我个人觉得这样记忆是最好的。就是经过节点的次数。</p><p>如果是前序遍历，当第一次经过该节点时就将该节点记录。中序遍历，当第二次经过该节点时就将该节点记录。后序遍历，当第三次经过该节点时就将该节点记录。但是最后的每个左子树或者右子树也要遍历是否是空节点。这样才能全部遍历生成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Preorder</span><span class="params">(Node *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,root-&gt;value);</span><br><span class="line">        Preorder(root-&gt;left);</span><br><span class="line">        Preorder(root-right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Inorder</span><span class="params">(Node *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        Inorder(root-&gt;left);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,root-&gt;value);</span><br><span class="line">        Inorder(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Postorder</span><span class="params">(Node *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        Postorder(root-&gt;left);</span><br><span class="line">        Postorder(root-&gt;right);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%c"</span>,root-&gt;value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码看起来是很简单，主要需要记住的就是前中后序的特点。</p><p>前序—根，左子树，右子树</p><p>中序—左子树，根，右子树</p><p>后序—左子树，右子树，根</p><p>但是递归的特点就是代码简单，所需要的就是<strong>找到终止条件，返回上一层。</strong></p><p><strong>还是代码学习知识！！！</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建二叉树结点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateNode</span><span class="params">(<span class="keyword">char</span> v)</span></span>&#123;</span><br><span class="line">    Node *node = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    node-&gt;value = v;</span><br><span class="line">    node-&gt;left = node-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回该二叉树的总节点数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetSize</span><span class="params">(Node *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = GetSize(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right = GetSize(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left + right + <span class="number">1</span>;<span class="comment">//不要忘了根节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回叶子节点的数量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetLeafSize</span><span class="params">(Node *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//如果没有左右子树，直接记录该子树的父结点</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> GetLeafSize(root-&gt;left) + GetLeafSize(root-&gt;right);<span class="comment">//叶子节点递归查询</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>递归中有一个返回值之后将跳到上一层，在上一层之后将寻找层中合适的出口在返回上上一层。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回二叉树的层数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetHeight</span><span class="params">(Node *root)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = GetHeight(root-&gt;left) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> right = GetHeight(root-&gt;right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (left &gt; right ? left : right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//遍历根节点的左右两个节点，谁返回的数值大，那么这个数就是层数</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回K层中的节点个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetKLevelSize</span><span class="params">(Node *root, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = GetKLevelSize(root-&gt;left, k<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> right = GetKLevelSize(root-&gt;right, k<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> left + right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二叉树的查找</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通二叉树的查找</span></span><br><span class="line"><span class="comment">// 如果找到了，返回 v 所在结点的地址</span></span><br><span class="line"><span class="comment">// 如果没找到，返回 NULL</span></span><br><span class="line"><span class="comment">// 先去根里找</span></span><br><span class="line"><span class="comment">// 如果没找到，再去左子树找</span></span><br><span class="line"><span class="comment">// 如果还没找到，再去右子树找</span></span><br><span class="line"><span class="comment">// 在空树里找的结果，一定找不到，return NULL</span></span><br><span class="line"><span class="function">Node *<span class="title">Find</span><span class="params">(Node *root, <span class="keyword">char</span> v)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>判断是否是相同的二叉树</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSame</span><span class="params">(Node *p, Node *q)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span> &amp;&amp; q ==<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ture;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span> || q == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q-&gt;value == p-&gt;value &amp;&amp; isSame(p-&gt;left, q-&gt;left) &amp;&amp; isSame(p-&gt;right, q-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>另一颗树的子树</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">preorder</span><span class="params">(Node *root, Node *t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(isSame(root, t))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="comment">//如果t就是root的一个子树，直接返回true</span></span><br><span class="line">        <span class="keyword">if</span>(preorder(root-&gt;left, t) == <span class="literal">true</span>)&#123;<span class="comment">//如果在左子树中找到t子树，直接返回true，否则直接去右子树中查找</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> preorder(root-&gt;right, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flase;<span class="comment">//如果都没找到直接返回false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSubtree</span><span class="params">(Node *s, Node *t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> preorder(s,t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>二叉树的构建及遍历</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node *<span class="title">CreatTree</span><span class="params">(<span class="keyword">char</span> preorder[], <span class="keyword">int</span> size, <span class="keyword">int</span> *used)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如下图所示，数组保存的是前序遍历的一棵二叉树，#代表的是NULL</span></span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">        *used = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(preorder[<span class="number">0</span>] == <span class="string">'#'</span>)&#123;<span class="comment">//#也占了一个数组的*used，所以+1</span></span><br><span class="line">        *used = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Node *root = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    <span class="comment">//先定义一个父节点</span></span><br><span class="line">    <span class="keyword">int</span> leftUesd;</span><br><span class="line">    root-&gt;left = CreatTree(preorder + <span class="number">1</span>, size - <span class="number">1</span>, &amp;leftUsed);</span><br><span class="line">    <span class="comment">//根的左子数为：递归中数组中下一个的数，数组的容量-1，将左子树用的值返回</span></span><br><span class="line">    <span class="keyword">int</span> rightUsed;</span><br><span class="line">    root-&gt;right = CreatTree(preorder + <span class="number">1</span> + leftUsed, size - <span class="number">1</span> - leftUsed, &amp;rightUsed);</span><br><span class="line">    </span><br><span class="line">    *used = <span class="number">1</span> + leftUsed + rightUsed;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/04/数据结构之二叉树/二叉树2.png" alt="二叉树2"></p><p>在二叉树的递归中，不用特别明确的想出具体的递归路线。当为<code>root-&gt;left</code>那么此时一直都走的是左子树，反之一直都走的右子树。关键还是在于终止条件的寻找，只要找到了终止条件，那么递归才可一层一层的向上返回。</p><p>前中后序组合找出二叉树。怎么组合可以找出？</p><p>前序    找根最方便，preorder[0]</p><p>中序    分割左右子树最方便</p><p>后序    找根最方便，preorder[size - 1]</p><p>答案一目了然，只有<strong>前序+中序</strong>和<strong>后序+中序</strong>。前序+后序的组合，都是找根，那么左右子树的划分就不方便了。这样遍历起来明显有问题</p><p>就比如生活中，工作应该配合做才能更快，如果是两个做相同事情的人，那么工作总有一部分完成不了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Find</span><span class="params">(<span class="keyword">char</span> <span class="built_in">array</span>[], size, v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">array</span>[i] == v)&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//利用中序和后序进行创建二叉树</span></span><br><span class="line"><span class="function">Node *<span class="title">buildtree</span><span class="params">(<span class="keyword">char</span> inorder[], <span class="keyword">char</span> postorder[], <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> rootValue = postorder[size - <span class="number">1</span>];<span class="comment">//记录根节点的值，对于前后序不是第一个就是最后一个</span></span><br><span class="line">    <span class="keyword">int</span> leftsize = Find(inorder,size,rootValue);<span class="comment">//查找的是中序数组中左子树的个数</span></span><br><span class="line">    </span><br><span class="line">    Node *root = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    root-&gt;value = rootValue;</span><br><span class="line">    <span class="comment">//左子树不断的向下个递归创建。</span></span><br><span class="line">    root-&gt;left = buildtree(inorder, postorder, leftsize);</span><br><span class="line">    root-&gt;right = buildtree(inorder + leftsize + <span class="number">1</span>,postorder + leftsize,size - <span class="number">1</span> - leftsize);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/04/数据结构之二叉树/二叉树3.png" alt="二叉树3"></p><p>那么可以试下写前序和中序组合的方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比如上图这个组合</span></span><br><span class="line"><span class="function">Node *<span class="title">buildtree</span><span class="params">(<span class="keyword">char</span> postorder[], <span class="keyword">char</span> inorder[], <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> treeValue = postorder[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> leftused = Find(inorder, size, treeValue);</span><br><span class="line">    Node *root = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    </span><br><span class="line">    root-&gt;value = treeValue;</span><br><span class="line">    buildtree(postorder + <span class="number">1</span>, inorder, leftused);</span><br><span class="line">    buildtree(postorder + leftused + <span class="number">1</span>,inorder + <span class="number">1</span> + leftsize, size - <span class="number">1</span> - leftsize);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h4><p><strong>堆是一种逻辑上的完全二叉树，利用顺序存储，存在数组里。</strong></p><p>二叉堆用的是顺序存储的方式，更多用在完全二叉树。</p><p>任取一个节点，要求根的值 &gt;= 左右孩子的值（大堆）</p><p>任取一个节点，要求根的值 &lt;= 左右孩子的值（小堆）</p><p>作用：找最大值，永远出现在二叉树的根</p><p>操作：向下调整，为了调整成小堆，不断的向下将大的节点往下放(这个可以认为是寻找最小值)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AdjustDown</span><span class="params">(<span class="keyword">char</span> <span class="built_in">array</span>[], <span class="keyword">int</span> size, <span class="keyword">int</span> rootIdx)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> leftIdx = rootIdx * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> rightIdx = rootIdx * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(leftIdx &gt; size)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> min = leftIdx;</span><br><span class="line">    <span class="keyword">if</span>(rightIdx &lt; size &amp;&amp; rightIdx &lt; leftIdx)&#123;</span><br><span class="line">        min = rightIdx;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">array</span>[min] &gt;= <span class="built_in">array</span>[rootIdx])&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> tmp = <span class="built_in">array</span>[min];</span><br><span class="line">    <span class="built_in">array</span>[min] = <span class="built_in">array</span>[rootIdx];</span><br><span class="line">    <span class="built_in">array</span>[rootIdx] = tmp;</span><br><span class="line">    </span><br><span class="line">    AdjustDown(<span class="built_in">array</span>, size, min);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的都是怎么调整堆，那么怎么<strong>将一个完全无序的随机分布的数组变成满足堆的性质？</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateHeap</span><span class="params">(<span class="keyword">int</span> tree[], <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="comment">//最后一个节点的下标是 size - 1</span></span><br><span class="line">    <span class="comment">//最后一个非子叶节点就是最后一个节点的双亲</span></span><br><span class="line">    <span class="comment">//parent = (child - 1) / 2;</span></span><br><span class="line">    <span class="comment">//带入之后得 （size - 2） / 2</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = (size - <span class="number">2</span>) / <span class="number">2</span>;i &gt;= <span class="number">0</span>;i++)&#123;</span><br><span class="line">        AdjustDown(tree, size, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/04/数据结构之二叉树/二叉树4.png" alt="二叉树4"></p><p>这些只能算是初步了解了二叉树的逻辑和算法，毕竟二叉树不仅仅需要递归，非递归也是可以完成的。而且关于二叉堆只是仅仅懂了方法，还是不太知道具体的使用位置。学习还是得不断努力呀！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;树的概念&quot;&gt;&lt;a href=&quot;#树的概念&quot; class=&quot;headerlink&quot; title=&quot;树的概念&quot;&gt;&lt;/a&gt;树的概念&lt;/h4&gt;&lt;p&gt;树是一种&lt;strong&gt;非线性&lt;/strong&gt;的结构，它是由n(n&amp;gt;0)个有限结点组成一个具有层次关系的集合。把他叫
      
    
    </summary>
    
    
      <category term="C-数据结构" scheme="https://skrskr66.github.io/tags/C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Linux进程概念</title>
    <link href="https://skrskr66.github.io/2019/03/31/Linux%E8%BF%9B%E7%A8%8B%E6%A6%82%E5%BF%B5/"/>
    <id>https://skrskr66.github.io/2019/03/31/Linux进程概念/</id>
    <published>2019-03-31T15:09:31.000Z</published>
    <updated>2019-04-04T08:08:05.663Z</updated>
    
    <content type="html"><![CDATA[<p>进程是什么？在操作系统中，我们经常能听到这样的话。我们要终止一个进程或者杀死一个进程，父进程创建了子进程这一类的话。往往我们听到都会觉得很高大上，这跟编程语言完全不同的感觉，操作了整个计算机。</p><h3 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h3><h4 id="冯诺依曼体系结构"><a href="#冯诺依曼体系结构" class="headerlink" title="冯诺依曼体系结构"></a>冯诺依曼体系结构</h4><p>在进程之前首先要提一下我们的“祖师爷”——冯诺依曼体系结构。</p><p>这个是一个计算机入门第一节课必然会提到的知识。</p><p>冯诺依曼体系结构提出了计算机采用二进制；计算机应该按照程序顺序执行。</p><p>它由<strong>输入设备，输出设备，存储器，控制器，运算器</strong>组成</p><p>注意！注意！注意！</p><p>1、这里的存储器指的是内存。</p><p>2、不考虑缓存情况，这里的cpu（控制器+运算器）只能对内存进行读写，不能访问外设（输入或输出设备）</p><p>3、外设要输入或输出数据，也只能写入内存或者从内存中读取</p><h4 id="操作系统（0S）"><a href="#操作系统（0S）" class="headerlink" title="操作系统（0S）"></a>操作系统（0S）</h4><p>任何计算机系统都包含一个基本的程序集合，称为操作系统(OS)</p><p>操作系统的存在就是让计算机更加的好用，能更方便的、统筹合理的管理计算机的软硬件资源。</p><p>那么是怎么管理的？</p><p>我们可以先举一个例子，学校的管理，首先我们被辅导员统一管理，辅导员又由院内领导管理，院内领导又由校长管理。</p><p>学生-&gt;辅导员-&gt;院内领导-&gt;校长    这么一个层次结构。但在这之前管理需要制定一个制度来管理，每一个层次的人都遵守这个制度。这样才能按部就班的进行工作的分配。</p><p>那么操作系统也一样。总的来说就是：<strong>先描述，再组织</strong></p><p><strong>描述用struct结构体，比如进程有task_struct这样一个结构体来描述</strong></p><p><strong>组织可以用链表或者其他高效的数据结构</strong></p><h5 id="系统调用和库函数概念"><a href="#系统调用和库函数概念" class="headerlink" title="系统调用和库函数概念"></a>系统调用和库函数概念</h5><p>在开发角度，操作系统对外会表现一个整体，但是会暴露自己的部分接口，供上层开发使用，这部分由操作系统提供的接口，叫做系统调用。</p><p>系统调用在使用上，功能比较基础，对用户的要求也相对比较高，所以，有心的开发者可以对部分系统调用进行适度封装，从而形成了库，有了库，就很有利于更上层用户或者开发者进行二次开发</p><h4 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h4><p>从用户角度：进程就是一个正在运行中的程序。</p><p>操作系统角度：操作系统运行一个程序，需要描述这个程序的运行过程，这个描述通过一个结构体task_struct{}来描述，统称为PCB，因此对操作系统来说进程就是PCB(process control block)程序控制块</p><p>进程的描述信息有：标识符PID，进程状态，优先级，程序计数器，上下文数据，内存指针，IO状态信息，记账信息。都需要操作系统进行调度。</p><p>那么在Linux操作系统下，怎么查看进程呢</p><h4 id="查看进程"><a href="#查看进程" class="headerlink" title="查看进程"></a>查看进程</h4><p>输入<code>ls /porc</code>指令即可</p><p><img src="/2019/03/31/Linux进程概念/进程1.png" alt="进程1"></p><p>前面蓝色数字代表的进程的ID。如果你想查看PID为1的进程信息，你需要查看<code>/porc/1</code>这个文件夹</p><p>我们也可以使用<code>ps -ef -aux</code>指令来直接显示进程状态</p><p><img src="/2019/03/31/Linux进程概念/进程2.png" alt="进程2"></p><p>还有getpid()和getppid()这两个函数用来查看当前程序的进程和父进程PID。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"getpid:%d"</span>,getpid());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"getppid:%d"</span>,getppid());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h4><p>Linux中非常重要的函数——<code>fork()</code>，它从已存在的进程中创建一个新进程。新进程为子进程，而原进程为父进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>);</span><br><span class="line">返回值：</span><br><span class="line">父进程：返回值大于<span class="number">0</span>，子进程的pid</span><br><span class="line">子进程：返回值等于<span class="number">0</span></span><br></pre></td></tr></table></figure><p>写这么个程序来初始fork函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;   </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"parent pid:%d\n"</span>,getpid());    </span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">100</span>;    </span><br><span class="line">  <span class="keyword">pid_t</span> pid = fork();    </span><br><span class="line">  <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)&#123;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)&#123;    </span><br><span class="line">    a = <span class="number">20</span>;    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"child !! pid:%d----a:%d--%p\n"</span>,getpid(),a ,&amp;a);    </span><br><span class="line">    </span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;    </span><br><span class="line">    sleep(<span class="number">1</span>);    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"parent !! pid:%d----a:%d--%p\n"</span>,getpid(), a, &amp;a);    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"nihaoa %d\n"</span>,a);    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于fork函数需要理解，每当调用一次fork函数时，会返回两个两次。一次是在调用进程中（父进程）返回一次，返回值是新派生的进程的进程ID。一次是在子进程中返回，返回值是0，代表当前进程为子进程。如果返回-1，那么则代表在创建子进程的过程中出现了错误。</p><p>将上面代码执行之后</p><p><img src="/2019/03/31/Linux进程概念/进程3.png" alt="进程3"></p><p>先返回了子进程的pid，之后再返回了父进程的pid。</p><p>fork()相当于创建了一个新的子进程，但是拷贝的是fork()函数之后的所有数据，之前的并不会拷贝。在代码之上就可以看到parentpid只打印了一次</p><p><strong>总的来说：复制pcb，代码共享，但是子进程并非从头开始，而是从fork()函数之后开始，数据独有</strong></p><p>借用一下网上大佬对fork()的理解</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(1)一个进程进行自身的复制，这样每个副本可以独立的完成具体的操作，在多核处理器中可以并行处理数据。这也是网络服务器的其中一个典型用途，多进程处理多连接请求。 </span><br><span class="line">(2)一个进程想执行另一个程序。比如一个软件包含了两个程序，主程序想调起另一个程序的话，它就可以先调用fork来创建一个自身的拷贝，然后通过exec函数来替换成将要运行的新程序。</span><br></pre></td></tr></table></figure><p>那么创建子进程的意义是什么————<strong>压力分摊/干其他工作</strong></p><h4 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h4><p>进程状态一般有：就绪态，阻塞态，运行态</p><p>在Linux下：R运行状态，S睡眠状态，D磁盘休眠状态，T停止状态，X死亡状态</p><p>这些当我们使用指令<code>ps -aux</code>就可以看到</p><h5 id="僵尸进程"><a href="#僵尸进程" class="headerlink" title="僵尸进程"></a>僵尸进程</h5><p>在进程状态中有两个比较特殊的存在。僵尸和孤儿</p><p>僵尸进程是进程退出后，但是资源没有释放，处于僵死状态的进程。</p><p>产生原因：子进程先于父进程退出，操作系统检测到进程的退出，通知父进程，但是父进程这时候正在执行其他操作，没有关注这个通知，这时候操作系统为了保护子进程，不会释放子进程资源，因为子进程的PCB中包含有退出原因。这时候因为既没有运行也没有退出，因此处于僵死状态，成为僵尸进程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;    </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;                                                                                                         </span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">  <span class="keyword">pid_t</span>  pid;    </span><br><span class="line">  <span class="comment">//循环创建子进程    </span></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)    </span><br><span class="line">  &#123;    </span><br><span class="line">    pid = fork();    </span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)    </span><br><span class="line">    &#123;    </span><br><span class="line">      perror(<span class="string">"fork error:"</span>);    </span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)    </span><br><span class="line">    &#123;    </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"I am a child process.\nI am exiting.\n"</span>);    </span><br><span class="line">  <span class="comment">//子进程退出，成为僵尸进程    </span></span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">0</span>);    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">else</span>    </span><br><span class="line">    &#123;    </span><br><span class="line">      <span class="comment">//父进程休眠20s继续创建子进程    </span></span><br><span class="line">      sleep(<span class="number">20</span>);    </span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;       </span><br><span class="line">  &#125;      </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;                            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行这上面这个程序，子进程中途退出了。</p><p><img src="/2019/03/31/Linux进程概念/进程4.png" alt="进程4"></p><p><img src="/2019/03/31/Linux进程概念/进程5.png" alt="进程5"></p><p>z+这个标志就是僵尸进程的标志。</p><p>那么怎么避免僵尸进程的产生？</p><p>我们一般<strong>处理就是关闭父进程</strong>，这样僵尸子进程也随之消失了。</p><p>所以我们最好设置<strong>进程等待</strong>，等待子进程完成了工作，并且通知了父进程之后，在退出。</p><h5 id="孤儿进程"><a href="#孤儿进程" class="headerlink" title="孤儿进程"></a>孤儿进程</h5><p>孤儿进程与僵尸进程在理解上可以认为相反。</p><p>父进程先于子进程退出，父进程退出后，子进程成为后台进程，并且父进程为1号进程。</p><p>守护进程：特殊（脱离了与终端的关联+会话的关联）的孤儿进程    </p><h4 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h4><p>优先级：决定资源的优先分配权的等级划分</p><p>那么进程为什么具有优先级呢？</p><p><strong>为了让操作系统的运行更加的合理——交互式进程（一旦有操作优先处理）和批处理进程（一直处理程序，但对CPU要求不高）</strong></p><p>设置优先级，可以使用指令<code>ps -elf</code>先查看进程</p><p>可以看到 PRI 和 NI这两个数值</p><p>PRI：优先级    NI：nice值</p><p>PRI是无法直接调整的，但是可以通过调整nice值来调整优先级的大小</p><p>PRI = PRI + NI，但是NI也是有范围的——(-20~19)</p><p>指令操作为<code>renice -n size -p pid</code></p><p>运行时操作为<code>nice -n size ./main(可执行文件)</code></p><p>这里稍微提一下，程序在运行时具有并行和并发两种执行。</p><p>并行：CPU资源足够，多个程序同时运行</p><p>并发：CPU资源不够，多个程序切换调度运行（可以看看我之前的一篇关于操作系统的博客，有关调度方法的介绍）</p><p><img src="/2019/03/31/Linux进程概念/进程6.png" alt="进程6"></p><p>Linux下指令<code>top</code>指令可以查看进程的优先级</p><p>进入top后按<code>“r”–&gt;输入进程PID–&gt;输入nice值</code></p><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>环境变量是保存系统运行环境参数的变量</p><p>环境变量在安装java的过程中，可能接触过，需要进入系统环境变量，然后设置PATH添加java的路径</p><p>在Linux下可以通过命令指令自己设置</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo 通过变量名称，查看指定环境变量</span><br><span class="line">env 查看所有环境变量</span><br><span class="line">set 查看环境变量以及临时变量</span><br><span class="line">export 声明一个环境</span><br><span class="line">unset 删除一个临时变量</span><br></pre></td></tr></table></figure><p>常见的环境变量：HOME SHELL USER PATH</p><p><img src="/2019/03/31/Linux进程概念/进程7.png" alt="进程7"></p><p><strong>环境变量的全局特性：在子进程中获取继承于父进程的环境变量信息</strong></p><p>三种获取环境变量的参数</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argc[],<span class="keyword">char</span> *env[])参数获取</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;全局变量获取</span><br><span class="line"></span><br><span class="line">char *getenv(const char *env_name)接口获取</span><br></pre></td></tr></table></figure><p>写一个获取变量的demo</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;    </span></span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;    </span></span></span><br><span class="line">      </span><br><span class="line">W&gt;<span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[], <span class="keyword">char</span> *env[])</span></span>&#123;    </span><br><span class="line">    <span class="comment">//main函数的参数值是从操作系统命令行上获得的。当我们要运行一个可执行文件时，在DOS提示符下键入文件名，再输入实际参数&gt;  即可把这些实参传送到main的形参中去。        </span></span><br><span class="line">    <span class="comment">//C:\&gt;可执行文件名 参数 参数……    </span></span><br><span class="line">    <span class="comment">//argv参数是字符串指针数组，其各元素值为命令行中各字符串(参数均按字符串处理)的首地址    </span></span><br><span class="line">    <span class="comment">//env：字符指针的数组，每一个元素是指向一个环境变量的字符指针                                                       </span></span><br><span class="line">    <span class="keyword">int</span> i;                                      </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; argc; i++)&#123;                   </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"argv[%d]=[%s]\n"</span>,i , argv[i]);     </span><br><span class="line">    &#125;                                            </span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">char</span> **environ;                       </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;environ[i] != <span class="literal">NULL</span>;i++)&#123;           </span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"env[%d]=[%s]\n"</span>,i, environ[i]);    </span><br><span class="line">    &#125;                               </span><br><span class="line">    <span class="keyword">char</span> *ptr = getenv(<span class="string">"MYENV"</span>);    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"MYENV:[%s]\n"</span>,ptr);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                 </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/03/31/Linux进程概念/进程8.png" alt="进程8"></p><p>如果输入<code>export MYENV=&quot;10000&quot;</code>，在运行程序</p><p>MYENV将变成<code>MYENV:[10000]</code></p><h4 id="程序地址空间"><a href="#程序地址空间" class="headerlink" title="程序地址空间"></a>程序地址空间</h4><table><thead><tr><th style="text-align:center">内核空间</th></tr></thead><tbody><tr><td style="text-align:center">运行参数/环境变量</td></tr><tr><td style="text-align:center">栈</td></tr><tr><td style="text-align:center">栈区（从上往下取）中间有共享区</td></tr><tr><td style="text-align:center">堆区（从下往上取）中间有共享区</td></tr><tr><td style="text-align:center">堆</td></tr><tr><td style="text-align:center">初始化全局数据</td></tr><tr><td style="text-align:center">未初始化全局数据</td></tr><tr><td style="text-align:center">代码段</td></tr></tbody></table><p>地址是什么？地址是内存的编号，指向内存的一块区域</p><p>虚拟地址空间：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mm_struct&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span> size</span><br><span class="line">code_start</span><br><span class="line">code_end</span><br><span class="line">data_start</span><br><span class="line">a</span><br><span class="line">data_end</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/03/31/Linux进程概念/进程9.png" alt="进程9"></p><p>上图之中，中间的物理内存地址，两边的为虚拟内存地址。</p><p>右边是父进程将虚拟地址通过页表查找到物理内存的地址，这时父进程在运行一个程序。此时父进程又创建了一个子进程(图最右)。子进程也通过页表找到物理内存的地址，这时子进程运行的程序在物理内存的另一个新空间运行。</p><p>这是虚拟内存地址使用的过程。它的作用就是保持进程的独立性，通过页表映射物理地址，充分的利用物理地址，增加内存访问控制。</p><p>这就是进程有关的知识。总结一下</p><p>进程从用户角度和操作系统角度去理解。前者就是一个运行的程序，后者表示运行一个程序，需要描述一个程序的运行过程，通过一个结构体task_struct{}来描述，叫做PCB。对操作系统来说，进程就是PCB</p><p>进程的创建需要一个我们必须要掌握的函数——fork()函数，创建一个子进程。并且fork()函数会有两个返回值，在返回的过程中父进程之前的数据不进行拷贝，之后与父进程的运行一致。创建子进程是为了分摊压力/干其他工作</p><p>进程的状态有运行态，睡眠状态，磁盘休眠状态，停止状态，死亡状态。每一种状态是容易理解的。但是还有两个特殊的进程</p><p>僵尸进程和孤儿进程，<strong>前者</strong>是进程退出后资源没有释放，操作系统通知父进程，但是父进程此时正在处理其他事情，没有关注子进程的退出通知，系统为了保护资源，没有释放掉，并且在子进程的PCB中也保留了退出原因，此时既没有运行也没有完全退出，处于了僵死状态。但是<strong>后者</strong>是父进程先于子进程先退出，子进程成为了后台程序，由一号进程接管。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;进程是什么？在操作系统中，我们经常能听到这样的话。我们要终止一个进程或者杀死一个进程，父进程创建了子进程这一类的话。往往我们听到都会觉得很高大上，这跟编程语言完全不同的感觉，操作了整个计算机。&lt;/p&gt;
&lt;h3 id=&quot;进程的概念&quot;&gt;&lt;a href=&quot;#进程的概念&quot; clas
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://skrskr66.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux的文件权限</title>
    <link href="https://skrskr66.github.io/2019/03/30/Linux%E7%9A%84%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90/"/>
    <id>https://skrskr66.github.io/2019/03/30/Linux的文件权限/</id>
    <published>2019-03-30T09:15:58.000Z</published>
    <updated>2019-03-30T10:45:28.961Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Linux的权限"><a href="#Linux的权限" class="headerlink" title="Linux的权限"></a>Linux的权限</h3><p>Linux下有三种用户，普通用户和超级用户和系统用户</p><p>超级用户就是我们所说的root，普通用户是我们自己所创建的一个用户，能在有限的权限内进行操作。</p><p>系统用户是<a href="https://www.baidu.com/s?wd=Linux%E7%B3%BB%E7%BB%9F&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">Linux系统</a>正常工作所必需的内建的用户，主要是为了满足相应的系统进程对文件属主的要求而建立的，系统用户不能用来登录，如bin、daemon、adm、lp等用户。 </p><h4 id="Linux权限的管理"><a href="#Linux权限的管理" class="headerlink" title="Linux权限的管理"></a>Linux权限的管理</h4><h5 id="文件访问者的管理"><a href="#文件访问者的管理" class="headerlink" title="文件访问者的管理"></a>文件访问者的管理</h5><p>文件访问者的管理分为：文件和文件目录的所有者u—user、文件和文件目录的所有者的组的用户g—group、其他用户o—others.</p><h5 id="文件类型和访问权限"><a href="#文件类型和访问权限" class="headerlink" title="文件类型和访问权限"></a>文件类型和访问权限</h5><p><img src="/2019/03/30/Linux的文件权限/权限1.png" alt="权限1"></p><p>上图是我在我的云服务器上输入<code>ll</code>指令出来的当前文件夹下的文件显示</p><p><strong>d</strong>代表的<strong>文件类型</strong>，在这之外还有许多文件类型</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">d：文件夹</span><br><span class="line">-：普通文件</span><br><span class="line">l：软链接（类似windows的快捷方式）</span><br><span class="line">b：块设备文件（例如硬盘、光驱等）</span><br><span class="line">p：管道文件</span><br><span class="line">c：字符设备文件</span><br><span class="line">s：套接口文件（socket）</span><br></pre></td></tr></table></figure><p><strong>rwxr-xr-x</strong>这代表的是权限，每三个代表的是文件访问者的管理。前三位是user的权限，中间三位是group的权限，后三位是其他用户的权限。</p><p><strong>rwx</strong>又分别为可读文件，可写文件，可执行文件。</p><p>读（r/4）：Read对文件而言，具有读取文件内容的权限；对目录来说，具有浏览该目录信息的权限</p><p>写（w/2）：Write对文件而言，具有修改文件内容的权限；对目录来说具有删除移动目录内文件的权限</p><p>执行（x/1）：execute对文件而言，具有执行文件的权限；对目录来说，具有进入目录的权限</p><p>“—”：表示不具有该项权限</p><table><thead><tr><th>Linux表示</th><th>说明</th><th>Linux表示</th><th>说明</th></tr></thead><tbody><tr><td>r–</td><td>只读</td><td>-w-</td><td>仅可写</td></tr><tr><td>–x</td><td>仅可执行</td><td>rw-</td><td>可读可写</td></tr><tr><td>-wx</td><td>可写和可执行</td><td>r-x</td><td>可读可执行</td></tr><tr><td>rwx</td><td>可读可写可执行</td><td>—</td><td>无权限</td></tr></tbody></table><p>8进制数值表示法</p><table><thead><tr><th>权限符号</th><th>八进制</th><th>二进制</th></tr></thead><tbody><tr><td>r</td><td>4</td><td>100</td></tr><tr><td>w</td><td>2</td><td>010</td></tr><tr><td>x</td><td>1</td><td>001</td></tr><tr><td>rw</td><td>6</td><td>110</td></tr><tr><td>rx</td><td>5</td><td>101</td></tr><tr><td>wx</td><td>3</td><td>011</td></tr><tr><td>rwx</td><td>7</td><td>111</td></tr><tr><td>—</td><td>0</td><td>000</td></tr></tbody></table><h5 id="文件访问权限的相关方法"><a href="#文件访问权限的相关方法" class="headerlink" title="文件访问权限的相关方法"></a>文件访问权限的相关方法</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chomd </span><br><span class="line">设置文件的访问权限</span><br><span class="line">格式：chmod [参数] 权限 文件名</span><br></pre></td></tr></table></figure><p>这是最常用的文件访问，它的使用有两种方式</p><p>1、<code>chmod u+w filename</code>，<code>chmod o-x filename</code></p><p>通过用户表示符 +/-= 权限字符</p><p>这里用户表示符还有<code>a</code>,代表了所有文件访问管理者</p><p>2、三位8进制数字表示，<code>chmod 741 filename</code> </p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chown</span><br><span class="line">修改文件的拥有者</span><br><span class="line">格式：chown [参数] 用户名 文件名</span><br></pre></td></tr></table></figure><p>chown user1 f1</p><p>chown -R user1 filegroup1</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chgrp</span><br><span class="line">修改文件或目录的所属组</span><br><span class="line">格式：chgrp [参数] 用户组名 文件名</span><br><span class="line">常用选项：-R 递归修改文件或目录的所属组</span><br></pre></td></tr></table></figure><h5 id="umask"><a href="#umask" class="headerlink" title="umask"></a><strong>umask</strong></h5><p>功能：查看或修改文件掩码</p><p>比如新建了一个文件夹默认权限为666，新建目录为777。但实际上你所创建的文件和目录，看到的往往不是上面这个值。</p><p>原因就是创建文件或目录的时候还要受到umask的影响。假如默认权限mask，则实际创建出来的文件权限是：mask &amp; ~umask 其实就是——<code>默认权限mask-文件掩码umask</code></p><h5 id="沾滞位"><a href="#沾滞位" class="headerlink" title="沾滞位"></a>沾滞位</h5><p>当一堆用户在做一个项目时，大家都在同一个服务器上。这时每个人的文件都被保存在一个文件夹下。那么当文件具有可读可写可执行的某一权限时，每个人都可以对别人的文件进行操作，那这样张三岂不是可以把李四的文章随便删除？</p><p>为了解决这一方法，引出了沾滞位这一概念。</p><p>当一个目录被设置为“沾滞位”（chmod + t），则该目录下的文件只能由</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一、超级管理员删除 </span><br><span class="line">二、该目录的所有者删除 </span><br><span class="line">三、该文件的所有者删除</span><br></pre></td></tr></table></figure><h4 id="权限的总结"><a href="#权限的总结" class="headerlink" title="权限的总结"></a>权限的总结</h4><p>目录的可执行权限是表示你可否在目录下执行命令。 </p><p>如果目录没有-x权限，则无法对目录执行任何命令，甚至无法cd进入目录, 即使目录仍然有-r 读权限(这个地方很容易犯错，认为有读权限就可以进入目录读取目录下的文件)</p><p>而如果目录具有-x权限，但没有-r权限，则用户可以执行命令，可以cd进入目录。但由于没有目录的读权限，所以在目录下，即使可以执行ls命令，但仍然没有权限独出目录下的文档。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Linux的权限&quot;&gt;&lt;a href=&quot;#Linux的权限&quot; class=&quot;headerlink&quot; title=&quot;Linux的权限&quot;&gt;&lt;/a&gt;Linux的权限&lt;/h3&gt;&lt;p&gt;Linux下有三种用户，普通用户和超级用户和系统用户&lt;/p&gt;
&lt;p&gt;超级用户就是我们所说的r
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://skrskr66.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>数据结构之链表练习题</title>
    <link href="https://skrskr66.github.io/2019/03/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8%E7%BB%83%E4%B9%A0%E9%A2%98/"/>
    <id>https://skrskr66.github.io/2019/03/27/数据结构之链表练习题/</id>
    <published>2019-03-27T08:52:15.000Z</published>
    <updated>2019-03-29T04:38:32.496Z</updated>
    
    <content type="html"><![CDATA[<p>这些练习都是力扣中的真题，挺容易对链表有个更进一步了解的</p><p>1、删除链表中等于给定值 val 的所有节点</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SListRemoveAll</span><span class="params">(SList *s, SLDataType v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s-&gt;first == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(s-&gt;first-&gt;value == v)&#123;</span><br><span class="line">        Node *next = s-&gt;first;</span><br><span class="line">        s-&gt;first = s-&gt;first-&gt;next;</span><br><span class="line">        <span class="built_in">free</span>(s-&gt;first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Node *c = s-&gt;first;</span><br><span class="line">        <span class="keyword">while</span>(c-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(c-&gt;next-&gt;value == v)&#123;</span><br><span class="line">                Node *next = c-&gt;next;</span><br><span class="line">                c-&gt;next = c-&gt;next-&gt;next;</span><br><span class="line">                <span class="built_in">free</span>(c-&gt;next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                c = c-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、 反转一个单链表。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SListReverse</span><span class="params">(SList *head)</span></span>&#123;</span><br><span class="line">    Node *result = <span class="literal">NULL</span>;</span><br><span class="line">    Node *c = head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(c != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        Node *next = c-&gt;next;</span><br><span class="line">        </span><br><span class="line">        c-&gt;next = result;</span><br><span class="line">        result = c;</span><br><span class="line">        </span><br><span class="line">        c = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、给定一个带有头结点 head 的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个 中间结点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">middleNode</span><span class="params">(SList *head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;<span class="comment">//利用快慢指针的思想</span></span><br><span class="line">    Node *fast = head;</span><br><span class="line">    Node *slow = head;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(fast == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(fast == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、输入一个链表，输出该链表中倒数第k个结点。 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node *<span class="title">FindKthToTail</span><span class="params">(Node *head, <span class="keyword">unsigned</span> <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    Node *front = head;</span><br><span class="line">    Node *back = head;</span><br><span class="line">    <span class="comment">//让前面的先走k步</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; k &amp;&amp; front != <span class="literal">NULL</span>;i++)&#123;</span><br><span class="line">        front = front-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i &lt; k)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(front != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        front = front-&gt;next;</span><br><span class="line">        back = back-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> back;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5、 将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成 的。新链表也是有序的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">mergeTwoList</span><span class="params">(SList *c1, SList *c2)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SList</span> *<span class="title">c1</span> = <span class="title">l1</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SList</span> *<span class="title">c2</span> = <span class="title">l2</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SList</span> *<span class="title">result</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SList</span> *<span class="title">last</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(l1 == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l2 == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(l1 != <span class="literal">NULL</span> &amp;&amp; l2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1-&gt;value &lt;= l2-&gt;value)&#123;</span><br><span class="line">            <span class="keyword">if</span>(result == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                result = last = l1;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                last-&gt;next = last;</span><br><span class="line">                last = l1;</span><br><span class="line">            &#125;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">if</span>(result == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                result = last = l2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                last-&gt;next = last;</span><br><span class="line">                last = l2;</span><br><span class="line">            &#125;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//两个有序链表不一定等长，多出来的直接接到新链表之后就可以</span></span><br><span class="line">    <span class="keyword">if</span>(l1 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        last-&gt;next = l1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(l2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        last-&gt;next = l2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>6、 编写代码，以给定值x为基准将链表分割成两部分，所有小于x的结点排在大于或等于x的结点之前 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node *<span class="title">partition</span><span class="params">(SList* head, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    SList *small;</span><br><span class="line">    SList *big;</span><br><span class="line">    SList *lastsmall;</span><br><span class="line">    SList *lastbig;</span><br><span class="line">    </span><br><span class="line">    SList *node = head;</span><br><span class="line">    <span class="keyword">while</span>(node != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;value &lt; x)&#123;</span><br><span class="line">            <span class="keyword">if</span>(small == <span class="literal">NULL</span>)&#123;</span><br><span class="line">                small = smalllast =node;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                lastsmall-&gt;next = node;</span><br><span class="line">                lastsmall = node; <span class="comment">// lastsmall表示的是最后一个节点，它等于node说明他就是最后一个结点，因为node每次将判断好的结点放在最后一个位置</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(big == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            big = lastbig =node;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                lastbig-&gt;next = node;</span><br><span class="line">                lastbig = node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(lastsmall != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">//如果比x小的结点存在，则该链表最后接上big链表</span></span><br><span class="line">        lastsmall-&gt;next = big;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(lastbig != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">//如果比x大的结点存在，则该链表最后指向NULL</span></span><br><span class="line">        lastbig-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(lastsmall != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> small;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> big;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7、在一个排序的链表中，存在重复的结点，请删除该链表中重复的结点，重复的结点不保留，返回链表头指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node *<span class="title">deleteDuplication</span><span class="params">(SList* head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SList *fake = (Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));<span class="comment">//先定义一个假结点</span></span><br><span class="line">    fake-&gt;next = head;</span><br><span class="line">    </span><br><span class="line">    SList *prev = fake;</span><br><span class="line">    SList *p1 = head;</span><br><span class="line">    SList *p2 = head-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p2 != <span class="literal">NULL</span>)&#123;<span class="comment">//不要忘了判断，否则p2为空后继续走，将会发生内存泄漏</span></span><br><span class="line">    <span class="comment">//前后指针，一个在前走，一个在后走，在前走的同时判断有没有重复的</span></span><br><span class="line">    <span class="keyword">if</span>(p1-&gt;val != p2-&gt;val)&#123;</span><br><span class="line">        prev = p1;</span><br><span class="line">        p1 = p2;</span><br><span class="line">        p2 = p2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(p2 != <span class="literal">NULL</span> &amp;&amp; p1-&gt;val == p2-&gt;val)&#123;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        SList *cur = p1;</span><br><span class="line">        <span class="keyword">while</span>(cur != p2)&#123;</span><br><span class="line">            SList *next = cur-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(cur);</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        prev-&gt;next = p2;<span class="comment">//很关键的一步，删完之后继续连接未删除的</span></span><br><span class="line">        p1 = p2;</span><br><span class="line">        <span class="keyword">if</span>(p2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            p2 = p2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    head = fake-&gt;next;</span><br><span class="line">    <span class="comment">//prev在链表中一直相当于记录，就是fake</span></span><br><span class="line">    <span class="built_in">free</span>(fake);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>8、对于一个链表，请设计一个时间复杂度为O(n),额外空间复杂度为O(1)的算法，判断其是否为回文结构。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1-&gt;2-&gt;2-&gt;1</span><br></pre></td></tr></table></figure><p>思路还是很好理解的</p><p>1、找到中间结点</p><p>2、从中间结点开始往后逆转整个链表</p><p>3、将头结点和逆转数组作比较</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">middleNode</span><span class="params">(ListNode *head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *slow = head;</span><br><span class="line">    ListNode *fast = head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(fast == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">        <span class="keyword">if</span>(fast == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">reverlist</span><span class="params">(ListNode *head)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *result = <span class="literal">NULL</span>;</span><br><span class="line">    ListNode *cur = head;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(cur != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        ListNode *next = cur-&gt;next;</span><br><span class="line">        </span><br><span class="line">        cur-&gt;next = result;</span><br><span class="line">        result = cur;</span><br><span class="line">        </span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">chkPalindrome</span><span class="params">(ListNode* A)</span></span>&#123;</span><br><span class="line">    ListNode *middle = middleNode(A);</span><br><span class="line">    ListNode *r = reverselist(middle-&gt;next);</span><br><span class="line">    </span><br><span class="line">    ListNode *n1 = A, *n2 = r;</span><br><span class="line">    <span class="keyword">while</span>(n1 != <span class="literal">NULL</span> &amp;&amp; n2 != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n1-&gt;val != n2-&gt;val)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n1 = n1-&gt;next;</span><br><span class="line">        n2 = n2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这些练习都是力扣中的真题，挺容易对链表有个更进一步了解的&lt;/p&gt;
&lt;p&gt;1、删除链表中等于给定值 val 的所有节点&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class
      
    
    </summary>
    
    
      <category term="C-数据结构" scheme="https://skrskr66.github.io/tags/C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>Django建立一个音乐网站(五)</title>
    <link href="https://skrskr66.github.io/2019/03/25/Django%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AA%E9%9F%B3%E4%B9%90%E7%BD%91%E7%AB%99-%E4%BA%94/"/>
    <id>https://skrskr66.github.io/2019/03/25/Django建立一个音乐网站-五/</id>
    <published>2019-03-25T06:17:50.000Z</published>
    <updated>2019-03-26T14:36:05.160Z</updated>
    
    <content type="html"><![CDATA[<p>接下来就是后台管理了。</p><p>在这本书这个项目之前，我最初接触python看的是《python基础教程—从实践到入门》，这本后面讲解了django，而且这里面讲解是从admin开始。如果有兴趣了解的可以看看书或者从网上寻找资料，但是django版本不是很高，看起来可能让人容易懵</p><p>后台管理是管理员对用户数据进行管理的存在。在这之中也可以对用户进行权限的赋予（知道为啥VIP牛X了吧）。</p><p>登陆后台管理操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python manage.py runserver</span><br><span class="line"><span class="comment">#启动之后，在浏览器输入栏输入</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8000</span>/admin</span><br><span class="line">即可进入</span><br></pre></td></tr></table></figure><p>在整个网站中，index和user算两个app所以分别定义模型，因此在Admin后台系统是区分两个模块的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#index的__init__.py</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#对功能模块进行命名</span></span><br><span class="line"><span class="keyword">from</span> django.apps <span class="keyword">import</span> AppConfig</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="comment">#修改App在Admin后台显示的名称</span></span><br><span class="line"><span class="comment">#default_app_config的值来自apps.py的类名</span></span><br><span class="line">default_app_config = <span class="string">'index.IndexConfig'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取当前App的命名</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_cuurrent_app_name</span><span class="params">(_file)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> os.path.split(os.path.dirname(_file))[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#重写类IndexConfig</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexConfig</span><span class="params">(AppConfig)</span>:</span></span><br><span class="line">    name = get_cuurrent_app_name(__file__)</span><br><span class="line">    verbose_name = <span class="string">'网站首页'</span></span><br><span class="line">    </span><br><span class="line">------------------------------------------------------------------------------------------------    </span><br><span class="line"><span class="comment">#index的admin.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#修改title和header</span></span><br><span class="line"></span><br><span class="line">admin.site.site_title = <span class="string">'我的音乐后台管理系统'</span></span><br><span class="line">admin.site.site_header = <span class="string">'我的音乐'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#模型Label</span></span><br><span class="line"><span class="meta">@admin.register(Label)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LabelAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    <span class="comment">#设置模型字段，用于Admin后台数据的表头设置</span></span><br><span class="line">    list_display = [<span class="string">'label_id'</span>, <span class="string">'label_name'</span>]</span><br><span class="line">    <span class="comment">#设置可搜索的字段并在Admin后台数据生成搜索框,如有外键应使用双下画线链接两个模型的字段</span></span><br><span class="line">    search_fields = [<span class="string">'label_name'</span>]</span><br><span class="line">    <span class="comment">#设置排序方式</span></span><br><span class="line">    ordering = [<span class="string">'label_id'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#模型Song</span></span><br><span class="line"><span class="meta">@admin.register(Song)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SongAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    list_display = [<span class="string">'song_id'</span>,<span class="string">'song_name'</span>,<span class="string">'song_singer'</span>,<span class="string">'song_album'</span>,<span class="string">'song_languages'</span>,<span class="string">'song_release'</span>]</span><br><span class="line">    search_fields = [<span class="string">'song_name'</span>,<span class="string">'song_singer'</span>,<span class="string">'song_album'</span>,<span class="string">'song_languages'</span>]</span><br><span class="line">    <span class="comment">#设置过滤器，在后台数据的右侧生成导航栏,如有外键应使用双下画线连接两个模型的字段</span></span><br><span class="line">    list_filter = [<span class="string">'song_singer'</span>,<span class="string">'song_album'</span>,<span class="string">'song_languages'</span>]</span><br><span class="line">    ordering = [<span class="string">'song_id'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#模型Dynamic</span></span><br><span class="line"><span class="meta">@admin.register(Dynamic)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DynamicAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    list_display = [<span class="string">'dynamic_id'</span>,<span class="string">'song'</span>,<span class="string">'dynamic_plays'</span>,<span class="string">'dynamic_search'</span>,<span class="string">'dynamic_down'</span>]</span><br><span class="line">    search_fields = [<span class="string">'song'</span>]</span><br><span class="line">    list_filter = [<span class="string">'dynamic_plays'</span>,<span class="string">'dynamic_search'</span>,<span class="string">'dynamic_down'</span>]</span><br><span class="line">    ordering = [<span class="string">'dynamic_id'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#模型Comment</span></span><br><span class="line"><span class="meta">@admin.register(Comment)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommentAdmin</span><span class="params">(admin.ModelAdmin)</span>:</span></span><br><span class="line">    list_display = [<span class="string">'comment_id'</span>,<span class="string">'comment_text'</span>,<span class="string">'comment_user'</span>,<span class="string">'song'</span>,<span class="string">'comment_date'</span>]</span><br><span class="line">    search_fields = [<span class="string">'comment_user'</span>,<span class="string">'song'</span>,<span class="string">'comment_date'</span>]</span><br><span class="line">    list_filter = [<span class="string">'song'</span>,<span class="string">'comment_date'</span>]</span><br><span class="line">    ordering = [<span class="string">'comment_id'</span>]</span><br></pre></td></tr></table></figure><p>接下来就是user这个app的一些设置，与上面大同小异</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#user的__init__.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> django.apps <span class="keyword">import</span> AppConfig</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">default_app_config = <span class="string">'user.IndexConfig'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#获取当前App的命名</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_current_app_name</span><span class="params">(_file)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> os.path.split(os.path.dirname(_file))[<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#重写类IndexConfig</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexConfig</span><span class="params">(AppConfig)</span>:</span></span><br><span class="line">    name = get_current_app_name(__file__)</span><br><span class="line">    verbose_name = <span class="string">'用户管理'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------------------------------------------------------------------------------------------------</span><br><span class="line"><span class="comment">#user的admin.py</span></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> MyUser</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth.admin <span class="keyword">import</span> UserAdmin</span><br><span class="line"><span class="keyword">from</span> django.utils.translation <span class="keyword">import</span> gettext_lazy <span class="keyword">as</span> _</span><br><span class="line"><span class="meta">@admin.register(MyUser)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyUserAdmin</span><span class="params">(UserAdmin)</span>:</span></span><br><span class="line">    list_display = [<span class="string">'username'</span>,<span class="string">'email'</span>,<span class="string">'mobile'</span>,<span class="string">'qq'</span>,<span class="string">'weChat'</span>]</span><br><span class="line">    <span class="comment">#在用户信息界面添加’mobile‘，'qq','weChat'的信息输入框</span></span><br><span class="line">    <span class="comment">#将源码的UserAdmin.filesets转换成列表格式</span></span><br><span class="line">    fieldsets = list(UserAdmin.fieldsets)</span><br><span class="line">    <span class="comment">#重写UserAdmin的fieldsets，添加'mobile','qq','weChat'的信息录入</span></span><br><span class="line">    fieldsets[<span class="number">1</span>] = (_(<span class="string">'Personal info'</span>),</span><br><span class="line">                    &#123;<span class="string">'fields'</span>:(<span class="string">'first_name'</span>,<span class="string">'last_name'</span>,<span class="string">'email'</span>,<span class="string">'mobile'</span>,<span class="string">'qq'</span>,<span class="string">'weChat'</span>)&#125;)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">#设置fieldsets 控制管理“添加”和 “更改” 页面的布局.</span></span><br><span class="line"><span class="comment">#fieldsets 是一个以二元元组为元素的列表, 每一个二元元组代表一个在管理表单二元元组的格式是 (name, field_options), 其中 name 是一个字符串相当于 fieldset的标题， field_options 是一个关于 fieldset的字典信息,一个字段列表包含在里面。</span></span><br></pre></td></tr></table></figure><p>当网页遇到错误时，往往我们会返回404，这时候我们在网页中也可以设置一下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#music的urls.py</span></span><br><span class="line"><span class="comment">#设置404、500错误状态码</span></span><br><span class="line"><span class="keyword">from</span> index <span class="keyword">import</span> views</span><br><span class="line">handler404 = views.page_not_found</span><br><span class="line">handler500 = views.page_not_found</span><br><span class="line"></span><br><span class="line"><span class="comment">#index的views.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">page_not_found</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">'error404.html'</span>, status = <span class="number">404</span>)</span><br></pre></td></tr></table></figure><p>到这块基本网站的建立就完成了，这时候可以在后台进行对用户设置权限，可以更换音乐和照片素材，也可以进行新的数据库数据添加，但是要考虑到数据改变是否影响到html的设置。这个由个人随机操作。</p><p>最后重头戏就是项目上线部署了，一般采用django+nginx+uWSGI这样。我利用虚拟机进行了多次部署….期间废掉了好几个VM…目前还没成功，等我成功之后将继续写博客分享经验。</p><p>根据书上的内容进行了操作对django框架有了一个简单的认识，我还是打算在此立个flag，我也会继续学习，建立一个属于自己的电影网站！</p><p>加油吧！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;接下来就是后台管理了。&lt;/p&gt;
&lt;p&gt;在这本书这个项目之前，我最初接触python看的是《python基础教程—从实践到入门》，这本后面讲解了django，而且这里面讲解是从admin开始。如果有兴趣了解的可以看看书或者从网上寻找资料，但是django版本不是很高，看起来可
      
    
    </summary>
    
    
      <category term="python, django" scheme="https://skrskr66.github.io/tags/python-django/"/>
    
  </entry>
  
</feed>
