<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>程序程</title>
  
  <subtitle>为了梦想的skr</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://skrskr66.github.io/"/>
  <updated>2019-03-06T15:16:40.717Z</updated>
  <id>https://skrskr66.github.io/</id>
  
  <author>
    <name>Lyc</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Django建立一个音乐网站(一)</title>
    <link href="https://skrskr66.github.io/2019/03/06/Django%E5%BB%BA%E7%AB%8B%E4%B8%80%E4%B8%AA%E9%9F%B3%E4%B9%90%E7%BD%91%E7%AB%99-%E4%B8%80/"/>
    <id>https://skrskr66.github.io/2019/03/06/Django建立一个音乐网站-一/</id>
    <published>2019-03-06T14:45:58.000Z</published>
    <updated>2019-03-06T15:16:40.717Z</updated>
    
    <content type="html"><![CDATA[<p>Django是python学习的一个分支。最近跟着书上在学习。关于书上的项目我觉得拿来练手非常合适。而且涉及了数据库，html相关知识，对程序员的学习关联性我觉得还是有很大的提升的。</p><h4 id="Django的安装"><a href="#Django的安装" class="headerlink" title="Django的安装"></a>Django的安装</h4><p>因为Django也到了2.0的时代，而且2.0之前的版本与现在有了一些很大变化，所以根据书上进行，使用2.0进行的学习。</p><p>python的环境不再多说，应该都是准备好了。</p><p>但是django与python的版本互搭问题这个请网上自己寻找。django-2.0还是推荐python3.5之上版本</p><h5 id="利用pip安装"><a href="#利用pip安装" class="headerlink" title="利用pip安装"></a>利用pip安装</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install Django</span><br></pre></td></tr></table></figure><p>这个是最简单的方式，但是如果pip版本不高，可能下的django版本也不高。还有另一个方法</p><h5 id="下载源码安装"><a href="#下载源码安装" class="headerlink" title="下载源码安装"></a>下载源码安装</h5><p><a href="https://www.djangoproject.com/download/" target="_blank" rel="noopener">https://www.djangoproject.com/download/</a> </p><p>如果是源码包, 比如 django-1.11.8.tar.gz </p><p>直接用解压软件解压，然后到命令行（XP/Win7点击<strong>开始</strong>，在下面的那个输入框中输入 cmd, Win8在开始那里点右键，选择命令行)</p><p>比如在<code>D:\django-1.11.8\</code>这个文件夹下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd D:</span><br><span class="line">cd django<span class="number">-1.11</span><span class="number">.8</span></span><br><span class="line">python setup.py install</span><br></pre></td></tr></table></figure><p>之后检查是否安装成功,从终端进入python环境.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> django</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>django.VERSION</span><br><span class="line">(<span class="number">1</span>, <span class="number">11</span>, <span class="number">8</span>, <span class="string">'final'</span>, <span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>django.get_version()</span><br><span class="line"><span class="string">'1.11.8'</span></span><br></pre></td></tr></table></figure><h4 id="Django项目的创建"><a href="#Django项目的创建" class="headerlink" title="Django项目的创建"></a>Django项目的创建</h4><p>当基本安装完成后，开始项目的创建。这时候使用Pycharm来进行项目的创建。</p><p>选择Pycharm的理由是IDE能更好的帮助我们，工具好，我们才能更好的去理解其他的知识。</p><p>在Pycharm直接新建工程。</p><p><strong>注意！注意！注意！</strong></p><p>此时不要建立成了python工程，要选择django工程。(如果你没有，说明你下载的可能是社区版，请寻找激活码激活的版本)</p><p><img src="/2019/03/06/Django建立一个音乐网站-一/django1.png" alt="django1"></p><p>如上图所示，建立完成后，开始进行项目的初始配置</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Django是python学习的一个分支。最近跟着书上在学习。关于书上的项目我觉得拿来练手非常合适。而且涉及了数据库，html相关知识，对程序员的学习关联性我觉得还是有很大的提升的。&lt;/p&gt;
&lt;h4 id=&quot;Django的安装&quot;&gt;&lt;a href=&quot;#Django的安装&quot; c
      
    
    </summary>
    
    
      <category term="python, django" scheme="https://skrskr66.github.io/tags/python-django/"/>
    
  </entry>
  
  <entry>
    <title>利用结构体实现一个通讯录</title>
    <link href="https://skrskr66.github.io/2019/02/22/%E2%80%9C%E5%88%A9%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%80%9A%E8%AE%AF%E5%BD%95/"/>
    <id>https://skrskr66.github.io/2019/02/22/“利用结构体实现一个通讯录/</id>
    <published>2019-02-22T03:16:12.000Z</published>
    <updated>2019-03-01T03:33:13.814Z</updated>
    
    <content type="html"><![CDATA[<p>实现一个通讯录；  通讯录可以用来存储1000个人的信息，每个人的信息包括：  姓名、性别、年龄、电话、住址   </p><p>提供方法1.添加联系人信息  2.删除指定联系人信息  3.查找指定联系人信息  4.修改指定联系人信息  5.显示所有联系人信息  6.清空所有联系人  7.以名字排序所有联系人  8. 保存联系人到文件  9. 加载联系人   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PERSON_INFO_MAX_SIZE 1024</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PersonInfo</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">char</span> phone[<span class="number">1024</span>];</span><br><span class="line">&#125;PersonInfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AddressBook</span>&#123;</span><span class="comment">//结构体数组</span></span><br><span class="line">    PersonInfo infos[PERSON_INFO_MAX_SIZE];</span><br><span class="line">    <span class="keyword">int</span> size;<span class="comment">//描述数组中前多少个元素是被使用的，有效元素区间[0,size)</span></span><br><span class="line">&#125;AddressBook;</span><br><span class="line"><span class="comment">//我们将生活中的常识抽象成计算机中的语言</span></span><br><span class="line"></span><br><span class="line">AddressBook g_address_book;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(AddressBook* addr_book)</span></span>&#123;</span><br><span class="line">    assert(addr_book != <span class="literal">NULL</span>);</span><br><span class="line">    addr_book-&gt; size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddPersonInfo</span><span class="params">(AddressBook* addr_book)</span></span>&#123;</span><br><span class="line">    assert(addr_book != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"插入一个联系人！\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(addr_book-&gt;size &gt;= PERSON_INFO_MAX_SIZE)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"当前通讯已满,插入失败!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//每次都把新的联系人放到有效数组的最后一个元素上</span></span><br><span class="line">    PersonInfo *p = &amp;addr_book-&gt;infos[addr_book-&gt;size];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入新增的联系人姓名:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,p-&gt;name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入新增的联系人的电话:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,p-&gt;phone);</span><br><span class="line">    <span class="comment">//新增完成后，需要更新size</span></span><br><span class="line">    ++addr_book-&gt;size;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"插入联系人成功！\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DelPersonInfo</span><span class="params">(AddressBook* addr_book)</span></span>&#123;</span><br><span class="line">    assert(addr_book != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"删除联系人！\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据用户输入的下标来删除联系人</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入要删除的联系人符号："</span>);</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;id);</span><br><span class="line">    <span class="keyword">if</span>(id &lt; <span class="number">0</span> || id &gt;= addr_book-&gt;size)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"您输入的序号有误!删除失败!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PersonInfo *p = &amp;addr_book-&gt;infos[id];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"您要删除的联系人为[%d] %s,确认请输入Y:"</span>,id,p-&gt;name);</span><br><span class="line">    <span class="keyword">char</span> cmd[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,cmd);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(cmd, <span class="string">"Y"</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"删除操作已经取消!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PersonInfo* from = &amp;aaddr_book-&gt;infos[addr_book-&gt;size - <span class="number">1</span>];</span><br><span class="line">    PersonInfo* to = p;</span><br><span class="line">    *to = *from;</span><br><span class="line">    --addr_book-&gt;size;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"删除成功!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModifyPersonInfo</span><span class="params">(AddressBook* addr_book)</span></span>&#123;</span><br><span class="line">    assert(addr_book != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"修改联系人\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入需要修改的联系人序号:"</span>);</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;id);</span><br><span class="line">    <span class="keyword">if</span>(id &lt; <span class="number">0</span> || id &gt;= addr_book-&gt;size)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"您输入的序号错误"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PersonInfo *p = &amp;addr_book-&gt;infos[id];</span><br><span class="line">    <span class="keyword">char</span> input[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入要修改的姓名:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,input);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(input,<span class="string">"#"</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(p-&gt;name,input);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入要修改的电话:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,input);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(input,<span class="string">"#"</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(p-&gt;phone,input);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"修改成功!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindPersonInfo</span><span class="params">(AddressBook* addr_book)</span></span>&#123;</span><br><span class="line">    assert(addr_book != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"开始进行查找！\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入要查找的姓名："</span>);</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,name);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; addr_book-&gt;size;++i)&#123;</span><br><span class="line">        PersonInfo* p = &amp;addr_book-&gt;infos[i];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(name,p-&gt;name) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[%d] %s\t%s\n"</span>,i,p-&gt;name,p-&gt;phone);</span><br><span class="line">        ++count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"查找完毕！共找到 %d 条记录！\n"</span>,count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SortPersonInfo</span><span class="params">(AddressBook* addr_book)</span></span>&#123;<span class="comment">//只适用于英文名字的排序</span></span><br><span class="line">    assert(addr_book != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; addr_book-&gt;size;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; addr_book-&gt;size - <span class="number">1</span> - i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strcmp</span>(addr_book-&gt;infos[j].name,addr_book-&gt;infos[j + <span class="number">1</span>].name) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                PersonInfo tmp;</span><br><span class="line">                tmp = addr_book-&gt;infos[j];</span><br><span class="line">                addr_book-&gt;infos[j] = addr_book-&gt;infos[j + <span class="number">1</span>];</span><br><span class="line">                addr_book-&gt;infos[j + <span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAllPersonInfo</span><span class="params">(AddressBook* addr_book)</span></span>&#123;</span><br><span class="line">    assert(addr_book != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; addr_book-&gt;size;++i)&#123;</span><br><span class="line">        PersonInfo* p = &amp;addr_book-&gt;infos[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[%d] %s\t%s\n"</span>,i ,p-&gt;name,p-phone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearPersonInfo</span><span class="params">(AddressBook* addr_book)</span></span>&#123;</span><br><span class="line">    assert(addr_book != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"清空所有记录！\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"您确认要清空所有记录吗？输入 Y 表示确定"</span>);</span><br><span class="line">    <span class="keyword">char</span> cmd[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,&amp;cmd);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(cmd,<span class="string">"Y"</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"清空操作取消"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    addr_book-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"清空操作成功！\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Menu</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"================="</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"1.新增\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"2.删除\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"3.修改\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"4.查找\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"5.排序\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"6.显示全部\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"7.清空全部\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"0.退出\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"================="</span>);</span><br><span class="line">    <span class="keyword">int</span> choice = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;choice);</span><br><span class="line">    <span class="keyword">return</span> choice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.对通讯录进行初始化</span></span><br><span class="line">    Init(&amp;g_address_book);</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*<span class="keyword">pfunc_t</span>)</span><span class="params">(AddressBook*)</span></span>;</span><br><span class="line">    <span class="keyword">pfunc_t</span> table[] = &#123;</span><br><span class="line">        AddPersonInfo,</span><br><span class="line">        DelPersonInfo,</span><br><span class="line">        ModifyPersonInfo,</span><br><span class="line">        FindPersonInfo,</span><br><span class="line">        SortPersonInfo,</span><br><span class="line">        PrintAllPersonInfo,</span><br><span class="line">        ClearPersonInfo</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> choice = Menu();</span><br><span class="line">        <span class="keyword">if</span>(choice &lt; <span class="number">0</span> || choice &gt; (<span class="keyword">int</span>)(<span class="keyword">sizeof</span>(table) / <span class="keyword">sizeof</span>(table[<span class="number">0</span>])))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"您的输入有误!\n"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(choice == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"goodbye!\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        table[choice - <span class="number">1</span>](&amp;g_address_book);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个通讯录只是一个静态的，此时还可以进行一些改版，将其变为动态结合的，这时候可利用到malloc函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PERSON_INFO_MAX_SIZE 1024</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PersonInfo</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">char</span> phone[<span class="number">1024</span>];</span><br><span class="line">&#125;PersonInfo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AddressBook</span>&#123;</span><span class="comment">//结构体数组</span></span><br><span class="line">    PersonInfo* infos;</span><br><span class="line">    <span class="keyword">int</span> capacity;<span class="comment">//容量，infos指针指向的动态数组的长度（元素个数）</span></span><br><span class="line">    <span class="keyword">int</span> size;<span class="comment">//描述数组中前多少个元素是被使用的，有效元素区间[0,size)</span></span><br><span class="line">&#125;AddressBook;</span><br><span class="line"><span class="comment">//我们将生活中的常识抽象成计算机中的语言</span></span><br><span class="line"></span><br><span class="line">AddressBook g_address_book;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(AddressBook* addr_book)</span></span>&#123;</span><br><span class="line">    assert(addr_book != <span class="literal">NULL</span>);</span><br><span class="line">    addr_book-&gt; size = <span class="number">0</span>;</span><br><span class="line">    addr_book-&gt;capacity = <span class="number">10</span>;</span><br><span class="line">    addr_book-&gt;infos = (PersonInfo*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(PersonInfo) * addr_book-&gt;capacity);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Realloc</span><span class="params">(AddressBook* addr_book)</span></span>&#123;</span><br><span class="line">    assert(addr_book != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//此处每次扩容多少，这样的策略完全是我们自定制的</span></span><br><span class="line">    <span class="comment">//1.扩大capacity的取值</span></span><br><span class="line">    addr_book-&gt;capacity *= <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//2.申请一个更大的内存</span></span><br><span class="line">    PersonInfo* old_infos = addr_book-&gt;infos;    </span><br><span class="line">    addr_book-&gt;infos = (PersonInfo*)<span class="built_in">malloc</span>(addr_book-&gt;capacity * <span class="keyword">sizeof</span>(PersonInfo));</span><br><span class="line">    <span class="comment">//3.把原有的内存中的数据复制过来</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; addr_book-&gt;size;++i)&#123;</span><br><span class="line">        addr_book-&gt;infos[i] = old_infos[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.释放原有的内存</span></span><br><span class="line">    <span class="built_in">free</span>(old_infos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddPersonInfo</span><span class="params">(AddressBook* addr_book)</span></span>&#123;</span><br><span class="line">    assert(addr_book != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"插入一个联系人！\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(addr_book-&gt;size &gt;= addr_book-&gt;capacity)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"当前通讯已满,插入失败!进行扩容！\n"</span>);</span><br><span class="line">        Realloc(addr_book);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//每次都把新的联系人放到有效数组的最后一个元素上</span></span><br><span class="line">    PersonInfo *p = &amp;addr_book-&gt;infos[addr_book-&gt;size];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入新增的联系人姓名:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,p-&gt;name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入新增的联系人的电话:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,p-&gt;phone);</span><br><span class="line">    <span class="comment">//新增完成后，需要更新size</span></span><br><span class="line">    ++addr_book-&gt;size;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"插入联系人成功！\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DelPersonInfo</span><span class="params">(AddressBook* addr_book)</span></span>&#123;</span><br><span class="line">    assert(addr_book != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"删除联系人！\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//根据用户输入的下标来删除联系人</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入要删除的联系人符号："</span>);</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;id);</span><br><span class="line">    <span class="keyword">if</span>(id &lt; <span class="number">0</span> || id &gt;= addr_book-&gt;size)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"您输入的序号有误!删除失败!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PersonInfo *p = &amp;addr_book-&gt;infos[id];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"您要删除的联系人为[%d] %s,确认请输入Y:"</span>,id,p-&gt;name);</span><br><span class="line">    <span class="keyword">char</span> cmd[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,cmd);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(cmd, <span class="string">"Y"</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"删除操作已经取消!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PersonInfo* from = &amp;aaddr_book-&gt;infos[addr_book-&gt;size - <span class="number">1</span>];</span><br><span class="line">    PersonInfo* to = p;</span><br><span class="line">    *to = *from;</span><br><span class="line">    --addr_book-&gt;size;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"删除成功!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ModifyPersonInfo</span><span class="params">(AddressBook* addr_book)</span></span>&#123;</span><br><span class="line">    assert(addr_book != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"修改联系人\n"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入需要修改的联系人序号:"</span>);</span><br><span class="line">    <span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;id);</span><br><span class="line">    <span class="keyword">if</span>(id &lt; <span class="number">0</span> || id &gt;= addr_book-&gt;size)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"您输入的序号错误"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PersonInfo *p = &amp;addr_book-&gt;infos[id];</span><br><span class="line">    <span class="keyword">char</span> input[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入要修改的姓名:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,input);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(input,<span class="string">"#"</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(p-&gt;name,input);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入要修改的电话:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,input);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(input,<span class="string">"#"</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">strcpy</span>(p-&gt;phone,input);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"修改成功!\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindPersonInfo</span><span class="params">(AddressBook* addr_book)</span></span>&#123;</span><br><span class="line">    assert(addr_book != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"开始进行查找！\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入要查找的姓名："</span>);</span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,name);</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; addr_book-&gt;size;++i)&#123;</span><br><span class="line">        PersonInfo* p = &amp;addr_book-&gt;infos[i];</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(name,p-&gt;name) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"[%d] %s\t%s\n"</span>,i,p-&gt;name,p-&gt;phone);</span><br><span class="line">        ++count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"查找完毕！共找到 %d 条记录！\n"</span>,count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SortPersonInfo</span><span class="params">(AddressBook* addr_book)</span></span>&#123;<span class="comment">//只适用于英文名字的排序</span></span><br><span class="line">    assert(addr_book != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; addr_book-&gt;size;++i)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; addr_book-&gt;size - <span class="number">1</span> - i;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">strcmp</span>(addr_book-&gt;infos[j].name,addr_book-&gt;infos[j + <span class="number">1</span>].name) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                PersonInfo tmp;</span><br><span class="line">                tmp = addr_book-&gt;infos[j];</span><br><span class="line">                addr_book-&gt;infos[j] = addr_book-&gt;infos[j + <span class="number">1</span>];</span><br><span class="line">                addr_book-&gt;infos[j + <span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAllPersonInfo</span><span class="params">(AddressBook* addr_book)</span></span>&#123;</span><br><span class="line">    assert(addr_book != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; addr_book-&gt;size;++i)&#123;</span><br><span class="line">        PersonInfo* p = &amp;addr_book-&gt;infos[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"[%d] %s\t%s\n"</span>,i ,p-&gt;name,p-phone);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ClearPersonInfo</span><span class="params">(AddressBook* addr_book)</span></span>&#123;</span><br><span class="line">    assert(addr_book != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"清空所有记录！\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"您确认要清空所有记录吗？输入 Y 表示确定"</span>);</span><br><span class="line">    <span class="keyword">char</span> cmd[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%s"</span>,&amp;cmd);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(cmd,<span class="string">"Y"</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"清空操作取消"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    addr_book-&gt;size = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"清空操作成功！\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Menu</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"================="</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"1.新增\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"2.删除\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"3.修改\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"4.查找\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"5.排序\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"6.显示全部\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"7.清空全部\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"0.退出\n"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"================="</span>);</span><br><span class="line">    <span class="keyword">int</span> choice = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;choice);</span><br><span class="line">    <span class="keyword">return</span> choice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//1.对通讯录进行初始化</span></span><br><span class="line">    Init(&amp;g_address_book);</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*<span class="keyword">pfunc_t</span>)</span><span class="params">(AddressBook*)</span></span>;</span><br><span class="line">    <span class="keyword">pfunc_t</span> table[] = &#123;</span><br><span class="line">        AddPersonInfo,</span><br><span class="line">        DelPersonInfo,</span><br><span class="line">        ModifyPersonInfo,</span><br><span class="line">        FindPersonInfo,</span><br><span class="line">        SortPersonInfo,</span><br><span class="line">        PrintAllPersonInfo,</span><br><span class="line">        ClearPersonInfo</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> choice = Menu();</span><br><span class="line">        <span class="keyword">if</span>(choice &lt; <span class="number">0</span> || choice &gt; (<span class="keyword">int</span>)(<span class="keyword">sizeof</span>(table) / <span class="keyword">sizeof</span>(table[<span class="number">0</span>])))&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"您的输入有误!\n"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(choice == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"goodbye!\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        table[choice - <span class="number">1</span>](&amp;g_address_book);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在扩容过程中，我们经过分析之后，当内存不够时，考虑到只有添加才需要开辟新的空间。</p><p>所以在第一个静态的版本之上，又加入了动态开辟，这样当添加不够时，我们的程序会自动开辟新的空间，为了当前能够使用。</p><p>在代码中有注释，关于开辟的关键。</p><p>内存中原先保存的位置我们也要管理，否则会造成内存泄漏。必须要保证这有一个合适的内存分配。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;实现一个通讯录；  通讯录可以用来存储1000个人的信息，每个人的信息包括：  姓名、性别、年龄、电话、住址   &lt;/p&gt;
&lt;p&gt;提供方法1.添加联系人信息  2.删除指定联系人信息  3.查找指定联系人信息  4.修改指定联系人信息  5.显示所有联系人信息  6.清空所
      
    
    </summary>
    
    
      <category term="进阶C" scheme="https://skrskr66.github.io/tags/%E8%BF%9B%E9%98%B6C/"/>
    
  </entry>
  
  <entry>
    <title>模拟实现strncpy,strncat,strncmp</title>
    <link href="https://skrskr66.github.io/2019/02/21/%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0strncpy-strncat-strncmp/"/>
    <id>https://skrskr66.github.io/2019/02/21/模拟实现strncpy-strncat-strncmp/</id>
    <published>2019-02-21T13:05:23.000Z</published>
    <updated>2019-02-21T13:13:26.421Z</updated>
    
    <content type="html"><![CDATA[<p>main()函数中的例子全部取于cplusplus网站</p><p>模拟实现strncat</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">Strncat</span><span class="params">(<span class="keyword">char</span>* dest,<span class="keyword">const</span> <span class="keyword">char</span>* src,<span class="keyword">size_t</span> num)</span></span>&#123;    </span><br><span class="line">  assert(dest != <span class="literal">NULL</span>);    </span><br><span class="line">  assert(src != <span class="literal">NULL</span>);    </span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>;    </span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; num; i++);    </span><br><span class="line">  <span class="built_in">strncpy</span>(&amp;dest[i],src,num);    </span><br><span class="line">  <span class="keyword">return</span> dest;    </span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </span><br><span class="line">  <span class="keyword">char</span> str1[<span class="number">20</span>];    </span><br><span class="line">  <span class="keyword">char</span> str2[<span class="number">20</span>];    </span><br><span class="line">  <span class="built_in">strcpy</span> (str1,<span class="string">"To be "</span>);    </span><br><span class="line">  <span class="built_in">strcpy</span> (str2,<span class="string">"or not to be"</span>);    </span><br><span class="line">  Strncat (str1, str2, <span class="number">6</span>);    </span><br><span class="line">  <span class="built_in">puts</span> (str1);    </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟实现strncmp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Strncmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *dest, <span class="keyword">const</span> <span class="keyword">char</span>*src, <span class="keyword">int</span> count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">assert(dest != <span class="literal">NULL</span>);</span><br><span class="line">assert(src != <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">while</span> (count &amp;&amp; *dest != <span class="string">'\0'</span> &amp;&amp; *src != <span class="string">'\0'</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (*dest &gt; *src)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (*dest &lt; *src)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">dest++;</span><br><span class="line">src++;</span><br><span class="line">count--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> str[][<span class="number">5</span>] = &#123; <span class="string">"R2D2"</span>, <span class="string">"C3PO"</span>, <span class="string">"R2A6"</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Looking for R2 astromech droids...\n"</span>);</span><br><span class="line"><span class="keyword">for</span> (n = <span class="number">0</span>; n&lt;<span class="number">3</span>; n++)</span><br><span class="line"><span class="keyword">if</span> (Strncmp(str[n], <span class="string">"R2xx"</span>, <span class="number">2</span>) == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"found %s\n"</span>, str[n]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>strncpy模拟实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">Strncpy</span><span class="params">(<span class="keyword">char</span>* dest, <span class="keyword">const</span> <span class="keyword">char</span>* src, <span class="keyword">size_t</span> num)</span></span>&#123;    </span><br><span class="line">  assert(dest != <span class="literal">NULL</span>);    </span><br><span class="line">  assert(src != <span class="literal">NULL</span>);    </span><br><span class="line">  <span class="keyword">int64_t</span> i = <span class="number">0</span>;    </span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>;(<span class="keyword">unsigned</span>)i &lt; num;i++)&#123;    </span><br><span class="line">    dest[i] = src[i];    </span><br><span class="line">  &#125;    </span><br><span class="line">  dest[num] = <span class="string">'\0'</span>;    </span><br><span class="line">  <span class="keyword">return</span> dest;    </span><br><span class="line">&#125;    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> str1[]= <span class="string">"To be or not to be"</span>;</span><br><span class="line">  <span class="keyword">char</span> str2[<span class="number">40</span>];</span><br><span class="line">  <span class="keyword">char</span> str3[<span class="number">40</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* copy to sized buffer (overflow safe): */</span></span><br><span class="line">  Strncpy ( str2, str1, <span class="keyword">sizeof</span>(str2)  );</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* partial copy (only 5 chars): */</span></span><br><span class="line">  Strncpy ( str3, str2, <span class="number">7</span>  );</span><br><span class="line">  str3[<span class="number">7</span>] = <span class="string">'\0'</span>;   <span class="comment">/* null character manually added */</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span> (str1);</span><br><span class="line">  <span class="built_in">puts</span> (str2);</span><br><span class="line">  <span class="built_in">puts</span> (str3);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;main()函数中的例子全部取于cplusplus网站&lt;/p&gt;
&lt;p&gt;模拟实现strncat&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/s
      
    
    </summary>
    
    
      <category term="进阶C" scheme="https://skrskr66.github.io/tags/%E8%BF%9B%E9%98%B6C/"/>
    
  </entry>
  
  <entry>
    <title>C语言标准库函数的理解与重写</title>
    <link href="https://skrskr66.github.io/2019/02/16/C%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86%E5%BA%93%E5%87%BD%E6%95%B0%E7%9A%84%E7%90%86%E8%A7%A3%E4%B8%8E%E9%87%8D%E5%86%99/"/>
    <id>https://skrskr66.github.io/2019/02/16/C语言标准库函数的理解与重写/</id>
    <published>2019-02-16T04:33:44.000Z</published>
    <updated>2019-02-17T10:36:56.129Z</updated>
    
    <content type="html"><![CDATA[<p>1.实现strcpy  2.实现strcat  3.实现strstr  4.实现strchr  5.实现strcmp  6.实现memcpy  7.实现memmove </p><p>为了更好的去理解这几个函数的用法，自己去实现一下功能，才能更好的学习</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="keyword">size_t</span> Strlen(<span class="keyword">const</span> <span class="keyword">char</span>* str)&#123;<span class="comment">//无符号整型</span></span><br><span class="line">    assert(str != <span class="literal">NULL</span>);<span class="comment">//首先要进行合法性判断，如果字符串本身都有问题，那么就没必要检验了</span></span><br><span class="line">    <span class="keyword">size_t</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(str[count] != <span class="string">'\0'</span>)&#123;</span><br><span class="line">        ++count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> conunt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">Strcpy</span><span class="params">(<span class="keyword">char</span>* dest,<span class="keyword">const</span> <span class="keyword">char</span>* src)</span></span>&#123;</span><br><span class="line">    assert(dest != <span class="literal">NULL</span>);</span><br><span class="line">    assert(src != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">int64_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;src[i] != <span class="string">'\0'</span>;i++)&#123;</span><br><span class="line">        dest[i] = src[i];</span><br><span class="line">    &#125;</span><br><span class="line">    dest[i] = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">Strcat</span><span class="params">(<span class="keyword">char</span>* dest,<span class="keyword">const</span> <span class="keyword">char</span>* src)</span></span>&#123;</span><br><span class="line">    assert(dest != <span class="literal">NULL</span>);</span><br><span class="line">    assert(src != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; dest[i] != <span class="string">'\0'</span>;i++);</span><br><span class="line">    Strcpy(&amp;dest[i],src);</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">Strstr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str1,<span class="keyword">const</span> <span class="keyword">char</span>* str2)</span></span>&#123;</span><br><span class="line">    assert(str1 != <span class="literal">NULL</span>);</span><br><span class="line">    assert(str2 != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span>(*str1 == <span class="string">'\0'</span> || *str2 == <span class="string">'\0'</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* black_ptr = str1;</span><br><span class="line">    <span class="keyword">while</span>(*black_ptr != <span class="string">'\0'</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* sub_ptr = str2;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* red_ptr = black_ptr;</span><br><span class="line">        <span class="keyword">while</span>(*red_ptr != <span class="string">'\0'</span> &amp;&amp; *sub_ptr != <span class="string">'\0'</span> &amp;&amp;(*red_ptr == *sub_ptr))&#123;</span><br><span class="line">            ++red_ptr;</span><br><span class="line">            ++sub_ptr;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(*sub_ptr == <span class="string">'\0'</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> black_ptr;</span><br><span class="line">        &#125;</span><br><span class="line">        ++black_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">Strchr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str,<span class="keyword">int</span> chr)</span></span>&#123;</span><br><span class="line">    assert(str != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span>(*str)&#123;<span class="comment">//*str表示字符数组中第一个字符</span></span><br><span class="line">        <span class="keyword">if</span>(*str == (<span class="keyword">char</span>)chr)&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">char</span>*)str;<span class="comment">//此时返回的是第一个找到所需字符的地址</span></span><br><span class="line">        &#125;</span><br><span class="line">        ++str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str1, <span class="keyword">const</span> <span class="keyword">char</span>* str2)</span></span>&#123;</span><br><span class="line">    assert(str1 != <span class="literal">NULL</span>);</span><br><span class="line">    assert(str2 != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">while</span>(*str1 != <span class="string">'\0'</span> &amp;&amp; *str2 != <span class="string">'\0'</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(*str1 &gt; *str2)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(*str1 &lt; *str2)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            ++str1;</span><br><span class="line">            ++str2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//此时如果str1或者str2有一个提前遇到了'\0',那么跳出了while循环，接着判断</span></span><br><span class="line">    <span class="keyword">if</span>(*str1 &gt; *str2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(*str1 &lt; *str2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Memcpy</span><span class="params">(<span class="keyword">void</span>* dest,<span class="keyword">void</span>* src,<span class="keyword">size_t</span> num)</span></span>&#123;</span><br><span class="line">    assert(dest != <span class="literal">NULL</span>);</span><br><span class="line">    assert(src != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">char</span>* pdest = (<span class="keyword">char</span>*)dest;<span class="comment">//void*不能解引用，类型改变，只在运算中起作用，是临时的，本身的类型不改变，所以最后还是返回dest</span></span><br><span class="line">    <span class="keyword">char</span>* psrc = (<span class="keyword">char</span>*)src;</span><br><span class="line">    <span class="keyword">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; num;++i)&#123;</span><br><span class="line">        pdest[i] = psrc[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Memmove</span><span class="params">(<span class="keyword">void</span>* dest,<span class="keyword">const</span> <span class="keyword">void</span>* src,<span class="keyword">size_t</span> num)</span></span>&#123;</span><br><span class="line">    assert(dest != <span class="literal">NULL</span>);</span><br><span class="line">    assert(src != <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">char</span>* pdest = (<span class="keyword">char</span>*)dest;</span><br><span class="line">    <span class="keyword">char</span>* psrc = (<span class="keyword">char</span>*)src;</span><br><span class="line">    <span class="keyword">if</span>(pdest &gt;= psrc &amp;&amp; pdest &lt; psrc + num)&#123;<span class="comment">//这是标准库认为的缓冲区重合</span></span><br><span class="line">        <span class="comment">//起始dest指针如果在src缓冲区范围以内，拷贝为缓冲区重合</span></span><br><span class="line">        <span class="comment">//以外则不为缓冲区拷贝</span></span><br><span class="line">        <span class="keyword">int64_t</span> i = <span class="number">0</span>;<span class="comment">//从最后一个元素的下标开始，倒着拷贝</span></span><br><span class="line">        <span class="keyword">for</span>(i = num - i;i &gt;= <span class="number">0</span>;i++)&#123;</span><br><span class="line">            pdest[i] = psrc[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//完全按照原来方法拷贝</span></span><br><span class="line">        Memcpy(dest,src,num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.实现strcpy  2.实现strcat  3.实现strstr  4.实现strchr  5.实现strcmp  6.实现memcpy  7.实现memmove &lt;/p&gt;
&lt;p&gt;为了更好的去理解这几个函数的用法，自己去实现一下功能，才能更好的学习&lt;/p&gt;
&lt;figur
      
    
    </summary>
    
    
      <category term="进阶C" scheme="https://skrskr66.github.io/tags/%E8%BF%9B%E9%98%B6C/"/>
    
  </entry>
  
  <entry>
    <title>初阶C-0215</title>
    <link href="https://skrskr66.github.io/2019/02/15/%E5%88%9D%E9%98%B6C-0215/"/>
    <id>https://skrskr66.github.io/2019/02/15/初阶C-0215/</id>
    <published>2019-02-15T13:31:49.000Z</published>
    <updated>2019-02-16T04:24:29.986Z</updated>
    
    <content type="html"><![CDATA[<p>1.实现一个函数，可以左旋字符串中的k个字符。  </p><p>ABCD左旋一个字符得到BCDA  ABCD左旋两个字符得到CDAB  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">left_rotate</span><span class="params">(<span class="keyword">char</span>* str,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(k--)&#123;</span><br><span class="line">    <span class="keyword">char</span> tmp = *str;</span><br><span class="line">    <span class="keyword">char</span>* cur = str;</span><br><span class="line">    <span class="keyword">while</span>(*(cur + <span class="number">1</span>))&#123;<span class="comment">//判断真假是否到了‘\0’</span></span><br><span class="line">    *cur = *(cur + <span class="number">1</span>);</span><br><span class="line">    cur++;</span><br><span class="line">    &#125;</span><br><span class="line">        *cur = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有一个问题需要我们去注意</p><p>当我们左旋的时候，将B  C  D移动向前之后，之前字符串的<code>\0</code>也被提前了。</p><p>但是字符串数组本身最后有一个<code>\0</code>,所以我们要在字符串的前一个位置，把旋转的字符与前面的<code>\0</code>交换</p><p>那么这个时候在while循环里，需要将我们的<code>cur</code>向后移动一个位置，也就是字符串之前的最后一个位置。</p><p>此时的判断条件为<code>cur + 1</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">"ABCD"</span>;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,str)</span><br><span class="line">    left_rotate(str, k);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>,str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于右旋，右旋就是左旋的相反，即<code>strlen(str)-k</code>次，直接在右旋中，调用左旋设置k的次数即可</p><p>2.判断一个字符串是否为另外一个字符串旋转之后的字符串。  </p><p>例如：给定s1 =AABCD和s2 = BCDAA，返回1，给定s1=abcd和s2=ACBD，返回0.   </p><p>AABCD左旋一个字符得到ABCDA  </p><p>AABCD左旋两个字符得到BCDAA   </p><p>AABCD右旋一个字符得到DAABC  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">is_rotate</span><span class="params">(<span class="keyword">char</span>* dest, <span class="keyword">char</span>* src)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strlen</span>(dest) != <span class="built_in">strlen</span>(src))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in">strlen</span>(src);</span><br><span class="line">    <span class="keyword">while</span>(len--)&#123;</span><br><span class="line">        right_rotate(src, <span class="number">1</span>);<span class="comment">//一次一个判断</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(dest, src) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.一个数组中只有两个数字是出现一次，  其他所有数字都出现了两次。  </p><p>找出这两个数字，编程实现。  </p><p>首先要清楚连续异或的结果，因为单独出现的数字会在最后呈现出来</p><p>这样我们就可以找到异或结果中，二进制‘1’在什么位置不同</p><p>根据‘1’的位置把所有数分成两组，每一组当中必有一个数单独出现一次</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[]=&#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> sz = <span class="keyword">sizeof</span>(a)/<span class="keyword">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; sz;i++)&#123;</span><br><span class="line">        ret ^= a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">32</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(((ret &gt;&gt; i) &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">        pos = i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; sz;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(((a[i] &gt;&gt; pos) &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">            x ^= a[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            y ^= a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d"</span>,x,y);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.喝汽水，1瓶汽水1元，2个空瓶可以换一瓶汽水，  给20元，可以多少汽水。  </p><p>编程实现。   </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> empty ;</span><br><span class="line">    <span class="keyword">int</span> total ;</span><br><span class="line">    <span class="keyword">int</span> money;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;money);</span><br><span class="line">    total = money;</span><br><span class="line">    empty = money;</span><br><span class="line">    <span class="keyword">while</span>(empty &gt; <span class="number">1</span>)&#123;</span><br><span class="line">       total +=  (empty / <span class="number">2</span>);</span><br><span class="line">        empty = (empty % <span class="number">2</span>) + (empty / <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.实现一个函数，可以左旋字符串中的k个字符。  &lt;/p&gt;
&lt;p&gt;ABCD左旋一个字符得到BCDA  ABCD左旋两个字符得到CDAB  &lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;
      
    
    </summary>
    
    
      <category term="C初阶" scheme="https://skrskr66.github.io/tags/C%E5%88%9D%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>八皇后问题(C+python)</title>
    <link href="https://skrskr66.github.io/2019/01/27/%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98-C-python/"/>
    <id>https://skrskr66.github.io/2019/01/27/八皇后问题-C-python/</id>
    <published>2019-01-27T05:01:59.000Z</published>
    <updated>2019-01-29T03:48:22.673Z</updated>
    
    <content type="html"><![CDATA[<p>最近继续自学python，看到了八皇后问题，觉得是个有点意思的问题。</p><p>八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。</p><p>首先得说一下什么是回溯算法，<strong>实际是一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。</strong>回溯法是一种优选搜索法，按优选条件向前搜索，以达到目标。</p><p>该问题是在8x8格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、后一列、或同一斜线上有多少种摆法。</p><h5 id="通过C语言解决"><a href="#通过C语言解决" class="headerlink" title="通过C语言解决"></a>通过C语言解决</h5><p>因为是在python递归、迭代和生成器时碰到的这些问题，看了好久，还是有点懵，所以先用C语言的思想去理解一下。</p><p>首先我们得明确我们的思想，在这个8x8的棋盘上，我们如何去部署我们的棋子，我们已y轴为我们定义的数组下标范围，让x轴为数组内表示的元素所在的格子位置。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> board[<span class="number">8</span>] = &#123;&#125;;</span><br><span class="line"><span class="keyword">int</span> board_size = <span class="keyword">sizeof</span>(board)/<span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure><p>接着需要去思考如何使用数学的语言来表述<strong>斜线上重叠的皇后</strong>。对于棋盘上任意的一点，都要在[0，7]这个范围内，那么这个关系就是目标格子(a,b)和当前所在格子(x,y)等价于&#124;a-x&#124;==&#124;b-y&#124;</p><p>所以首先进行一个判定</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> *board,<span class="keyword">int</span> row)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; row)&#123;</span><br><span class="line">        <span class="keyword">if</span>(board[i] == board[row] || row - i == board[row] - board[i] || row - i == board[i] - board[row])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们从第一行开始给每一行的皇后确定一个位置。每来到新的一行时，对本行的所有可能位置（皇后放在这个位置和前面所有已放置的皇后无冲突）分别进行递归地深入；若某一行可能放置地位置为0，那么说明这是一个四路，此时需要返回到上一层去重新选择。若此时八行都结束后，那么说明这是一个可行的方法。</p> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">eight_queen</span><span class="params">(<span class="keyword">int</span> *board,<span class="keyword">int</span> row)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(row == <span class="number">8</span>)&#123;</span><br><span class="line">        printf_board(board);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    board[row] = <span class="number">0</span>;<span class="comment">//每次当row行跳转到下一行时，需要重新初始化一下</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(check(board,row) &amp;&amp; eight_queen(board,row + <span class="number">1</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(++board[row] &gt;= <span class="number">8</span>)&#123;<span class="comment">//当上面的判断条件失败之后，将row行的值向后+1看是否满足了全部落完棋子的情况</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里需要解释一下这个递归，在第一个if语句中，进行了两个函数的判断。首先是check函数，当第一个棋子部署后，进行第二个部署并且此时还要提前检查是否在第一个棋子的周围。如果不符合，那么board[row]+1，在进行判断，看此时是否符合要求。如果这时已经符合要求了，那么eight_queen函数也返回1，那么此时第二个就可以部署，以此类推，第三个也按照如此去部署。</p><p>当数组board[row]知道每个确切的值之后，我们将其数组打印，并且，打印出一个大概的图像</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_board</span><span class="params">(<span class="keyword">int</span> *board)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> size = board_size;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; size; ++i)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d"</span>,board[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    i = <span class="number">0</span>;<span class="comment">//局部变量此时值不相同</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt; size)&#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; size; ++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j == board[i])&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%s"</span>,<span class="string">"x"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="built_in">printf</span>(<span class="string">"%s"</span>,<span class="string">"0"</span>);   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码比较不好理解的就是，在递归的过程中，何时board[row]被赋值，知道具体哪个位置可以被部署皇后。所以建议利用调试器去看！</p><h5 id="通过python解决"><a href="#通过python解决" class="headerlink" title="通过python解决"></a>通过python解决</h5><p>其实早都该写完这篇博客，有点懒了，也是有点小受挫，总觉得python简单。现在不会再轻敌了。</p><p>关于问题的本身跟用C语言来分析是大概一样的，那么就是应该怎么样利用去python去想这个问题</p><p>还是先定义一个判定的方法，当我们去放置皇后时，判定是否可以去落棋子,这里称为检测冲突</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conflict</span><span class="params">(state, nextX)</span>:</span><span class="comment">#这里的state将其定义为元组，它表示皇后落在每一行的第几个位置上</span></span><br><span class="line">    nextY = len(state)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(nextY):<span class="comment">#检查每一个已摆放的棋子和当前行摆放的棋子的位置是否冲突</span></span><br><span class="line">        <span class="keyword">if</span> abs(state[i] - nextX) <span class="keyword">in</span> (<span class="number">0</span>,nextY - i):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><p>主函数的思想则是利用python的生成器和递归的思想</p><p>将问题拆解，如果一个已经布置好了，那么接下来就是有限制的七皇后问题。那么每一次剩下的皇后没有放好，就遍历所有可能的位置，并放回那些不会引发冲突的位置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eight_queen</span><span class="params">(num=<span class="number">8</span>,state=<span class="params">()</span>)</span>:</span><span class="comment">#num为皇后数目，state为元组</span></span><br><span class="line">    <span class="keyword">for</span> pos <span class="keyword">in</span> range(num):<span class="comment">#pos此时可以看成当前所在的行数</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> conflict(state, pos):<span class="comment">#此时是冲突判断，not是与函数内的true和false相反</span></span><br><span class="line">            <span class="keyword">if</span> len(state) == num - <span class="number">1</span><span class="comment">#当没有冲突时，元组内记录的皇后数-1，这样就代表继续向下部署</span></span><br><span class="line">            <span class="keyword">yield</span>(pos,)<span class="comment">#yield函数存在，此时已经成为了一个生成器，每次从上次pos结束的位置进行判断</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">for</span> result <span class="keyword">in</span> queens(num,state + (pos,)):<span class="comment">#此时将已得到的数据存入元组</span></span><br><span class="line">                    <span class="keyword">yield</span>(pos,) + result</span><br></pre></td></tr></table></figure><p>当主函数没问题了，我们也会想知道总共有多少方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len(list(eight_queen(<span class="number">8</span>)))</span><br></pre></td></tr></table></figure><p>这样就可以知道有多少方法了。</p><p>最后，这个问题让我想了好久好久啊，感觉如果学习一门新的语言出现疑惑时，不妨利用C语言去思考一下，这样有助于更好去发现自己的盲点存在那里。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近继续自学python，看到了八皇后问题，觉得是个有点意思的问题。&lt;/p&gt;
&lt;p&gt;八皇后问题，是一个古老而著名的问题，是回溯算法的典型案例。&lt;/p&gt;
&lt;p&gt;首先得说一下什么是回溯算法，&lt;strong&gt;实际是一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当
      
    
    </summary>
    
    
      <category term="算法分析" scheme="https://skrskr66.github.io/tags/%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>C进阶-C语言文件操作</title>
    <link href="https://skrskr66.github.io/2019/01/22/%E8%BF%9B%E9%98%B6C-C%E8%AF%AD%E8%A8%80%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <id>https://skrskr66.github.io/2019/01/22/进阶C-C语言文件操作/</id>
    <published>2019-01-22T03:23:39.000Z</published>
    <updated>2019-01-22T05:25:46.390Z</updated>
    
    <content type="html"><![CDATA[<h5 id="什么是文件"><a href="#什么是文件" class="headerlink" title="什么是文件"></a>什么是文件</h5><p>磁盘上的文件是文件。但在程序设计中，我们一般谈的文件有两种：程序文件、数据文件</p><p><strong>程序文件：</strong>包括源程序文件，目标文件，可执行文件。</p><p><strong>数据文件：</strong>文件的内容不一定是程序，而是程序运行时读写的数据，比如程序运行需要从中读取数据的文件，或者输出内容的文件。</p><h5 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h5><p>文件标识常被成为文件名</p><h5 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h5><p>根据数据的组织形式，数据文件被称为<strong>文本文件</strong>或者<strong>二进制文件</strong>。</p><p>数据在内存中以二进制的形式存储，如果不加转换的输出的外存，就是<strong>二进制文件</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;什么是文件&quot;&gt;&lt;a href=&quot;#什么是文件&quot; class=&quot;headerlink&quot; title=&quot;什么是文件&quot;&gt;&lt;/a&gt;什么是文件&lt;/h5&gt;&lt;p&gt;磁盘上的文件是文件。但在程序设计中，我们一般谈的文件有两种：程序文件、数据文件&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;程序文
      
    
    </summary>
    
    
      <category term="进阶C" scheme="https://skrskr66.github.io/tags/%E8%BF%9B%E9%98%B6C/"/>
    
  </entry>
  
  <entry>
    <title>进阶C-动态内存管理</title>
    <link href="https://skrskr66.github.io/2019/01/20/%E8%BF%9B%E9%98%B6C-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://skrskr66.github.io/2019/01/20/进阶C-动态内存管理/</id>
    <published>2019-01-20T11:11:55.000Z</published>
    <updated>2019-01-21T10:22:47.148Z</updated>
    
    <content type="html"><![CDATA[<p>动态内存分配可以说是C语言中的超级大BOSS，他能使用的地方有许多许多，而且与free搭配使用。很多初学者，经常会忘记这个的使用。</p><p>而且它也是数据结构中很关键的一环。在各种的链表，顺序表等等，我们都需要去使用它。所以这是一个非常重要的一节</p><h5 id="为什么存在动态内存分配"><a href="#为什么存在动态内存分配" class="headerlink" title="为什么存在动态内存分配"></a>为什么存在动态内存分配</h5><p>我们以尽掌握的内存开辟方式</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">20</span>;<span class="comment">//在栈空间上开辟四个字节</span></span><br><span class="line"><span class="keyword">char</span> arr[<span class="number">10</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">//在栈空间上开辟10个字节的连续空间</span></span><br></pre></td></tr></table></figure><p>但是上述的开辟方式有两个特点：</p><p>1.空间的开辟大小是固定的。</p><p>2.数组在申明的时候，必须指定数组的长度，它所需要的内存在编译时分配。</p><p>但比如我们在动态顺序表中，我们先开辟了一部分，但是在分配过程中，我们所分配的内存不够了，此时我们就需要malloc函数先临时开辟一个空间，之后再去使用，当使用完成之后在free释放掉。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;    </span><br><span class="line">    <span class="keyword">int</span> len = <span class="number">0</span>;    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入长度:"</span>);    </span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;len);    </span><br><span class="line">    <span class="comment">//malloc只是动态申请一块连续的内存空间                            </span></span><br><span class="line"><span class="keyword">int</span>* a = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(len * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">malloc()函数的优点</span><br><span class="line">1.申请内存空间的长度能够比较灵活    </span><br><span class="line">2.何时释放，完全由用户来掌控</span><br></pre></td></tr></table></figure><h5 id="malloc"><a href="#malloc" class="headerlink" title="malloc"></a>malloc</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>这个函数向内存申请一块连续可用的空间，并返回指向这块空间的指针。</strong><br>    如果开辟成功，则返回一个指向开辟好空间的指针。</p><p>如果开辟失败，则返回一个NULL指针，因此malloc的返回值一定要做检查。</p><p>返回值的类型是 void* ，所以malloc函数并不知道开辟空间的类型，具体在使用的时候使用者自己来决定。</p><p>如果参数 size 为0，malloc的行为是标准是未定义的，取决于编译器。</p><h5 id="free"><a href="#free" class="headerlink" title="free"></a>free</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span>* ptr)</span></span>;</span><br></pre></td></tr></table></figure><p>free函数用来释放动态开辟的内存。</p><p>如果参数 ptr 指向的空间不是动态开辟的，那free函数的行为是未定义的。</p><p>如果参数 ptr 是NULL指针，则函数什么事都不做。</p><p><strong>如果频繁 malloc 但是忘记 free，此时就是内存泄漏</strong></p><h5 id="关于一些经典的动态分配"><a href="#关于一些经典的动态分配" class="headerlink" title="关于一些经典的动态分配"></a>关于一些经典的动态分配</h5><p>1.首先不能malloc()两次，或者free两次。动态分配两次也就是说你释放的时候只能释放一个，另一个并没有释放掉。即使你释放了两次。</p><p>2.free必须搭配malloc函数来使用。如果定义一个指针的地址，是不能释放掉的。这是错误的操作。</p><p>3.还有特殊规定，C++标准中规定了对 空指针进行 free/delete，都是合法的（无事发生）。所以当free一个内存之后，就把这个指针设为NULL。推荐这样做</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//如果*p = 100；这就是一个未定义行为</span></span><br></pre></td></tr></table></figure><p><strong>calloc</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> num,<span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><p>函数的功能是为<code>num</code>个大小为size的元素开辟一块空间，并且把空间的每个字节初始化为0.</p><p>与函数<code>malloc</code>的区别只在于<code>calloc</code>会返回地址之前把申请的空间的每个字节初始化为全0.</p><p><strong>realloc</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">realloc</span><span class="params">(<span class="keyword">void</span>* ptr,<span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure><p>当我们发现我们申请的内存空间过大或者过小，我此时就可以使用<code>realloc</code>函数就可以对动态开辟内存大小的调整</p><p><code>ptr</code>是要调整的内存地址</p><p><code>size</code>调整之后新的大小</p><p>返回值为调整之后的内存起始位置</p><p>这个函数调整原内存空间大小的基础上，还会将原来内存中的数据移动到<strong>新</strong>的空间上</p><h5 id="一些常见的动态内存错误"><a href="#一些常见的动态内存错误" class="headerlink" title="一些常见的动态内存错误"></a>一些常见的动态内存错误</h5><p>对NULL指针的解引用操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(INT_MAX/<span class="number">4</span>);</span><br><span class="line">    *p = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 对动态开辟空间的越界访问</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span>*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">NULL</span> == p)&#123;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);<span class="comment">//是个宏，返回1成功，返回0失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt;= <span class="number">10</span>;i++)&#123;</span><br><span class="line">        *(p+i) = i;<span class="comment">//当i是10的时候越界访问，*(p+i)相当于p[i]，i为10时，数组下标越界</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用free释放一块动态开辟内存的一部分</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    p++;</span><br><span class="line">    <span class="built_in">free</span>(p);<span class="comment">//p不再指向动态内存的起始位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>free只能释放开辟的所有空间，这种行为是未定义行为</p><h5 id="经典笔试题"><a href="#经典笔试题" class="headerlink" title="经典笔试题"></a>经典笔试题</h5><p><strong>第一题</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetMemory</span><span class="params">(<span class="keyword">char</span> *p)</span></span>&#123;</span><br><span class="line"> p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line"> <span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line"> GetMemory(str);</span><br><span class="line"> <span class="built_in">strcpy</span>(str, <span class="string">"hello world"</span>);</span><br><span class="line"> <span class="built_in">printf</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Test函数中，*str是实参，当通过GetMemory调用之后的str是形参，当函数结束结束之后，就不存在了，str依旧是一个空指针，将字符拷贝到一个空指针中，这将发生段错误，也就是未定义行为。应该修改为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetMemory</span><span class="params">(<span class="keyword">char</span> **p)</span></span>&#123;    </span><br><span class="line">  *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">100</span>);    </span><br><span class="line">          </span><br><span class="line">&#125;         </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;    </span><br><span class="line">  <span class="keyword">char</span> *str = <span class="literal">NULL</span>;    </span><br><span class="line">  GetMemory(&amp;str);    </span><br><span class="line">  <span class="built_in">strcpy</span>(str, <span class="string">"hello world"</span>);    </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,str);    </span><br><span class="line">  <span class="built_in">free</span>(str);                                                 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>第二题</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">GetMemory</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">char</span> p[] = <span class="string">"hello world"</span>;</span><br><span class="line"> <span class="keyword">return</span> p;<span class="comment">//返回的是数组的首元素地址</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line"> str = GetMemory();</span><br><span class="line"> <span class="built_in">printf</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是p[]数组仅仅是一个局部变量，函数结束，内存就释放了。应该修改为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">GetMemory</span><span class="params">(<span class="keyword">void</span>)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* p = <span class="string">"hello world"</span>;    </span><br><span class="line">  <span class="keyword">return</span> p;    </span><br><span class="line">&#125;    </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span>    </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *str = <span class="literal">NULL</span>;                                        </span><br><span class="line">  str = GetMemory();    </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,str);       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然内存可以访问，但是不可以修改</p><p><strong>第三题</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetMemory2</span><span class="params">(<span class="keyword">char</span> **p, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> *p = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="keyword">char</span> *str = <span class="literal">NULL</span>;</span><br><span class="line"> GetMemory(&amp;str, <span class="number">100</span>);</span><br><span class="line"> <span class="built_in">strcpy</span>(str, <span class="string">"hello"</span>);</span><br><span class="line"> <span class="built_in">printf</span>(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先没有释放内存，并且在我们的调用过程中最好进行一个if对str的判断</p><p><strong>第四题</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *str = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(<span class="number">100</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(str, “hello”);</span><br><span class="line">    <span class="built_in">free</span>(str);</span><br><span class="line"> <span class="keyword">if</span>(str != <span class="literal">NULL</span>)&#123;</span><br><span class="line">     <span class="built_in">strcpy</span>(str, “world”);</span><br><span class="line">     <span class="built_in">printf</span>(str);</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>释放完毕之后就不能在使用了，此时str就相当于一个野指针，虽然有结果打印出来，但是这个打印是非法的。</p><p>那么我们什么时候需要malloc内存？</p><p>当申请的内存空间比较大的时候，需要malloc</p><p>什么时候血药直接定义临时变量？</p><p>如果对于内存申请的性能要求较高的时候</p><h5 id="柔性数组"><a href="#柔性数组" class="headerlink" title="柔性数组"></a>柔性数组</h5><p>只在C语言中存在</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Test</span>&#123;</span></span><br><span class="line"> <span class="keyword">int</span> i;</span><br><span class="line"> <span class="keyword">int</span> a[<span class="number">0</span>];<span class="comment">//a成员就是柔性数组成员</span></span><br><span class="line">&#125;Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Test2</span>&#123;</span></span><br><span class="line"> <span class="keyword">int</span> i;</span><br><span class="line"> <span class="keyword">int</span>* a;</span><br><span class="line">&#125;Test;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Test* t = (Test*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)+<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">10</span>);</span><br><span class="line">    t-&gt;i = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)&#123;</span><br><span class="line">        t-&gt;a[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(t);</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    Test2* t2 = (Test2*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)+<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*<span class="number">100</span>);</span><br><span class="line">    t2-&gt;i = <span class="number">10</span>;</span><br><span class="line">    t2-&gt;a  = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>) * <span class="number">10</span>);</span><br><span class="line">    <span class="built_in">free</span>(t2-&gt;a);</span><br><span class="line">    <span class="built_in">free</span>(t2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>柔性数组的特点：</strong></p><p>结构中的柔性数组成员前面必须至少一个其他成员。</p><p>sizeof 返回的这种结构大小不包括柔性数组的内存。</p><p>包含柔性数组成员的结构用malloc ()函数进行内存的动态分配，并且分配的内存应该大于结构的大小，以适应柔性数组的预期大小。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;动态内存分配可以说是C语言中的超级大BOSS，他能使用的地方有许多许多，而且与free搭配使用。很多初学者，经常会忘记这个的使用。&lt;/p&gt;
&lt;p&gt;而且它也是数据结构中很关键的一环。在各种的链表，顺序表等等，我们都需要去使用它。所以这是一个非常重要的一节&lt;/p&gt;
&lt;h5 id
      
    
    </summary>
    
    
      <category term="进阶C" scheme="https://skrskr66.github.io/tags/%E8%BF%9B%E9%98%B6C/"/>
    
  </entry>
  
  <entry>
    <title>进阶C-结构体,枚举,联合</title>
    <link href="https://skrskr66.github.io/2019/01/19/%E8%BF%9B%E9%98%B6C-%E7%BB%93%E6%9E%84%E4%BD%93-%E6%9E%9A%E4%B8%BE-%E8%81%94%E5%90%88/"/>
    <id>https://skrskr66.github.io/2019/01/19/进阶C-结构体-枚举-联合/</id>
    <published>2019-01-19T09:59:20.000Z</published>
    <updated>2019-01-20T11:10:48.684Z</updated>
    
    <content type="html"><![CDATA[<p>结构体也是一个很重要的东西。在数据结构中，这个是经常被拿来使用的一部分。</p><p>联合类型应该和结构体去比较着学习。</p><h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><h5 id="结构体的定义"><a href="#结构体的定义" class="headerlink" title="结构体的定义"></a><strong>结构体的定义</strong></h5><p>结构是一些值的集合，这些值称为成员变量。结构的每个成员可以是不同的类型</p><h5 id="结构的声明"><a href="#结构的声明" class="headerlink" title="结构的声明"></a><strong>结构的声明</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stu</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> sex;</span><br><span class="line">    <span class="keyword">char</span> id[<span class="number">20</span>];</span><br><span class="line">&#125;Stu;</span><br></pre></td></tr></table></figure><h5 id="特殊的声明"><a href="#特殊的声明" class="headerlink" title="特殊的声明"></a><strong>特殊的声明</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//匿名结构体类型  C语言支持</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">float</span> c;</span><br><span class="line">&#125;x;</span><br></pre></td></tr></table></figure><p>结构在声明的时候省略掉了结构体标签</p><p>实际应用中没啥用处，但是匿名函数特别有用，然而C语言不支持</p><p>不同的匿名结构体不能相互之间赋值</p><h5 id="结构的自引用"><a href="#结构的自引用" class="headerlink" title="结构的自引用"></a><strong>结构的自引用</strong></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Student</span>&#123;</span>    </span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">1024</span>];    </span><br><span class="line">    <span class="keyword">int</span> score;    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Student</span>* <span class="title">s</span>;</span>                                       </span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><p>当将自己作为结构体指针时，可以引用自己</p><h5 id="结构体内存对齐"><a href="#结构体内存对齐" class="headerlink" title="结构体内存对齐"></a>结构体内存对齐</h5><p>结构体成员占用的内存空间的相对位置和代码中结构体变量的定义写法是密切相关的</p><p>成员从低地址到高地址依次布置</p><p>如何计算？</p><blockquote><p>1.第一个成员在结构体变量偏移量为0的地址处</p><p>2.其他成员变量要对其到某个数字的整数倍的地址处</p><p>对其数 = 编译器默认的一个对其数 与 该成员大小的<strong>较小值</strong></p><p><code>VS中默认的值为8</code></p><p><code>Linux中的默认值为4</code></p><p>3.结构体中总大小为最大对齐数(每个成员变量都有一个对齐数)的整数倍。</p><p>4.如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有对齐数(含嵌套结构体的对齐数)的整数倍。</p></blockquote><h5 id="修改默认对齐数"><a href="#修改默认对齐数" class="headerlink" title="修改默认对齐数"></a>修改默认对齐数</h5><p><code>#pragma pack()</code>还原默认的对齐数</p><h5 id="结构体传参"><a href="#结构体传参" class="headerlink" title="结构体传参"></a>结构体传参</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">int</span> data[<span class="number">1000</span>];</span><br><span class="line"> <span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> <span class="title">s</span> = &#123;</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;, <span class="number">1000</span>&#125;;</span><br><span class="line"><span class="comment">//结构体传参</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print1</span><span class="params">(struct S s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, s.num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结构体地址传参</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print2</span><span class="params">(struct S* ps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ps-&gt;num);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> print1(s);  <span class="comment">//传结构体</span></span><br><span class="line"> print2(&amp;s); <span class="comment">//传地址</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="位段"><a href="#位段" class="headerlink" title="位段"></a>位段</h5><p>位段的声明和结构是类似的，有两个不同</p><p>位段成员必须是int，unsigned int 或 signed int。</p><p>位段的成员名后边有一个冒号和一个数字</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span></span><br><span class="line"> <span class="keyword">int</span> _a:<span class="number">2</span>;</span><br><span class="line"> <span class="keyword">int</span> _b:<span class="number">5</span>;</span><br><span class="line"> <span class="keyword">int</span> _c:<span class="number">10</span>;</span><br><span class="line"> <span class="keyword">int</span> _d:<span class="number">30</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>枚举顾名思义就是一一列举。</p><p>把可能的取值一一列举。</p><h5 id="枚举类型的定义"><a href="#枚举类型的定义" class="headerlink" title="枚举类型的定义"></a>枚举类型的定义</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Day&#123;</span><br><span class="line">    Mon,</span><br><span class="line">    Tues,</span><br><span class="line">    Wed,</span><br><span class="line">    Thur,</span><br><span class="line">    Fri,</span><br><span class="line">    Sat,</span><br><span class="line">    Sun</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="枚举的优点"><a href="#枚举的优点" class="headerlink" title="枚举的优点"></a>枚举的优点</h5><p>1.增加代码的可读性和可维护性</p><p>2.和#define定义的标识符比较枚举有类型检查，更加严谨。(核心优点)</p><p>3.防止了命名污染（封装）</p><p>4.便于调试</p><p>5.使用方便，一次可以定义多个常量</p><h4 id="联合-共用体"><a href="#联合-共用体" class="headerlink" title="联合(共用体)"></a>联合(共用体)</h4><p>联合也是一种特殊的自定义类型</p><p>这种类型定义的变量也包含一系列的成员，特征是这些成员公用同一块空间(所以联合也叫共用体)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> Un&#123;</span><br><span class="line">  <span class="keyword">char</span> a;</span><br><span class="line">  <span class="keyword">int</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//此时创建了一个联合体类型的变量 u</span></span><br><span class="line">  <span class="keyword">union</span> Un u;</span><br><span class="line">  u.a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//和结构体的区别 站在内存的角度去分析</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%lu\n"</span>,<span class="keyword">sizeof</span>(u));</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="联合的特点"><a href="#联合的特点" class="headerlink" title="联合的特点"></a>联合的特点</h5><p>联合的成员是共用同一块内存空间的，这样一个联合变量的大小，至少是最大成员的大小（因为联合至少得有能力保存你最大的那个成员）。</p><p>同一块内存空间中的数据可以有不同的理解方式</p><p>假设用联合体去表示怎么判断大小端</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IslittleEnd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">union</span> Un&#123;</span><br><span class="line">        <span class="keyword">char</span> a;</span><br><span class="line">        <span class="keyword">int</span> b;</span><br><span class="line">    &#125;u;</span><br><span class="line">    u.b = <span class="number">0x11223344</span>;</span><br><span class="line">    <span class="keyword">if</span>(u.a == <span class="number">0x11</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//大端</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;<span class="comment">//小端</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>char a与int b的最低字节放在一起，因为它们是共用一块内存。这样就可以判断是否在一个字节内的地址是否是相同的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;结构体也是一个很重要的东西。在数据结构中，这个是经常被拿来使用的一部分。&lt;/p&gt;
&lt;p&gt;联合类型应该和结构体去比较着学习。&lt;/p&gt;
&lt;h4 id=&quot;结构体&quot;&gt;&lt;a href=&quot;#结构体&quot; class=&quot;headerlink&quot; title=&quot;结构体&quot;&gt;&lt;/a&gt;结构体&lt;/h4&gt;
      
    
    </summary>
    
    
      <category term="进阶C" scheme="https://skrskr66.github.io/tags/%E8%BF%9B%E9%98%B6C/"/>
    
  </entry>
  
  <entry>
    <title>进阶C-字符串+内存函数</title>
    <link href="https://skrskr66.github.io/2019/01/17/%E8%BF%9B%E9%98%B6C-%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%86%85%E5%AD%98%E5%87%BD%E6%95%B0/"/>
    <id>https://skrskr66.github.io/2019/01/17/进阶C-字符串-内存函数/</id>
    <published>2019-01-17T08:55:00.000Z</published>
    <updated>2019-01-19T09:57:38.447Z</updated>
    
    <content type="html"><![CDATA[<p>关于这节学习重点：<strong>处理字符和字符串的库函数的使用和注意事项</strong></p><p><strong>求字符串长度</strong></p><p>strlen</p><p><strong>长度不受限制的字符串函数</strong></p><p>strcpy strcat strcmp</p><p><strong>长度受限制的字符串函数介绍</strong></p><p>strncpy strncat strncmp</p><p><strong>字符串查找</strong></p><p>strstr strtok</p><p><strong>错误信息报告</strong></p><p>strerror</p><p><strong>字符操作</strong></p><p><strong>内存操作函数</strong></p><p>memcpy memmove memset memcmp</p><h5 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h5><p>strlen</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> <span class="built_in">strlen</span>(<span class="keyword">const</span> <span class="keyword">char</span>* str);</span><br></pre></td></tr></table></figure><p>我们对这些函数需要掌握的是自己来写一个这样的函数</p><p>在我们自己编写一个函数时，我们需要进行一个合法性校验</p><p>所以我们要用到assert()这个函数</p><p>assert是断言，如果表达式为真，断言通过，无事发生；如果表达式为假，断言失败，程序直接退出</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> Strlen(<span class="keyword">const</span> <span class="keyword">char</span>* str)&#123;    </span><br><span class="line">    <span class="comment">//1.函数内部进行判定    </span></span><br><span class="line">    <span class="comment">//if(str == NULL)&#123;    </span></span><br><span class="line">    <span class="comment">//  return 0;    </span></span><br><span class="line">    <span class="comment">//&#125;    </span></span><br><span class="line">    assert(str != <span class="literal">NULL</span>);    </span><br><span class="line">    <span class="keyword">size_t</span> count = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">while</span>(str[count] != <span class="string">'\0'</span>)&#123;    </span><br><span class="line">      ++count;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">return</span> count;    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>strcpy</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strcpy</span><span class="params">(<span class="keyword">char</span> *destination,<span class="keyword">const</span> <span class="keyword">char</span> * source)</span></span>;</span><br></pre></td></tr></table></figure><p>源字符串必须以<code>\0</code>结尾。</p><p>会将源字符串中的<code>\0</code>拷贝到目标空间</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">Strcpy</span><span class="params">(<span class="keyword">char</span> * dest,<span class="keyword">const</span> <span class="keyword">char</span>* src)</span></span>&#123;    </span><br><span class="line">  assert(dest != <span class="literal">NULL</span>);    </span><br><span class="line">  assert(src != <span class="literal">NULL</span>);    </span><br><span class="line">  <span class="keyword">int64_t</span> i = <span class="number">0</span>;                                                  </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>;src[i] != <span class="string">'\0'</span>;++i)&#123;    </span><br><span class="line">    dest[i] = src[i];    </span><br><span class="line">  &#125;    </span><br><span class="line">  dest[i] = <span class="string">'\0'</span>;    </span><br><span class="line">  <span class="keyword">return</span> dest;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>strcat</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">cahr* <span class="title">strcat</span><span class="params">(<span class="keyword">char</span> * destnation,<span class="keyword">const</span> <span class="keyword">char</span> * source)</span></span>;</span><br></pre></td></tr></table></figure><p>将两个字符串合并</p><p>源字符串必须以<code>&#39;\0&#39;</code>结束。</p><p>目标空间必须足够大，能够容纳下源字符串的内容</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">Strcat</span><span class="params">(<span class="keyword">char</span>* dest,<span class="keyword">const</span> <span class="keyword">char</span>* src)</span></span>&#123;</span><br><span class="line">  assert(dest != <span class="literal">NULL</span>);    </span><br><span class="line">  assert(src != <span class="literal">NULL</span>);                                            </span><br><span class="line">  <span class="comment">//1.找到dest的末尾在哪里</span></span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (;dest[i] != <span class="string">'\0'</span>;++i);</span><br><span class="line">  <span class="comment">//2.拷贝数据</span></span><br><span class="line">  <span class="comment">//int j = 0;</span></span><br><span class="line">  <span class="comment">//for (;src[j] != '\0';++j,++i)&#123;</span></span><br><span class="line">  <span class="comment">//dest[i] = src[j];</span></span><br><span class="line">  <span class="comment">//&#125;</span></span><br><span class="line">  <span class="comment">//dest[i] = '\0';</span></span><br><span class="line">  Strcpy(&amp;dest[i],src);</span><br><span class="line">  <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>strcmp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str1,<span class="keyword">const</span> <span class="keyword">char</span>* str2)</span></span>;</span><br></pre></td></tr></table></figure><p>1.字符串是使用字符数组来表示的</p><p>2.数组名会隐式转换成指针</p><p>此处的比较就不再是字符串内容的比较了，而是两个指针保存的地址的比较</p><p>如果str1 = str2，返回0</p><p>如果str1 &lt; str2，返回负数</p><p>如果str1 &gt; str2，返回正数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Strcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str1,<span class="keyword">const</span> <span class="keyword">char</span>* str2)</span></span>&#123;    </span><br><span class="line">  assert(str1 != <span class="literal">NULL</span>);    </span><br><span class="line">  assert(str2 != <span class="literal">NULL</span>);    </span><br><span class="line">  <span class="keyword">while</span>(*str1 != <span class="string">'\0'</span> &amp;&amp; *str2 != <span class="string">'\0'</span>)&#123;    </span><br><span class="line">    <span class="keyword">if</span>(*str1 &lt; *str2)&#123;    </span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;                                                  </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(*str1 &gt;*str2)&#123;    </span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;    </span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;    </span><br><span class="line">      <span class="comment">//对应字符相等，继续比较下一个字符    </span></span><br><span class="line">      ++str1;    </span><br><span class="line">      ++str2;    </span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="comment">//str1 遇到'\0',str2 没遇到,认为str1 &lt; str2    </span></span><br><span class="line">  <span class="keyword">if</span>(*str1 &lt; *str2)&#123;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">  &#125;<span class="keyword">else</span> <span class="keyword">if</span>(*str1 &gt;*str2)&#123;     <span class="comment">//str1 没遇到，str2遇到'\0',认为 str1 &gt; str2  </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;    </span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;    <span class="comment">//str1和str2同时遇到 str1 = str2     </span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;    </span><br><span class="line">  &#125;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>strncpy</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strncpy</span><span class="params">(<span class="keyword">char</span>* dest,<span class="keyword">const</span> <span class="keyword">char</span>* source,<span class="keyword">size_t</span> num)</span></span>;</span><br></pre></td></tr></table></figure><p>拷贝num个字符从源字符串到目标空间。</p><p>如果源字符串的长度小于num，则拷贝完源字符串之后，在目标的后边追加0，直到num个。</p><p>strncat</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strncat</span><span class="params">(<span class="keyword">char</span>* dest,<span class="keyword">const</span> <span class="keyword">char</span>* src,<span class="keyword">size_t</span> num)</span></span>;</span><br></pre></td></tr></table></figure><p>将src字符串的num个数目合并到dest中。</p><p>目标字符串必须足够大</p><p>strncmp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">strncmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str1,<span class="keyword">const</span> <span class="keyword">char</span>* str2,<span class="keyword">size_t</span> num)</span></span>;</span><br></pre></td></tr></table></figure><p>比较到出现另个字符不一样或者一个字符串结束或者num个字符全部比较完</p><p>strstr</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strstr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str1,<span class="keyword">const</span> <span class="keyword">char</span>* str2)</span></span>;</span><br></pre></td></tr></table></figure> <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//str2 就是 str1的子字符串(str2是str1 的一部分)    </span></span><br><span class="line"><span class="keyword">char</span> str1[] = <span class="string">"abcdef"</span>;    </span><br><span class="line"><span class="keyword">char</span> str2[] = <span class="string">"ccc"</span>;                                            </span><br><span class="line">    </span><br><span class="line"><span class="comment">//返回的p的指针就只想str1中第一个c的位置    </span></span><br><span class="line"><span class="comment">//strstr就是在判定和查找 str2 是否是 str1的子字符串    </span></span><br><span class="line"><span class="comment">//判定str1 是否包含 str2    </span></span><br><span class="line"><span class="keyword">char</span>* p = <span class="built_in">strstr</span>(str1,str2);    </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%p\n"</span>,p);</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判定str2是不是str1的子字符串    </span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">Strstr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str1,<span class="keyword">const</span> <span class="keyword">char</span>* str2)</span></span>&#123;    </span><br><span class="line">  assert(str1 != <span class="literal">NULL</span>);    </span><br><span class="line">  assert(ser2 != <span class="literal">NULL</span>);    </span><br><span class="line"> <span class="comment">//如果str2是空字符串，就没有比较的必要了     </span></span><br><span class="line">  <span class="keyword">if</span>(*str2 == <span class="string">'\0'</span> || *str1 == <span class="string">'\0'</span>)&#123;    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* black_ptr = str1;    </span><br><span class="line">  <span class="keyword">while</span>(*black_ptr != <span class="string">'\0'</span>)&#123;    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* sub_ptr = str2;    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* red_ptr = black_ptr;    </span><br><span class="line">    <span class="keyword">while</span>(*red_ptr != <span class="string">'\0'</span> &amp;&amp; *sub_ptr != <span class="string">'\0'</span> &amp;&amp;(*red_ptr == *sub_ptr))&#123;        </span><br><span class="line">      ++sub_ptr;    </span><br><span class="line">      ++red_ptr;    </span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">if</span>(*sub_ptr == <span class="string">'\0'</span>)&#123;    </span><br><span class="line">      <span class="comment">//说明找到了子串,需要返回一个指向str1的位置。    </span></span><br><span class="line">      <span class="keyword">return</span> black_ptr;    </span><br><span class="line">    &#125;                                                             </span><br><span class="line">    ++black_ptr;    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>strtok</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strtok</span><span class="params">(<span class="keyword">char</span>* str,<span class="keyword">const</span> <span class="keyword">char</span>* sep)</span></span>;</span><br></pre></td></tr></table></figure><p>sep参数是个字符串，定义了用作分隔符的字符集合</p><p>第一个参数指定了一个字符串，它包含了0个或者多个由sep字符串中一个或者多个分隔符分割的标记。</p><p>strtok函数找到str中的下一个标记，并将其用<code>\0</code>结尾，返回一个指向这个标记的指针，</p><p>strtok函数的第一个参数不为<code>NULL</code>,函数将找到str中第一个标记，strtok函数将保存它在字符串中的位置</p><p>strtok函数的第一个参数为<code>NULL</code>,函数将在同一个字符串中被保存的位置开始，查找下一个标记</p><p>如果字符串中不存在更多的标记，则返回<code>NULL</code>指针</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于strtok进行封装，让 strtok 使用起来更简单一些    </span></span><br><span class="line"><span class="comment">//返回值的含义相当于切分出来的 token 的个数    </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Split</span><span class="params">(<span class="keyword">char</span>* input,<span class="keyword">const</span> <span class="keyword">char</span>* split_char,<span class="keyword">char</span>* output[])</span></span>&#123;    </span><br><span class="line">  <span class="keyword">int</span> output_index = <span class="number">0</span>;    </span><br><span class="line">  <span class="keyword">char</span>* p = strtok(input,split_char);                             </span><br><span class="line">  <span class="keyword">while</span>(p != <span class="literal">NULL</span>)&#123;    </span><br><span class="line">    output[output_index] = p;    </span><br><span class="line">    ++output_index;    </span><br><span class="line">    p = strtok(<span class="literal">NULL</span>,split_char);    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="keyword">return</span> output_index;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>strerror</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">strerror</span><span class="params">(<span class="keyword">int</span> errnum)</span></span>;</span><br></pre></td></tr></table></figure><p>返回错误码，所对应的错误信息</p><p>strerro函数是吧错误码转为错误提示信息</p><p>errno中，不同的数值代表不同的错误 </p><h5 id="与内存相关的函数"><a href="#与内存相关的函数" class="headerlink" title="与内存相关的函数"></a>与内存相关的函数</h5><p>memcpy</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">memcpy</span><span class="params">(<span class="keyword">void</span>* dest,<span class="keyword">const</span> <span class="keyword">void</span>* src,<span class="keyword">size_t</span> num)</span></span>;</span><br></pre></td></tr></table></figure><p>函数memcpy从src的位置开始向后复制num个字节的数据到dest的内存位置。</p><p>这个函数在遇到<code>&#39;\0&#39;</code>的时候并不会停下来。</p><p>如果src和dest有任何的重叠，复制的结果都是未定义的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回值也是dest    </span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Memcpy</span><span class="params">(<span class="keyword">void</span>* dest,<span class="keyword">const</span> <span class="keyword">void</span>* src,<span class="keyword">size_t</span> num)</span></span>&#123;    </span><br><span class="line">  assert(dest != <span class="literal">NULL</span> );    </span><br><span class="line">  assert(src != <span class="literal">NULL</span>);    </span><br><span class="line">  <span class="keyword">char</span>* pdest = (<span class="keyword">char</span>*)dest;    </span><br><span class="line">  <span class="keyword">char</span>* psrc = (<span class="keyword">char</span>*)src;</span><br><span class="line">  <span class="keyword">size_t</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(;i &lt; num; ++i)&#123;</span><br><span class="line">    pdest[i] = psrc[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//不需要设置'\0'</span></span><br><span class="line">  <span class="keyword">return</span> dest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>memmove</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">memmove</span><span class="params">(<span class="keyword">void</span>* dest,<span class="keyword">const</span> <span class="keyword">void</span>* src,<span class="keyword">size_t</span> num)</span></span>;</span><br></pre></td></tr></table></figure><p>和memcpy的差别就是memmove函数处理的源内存块和目标内存块是可以重叠的。</p><p>如果源空间和目标空间出现重叠，就得使用memmove函数处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">Memmove</span><span class="params">(<span class="keyword">void</span>* dest,<span class="keyword">const</span> <span class="keyword">void</span>* src,<span class="keyword">size_t</span> num)</span></span>&#123;    </span><br><span class="line">  assert(dest != <span class="literal">NULL</span>);    </span><br><span class="line">  assert(src != <span class="literal">NULL</span>);    </span><br><span class="line">  <span class="keyword">char</span>* pdest = (<span class="keyword">char</span>*)dest;    </span><br><span class="line">  <span class="keyword">char</span>* psrc = (<span class="keyword">char</span>*)src;    </span><br><span class="line">  <span class="keyword">if</span>(pdest &gt;= psrc &amp;&amp; pdest &lt; psrc + num)&#123;    </span><br><span class="line">    <span class="comment">//这是标准库认为的缓冲区重合    </span></span><br><span class="line">    <span class="comment">//特殊进行处理    </span></span><br><span class="line">    <span class="keyword">int64_t</span> i = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">for</span>(i = num - <span class="number">1</span>;i &gt;= <span class="number">0</span>;--i)&#123;                             </span><br><span class="line">      pdest[i] = psrc[i];    </span><br><span class="line">    &#125;    </span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;    </span><br><span class="line">    Memcpy(dest,src,num);    </span><br><span class="line">  &#125;    </span><br><span class="line">  <span class="keyword">return</span> dest;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>memcmp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">memcmp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* ptr1,<span class="keyword">const</span> <span class="keyword">void</span>* ptr2,<span class="keyword">size_t</span> num)</span></span>;</span><br></pre></td></tr></table></figure><p>比较从ptr1和ptr2指针开始的num个字节。</p><p>使用方法与strncpy非常类似。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;关于这节学习重点：&lt;strong&gt;处理字符和字符串的库函数的使用和注意事项&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;求字符串长度&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;strlen&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;长度不受限制的字符串函数&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;s
      
    
    </summary>
    
    
      <category term="进阶C" scheme="https://skrskr66.github.io/tags/%E8%BF%9B%E9%98%B6C/"/>
    
  </entry>
  
  <entry>
    <title>进阶C-指针的进阶</title>
    <link href="https://skrskr66.github.io/2019/01/16/%E8%BF%9B%E9%98%B6C-%E6%8C%87%E9%92%88%E7%9A%84%E8%BF%9B%E9%98%B6/"/>
    <id>https://skrskr66.github.io/2019/01/16/进阶C-指针的进阶/</id>
    <published>2019-01-16T08:08:26.000Z</published>
    <updated>2019-01-17T08:52:27.180Z</updated>
    
    <content type="html"><![CDATA[<p>指针之前有个初阶的总结，这次到了进阶。里面有更多的，更坑的地方。并且涉及到了各种指针。</p><h5 id="字符指针"><a href="#字符指针" class="headerlink" title="字符指针"></a>字符指针</h5><p>在指针的类型中我们知道有一种指针类型为字符指针<code>char*</code></p><p>一般使用：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="string">'w'</span>;</span><br><span class="line">    <span class="keyword">char</span> *pc = &amp;ch;</span><br><span class="line">    *pc = <span class="string">'w'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于某一指针p，指向的是单个字符。并且指向的不是字符串，就不能使用strlen。</p><p>强行使用strlen就会内存访问越界，此时就是未定义行为了。</p><h5 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h5><p>指针数组是一个存放指针的数组。<strong>数组的每一个元素是一个指针</strong></p><p>例如：<code>int* arr[5]</code>，这就是个指针数组</p><h5 id="数组指针"><a href="#数组指针" class="headerlink" title="数组指针"></a>数组指针</h5><p>数组指针就是一个指针。<strong>指向的元素是整个数组</strong></p><p>例如：<code>int (*arr)[5]</code>，这就是个数组指针，这个指针的类型 <code>int(*)[5]</code></p><h5 id="amp-数组名VS数组名"><a href="#amp-数组名VS数组名" class="headerlink" title="&amp;数组名VS数组名"></a>&amp;数组名VS数组名</h5><p>arr是数组名，数组名表示数组首元素的地址。int*类型的变量</p><p>&amp;arr是数组指针。</p><p>‘房间号’是相同的，但是类型不同</p><h5 id="函数指针-第二重要"><a href="#函数指针-第二重要" class="headerlink" title="函数指针(第二重要)"></a>函数指针(第二重要)</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Func</span><span class="params">()</span></span>&#123;             </span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"hehe\n"</span>);     </span><br><span class="line">   <span class="keyword">return</span> <span class="number">10</span>;            </span><br><span class="line"> &#125;                       </span><br><span class="line">                         </span><br><span class="line"> <span class="comment">//()函数调用操作符</span></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">//Func 也就是函数指针了</span></span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%p\n"</span>,Func);</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">"%d\n"</span>,Func());</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><code>Func</code>打印出来的就是当前函数存放的地址</p><p>在指针中，void*不能解引用。但是函数指针可以。</p><p>对于函数指针来说，最重要的操作是<code>调用()</code></p><p><code>int (*p)() = Func;</code>，此时定义了一个指针变量p，p的类型 <code>int(*)()</code></p><h5 id="函数指针数组"><a href="#函数指针数组" class="headerlink" title="函数指针数组"></a>函数指针数组</h5><p>把函数的地址存到一个数组中，那这个数组就叫函数指针数组</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*parr1[<span class="number">10</span>]])();</span><br><span class="line"><span class="keyword">int</span> *parr2[<span class="number">10</span>]();</span><br><span class="line"><span class="keyword">int</span> (*)() parr3[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>只有第一种写法算比较科学，但是还是推荐用typedef来描述</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">           <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">           <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">           <span class="keyword">return</span> a*b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">           <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*T)</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>; </span><br><span class="line">    T arr[] = &#123;</span><br><span class="line">    Add,</span><br><span class="line">    Sub,</span><br><span class="line">    Mul,</span><br><span class="line">    Div</span><br><span class="line">    &#125;;</span><br><span class="line">    arr[choice - <span class="number">1</span>](<span class="number">10</span>,<span class="number">20</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是利用函数指针数组来实现</p><h5 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h5><p>回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针被用来调用其所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该事件或条件进行响应</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Swap</span><span class="params">(<span class="keyword">int</span>* x,<span class="keyword">int</span>* y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> tmp = *x;</span><br><span class="line">    *x = *y; </span><br><span class="line">    *y = tmp;</span><br><span class="line">  &#125;                               </span><br><span class="line">  <span class="comment">//is_desc =&gt; 1降序排序 0升序排序</span></span><br></pre></td></tr></table></figure><p>通过调用一个开关进行排序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> size,<span class="keyword">int</span> is_desc)</span></span>&#123;</span><br><span class="line">    <span class="comment">//[0,bound)已排序区间</span></span><br><span class="line">    <span class="comment">//[bound,size)待排序区间</span></span><br><span class="line">    <span class="keyword">int</span> bound = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(bound = <span class="number">0</span>; bound &lt; size; ++bound)&#123;</span><br><span class="line">      <span class="comment">//反着循环是为了每次找到一个最小的元素并且放&gt;  到合适的位置上</span></span><br><span class="line">      <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(cur = size - <span class="number">1</span>;cur  &gt; bound; --cur)&#123;</span><br><span class="line">        <span class="keyword">if</span>(is_desc == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(arr[cur - <span class="number">1</span>] &gt; arr[cur])&#123;</span><br><span class="line">          <span class="comment">//这个条件其实就是在描述排序规则</span></span><br><span class="line">          <span class="comment">//这两个相邻元素不符合排序规则，需要交换</span></span><br><span class="line">          Swap(&amp;arr[cur - <span class="number">1</span>],&amp;arr[cur]);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(is_desc == <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="keyword">if</span>(arr[cur - <span class="number">1</span>] &gt; arr[cur])&#123;</span><br><span class="line">            Swap(&amp;arr[cur - <span class="number">1</span>],&amp;arr[cur]);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;                                          </span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>通过回调函数来进行冒泡排序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span><span class="params">(*T)</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>;</span><br><span class="line">  <span class="comment">//参数中引入一个函数指针，这个函数指针描述了排序&gt;  规则</span></span><br><span class="line">  <span class="comment">//排序规则可能会非常复杂，根据实际情况可能要考虑&gt;  很多很多方面</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">Less</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &lt; y ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">Greater</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">AbsLess</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">fabs</span>(x) &lt; <span class="built_in">fabs</span>(y) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BubbleSort2</span><span class="params">(<span class="keyword">int</span> arr[],<span class="keyword">int</span> size,T cmp)</span></span>&#123;</span><br><span class="line">    <span class="comment">//[0,bound)已排序区间</span></span><br><span class="line">    <span class="comment">//[bound,size)待排序区间</span></span><br><span class="line">    <span class="keyword">int</span> bound = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(bound = <span class="number">0</span>; bound &lt; size; ++bound)&#123;</span><br><span class="line">      <span class="comment">//反着循环是为了每次找到一个最小的元素并且放&gt;  到合适的位置上</span></span><br><span class="line">      <span class="keyword">int</span> cur = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(cur = size - <span class="number">1</span>;cur  &gt; bound; --cur)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cmp(arr[cur - <span class="number">1</span>] ,arr[cur]) == <span class="number">0</span>)&#123;</span><br><span class="line">          <span class="comment">//这个条件其实就是在描述排序规则</span></span><br><span class="line">          <span class="comment">//这两个相邻元素不符合排序规则，需要交换</span></span><br><span class="line">          Swap(&amp;arr[cur - <span class="number">1</span>],&amp;arr[cur]);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">5</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">//升序</span></span><br><span class="line">    BubbleSort2(arr,<span class="number">5</span>,Less);</span><br><span class="line">    <span class="comment">//降序</span></span><br><span class="line">    BubbleSort2(arr,<span class="number">5</span>,Greater);</span><br><span class="line">    <span class="comment">//元素的绝对值升序排序</span></span><br><span class="line">    BubbleSort2(arr,<span class="number">5</span>,AbsLess); </span><br><span class="line">    <span class="comment">//回调函数函数调用时机不是由调用者来决定，而是&gt;  由操作系统或者由代码框架来决定。</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着就是之前在指针初阶的总结中一部分超坑的打印题</p><p><a href="https://skrskr66.coding.me/2018/11/25/%E5%88%9D%E9%98%B6C-%E6%8C%87%E9%92%88%E6%80%BB%E7%BB%93%E4%B8%8E%E5%9D%91/" target="_blank" rel="noopener">附上链接</a>，拉到底部即可</p><p>接着还有一些超坑的指针代码块！</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> *ptr = (<span class="keyword">int</span> *)(&amp;a + <span class="number">1</span>);</span><br><span class="line"><span class="built_in">printf</span>( <span class="string">"%d,%d"</span>, *(a + <span class="number">1</span>), *(ptr - <span class="number">1</span>));</span><br><span class="line"><span class="comment">//结果为2，5</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">4</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> *ptr1 = (<span class="keyword">int</span> *)(&amp;a + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> *ptr2 = (<span class="keyword">int</span> *)((<span class="keyword">int</span>)a + <span class="number">1</span>);<span class="comment">//需修改</span></span><br><span class="line"><span class="built_in">printf</span>( <span class="string">"%x,%x"</span>, ptr1[<span class="number">-1</span>], *ptr2);</span><br><span class="line">    <span class="comment">//ptr1是指针数组+1，跳过了这个数组，那么-1就是向前取一位，也就是4</span></span><br><span class="line">    <span class="comment">//对于ptr2，假设a对应地址 0x ff ff ff ff 00 00 00 01 64位地址</span></span><br><span class="line">    <span class="comment">//0x 00 00 00 01  强转成int 占4个字节</span></span><br><span class="line">    <span class="comment">//0x 00 00 00 02  再+1</span></span><br><span class="line">    <span class="comment">//0x 00 00 00 00 00 00 00 02 再转为int*，所以再64位机子上，int的高位被截断，转没了，所以改为long，能正常显示</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">2</span>] = &#123; (<span class="number">0</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>) &#125;;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line">p = a[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">printf</span>( <span class="string">"%d"</span>, p[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">//这里涉及到了逗号表达式，整个表达式的值为最后一个表达式的值。</span></span><br><span class="line">    <span class="comment">//所以数组的初始化应为&#123;1，3，5，0，0，0&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span>(*p)[<span class="number">4</span>];</span><br><span class="line">p = a;</span><br><span class="line"><span class="built_in">printf</span>( <span class="string">"a_ptr=%#p,p_ptr=%#p\n"</span> , &amp;a[<span class="number">4</span>][<span class="number">2</span>], &amp;p[<span class="number">4</span>][<span class="number">2</span>]);</span><br><span class="line"><span class="built_in">printf</span>( <span class="string">"%p,%d\n"</span>, &amp;p[<span class="number">4</span>][<span class="number">2</span>] - &amp;a[<span class="number">4</span>][<span class="number">2</span>], &amp;p[<span class="number">4</span>][<span class="number">2</span>] - &amp;a[<span class="number">4</span>][<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">//内存分布见图一</span></span><br><span class="line">    <span class="comment">//a与p的内存之间从对其，到逐渐有了差值</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> aa[<span class="number">2</span>][<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> *ptr1 = (<span class="keyword">int</span> *)(&amp;aa + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> *ptr2 = (<span class="keyword">int</span> *)(*(aa + <span class="number">1</span>));<span class="comment">//相当于aa[1]强转成int*，就是指向6的指针</span></span><br><span class="line"><span class="built_in">printf</span>( <span class="string">"%d,%d"</span>, *(ptr1 - <span class="number">1</span>), *(ptr2 - <span class="number">1</span>));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> *a[] = &#123;<span class="string">"work"</span>,<span class="string">"at"</span>,<span class="string">"alibaba"</span>&#125;;<span class="comment">//数组指针</span></span><br><span class="line"> <span class="keyword">char</span>** p = a;<span class="comment">//将a数组中的首元素地址放在p指针中</span></span><br><span class="line"> p++;<span class="comment">//根据数据类型，+4个字节，这时候指针刚好指向了第二个元素</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, *p);<span class="comment">//再解引用，此时得到就是 “at”</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">char</span> *c[] = &#123;<span class="string">"ENTER"</span>,<span class="string">"NEW"</span>,<span class="string">"POINT"</span>,<span class="string">"FIRST"</span>&#125;;</span><br><span class="line"> <span class="keyword">char</span>**cp[] = &#123;c+<span class="number">3</span>,c+<span class="number">2</span>,c+<span class="number">1</span>,c&#125;;</span><br><span class="line"> <span class="keyword">char</span>***cpp = cp;</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, **++cpp);<span class="comment">//打印point</span></span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, *--*++cpp+<span class="number">3</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, *cpp[<span class="number">-2</span>]+<span class="number">3</span>);</span><br><span class="line"> <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, cpp[<span class="number">-1</span>][<span class="number">-1</span>]+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//内存见图二</span></span><br><span class="line">    <span class="comment">//第一个打印</span></span><br><span class="line">    ++ =&gt; cpp &amp;&amp;p3</span><br><span class="line">    * =&gt; &amp;p3</span><br><span class="line">    * =&gt; p3</span><br><span class="line">    <span class="comment">//第二个打印</span></span><br><span class="line">    <span class="comment">//运算顺序是 ++ * -- * +</span></span><br><span class="line">    ++ =&gt; &amp;&amp;p2</span><br><span class="line">    * =&gt; &amp;p2 此时相当于重新定义了一个指针指向p2元素的地址</span><br><span class="line">    -- =&gt;p2移动，位&amp;p1</span><br><span class="line">    * =&gt; p1</span><br><span class="line">    +<span class="number">3</span> =&gt; <span class="string">"ENTER"</span>,指向了第三个字符之后的</span><br><span class="line">    <span class="comment">//第三个打印</span></span><br><span class="line">    <span class="comment">//运算顺序 [] * +</span></span><br><span class="line">    [<span class="number">-2</span>] =&gt; 先减<span class="number">2</span>在解引用，cpp指针由之前此时指向&amp;p2，<span class="number">-2</span>得到的是&amp;p4</span><br><span class="line">    * =&gt; p4</span><br><span class="line">    +<span class="number">3</span> =&gt; ‘ST’</span><br><span class="line">    <span class="comment">//第四个打印</span></span><br><span class="line">    [<span class="number">-1</span>] =&gt; &amp;p3,相当于有另个指针指向了p3</span><br><span class="line">    [<span class="number">-1</span>] =&gt; p3<span class="number">-1</span>，就相当于p2</span><br><span class="line">    +1 =&gt; 'EW'</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图一：</p><p><img src="/2019/01/16/进阶C-指针的进阶/指针1.png" alt="指针1"></p><p>图二：</p><p><img src="/2019/01/16/进阶C-指针的进阶/指针2.png" alt="指针2"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;指针之前有个初阶的总结，这次到了进阶。里面有更多的，更坑的地方。并且涉及到了各种指针。&lt;/p&gt;
&lt;h5 id=&quot;字符指针&quot;&gt;&lt;a href=&quot;#字符指针&quot; class=&quot;headerlink&quot; title=&quot;字符指针&quot;&gt;&lt;/a&gt;字符指针&lt;/h5&gt;&lt;p&gt;在指针的类型中我们知道
      
    
    </summary>
    
    
      <category term="进阶C" scheme="https://skrskr66.github.io/tags/%E8%BF%9B%E9%98%B6C/"/>
    
  </entry>
  
  <entry>
    <title>进阶C-数据的存储</title>
    <link href="https://skrskr66.github.io/2019/01/07/%E8%BF%9B%E9%98%B6C-%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8/"/>
    <id>https://skrskr66.github.io/2019/01/07/进阶C-数据的存储/</id>
    <published>2019-01-07T15:05:59.000Z</published>
    <updated>2019-01-16T05:31:37.560Z</updated>
    
    <content type="html"><![CDATA[<p>就目前来看，<code>C++</code>和<code>JAVA</code>的选择我选择了前者。</p><p>大家都说是Hard模式，但是自己不尝试，不努力又怎么知道能否成功呢！</p><p>所以再一次开始了C语言的进阶。这几部分总结完之后，我想就能开始C++的真正学习了！</p><p>C语言好学但又不好学。首先是因为C语言的语法比较固定，是可以很快理解的。但是C中有一个关键的地方，就是涉及到内存。因为C++追求的性能的极致。这就有了许多坑。</p><h5 id="整型在内存中的存储"><a href="#整型在内存中的存储" class="headerlink" title="整型在内存中的存储"></a>整型在内存中的存储</h5><p>首先说到内存了，那么第一个需要考虑的还是在当前系统中，数据的存储模式。到底是大端还是小端。这里又要讨论到</p><p><strong>大端模式：是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中</strong></p><p>如：<code>0x00 0x00 0x00 0x00 0x00 0x00 0x00 0x0a</code>  0a是低位，因为在16进制中表示10，应为00 00 00 0a这个样子。</p><p>低地址—————————————————–高地址</p><p>我们一般写数据也喜欢00 00 00 0a。</p><p><strong>小端模式：是指数据的低位保存在内存低地址中，而数据的低位，保存在内存的高地址中</strong></p><p>如：<code>0x0a 0x00 0x00 0x00 0x00 0x00 0x00 0x00</code></p><p>低地址—————————————————–高地址</p><p>以上只是一个正整数在内存的表示方式。如果是负数呢？</p><p>这个时候就要考虑原码，补码，反码这三种的转换情况了</p><p><strong>原码</strong>：直接将二进制按照正负数的形式翻译成二进制就可以。</p><p><strong>反码</strong>：将原码的符号位不变，其他位依次按位取反就可以得到了。</p><p><strong>补码</strong>：反码+1就得到补码。正数的原/反/补码都相同</p><p>在转换过程中，约定一个整数的最高位为符号位。正数为0，负数为1。</p><p><strong>对于整型来说：数据存放内存中其实存放的是补码</strong></p><p>但为什么我们需要搞一个补码？对人来说，原码不是更直观吗</p><p>这是为了方便计算机的计算来使用。计算机的内部表示都是用二进制来表示，那不管加减乘除都用补码，这样不就转换成了全是加法的运算吗。减法也只不过是加上一个负数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检验大小端</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="comment">//如果是大端，返回0</span></span><br><span class="line"><span class="comment">//如果是小端，返回1</span></span><br><span class="line"><span class="comment">//非常重要！！校招总是爱考</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsLittleEnd</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0x11223344</span>;</span><br><span class="line"><span class="keyword">char</span>* b = (<span class="keyword">char</span>*)&amp;a;</span><br><span class="line"><span class="keyword">if</span> (*b == <span class="number">0x11</span>)&#123;</span><br><span class="line"><span class="comment">//检查低地址的内容是否是数字的高位</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">-10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>,a);</span><br><span class="line"><span class="comment">//printf("%d\n",IsLittleEnd());              </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>数据在内存中具有一定的存储形式，存储同样的内容，可以按照不同的方式来理解</strong></p><p>比如在unsigned char a = -1，这打印出来的即为255。因为-1在内存中表示为0xff，有时无符号此时就不管负号了。这之后0xff表示的就是255，所以打印出来不再是-1，就是255。</p><p><strong>如果两个数据在内存中存储的形式是相同的，再按照相同的方式来理解，结果也肯定是相同的</strong></p><p>char = 128和char = -128 在printf（“%u”)打印下都是一样的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">-20</span>;</span><br><span class="line"><span class="keyword">unsigned</span> j = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>,i+j);</span><br></pre></td></tr></table></figure><p>在这里又要碰到隐式转换。某个操作数属于不同的类型，那么除非其中一个操作数的转换为另一个操作数的类型，否则操作就无法进行。下面的层次体系为寻常算术转换</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">double</span></span><br><span class="line"><span class="keyword">double</span></span><br><span class="line"><span class="keyword">float</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">int</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span></span><br><span class="line"><span class="keyword">int</span></span><br></pre></td></tr></table></figure><p>如果某个操作数的类型在上面这个列表中排名较低，那么首先要转换为另一个操作数的类型后执行选择。比如int要转换成unsigned int，低类型要向高类型转换。</p><p>又因为打印为’%d’，是有符号的打印，所以我们最后为-10。</p><p>所以无符号整型在计算减法时很容易溢出。能不用无符号整数，就不用无符号，有符号整数来代替。</p><h5 id="浮点型在内存中的存储"><a href="#浮点型在内存中的存储" class="headerlink" title="浮点型在内存中的存储"></a>浮点型在内存中的存储</h5><p>浮点型在内存中的分配中是根据国际标准IEEE754来定义的。</p><blockquote><p>(-1)^S <em> M </em> 2^E</p><p>(-1)^s表示符号位，当s=0，V为正数；当s=1，V为负数。</p><p>M表示有效数字，大于等于1，小于2。</p><p>2^E表示指数位。</p></blockquote><p>举例来说：十进制的5.0，写成二进制是<code>101.0</code>，相当于<code>1.01x2^2</code></p><p>那么，s=1，M=1.01，E=2</p><p><strong>不能拿两个浮点数直接比较相等，浮点数的存储是存在误差的。因为在浮点数的存储中，如果是无限循环小数，数字超过了能存储的位数之后就不能在存储进去了。这样计算之后也无法得到准确的值</strong></p><p>能不用浮点数，就不用浮点数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;就目前来看，&lt;code&gt;C++&lt;/code&gt;和&lt;code&gt;JAVA&lt;/code&gt;的选择我选择了前者。&lt;/p&gt;
&lt;p&gt;大家都说是Hard模式，但是自己不尝试，不努力又怎么知道能否成功呢！&lt;/p&gt;
&lt;p&gt;所以再一次开始了C语言的进阶。这几部分总结完之后，我想就能开始C++的真正
      
    
    </summary>
    
    
      <category term="进阶C" scheme="https://skrskr66.github.io/tags/%E8%BF%9B%E9%98%B6C/"/>
    
  </entry>
  
  <entry>
    <title>操作系统之进程调度</title>
    <link href="https://skrskr66.github.io/2019/01/05/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B9%8B%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/"/>
    <id>https://skrskr66.github.io/2019/01/05/操作系统之进程调度/</id>
    <published>2019-01-05T14:43:59.000Z</published>
    <updated>2019-01-06T12:12:32.707Z</updated>
    
    <content type="html"><![CDATA[<p>这周学校布置了关于操作系统的知识点论文，正好也写篇博客来好好分析一下关于进程调度的知识点。</p><h4 id="调度的基本概念"><a href="#调度的基本概念" class="headerlink" title="调度的基本概念"></a>调度的基本概念</h4><p>在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程。处理机调度，就是从就绪队列中<strong>按照一定的算法选择一个进程</strong>并<strong>将处理机分配给它</strong>运行，以实现进程的并发执行。</p><h4 id="调度的三个层次"><a href="#调度的三个层次" class="headerlink" title="调度的三个层次"></a>调度的三个层次</h4><h5 id="高级调度"><a href="#高级调度" class="headerlink" title="高级调度"></a>高级调度</h5><p>由于内存空间有限，有时无法将用户的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序。</p><p><strong>高级调度（作业调度）</strong>。按一定的原则从外存上处于后备队列的作业中挑选一个（或多个）作业，给他们分配内存等必要资源，并<strong>建立相应的进程（建立PCB）</strong>，以使它们<strong>获得竞争处理机的权利</strong>。高级调度使辅存（外存）与内存之间的调度。每个作业只调入一次，调出一次。<strong>作业调入时会建立相应的PCB，作业调出时才撤销PCB</strong>。高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。</p><h5 id="中级调度"><a href="#中级调度" class="headerlink" title="中级调度"></a>中级调度</h5><p>暂时调到外存等待的进程状态为挂起状态。值得注意的是，PCB并不会一起调到外存，而是<strong>会常驻内存</strong>。PCB中会记录进程数据在外存中存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。被挂起的进程PCB会被放到的挂起队列中。</p><p><strong>中级调度（内存调度）</strong>，就是要决定将哪个处于挂起状态的进程重新调入内存。</p><p>一个进程可能会被多次调出、调入内存，因此中级调度发生的<strong>频率</strong>要比高级调度更高。</p><h5 id="低级调度"><a href="#低级调度" class="headerlink" title="低级调度"></a>低级调度</h5><p><strong>低级调度（进程调度）</strong>，其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。</p><p>进程调度是操作系统中<strong>最基本的一种调度</strong>，在一般的操作系统中都必须配置进程调度。</p><p>进程调度的频率很高，一般几十毫秒一次。</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">要做什么</th><th style="text-align:center">调度发生在..</th><th style="text-align:center">发生频率</th><th style="text-align:center">对进程状态的影响</th></tr></thead><tbody><tr><td style="text-align:center">高级调度</td><td style="text-align:center">按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程</td><td style="text-align:center">外存→内存</td><td style="text-align:center">最低</td><td style="text-align:center">无→创建态→就绪态</td></tr><tr><td style="text-align:center">中级调度</td><td style="text-align:center">按照某种规则，从挂起队列中选择合适的进程将其数据调回内存</td><td style="text-align:center">外存→内存</td><td style="text-align:center">中等</td><td style="text-align:center">挂起态→就绪态</td></tr><tr><td style="text-align:center">低级调度</td><td style="text-align:center">按照某种规则，从就绪队列中选择一个进程为其分配处理机</td><td style="text-align:center">内存→CPU</td><td style="text-align:center">最高</td><td style="text-align:center">就绪态→运行态</td></tr></tbody></table><h4 id="进程调度的方式"><a href="#进程调度的方式" class="headerlink" title="进程调度的方式"></a>进程调度的方式</h4><h5 id="非抢占方式"><a href="#非抢占方式" class="headerlink" title="非抢占方式"></a>非抢占方式</h5><p>只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。</p><h5 id="抢占方式"><a href="#抢占方式" class="headerlink" title="抢占方式"></a>抢占方式</h5><p>当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。</p><p>进程调度中的这两种方式决定了调度中时间的改变。</p><h4 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h4><p>CPU利用率 = 忙碌的时间/总时间</p><p>系统吞吐量 = 总共完成了多少道作业/总共花了多少时间</p><p>周转时间 = 作业完成时间 - 作业提交时间（到达时间）</p><p>平均周转时间 = 各作业周转时间之和 / 作业数</p><p>带权周转时间 = 作业周转时间/作业实际运行的时间</p><p>平均带权周转时间 = 各作业带权周转时间之和/作业数</p><p>这些名词可以衡量一个进程调度过程中，是否能达到一个高效的过程。时间的分配是否合理。但是这些也并不是都是绝对的。因为考虑到有些进程的调度有其他因素的考虑，所以我们只是将其作为一个参考。</p><h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><h5 id="先来先服务（FCFS）"><a href="#先来先服务（FCFS）" class="headerlink" title="先来先服务（FCFS）"></a>先来先服务（FCFS）</h5><p><strong>先来先服务算法</strong>：主要从“公平”的角度考虑（类似于我们生活中排队买东西的例子）。一种非抢占式的算法。</p><p>它主要按照作业/进程到达的先后顺序进行服务。等待时间越久的越优先得到服务。用于作业调度时，考虑的是哪个作业先到达后备队列；用于进程调度时，考虑的是哪个进程先到达就绪队列。对长作业有利，对短作业不利</p><table><thead><tr><th style="text-align:center">进程</th><th style="text-align:center">到达时间</th><th style="text-align:center">运行时间</th></tr></thead><tbody><tr><td style="text-align:center">P1</td><td style="text-align:center">0</td><td style="text-align:center">7</td></tr><tr><td style="text-align:center">P2</td><td style="text-align:center">2</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">P3</td><td style="text-align:center">4</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">P4</td><td style="text-align:center">5</td><td style="text-align:center">4</td></tr></tbody></table><p>调度顺序为：P1→P2→P3→P4</p><p><img src="/2019/01/05/操作系统之进程调度/操作系统1.png" alt="操作系统1"></p><h5 id="短作业优先（SJF）"><a href="#短作业优先（SJF）" class="headerlink" title="短作业优先（SJF）"></a>短作业优先（SJF）</h5><p><strong>短作业优先算法</strong>：追求最少的平均等待时间，最少的平均周转时间，最少的平均带权周转时间。所谓“最短”就是要求服务时间最短。即可用于作业调度，也可用于进程调度。它具有非抢占式和抢占式。</p><p><strong>非抢占式</strong>：每次调度时选择已到达且运行时间最短的作业/进程</p><p><strong>抢占式(最短剩余时间优先算法)</strong>：每当有进程加入就绪队列改变时就需要调度，如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程重新回到就绪队列，另外，当一个进程完成时也需要调度。 </p><p>调度顺序为：P1→P3→P2→P4</p><p><img src="/2019/01/05/操作系统之进程调度/操作系统2.png" alt="操作系统2"></p><h5 id="高响应比优先（HRRN）"><a href="#高响应比优先（HRRN）" class="headerlink" title="高响应比优先（HRRN）"></a>高响应比优先（HRRN）</h5><p><strong>高响应比优先算法：</strong>要综合考虑作业/进程的等待时间和要求服务的时间</p><p>在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务。</p><p>响应比 = （等待时间 + 要求服务时间）/ 要求服务时间（响应比 &gt;= 1)</p><p>即可作业调度也可进程调度。它是一种非抢占式的算法。因此只有当前运行的作业/进程主动放弃处理机（CPU）时，才需要调度，才需要计算响应比。调度时<strong>计算所有就绪进程的响应比，玄响应比最高的</strong>进程上处理机。看下面例子：</p><table><thead><tr><th style="text-align:center">进程</th><th style="text-align:center">到达时间</th><th style="text-align:center">运行时间</th></tr></thead><tbody><tr><td style="text-align:center">P1</td><td style="text-align:center">0</td><td style="text-align:center">7</td></tr><tr><td style="text-align:center">P2</td><td style="text-align:center">2</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">P3</td><td style="text-align:center">4</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">P4</td><td style="text-align:center">5</td><td style="text-align:center">4</td></tr></tbody></table><p>0时刻：只有P1到达就绪队列，P1上处理机</p><p>7时刻（P1主动放弃CPU）：就绪队列中有P2（响应比=（5+4）/4=2.25）、P3((3 + 1) / 1 =3)、P4((2 + 4)/4 = 1.5），P3的响应比高，所以P3上处理机</p><p>8时刻（P3完成）：P2（2.5），p4（1.75）P2高，P2上处理机</p><p>12时刻（P2完成）：就绪队列中只剩下P4.这时候P4上处理机</p><table><thead><tr><th style="text-align:center">算法</th><th style="text-align:center">可抢占？</th><th style="text-align:center">优点</th><th style="text-align:center">缺点</th><th style="text-align:center">考虑到等待时间&amp;运行时间</th><th style="text-align:center">会导致饥饿？</th></tr></thead><tbody><tr><td style="text-align:center">FCFS</td><td style="text-align:center">非抢占</td><td style="text-align:center">实现简单</td><td style="text-align:center">对短作业不利</td><td style="text-align:center">1，0</td><td style="text-align:center">不会</td></tr><tr><td style="text-align:center">SJF/SPF</td><td style="text-align:center">默认为非抢占式，但也有抢占式</td><td style="text-align:center">最短的平均等待/周转时间</td><td style="text-align:center">对长作业不利，可能导致饥饿；难以做到真正的短作业优先</td><td style="text-align:center">0，1</td><td style="text-align:center">会</td></tr><tr><td style="text-align:center">HRRN</td><td style="text-align:center">非抢占</td><td style="text-align:center">上述两种算法的权衡折中，综合考虑的等待时间和运行时间</td><td style="text-align:center"></td><td style="text-align:center">1，1</td><td style="text-align:center">不会</td></tr></tbody></table><p>注：1为考虑到，0为没有考虑到</p><p><strong>以上这三种算法一般适合于早期的批处理系统。下面的算法适合于交互式系统的调度算法。</strong> </p><h5 id="时间片轮转调度算法"><a href="#时间片轮转调度算法" class="headerlink" title="时间片轮转调度算法"></a>时间片轮转调度算法</h5><p><strong>时间片轮转算法：</strong>公平地、轮流地为各个进程服务，让每个进程在一定时间隔内都可以得到响应。按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms），若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。</p><p>只用于进程调度，只有作业放入内存建立了相应的进程后，才能被分配处理机时间片。该算法也属于抢占式算法，由时钟装置发出时钟中断，来通知CPU时间片已到。轮流让就绪队列中的进程依次执行一个时间片（每次选择的都是排在就绪队列队头的进程）。</p><table><thead><tr><th style="text-align:center">进程</th><th style="text-align:center">到达时间</th><th style="text-align:center">运行时间</th></tr></thead><tbody><tr><td style="text-align:center">P1</td><td style="text-align:center">0</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">P2</td><td style="text-align:center">2</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">P3</td><td style="text-align:center">4</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">P4</td><td style="text-align:center">5</td><td style="text-align:center">6</td></tr></tbody></table><p><img src="/2019/01/05/操作系统之进程调度/操作系统3.png" alt="操作系统3"></p><p>时间片的大小为2。</p><p>0时刻(P1(5)):0时刻只有P1到达就绪队列，让P1上处理机运行一个时间片</p><p>2时刻(P2(4)→P1(3))：2时刻P2到达就绪队列，P1运行完一个时间片，被剥夺处理机，重新放到队尾。此时P2排在队头，因此让P2上处理机。(注意：2时刻，P1下处理机，同一时刻新进程P2到达，如果在题目中遇到这种情况，<strong>默认新到达的进程先进入就绪队列</strong>)</p><p>4时刻(P1(3)→P3(1)→P2(2)):4时刻，P3到达，先插到就绪队尾，紧接着，P2下处理机也插到队尾</p><p>5时刻(P3(1)→P2(2)→P4(6)):5时刻，P4到达插到就绪队尾(注意：由于P1的时间片还没用完，因此P1重新排到就绪队列之后，等到执行)</p><p>6时刻(P3(1)→P2(2)→P4(6)→P1(1)):6时刻，P1时间片用完，下处理机，重新放回就绪队尾，发生调度</p><p>7时刻(P2(2)→P4(6)→P1(1))：虽然P3的时间片没用完，但是由于P3只需运行1个单位的时间，运行完了会主动放弃处理机，因此也会主动放弃处理机，因此也会发生调度。队头进程P2上处理机。</p><p>9时刻(P4(6)→P1(1))：进程P2时间片用完，并刚好运行完，发生调度，P4上处理机</p><p>11时刻(P1(1)→P4(4))：P4时间片用完，重新回到就绪队列，P1上处理机</p><p>12时刻(P4(4))：P1运行完，主动放弃处理机，此时就绪队列中只剩P4，P4上处理机</p><p>14时刻()：就绪队列为空，因此让P4接着运行一个时间片</p><p>16时刻：所有进程运行结束</p><h5 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h5><p><strong>优先级调度算法：</strong>每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程。即可用于作业调度，也可用于进程调度。</p><p><strong>非抢占式：</strong>只需在进程主动放弃处理机时进行调度即可，每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度</p><p><img src="/2019/01/05/操作系统之进程调度/操作系统2.png" alt="操作系统2"></p><p><strong>抢占式：</strong>需要在就绪队列变化时，检查是否会发生抢占。每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度。另外，当就绪队列改变时也需要检查是否会发生抢占。</p><p><img src="/2019/01/05/操作系统之进程调度/操作系统4.png" alt="操作系统4"></p><p>0时刻(P1):只有P1到达，P1上处理机</p><p>2时刻(P2)：P2到达就绪队列，优先级比P1更高，发生抢占。P1回到就绪队列，P2上处理机</p><p>4时刻(P1、P3)：P3到达，优先级比P2更高，P2回到就绪队列，P3抢占处理机</p><p>5时刻(P1、P2、P4):P3完成，主动释放处理机，同时，P4也到达，由于P2比P4更先进入就绪队列，因此选择P2上处理机</p><p>7时刻(P1、P4):P2完成，就绪队列只剩P1、P4，P4上处理机。</p><p>11时刻(P1):P4完成，P1上处理机。</p><p>就绪队列未必只有一个，可以按照不同优先级来组织，另外，也可以把优先级高的进程排在更靠近队头的位置。</p><p>以上就是关于操作系统进程调度的基本定义和算法。毕竟CPU是计算机的核心，它具有对我们的进程进行分配的一个过程。可以看作是OS中关键的部分。比如我们日常生活中又想听歌又想敲代码。这时候我们的CPU就要对我们的这个行为进行一个分配管理。通过一个学期的学习，OS让我更加对计算机和编程有了更大兴趣。也真的更加看到了自己的不足。想真正成为一个大佬还差得十万八千里呢。所以，从现在脚踏实地的做起吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这周学校布置了关于操作系统的知识点论文，正好也写篇博客来好好分析一下关于进程调度的知识点。&lt;/p&gt;
&lt;h4 id=&quot;调度的基本概念&quot;&gt;&lt;a href=&quot;#调度的基本概念&quot; class=&quot;headerlink&quot; title=&quot;调度的基本概念&quot;&gt;&lt;/a&gt;调度的基本概念&lt;/h4&gt;
      
    
    </summary>
    
    
      <category term="操作系统" scheme="https://skrskr66.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>vim操作总结</title>
    <link href="https://skrskr66.github.io/2019/01/03/vim%E6%93%8D%E4%BD%9C%E6%80%BB%E7%BB%93/"/>
    <id>https://skrskr66.github.io/2019/01/03/vim操作总结/</id>
    <published>2019-01-03T14:48:56.000Z</published>
    <updated>2019-01-05T10:08:20.983Z</updated>
    
    <content type="html"><![CDATA[<p>之前学了Linux，用了vim之后发现特别强大。这一周又在做串口实验，我又用的Linux做的，再一次感觉到vim的强大。但是在写代码的过程中，因为快捷键没有记住，所以并不流畅。所以这周闲了，赶快来总结一下。</p><p>首先通过指令    <code>vimtutor</code>        进入到vim新手教程。</p><p>Kana大神说过，对vim的掌握有五个层次：</p><ul><li><p>层次0： 对vim一无所知</p></li><li><p>层次1： 了解vim的基本使用</p></li><li><p>层次2： 知道可视模式</p></li><li><p>层次3： 知道多种移动动作</p></li><li><p>层次4： 不再需要可视模式</p><p>说实话，我目前只能说在层次0.5（哈哈哈哈哈哈哈哈哈）。因为我了解但是基本操作都不记得</p><h4 id="文本基本编辑"><a href="#文本基本编辑" class="headerlink" title="文本基本编辑"></a>文本基本编辑</h4><h5 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h5><p>这个操作比较基础，上下左右的使用，打破了使用方向键的惯性习惯。不是说不能使用方向键，而是编辑器特有的操作方式。</p><p>h：代表光标左移</p><p>l：代表光标右移</p><p>j：代表光标下移</p><p>k：代表光标上移</p><h5 id="进入与退出"><a href="#进入与退出" class="headerlink" title="进入与退出"></a>进入与退出</h5><p>输入vimtutor进入教程，退出或者需要其他指令时，先使用ESC键。然后<code>:q!</code>退出。</p><h5 id="文本删除"><a href="#文本删除" class="headerlink" title="文本删除"></a>文本删除</h5><p>将光标移至需要删除的字符处，按下x键</p><h5 id="文本插入"><a href="#文本插入" class="headerlink" title="文本插入"></a>文本插入</h5><p>将光标移至第一个准备插入字符的位置，按下<code>i</code>键</p><h5 id="文本添加"><a href="#文本添加" class="headerlink" title="文本添加"></a>文本添加</h5><p>将光标移至需要插入的位置，按下<code>a</code>键</p><h5 id="文本保存并退出"><a href="#文本保存并退出" class="headerlink" title="文本保存并退出"></a>文本保存并退出</h5><p>按下ESC进入正常模式，然后<code>:wq</code>按键操作，即可退出并保存。</p><h4 id="删除命令"><a href="#删除命令" class="headerlink" title="删除命令"></a>删除命令</h4><p>使用<code>dw</code>可以从光标处删除至一个单词的结尾</p><p>使用<code>d$</code>可以从当前光标删除至行末</p><p>使用<code>de</code>可以从当前光标删除到单词末尾，包括最后一个字符</p><h5 id="计数动作"><a href="#计数动作" class="headerlink" title="计数动作"></a>计数动作</h5><p>输入<code>2w</code>使光标向前移动两个单词</p><p>输入<code>3e</code>使光标向前移动到第三个单词的末尾</p><p>输入<code>0</code>移动光标到行首</p><h5 id="计数动作删除"><a href="#计数动作删除" class="headerlink" title="计数动作删除"></a>计数动作删除</h5><p>d+number+motion</p><p>例如输入<code>d2w</code>删除光标后面两个单词</p><p>输入<code>dd</code>可以直接删除掉整行</p><p>输入<code>2dd</code>可以直接删除两行</p><h5 id="撤销类命令"><a href="#撤销类命令" class="headerlink" title="撤销类命令"></a>撤销类命令</h5><p><strong>重要的说三遍</strong></p><p><strong>ctrl组合键，按住ctrl不放+操作按键</strong></p><p><strong>ctrl组合键，按住ctrl不放+操作按键</strong></p><p><strong>ctrl组合键，按住ctrl不放+操作按键</strong></p><p>输入<code>x</code>删除字符之后，利用<code>u</code>来撤销最后一次的执行命令（类比于Windows下的ctrl-z）</p><p>利用<code>U</code>恢复该行的原始状态</p><p>利用<code>CTRL-R</code>撤销掉撤销命令（类比于Windows下的crtl-y）</p><h4 id="置入类命令"><a href="#置入类命令" class="headerlink" title="置入类命令"></a>置入类命令</h4><p>输入<code>p</code>将最后一次删除的内容置入光标之后</p><p>将光标移动到需要更改的位置，输入<code>r</code>之后在输入一个我们需要替换的字符，就可以完成更改</p><p>如果要改变文本中的一个单词，先将光标移动到错误单词处，按下<code>cw</code>键，然后输入正确的单词</p><p>如果要改变文本中的更多单词，先将光标移动到错误单词处，按下<code>c$</code>键，然后输入你想输入的</p><h4 id="定位及文件状态"><a href="#定位及文件状态" class="headerlink" title="定位及文件状态"></a>定位及文件状态</h4><h5 id="定位文件关键位置"><a href="#定位文件关键位置" class="headerlink" title="定位文件关键位置"></a>定位文件关键位置</h5><p>按下<code>CTRL-g</code>此时我们在vim编辑框最底部，可以查看到一个状态信息行。记住这个行号！！</p><p>按下<code>gg</code>跳至文件最开头，按下<code>G</code>跳至文件最底部</p><p>输入你想要返回的 <code>行号+G</code>，可以返回第一次按下<code>ctrl-g</code>时所在的行了</p><h5 id="搜索类命令"><a href="#搜索类命令" class="headerlink" title="搜索类命令"></a>搜索类命令</h5><p>跟<code>：</code>命令相似，输入<code>/</code>,加上你所要查找的关键字符，就可以查找到。</p><p>按键<code>n</code>查找同上一个字符，按键<code>N</code>查找同下一个字符（可称为逆向查找）</p><h5 id="配对括号查找（好用）"><a href="#配对括号查找（好用）" class="headerlink" title="配对括号查找（好用）"></a>配对括号查找（好用）</h5><p>输入<code>%</code>可以查找配对的括号)、]、}</p><h5 id="替换命令"><a href="#替换命令" class="headerlink" title="替换命令"></a>替换命令</h5><p>将光标移到需要改变的一行。输入<code>:s/错误字符/修改字符</code>，只替换第一个匹配串</p><p>若是<code>:s/错误字符/修改字符/g</code>替换全行的字符串</p><p>若是<code>:#,#s/错误字符/修改字符</code>#，#代表的是替换若干行的首尾两行</p><p>若是<code>:%s/错误字符/修改字符/g</code>替换整个文件的每个匹配串</p><p>若是<code>:%s/错误字符/修改字符/gc</code>替换整个文件的每个匹配串，但是会进行提示，是否进行替换</p><h4 id="vim内执行外部指令"><a href="#vim内执行外部指令" class="headerlink" title="vim内执行外部指令"></a>vim内执行外部指令</h4><p>输入<code>:!+你所需要的外部指令（LINUX具有的）</code>比如<code>:!dir</code></p><h5 id="对文件的改动保存到文件中"><a href="#对文件的改动保存到文件中" class="headerlink" title="对文件的改动保存到文件中"></a>对文件的改动保存到文件中</h5><p>输入<code>w FILENAME</code>保存到文件中</p><h5 id="可视模式（超关键）"><a href="#可视模式（超关键）" class="headerlink" title="可视模式（超关键）"></a>可视模式（超关键）</h5><p>按 v 键使 Vim 进入可视模式进行选取。您可以四处移动光标使选取区域变大或变小。</p><p>接着您可以使用一个操作符对选中文本进行操作。例如，按 d 键会删除选中的文本内容。</p><h5 id="提取和合并文件"><a href="#提取和合并文件" class="headerlink" title="提取和合并文件"></a>提取和合并文件</h5><p><code>:r FILENAME</code> 可提取磁盘文件 FILENAME 并将其插入到当前文件的光标位置后面。</p><h4 id="打开类命令"><a href="#打开类命令" class="headerlink" title="打开类命令"></a>打开类命令</h4><p>光标移动到想要添加的上一行，按下<code>o</code>键，可以打开新的一行，进行编辑</p><h5 id="附加类命令"><a href="#附加类命令" class="headerlink" title="附加类命令"></a>附加类命令</h5><p>输入 <code>a</code> 将可在光标之后插入文本。</p><p><code>a</code>、<code>i</code> 和 <code>A</code> 都会带您进入插入模式，惟一的区别在于字符插入的位置。</p><h5 id="另一个置换类命令的版本"><a href="#另一个置换类命令的版本" class="headerlink" title="另一个置换类命令的版本"></a>另一个置换类命令的版本</h5><p>移动光标到需要更改的位置，输入按键<code>R</code>，就可以连续更改了，按ESC退出</p><h5 id="复制粘贴文本（绝对是最需要的！！！！！！！！）"><a href="#复制粘贴文本（绝对是最需要的！！！！！！！！）" class="headerlink" title="复制粘贴文本（绝对是最需要的！！！！！！！！）"></a>复制粘贴文本（绝对是最需要的！！！！！！！！）</h5><p>先按键<code>v</code>进入可视模式，对需要复制的部分进行选取。选取完之后，按<code>y</code>进行复制拷贝。</p><p>在移动光标到我们需要复制的位置，按<code>p</code>进行粘贴。</p><h5 id="设置类的选项"><a href="#设置类的选项" class="headerlink" title="设置类的选项"></a>设置类的选项</h5><p>设置可使查找或者替换可忽略大小写的选项</p><p>输入<code>:set ic</code>可以忽略大小写。输入<code>:set noic</code>禁用大小写</p><p>输入<code>:set incsearch</code>,查找短语时显示部分匹配</p><p>输入<code>:set hlsearch</code>,高亮显示所有的匹配短语</p><h4 id="关于vim"><a href="#关于vim" class="headerlink" title="关于vim"></a>关于vim</h4><p>获取帮助，输入<code>:help</code>或者按下F1。</p><h5 id="创建启动脚本"><a href="#创建启动脚本" class="headerlink" title="创建启动脚本"></a>创建启动脚本</h5><p>Vim 的功能特性要比 Vi 多得多，但其中大部分都没有缺省启用。为了使用更多的特性，您得创建一个vimrc 文件。</p><p>开始编辑 vimrc 文件，具体命令取决于您所使用的操作系统：</p><pre><code>`:edit ~/.vimrc`          这是 Unix 系统所使用的命令`:edit $VIM/_vimrc `    这是 MS-Windows 系统所使用的命令</code></pre><p>接着读取 vimrc 示例文件的内容：<code>:r $VIMRUNTIME/vimrc_example.vim</code></p><p>保存文件，命令为：<code>:write</code></p></li></ul><p>以上就是vim的基本操作。这些掌握了，用起来就特别方便啦。还是那句话，操作不能靠背的。需要多练。换句话说，多敲代码就行啦！！！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前学了Linux，用了vim之后发现特别强大。这一周又在做串口实验，我又用的Linux做的，再一次感觉到vim的强大。但是在写代码的过程中，因为快捷键没有记住，所以并不流畅。所以这周闲了，赶快来总结一下。&lt;/p&gt;
&lt;p&gt;首先通过指令    &lt;code&gt;vimtutor&lt;/
      
    
    </summary>
    
    
      <category term="Linux" scheme="https://skrskr66.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>初阶C-1201</title>
    <link href="https://skrskr66.github.io/2019/01/01/%E5%88%9D%E9%98%B6C-1201/"/>
    <id>https://skrskr66.github.io/2019/01/01/初阶C-1201/</id>
    <published>2019-01-01T12:59:16.000Z</published>
    <updated>2019-01-01T15:10:30.463Z</updated>
    
    <content type="html"><![CDATA[<p>1.调整数组使奇数全部都位于偶数前面。</p><p>题目：输入一个整数数组，实现一个函数，来调整该数组中数字的顺序使得数组中所有的奇数位于数组的前半部分，所有偶数位于数组的后半部分。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse_array</span><span class="params">(<span class="keyword">int</span> a[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="comment">//数组的两头分别向中间检索</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">        <span class="comment">//从左开始查找数是偶数的</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; (a[left] % <span class="number">2</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从右开始查找是奇数的</span></span><br><span class="line">        <span class="keyword">while</span>(right &lt; left &amp;&amp; (a[right] % <span class="number">2</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            a[left] = a[left] ^ a[right];</span><br><span class="line">            a[right] = a[left] ^ a[right];</span><br><span class="line">            a[left] = a[left] ^ a[right];</span><br><span class="line">            <span class="comment">//利用异或的方式进行交换数</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.杨氏矩阵有一个二维数组. </p><p>数组的每行从左到右是递增的,每列从上到下是递增的. 在这样的数组中查找一个数字是否存在.</p><p>时间复杂度小于O(N);   数组： </p><p>1 2 3      /    1 3 4    /    1 2 3</p><p>2 3 4      /    2 4 5    /    4 5 6</p><p>3 4 5        /    4 5 6    /    7 8 9</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//从右上角开始搜索</span></span><br><span class="line">    <span class="comment">//key &gt; a[i][j]  --&gt; 向左搜索</span></span><br><span class="line">    <span class="comment">//key &lt; a[i][j]  --&gt; 向下搜索</span></span><br><span class="line">    <span class="comment">//从左下角开始搜索</span></span><br><span class="line">    <span class="comment">//key &lt; a[i][j]  --&gt; 向右搜索</span></span><br><span class="line">    <span class="comment">//key &gt; a[i][j]  --&gt; 向上搜索</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> px, py;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">if</span> (find(a, <span class="number">3</span>, <span class="number">3</span>, n, &amp;px, &amp;py))&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d,%d"</span>, px, py);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">3</span>],<span class="keyword">int</span> row,<span class="keyword">int</span> col,<span class="keyword">int</span> key,<span class="keyword">int</span> *px,<span class="keyword">int</span> *py)</span></span>&#123;</span><br><span class="line">    <span class="comment">//从右上角开始搜索</span></span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> y = col - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//左下角搜索结束</span></span><br><span class="line">    <span class="comment">//x &gt;= row;y &lt; 0;</span></span><br><span class="line">    <span class="keyword">while</span>(x &lt; row &amp;&amp; y &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[x][y] == key)&#123;</span><br><span class="line">            *px = x;</span><br><span class="line">            *py = y;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(a[x][y] &gt; key)&#123;</span><br><span class="line">            <span class="comment">//向左搜索</span></span><br><span class="line">            y--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            x++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    *px = <span class="number">-1</span>;</span><br><span class="line">    *py = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果都没有搜索到，就将其赋予一个不存在的值，直接返回0；</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_r</span><span class="params">(<span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">3</span>],<span class="keyword">int</span> row,<span class="keyword">int</span> col,<span class="keyword">int</span> x,<span class="keyword">int</span> y,<span class="keyword">int</span> key,<span class="keyword">int</span> *px,<span class="keyword">int</span> *py)</span></span>&#123;</span><br><span class="line">    <span class="comment">//从左下角开始搜索,利用递归的写法</span></span><br><span class="line">    <span class="comment">//因为是递归循环，所以没有循环，我们需要记住此时是在哪个位置</span></span><br><span class="line">    <span class="comment">//所以我们定义了参数x，y</span></span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">0</span> || y &gt; col)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(key &gt; a[x][y])&#123;</span><br><span class="line">        <span class="keyword">return</span> find_r(a, row, col, x, y + <span class="number">1</span>, key, px, py);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key &lt; a[x][y])&#123;</span><br><span class="line">        <span class="keyword">return</span> find_r(a, row, col, x - <span class="number">1</span>, y, key, px, py);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key == a[x][y])&#123;</span><br><span class="line">        *px = x;</span><br><span class="line">        *py = y;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初阶C已结束！接下来就是进阶了！加油！一定要完成自我的进化！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.调整数组使奇数全部都位于偶数前面。&lt;/p&gt;
&lt;p&gt;题目：输入一个整数数组，实现一个函数，来调整该数组中数字的顺序使得数组中所有的奇数位于数组的前半部分，所有偶数位于数组的后半部分。  &lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr
      
    
    </summary>
    
    
      <category term="C初阶" scheme="https://skrskr66.github.io/tags/C%E5%88%9D%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>python-对豆瓣的top250的爬取(利用正则表达式)</title>
    <link href="https://skrskr66.github.io/2018/12/10/python-%E5%AF%B9%E8%B1%86%E7%93%A3%E7%9A%84top250%E7%9A%84%E7%88%AC%E5%8F%96/"/>
    <id>https://skrskr66.github.io/2018/12/10/python-对豆瓣的top250的爬取/</id>
    <published>2018-12-10T14:22:36.000Z</published>
    <updated>2018-12-23T17:24:51.919Z</updated>
    
    <content type="html"><![CDATA[<p>之前写了一个猫眼的爬虫的代码。是利用了request()和beautifulsoup()。但是之前的方法是利用了selector的搜索方法。最近学习了一点正则表达式，用正则表达式对豆瓣的top250进行了尝试。</p><p>豆瓣一直都是我比较喜欢的一个app，我也很喜欢看电影，你如果喜欢，在我的博客里有我的豆瓣链接，我们可以互粉一下聊聊电影hhhhhh，看得不多，但坚持再看并且写影评。</p><p>这次爬取下来top250的数据也非常高兴。</p><h4 id="正则表达式的定义"><a href="#正则表达式的定义" class="headerlink" title="正则表达式的定义"></a>正则表达式的定义</h4><p><strong>正则表达式</strong>，又称规则表达式<strong>。</strong>（英语：Regular Expression，在代码中常简写为regex、regexp或RE），计算机科学的一个概念。正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br></pre></td></tr></table></figure><p>python如果要使用正则表达式，首先需要引用re库</p><p>re库是一个python中有关于正则表达式的第三方库。因为我们在匹配过程中，也需要一些函数来剔除我们不需要的冗余字符。</p><h4 id="正则表达式常用操作符-1"><a href="#正则表达式常用操作符-1" class="headerlink" title="正则表达式常用操作符(1)"></a><strong>正则表达式常用操作符(1)</strong></h4><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">说明</th><th style="text-align:center">实例</th></tr></thead><tbody><tr><td style="text-align:center">.</td><td style="text-align:center">表示任何单个字符</td><td style="text-align:center">比如在非贪婪匹配中(.*?)</td></tr><tr><td style="text-align:center">[  ]</td><td style="text-align:center">字符集，对单个字符给出取值范围</td><td style="text-align:center">[abc]表示a/b/c，[a-z]表示a到z的单个字符</td></tr><tr><td style="text-align:center">[^  ]</td><td style="text-align:center">非字符集，对单个字符给出排除范围</td><td style="text-align:center">[^abc]表示非a非b非c的单个字符</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">前一个字符0次或无限次扩展</td><td style="text-align:center">abc*表示为ab/abc/abccc</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">前一个字符1次或无限次扩展</td><td style="text-align:center">abc+表示abc/abcc/abccc</td></tr><tr><td style="text-align:center">?</td><td style="text-align:center">前一个字符0次或1次扩展</td><td style="text-align:center">abc？表示ab/abc</td></tr><tr><td style="text-align:center">&#124;</td><td style="text-align:center">左右表达式的任意一个</td><td style="text-align:center">abc &#124; def表示 abc、def</td></tr></tbody></table><h4 id="正则表达式的常用操作符-2"><a href="#正则表达式的常用操作符-2" class="headerlink" title="正则表达式的常用操作符(2)"></a>正则表达式的常用操作符(2)</h4><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">说明</th><th style="text-align:center">实例</th></tr></thead><tbody><tr><td style="text-align:center">{m}</td><td style="text-align:center">扩展前一个字符m次</td><td style="text-align:center">ab{2}c表示abbc</td></tr><tr><td style="text-align:center">{m,n}</td><td style="text-align:center">扩展前一个字符m至n次（含n）</td><td style="text-align:center">ab{1,2}c表示abc、abbc</td></tr><tr><td style="text-align:center">^</td><td style="text-align:center">匹配字符串开头</td><td style="text-align:center">^abc表示abc且在一个字符串的开头</td></tr><tr><td style="text-align:center">$</td><td style="text-align:center">匹配字符串结尾</td><td style="text-align:center">abc$表示abc且在一个字符串的结尾</td></tr><tr><td style="text-align:center">( )</td><td style="text-align:center">分组标记，内部只能使用 &#124; 操作符</td><td style="text-align:center">(abc)表示abc,(abc &#124; def)表示abc、def</td></tr><tr><td style="text-align:center">\d</td><td style="text-align:center">数字，等价于[0-9]</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">\w</td><td style="text-align:center">单词字符，等价于[A-Za-z0-9_]</td></tr></tbody></table><table><thead><tr><th style="text-align:center">常用标记</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">re.I        re.IGNORECASE</td><td style="text-align:center">忽略正则表达式中的大小写，[A-Z]能够匹配小写字符</td></tr><tr><td style="text-align:center">re.M        re.MULTILINE</td><td style="text-align:center">正则表达式中的^操作符能够将给定字符串的每行当作匹配开始</td></tr><tr><td style="text-align:center">re.S        re.DOTALL</td><td style="text-align:center">正则表达式中的.操作符能够匹配所有字符，默认匹配除了换行以外的所有字符</td></tr></tbody></table><p>以上这些常用的操作符对于爬虫来说是足够的了，我们还需要的是怎么去使用去让其匹配。</p><p>正则表达式的练习我用的是<strong>anaconda中的jupyter</strong>进行练习。</p><h4 id="几种常见的匹配方式"><a href="#几种常见的匹配方式" class="headerlink" title="几种常见的匹配方式"></a>几种常见的匹配方式</h4><p>首先引用这个库，常规操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br></pre></td></tr></table></figure><h5 id="最常规匹配"><a href="#最常规匹配" class="headerlink" title="最常规匹配"></a>最常规匹配</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">content=<span class="string">'Hello 123 4567 World_This is a Regex Demo'</span></span><br><span class="line">print(len(content))</span><br><span class="line">result=re.match(<span class="string">'^Hello\s\d\d\d\s\d&#123;4&#125;\s\w&#123;10&#125;.*Demo$'</span>,content)</span><br><span class="line">print(result)</span><br><span class="line">print(result.group())<span class="comment">#group()表示取全部匹配的字符串或者指定的组，返回结果是一个字符串</span></span><br><span class="line">print(result.span())<span class="comment">#span()表示返回一个元组包含匹配 (开始,结束) 的位置</span></span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">41</span></span><br><span class="line">&lt;re.Match object; span=(<span class="number">0</span>, <span class="number">41</span>), match=<span class="string">'Hello 123 4567 World_This is a Regex Demo'</span>&gt;</span><br><span class="line">Hello <span class="number">123</span> <span class="number">4567</span> World_This <span class="keyword">is</span> a Regex Demo</span><br><span class="line">(<span class="number">0</span>, <span class="number">41</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#这是最常规的匹配，将每一个字符都用操作符</span></span><br><span class="line"><span class="comment">#\s 是一个匹配空格 \d 匹配数字 \d&#123;4&#125; 匹配一串数字</span></span><br><span class="line"><span class="comment">#.*Demo$ 点用于匹配之前的 *作为前一个字符的匹配与'点'一起 最后用$作为一个匹配字符串的结尾</span></span><br></pre></td></tr></table></figure><h5 id="泛匹配"><a href="#泛匹配" class="headerlink" title="泛匹配"></a>泛匹配</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">content = <span class="string">'Hello 123 4567 World_This is a Regex Demo'</span></span><br><span class="line">result = re.match(<span class="string">'^Hello.*Demo$'</span>,content)</span><br><span class="line">print(result)</span><br><span class="line">print(result.group())</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;re.Match object; span=(<span class="number">0</span>, <span class="number">41</span>), match=<span class="string">'Hello 123 4567 World_This is a Regex Demo'</span>&gt;</span><br><span class="line">Hello <span class="number">123</span> <span class="number">4567</span> World_This <span class="keyword">is</span> a Regex Demo</span><br><span class="line"></span><br><span class="line"><span class="comment">#泛匹配就比较省略，有前面和后面的字符就行，中间的不需要也可以</span></span><br></pre></td></tr></table></figure><h5 id="匹配目标"><a href="#匹配目标" class="headerlink" title="匹配目标"></a>匹配目标</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">content = <span class="string">'Hello 1234567 World_This is a Regex Demo'</span></span><br><span class="line">result = re.match(<span class="string">'^Hello\s(\d+)\sWorld.*Demo$'</span>,content)</span><br><span class="line">print(result)</span><br><span class="line">print(result.group(<span class="number">1</span>))<span class="comment">#为了看看匹配的分组中是否是我所需要的</span></span><br><span class="line">print(result.span())</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;re.Match object; span=(<span class="number">0</span>, <span class="number">40</span>), match=<span class="string">'Hello 1234567 World_This is a Regex Demo'</span>&gt;</span><br><span class="line"><span class="number">1234567</span></span><br><span class="line">(<span class="number">0</span>, <span class="number">40</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#(\d+) \d表示数字, + 表示一个或多个，括号就是将其作为一个分组</span></span><br></pre></td></tr></table></figure><p>接着是两个比较关键的匹配方法</p><h5 id="贪婪匹配"><a href="#贪婪匹配" class="headerlink" title="贪婪匹配"></a>贪婪匹配</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">content = <span class="string">'Hello 1234567 World_This is a Regex Demo'</span></span><br><span class="line">result = re.match(<span class="string">'^He.*(\d+).*Demo$'</span>,content)</span><br><span class="line">print(result)</span><br><span class="line">print(result.group(<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;re.Match object; span=(<span class="number">0</span>, <span class="number">40</span>), match=<span class="string">'Hello 1234567 World_This is a Regex Demo'</span>&gt;</span><br><span class="line"><span class="number">7</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#Python里数量词默认是贪婪的（在少数语言里也可能是默认非贪婪），总是尝试匹配尽可能多的字符</span></span><br><span class="line"><span class="comment">#贪婪模式下字符串查找会直接走到字符串结尾去匹配，如果不相等就向前寻找，这一过程称为回溯。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#上面的例子可以看出 .* 这样的前后搭配匹配 可以前后尝试尽可能多的匹配字符</span></span><br></pre></td></tr></table></figure><h5 id="非贪婪匹配"><a href="#非贪婪匹配" class="headerlink" title="非贪婪匹配"></a>非贪婪匹配</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">content = <span class="string">'Hello 1234567 World_This is a Regex Demo'</span></span><br><span class="line">result = re.match(<span class="string">'^He.*?(\d+).*Demo$'</span>,content)</span><br><span class="line">print(result)</span><br><span class="line">print(result.group(<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;re.Match object; span=(<span class="number">0</span>, <span class="number">40</span>), match=<span class="string">'Hello 1234567 World_This is a Regex Demo'</span>&gt;</span><br><span class="line"><span class="number">1234567</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#非贪婪则相反，总是尝试匹配尽可能少的字符。在"*","?","+","&#123;m,n&#125;"后面加上？，使贪婪变成非贪婪。</span></span><br><span class="line"><span class="comment">#非贪婪模式下会自左向右查找，一个一个匹配不会出现回溯的情况。</span></span><br></pre></td></tr></table></figure><h5 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">content = <span class="string">'''Hello 1234567 World_This</span></span><br><span class="line"><span class="string">is a Regex Demo</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line">result = re.match(<span class="string">'^He.*?(\d+).*?Demo'</span>,content,re.S)</span><br><span class="line">print(result.group(<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>匹配模式主要利用了re库中的re.S参数，这样就可以将字符串作为一个整体，在整体中进行匹配。</p><p>以上就是关于正则表达式的基本知识。看一下例子，知道大概就足够了。</p><h4 id="豆瓣的正则表达式"><a href="#豆瓣的正则表达式" class="headerlink" title="豆瓣的正则表达式"></a>豆瓣的正则表达式</h4><p><img src="/2018/12/10/python-对豆瓣的top250的爬取/douban1.png" alt="douban1"></p><p>首先进入豆瓣的top250排行榜，我们首先能看到的就是关于电影的内容。利用chrome浏览器右击检查打开审查元素，我们来观察一下这个网页的html大概构成。</p><p><img src="/2018/12/10/python-对豆瓣的top250的爬取/douban2.png" alt="douban2"></p><p>我们将鼠标放到li标签上，可以看到左侧的一片区域都被标记了。说明这一块都是有关《肖申克的救赎》。</p><p><img src="/2018/12/10/python-对豆瓣的top250的爬取/douban3.png" alt="douban3"></p><p>一步一步点开这个标签我们将鼠标放到每一个标签之上能看到，每一个标签都有一个与之对应的区域，这个时候我们就需要使用这些标签来构建正则表达式。</p><p>我们从每一个标签自上而下看下来。</p><p>依次是名次 片名 职员表 类型 星级 评价人数 热门短评这几个</p><p>比如名次去匹配</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'&lt;em class=""&gt;(\d+)&lt;/em&gt;'</span></span><br><span class="line"><span class="comment">#因为名次是用数字表示的，先将一个标签内的数字用(\d+)来表示</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'&lt;em class=""&gt;(\d+)&lt;/em&gt;.*?&lt;span class=title"&gt;(.*?)&lt;/span&gt;'</span></span><br><span class="line"><span class="comment">#当第一个标签完成之后，根据非贪婪匹配的规则 .*? 这样继续根据HTML标签的镶嵌继续向下搜寻。直到span标签结束。中间括号是我们需要匹配的内容</span></span><br></pre></td></tr></table></figure><p>正则表达式的使用还是很简单的，只要找到我们需要的内容，利用非贪婪匹配进行前后选择就好了</p><p>下面的是一个已经匹配好的正则表达式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'&lt;em class=""&gt;(\d+)&lt;/em&gt;.*?&lt;span class="title"&gt;(.*?)&lt;/span&gt;.*?&lt;p class=""&gt;(.*?)&lt;/p&gt;.*?&lt;span class="rating_num" property="v:average"&gt;(.*?)&lt;/span&gt;.*?&lt;span&gt;(.*?)&lt;/span&gt;.*?&lt;span class="inq"&gt;(.*?)&lt;/span&gt;'</span></span><br></pre></td></tr></table></figure><h4 id="代码获取内容"><a href="#代码获取内容" class="headerlink" title="代码获取内容"></a>代码获取内容</h4><p>接下来的步骤就与我之前的一篇博文的内容很相似了</p><p><a href="https://skrskr66.coding.me/2018/11/26/python-%E5%AF%B9%E7%8C%AB%E7%9C%BC%E7%BD%91%E7%9A%84top100%E7%9A%84%E7%88%AC%E5%8F%96/#more" target="_blank" rel="noopener">python-对猫眼网的top100的爬取</a></p><p>首先需要定义一个函数去获取页面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">from</span> requests.exceptions <span class="keyword">import</span> RequestException</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment">#得到网页源代码</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_one_page</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        res=resquest.get(url)</span><br><span class="line">        <span class="keyword">if</span> res.status_code==<span class="number">200</span>:</span><br><span class="line">            <span class="keyword">return</span> res.text</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">except</span> RequestException:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure><p>得到了网页源代码之后，需要利用正则表达式去匹配出我们需要的内容，并将它们放入到一个字典中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pares_one_html</span><span class="params">(html)</span>:</span></span><br><span class="line">    regex=<span class="string">'&lt;em class=""&gt;(\d+)&lt;/em&gt;.*?&lt;span class="title"&gt;(.*?)&lt;/span&gt;.*?&lt;p class=""&gt;(.*?)&lt;/p&gt;.*?&lt;span class="rating_num" property="v:average"&gt;(.*?)&lt;/span&gt;.*?&lt;span&gt;(.*?)&lt;/span&gt;.*?&lt;span class="inq"&gt;(.*?)&lt;/span&gt;'</span></span><br><span class="line">    pattern=re.compile(regex,re.S)<span class="comment">#re.compile()编译正则表达式模式</span></span><br><span class="line">    items=re.findall(pattern,html)<span class="comment">#返回的是一个list对象</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:</span><br><span class="line">        content=<span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> every_list <span class="keyword">in</span> item[<span class="number">2</span>].split():</span><br><span class="line">            <span class="comment">#split()通过指定分隔符对字符串进行切片，因为职员表处有些标签需要我们进行处理</span></span><br><span class="line">            content=content+<span class="string">""</span>.join(every_list)</span><br><span class="line">        content=re.sub(<span class="string">'&amp;nbsp;'</span>,<span class="string">' '</span>,content)</span><br><span class="line">        content=re.sub(<span class="string">'&lt;br&gt;'</span>,<span class="string">' '</span>,content)</span><br><span class="line">        <span class="comment">#删除空格和&lt;br&gt;这些多余的部分</span></span><br><span class="line">        <span class="comment">#将获取到的list放到dict字典中</span></span><br><span class="line">        dict=&#123;</span><br><span class="line">            <span class="string">"index"</span>:item[<span class="number">0</span>],</span><br><span class="line">            <span class="string">"name"</span>:item[<span class="number">1</span>],</span><br><span class="line">            <span class="string">"describe"</span>:content,</span><br><span class="line">            <span class="string">"star"</span>:item[<span class="number">3</span>],</span><br><span class="line">            <span class="string">"evaluate"</span>:item[<span class="number">4</span>],</span><br><span class="line">            <span class="string">"title"</span>:item[<span class="number">5</span>]</span><br><span class="line">        &#125;</span><br><span class="line">        print(dict)</span><br><span class="line">        <span class="comment">#此时先打印看一下，是否数据是正确的</span></span><br><span class="line">        <span class="comment">#将数据写入文本中</span></span><br><span class="line">        <span class="keyword">with</span> open(<span class="string">'doubanMovie.txt'</span>,<span class="string">'a'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(json.dumps(dict,ensure_ascii=<span class="keyword">False</span>)+<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure><p>此时还有两个问题，我们此时只是能将第一个页面的数据爬取下来，这时候我们得分析一下这个url在切换页面时，它是怎么变化的。</p><p><img src="/2018/12/10/python-对豆瓣的top250的爬取/douban4.png" alt="douban4"></p><p><img src="/2018/12/10/python-对豆瓣的top250的爬取/douban5.png" alt="douban5"></p><p><a href="https://movie.douban.com/top250这是豆瓣top250的第一页" target="_blank" rel="noopener">https://movie.douban.com/top250这是豆瓣top250的第一页</a></p><p>转到第二页，第三页可以看到网页的变化</p><p><a href="https://movie.douban.com/top250?start=25&amp;filter=" target="_blank" rel="noopener">https://movie.douban.com/top250?start=25&amp;filter=</a>  第二页</p><p><a href="https://movie.douban.com/top250?start=50&amp;filter=" target="_blank" rel="noopener">https://movie.douban.com/top250?start=50&amp;filter=</a>  第三页</p><p>url中的参数start={} 这个数在不断的变化，而且规律是每次隔25个，说明这就是我们需要的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    urls=[<span class="string">'https://movie.douban.com/top250?start=&#123;&#125;&amp;filter='</span>.format(str(i)) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">250</span>,<span class="number">25</span>)]</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        html=get_one_page(url)</span><br><span class="line">        parse_one_html(html)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>最后将url放在一个列表中，利用for循环去将所有这些网页循环将数据爬取出来。</p><p>最后展示一下</p><p><img src="/2018/12/10/python-对豆瓣的top250的爬取/douban6.png" alt="douban6"></p><p><img src="/2018/12/10/python-对豆瓣的top250的爬取/douban7.png" alt="douban7"></p><p>python的学习中，爬虫只要有了基本的知识之后就可以慢慢尝试了，而且我觉得爬虫是最容易有自豪感的。</p><p>之前对猫眼的爬取用到了基本的Requests和beautifulsoup，接下来还会在写一篇关于Scrapy的基础知识，这个我认为是爬虫的总统山…但是我也还在摸索中</p><p>接着刷电影去了….(●’◡’●)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前写了一个猫眼的爬虫的代码。是利用了request()和beautifulsoup()。但是之前的方法是利用了selector的搜索方法。最近学习了一点正则表达式，用正则表达式对豆瓣的top250进行了尝试。&lt;/p&gt;
&lt;p&gt;豆瓣一直都是我比较喜欢的一个app，我也很喜欢看
      
    
    </summary>
    
    
      <category term="python-爬虫" scheme="https://skrskr66.github.io/tags/python-%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
  <entry>
    <title>初阶C-1124</title>
    <link href="https://skrskr66.github.io/2018/12/06/%E5%88%9D%E9%98%B6C-1124/"/>
    <id>https://skrskr66.github.io/2018/12/06/初阶C-1124/</id>
    <published>2018-12-06T13:59:28.000Z</published>
    <updated>2018-12-06T16:35:35.141Z</updated>
    
    <content type="html"><![CDATA[<p>1.编写函数：  unsigned int reverse_bit(unsigned int value);  </p><p>这个函数的返回值value的二进制位模式从左到右翻转后的值。   </p><p>如：  在32位机器上    25这个值包含下列各位：  </p><p>00000000000000000000000000011001  翻转后：（2550136832）          </p><p>10011000000000000000000000000000  程序结果返回：  2550136832 </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">reverse_bit</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line">    <span class="comment">//第一种方法</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">32</span>;i++)&#123;</span><br><span class="line">        sum = sum + ((value &gt;&gt; i) &amp; <span class="number">1</span>) * <span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">31</span> - i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">    <span class="comment">//输入任意一个数，进行移位操作并且移位一次还要和1进行一次与操作，这个时候判断最后一个位是1还是0。</span></span><br><span class="line">    <span class="comment">//当判断完之后，进行乘方</span></span><br><span class="line">    <span class="comment">//第一个数 ----&gt; 32位   2^31</span></span><br><span class="line">    <span class="comment">//第二个数 ----&gt; 32位   2^30</span></span><br><span class="line">    <span class="comment">//对每一位的数进行了判断之后(判断是为1还是为0)，乘以它的方就是将其转换放在翻转后的位置</span></span><br><span class="line">    <span class="comment">//全部相加之后，就是每个翻转之后的位置</span></span><br><span class="line">    <span class="comment">//第二种方法</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">31</span>;i++)&#123;</span><br><span class="line">        temp = temp &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        temp = temp | ((value &gt;&gt; i) &amp; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">    <span class="comment">//将每一个最后位都取出来</span></span><br><span class="line">    <span class="comment">//放在新建变量的最后一位</span></span><br><span class="line">    <span class="comment">//左移新建变量temp</span></span><br><span class="line">    <span class="comment">//我们可以这样理解，我们取出一个变量。让这个变量每次向左移动。这样每次左移之后它的位数都在增加，但是增加之后，仅仅只是增加了位数，具体值的判断再由下一步</span></span><br><span class="line">    <span class="comment">//还是依旧判断最后一位是否为1，判断是否为1之后再去与变量进行 或运算。如果是1，那么与完之后的结果为1.否则与完之后的结果为0.并不冲突。位数再增加，但是每次增加的位数还是要进行判断是0还是1.最后将这个变量返回。即为翻转之后的数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.不使用（a+b）/2这种方式，求两个数的平均值。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avg</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">int</span> num;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"enter tow numbers\n"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>,&amp;i,&amp;j);</span><br><span class="line">    num = (i &amp; j) + (i ^ j) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,num);</span><br><span class="line">    <span class="comment">//不用最常规的写法，那么就是以二进制的角度来思考。</span></span><br><span class="line">    <span class="comment">//二进制去求平均数。那么就是让每一位都进行一个求其平均</span></span><br><span class="line">    <span class="comment">//&amp; 用来判断相同位的平均值， ^ 用来判断不同位的平均值(不同位进行^运算之后，得的是不同位的值，这时候将其除以2得到的就是不同位的平均值)</span></span><br><span class="line">    <span class="comment">//之后将它们相加之后，得到就是二进制下的平均数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.编程实现：  一组数据中只有一个数字出现了一次。其他所有数字都是成对出现的。  请找出这个数字。（使用位运算） </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">find_num</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">9</span>] = &#123; <span class="number">5</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">9</span> &#125;;</span><br><span class="line">    <span class="keyword">int</span> len = <span class="keyword">sizeof</span>(arr)/<span class="keyword">sizeof</span>(arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; len;i++)&#123;</span><br><span class="line">        arr[<span class="number">0</span>] = arr[<span class="number">0</span>] ^ arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>,arr[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">//连续异或，偶数位的最后异或还是为0，但是奇数位的异或最后为1</span></span><br><span class="line">    <span class="comment">//所以最后可能出现的只是单独出现的的位数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.有一个字符数组的内容为:”student a am i”,  请你将数组的内容改为”i am a student”.  </p><p>要求：  不能使用库函数。  只能开辟有限个空间（空间个数和字符串的长度无关）。   </p><p>student a am i </p><p> i ma a tneduts </p><p> i am a student  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mystrlen</span><span class="params">(<span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line">    <span class="comment">//判断字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(*str++)&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//字符串判定长度，设置的形参为char类型的指针，一个字符串的长度始终都在变化</span></span><br><span class="line"><span class="comment">//在输出时，系统先输出字符指针指向的第一个字符数据，然后使指针加1，使之指向下一个，然后再输出……直至遇到字符'\0‘，结束。所以给while的判断是 *str++，指针一个一个的走判断。</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//逆转指定范围的字符串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse_string</span><span class="params">(<span class="keyword">char</span>* start,<span class="keyword">char</span>* end)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">        <span class="comment">//比如classmate start的字符为‘c’，end的字符则为‘e’</span></span><br><span class="line">        <span class="keyword">char</span> temp = *start;</span><br><span class="line">        *start = *end;</span><br><span class="line">        *end = temp;</span><br><span class="line">        start++;<span class="comment">//字符串指向的位置，从开始不断向后</span></span><br><span class="line">        end--;<span class="comment">//才指定范围的字符串，从结尾不断向前</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span>* str)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = mystrlen(str);</span><br><span class="line">    <span class="keyword">char</span>* start = str;</span><br><span class="line">    <span class="keyword">char</span>* end = str + len - <span class="number">1</span>;   <span class="comment">//  len-1是不包括‘\0’</span></span><br><span class="line">    <span class="keyword">char</span>* cur = str;</span><br><span class="line">    <span class="comment">//整体逆转一次</span></span><br><span class="line">    reverse_string(start,end);</span><br><span class="line">    <span class="comment">//局部逆转</span></span><br><span class="line">    <span class="keyword">while</span>(*cur != <span class="string">'\0'</span>)&#123;</span><br><span class="line">        <span class="keyword">char</span>* st = cur;</span><br><span class="line">        <span class="comment">//寻找子串的尾点</span></span><br><span class="line">        <span class="keyword">while</span>(*cur != <span class="string">' '</span> &amp;&amp; *cur != <span class="string">'\0'</span>)&#123;</span><br><span class="line">            cur++;<span class="comment">//cur作为一个尾点，我们去寻找cur具体到哪个位置，当为‘ ’和‘\0’之前的一个位置将它作为end，cur最开始的作为st，这样局部的前后就有了，可以交换一次。</span></span><br><span class="line">        &#125;</span><br><span class="line">        reverse_string(st,cur<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">while</span>(*cur == <span class="string">' '</span>)&#123;</span><br><span class="line">            cur++;<span class="comment">//在指针走的过程中，如果遇到了' '，则使其跳过，因为这样将不用再去将' '逆转一次。否则会有多余的步骤。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感觉初阶到了后期难度一下就上来了。考试周结束后，还是得好好敲代码啊。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.编写函数：  unsigned int reverse_bit(unsigned int value);  &lt;/p&gt;
&lt;p&gt;这个函数的返回值value的二进制位模式从左到右翻转后的值。   &lt;/p&gt;
&lt;p&gt;如：  在32位机器上    25这个值包含下列各位：  &lt;/p
      
    
    </summary>
    
    
      <category term="C初阶" scheme="https://skrskr66.github.io/tags/C%E5%88%9D%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>数据结构之链表</title>
    <link href="https://skrskr66.github.io/2018/12/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%93%BE%E8%A1%A8/"/>
    <id>https://skrskr66.github.io/2018/12/02/数据结构之链表/</id>
    <published>2018-12-02T14:52:42.000Z</published>
    <updated>2018-12-05T00:28:16.800Z</updated>
    
    <content type="html"><![CDATA[<h2 id="链表的定义"><a href="#链表的定义" class="headerlink" title="链表的定义"></a>链表的定义</h2><p>链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 相比于线性表顺序结构，操作复杂。 （百度）</p><p>链表：一种链式存储的线性表，用一组地址任意的存储单元存放线性表的数据元素，称存储单元为一个结点。</p><p><strong>链表的形式：结点地址{data，next}</strong></p><p>链表的形式基本知道后，链表的使用离不开指针。关于<strong>指针</strong> 和 <strong>指针指向的空间</strong> 是有区别的</p><p>指针不能看成是一个地址，指针是用来存放地址的。指针指向的空间不是地址，是一个还未使用开辟出来的空间。</p><p><strong>链表里的结构体</strong>与<strong>顺序表的结构体</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;链表的定义&quot;&gt;&lt;a href=&quot;#链表的定义&quot; class=&quot;headerlink&quot; title=&quot;链表的定义&quot;&gt;&lt;/a&gt;链表的定义&lt;/h2&gt;&lt;p&gt;链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结
      
    
    </summary>
    
    
      <category term="C-数据结构" scheme="https://skrskr66.github.io/tags/C-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>初阶C-1121</title>
    <link href="https://skrskr66.github.io/2018/11/27/%E5%88%9D%E9%98%B6C-1121/"/>
    <id>https://skrskr66.github.io/2018/11/27/初阶C-1121/</id>
    <published>2018-11-27T12:17:13.000Z</published>
    <updated>2018-11-27T12:21:32.726Z</updated>
    
    <content type="html"><![CDATA[<p>1.写一个函数返回参数二进制中 1 的个数 ，比如：15   —&gt;   0000 1111 中4个1。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">count_one_bits</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> count  = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (((value &gt;&gt; i) &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, count);</span><br><span class="line"><span class="comment">// 返回 1的位数 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.获取一个数二进制序列中所有的偶数位和奇数位,分别输出二进制序列。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Print_col</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>&#123;</span><br><span class="line"><span class="comment">//二进制的奇偶数位是从低位0123456开始算起</span></span><br><span class="line"><span class="keyword">int</span> odd;<span class="comment">//奇数</span></span><br><span class="line"><span class="keyword">int</span> even;<span class="comment">//偶数</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"偶数的序列:"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i += <span class="number">2</span>)&#123;</span><br><span class="line">even = (value &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, even);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"奇数的序列:"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">32</span>; j += <span class="number">2</span>)&#123;</span><br><span class="line">odd = (value &gt;&gt; j) &amp; <span class="number">1</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, odd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3.输出一个整数的每一位。  </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print_num</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请输入数:"</span>);</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x);</span><br><span class="line"><span class="keyword">while</span> (x)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d "</span>, x % <span class="number">10</span>);</span><br><span class="line">x /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4.两个int（32位）整数m和n的二进制表达中,有多少个位(bit)不同?</p><p>输入例子:  1999 2299  输出例子:7</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">diff_bit</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> m, n,num,count = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"请输入两个数:"</span>);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;m, &amp;n);</span><br><span class="line">num = m ^ n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)&#123;</span><br><span class="line"><span class="keyword">if</span> (((num &gt;&gt; i) &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 在操作符总结完之后做的一些题。我个人觉得总结完之后，上手是非常容易的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.写一个函数返回参数二进制中 1 的个数 ，比如：15   —&amp;gt;   0000 1111 中4个1。  &lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;
      
    
    </summary>
    
    
      <category term="C初阶" scheme="https://skrskr66.github.io/tags/C%E5%88%9D%E9%98%B6/"/>
    
  </entry>
  
  <entry>
    <title>python-对猫眼网的top100的爬取</title>
    <link href="https://skrskr66.github.io/2018/11/26/python-%E5%AF%B9%E7%8C%AB%E7%9C%BC%E7%BD%91%E7%9A%84top100%E7%9A%84%E7%88%AC%E5%8F%96/"/>
    <id>https://skrskr66.github.io/2018/11/26/python-对猫眼网的top100的爬取/</id>
    <published>2018-11-26T08:33:42.000Z</published>
    <updated>2018-11-30T13:08:46.202Z</updated>
    
    <content type="html"><![CDATA[<p>python我从今年过年开始自学，断断续续的，最近参加了一个爬虫训练营，我发现爬虫对开始学习python是非常合适的，只不过首先得具备一些HTML的知识储备，毕竟爬虫是需要解析网页的。而且爬虫实现后的成就感是非常巨大的。所以，根据上周学习的一些知识，做一个小的总结。</p><p>首先需要安装requests库和beautifulsoup库，这两个库是有函数可以对网页进行一个解析操作的。比如request中的get()。beautifulsoup中的Beautifulsoup()的使用。</p><h4 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h4><p>首先最简单的安装就是利用cmd通过pip指令安装</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install requests</span><br><span class="line">pip install beautifulsoup4 //这里需要注意一下，后面必须有个<span class="number">4</span>。</span><br></pre></td></tr></table></figure><p>如果安装不上，那就从网上先下载好需要的安装文件，在进入该文件的目录下，进行安装。</p><h4 id="request的使用"><a href="#request的使用" class="headerlink" title="request的使用"></a>request的使用</h4><p>request的请求方式有多种，因为是一个第三方库，有多种使用方法，可以在网上寻找一些使用文档参考</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">requests.get(<span class="string">'http://www.xxxxxxxx.com'</span>)</span><br><span class="line">requests.post(<span class="string">'http://www.xxxxxxxx.com'</span>)</span><br><span class="line">requests.delete(<span class="string">'http://www.xxxxxxxx.com'</span>)</span><br><span class="line">requests.put(<span class="string">'http://www.xxxxxxxx.com'</span>)</span><br><span class="line">requests.head(<span class="string">'http://www.xxxxxxxx.com'</span>)</span><br></pre></td></tr></table></figure><p>列举一些常用的。</p><p>get：请求指定的页面信息，并返回一个主体。使用get方式时，请求数据直接放在url中。</p><p>post：请求主要是发送一些较长的数据，数据比较安全 。使用post方式时，数据放在data或者body中，不能放在url中，放在url中将被忽略。</p><p>delete：请求服务器删除Request-URI所标识的资源。 </p><p>put：向指定资源位置上传其最新内容 。</p><p>head： 向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。 </p><h4 id="request的实例"><a href="#request的实例" class="headerlink" title="request的实例"></a>request的实例</h4><p>首先我们要爬取的是猫眼网站的top100榜单。网址为<a href="http://maoyan.com/board/4。" target="_blank" rel="noopener">http://maoyan.com/board/4。</a></p><p><img src="/2018/11/26/python-对猫眼网的top100的爬取/111.png" alt="111"></p><p>这是第一页的情况，此时我们点击一个下一页，就能发现网址发现了变化。</p><p><img src="/2018/11/26/python-对猫眼网的top100的爬取/222.png" alt="222"></p><p>能明显看到网址的变化是<a href="http://maoyan.com/board/4?offset={}。" target="_blank" rel="noopener">http://maoyan.com/board/4?offset={}。</a></p><p>不断去往下翻页，我们就能看到offset=后面这个数在不断的变化，第一页是0，到最后一页是90。</p><p>说明offset是偏移量，等于号后面的是偏移量的值</p><p>知道了这个url的规律之后，就可以来进行获取网址了。</p><p>通过get去获取一个网页信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_url</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        wb_data=requests.get(url)</span><br><span class="line">        wb_data.raise_for_status</span><br><span class="line">        wb_data.encoding=wb_data.apparent_encoding</span><br><span class="line">        <span class="keyword">return</span> wb_data.text</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"代码段异常"</span></span><br></pre></td></tr></table></figure><p>上面是单个网页去抓取。我们能发现，此时所有的html页面信息都被反馈出来了。</p><p>我们利用谷歌浏览器打开该网站，右键点击检查，我们能看到各个标签内的字符串在其中，这个时候我们就需要正则表达式将其提取出来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_one_page</span><span class="params">(html)</span>:</span></span><br><span class="line">    pattern=re.compile(<span class="string">'&lt;dd&gt;.*?board-index.*?&gt;(.*?)&lt;/i&gt;.*?data-src="(.*?)".*?name.*?a.*?&gt;(.*?)&lt;/a&gt;.*?star.*?&gt;(.*?)&lt;/p&gt;.*?releasetime.*?&gt;(.*?)&lt;/p&gt;.*?integer.*?&gt;(.*?)&lt;/i&gt;.*?fraction.*?&gt;(.*?)&lt;/i&gt;.*?&lt;/dd&gt;'</span>,re.S)</span><br><span class="line">    items=re.findall(pattern,html)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> items:         </span><br><span class="line">        <span class="keyword">yield</span>&#123;             </span><br><span class="line">                <span class="string">'index'</span>:item[<span class="number">0</span>],</span><br><span class="line">                <span class="string">'img'</span>:item[<span class="number">1</span>],</span><br><span class="line">                <span class="string">'名称'</span>:item[<span class="number">2</span>],</span><br><span class="line">                <span class="string">'主演'</span>:item[<span class="number">3</span>].strip()[<span class="number">3</span>:],</span><br><span class="line">                <span class="string">'上映时间'</span>:item[<span class="number">4</span>].strip()[<span class="number">5</span>:]</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><p>关于正则表达式不在这里详细说了，以后我会专门写一篇总结。</p><p>yield的用法：如果一个函数包含<code>yield</code>关键字，这个函数就会变为一个生成器。</p><p>生成器并不会一次返回所有结果，而是每次遇到<code>yield</code>关键字后返回相应结果，并保留函数当前的运行状态，等待下一次的调用。所以在我们去请求网页的过程中，每寻找一次，找到相对应的标签，就将其内容爬取下来。</p><p>接下来需要对offset这个偏移量找到方法将他添加到我们的url中，并且可以循环的使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(offset)</span>:</span></span><br><span class="line">    url=<span class="string">'http://maoyan.com/board/4?offset=&#123;0&#125;'</span>.format(offset)</span><br><span class="line">    html=get_url(url)</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> get_url(html):</span><br><span class="line">        print(item)</span><br></pre></td></tr></table></figure><p>format函数就不需要多说了，就是往其中添加字符串。这里利用一个for循环使用，这样可以循环将网页都在函数get_url中请求一次。</p><p>最后将它输出出来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    main(offset=i*<span class="number">10</span>)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>在控制台观察，就会发现我们需要的网页信息被一个一个的提取出来了。</p><p>这里使用了一个time.sleep(2),它的作用是让请求有一定的间隔，我们都知道各个网站具有反爬虫机制，如果访问太频繁，则会被禁止访问。让2s访问一次，则可以避免这种机制。</p><p>这就是一个简单的爬取过程。接下来是更具体的一种。利用了beautifulsoup来使用</p><h4 id="BeautifulSoup的用法"><a href="#BeautifulSoup的用法" class="headerlink" title="BeautifulSoup的用法"></a>BeautifulSoup的用法</h4><p>‘美味汤’，是用Python写的一个HTML/XML的解析器，它可以很好的处理不规范标记并生成剖析树(parse tree)。 它提供简单又常用的导航（navigating），搜索以及修改剖析树的操作。它可以大大节省你的编程时间。 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//引用该库的方法不是直接<span class="keyword">import</span>就可以，而是通过<span class="keyword">from</span></span><br><span class="line">form bs4 <span class="keyword">import</span> beautifulsoup</span><br><span class="line"></span><br><span class="line">soup=BeautifulSoup(wb_data.text,<span class="string">'lxml'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span>（soup.find_all(<span class="string">'a'</span>)）</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span>（soup.get_text()）</span><br><span class="line">//以上是举例它的写法</span><br></pre></td></tr></table></figure><p>soup 就是BeautifulSoup处理格式化后的字符串，soup.title 得到的是title标签，soup.p  得到的是文档中的第一个p标签，要想得到所有标签，得用find_all</p><p>函数。find_all 函数返回的是一个序列，可以对它进行循环，依次得到想到的东西.</p><p>get_text() 是返回文本,这个对每一个BeautifulSoup处理后的对象得到的标签都是生效的。</p><p>我们在上面看到一个‘lxml’这个东西，这是解析库。在这里说明一下</p><table><thead><tr><th style="text-align:center">解析器</th><th style="text-align:center">使用方法</th><th style="text-align:center">优势</th><th style="text-align:center">劣势</th></tr></thead><tbody><tr><td style="text-align:center">python标准库</td><td style="text-align:center">BeautifulSoup(markup,’parser’)</td><td style="text-align:center">python内置；执行速度适中；文档容错能力强</td><td style="text-align:center">低版本pyton容错能力差</td></tr><tr><td style="text-align:center">lxml HTML解析器</td><td style="text-align:center">BeautifulSoup(markup,’lxml’)</td><td style="text-align:center">速度快；容错能力强</td><td style="text-align:center">需要安装lxml</td></tr><tr><td style="text-align:center">lxml XML解析器</td><td style="text-align:center">BeautifulSoup(markup,’xml’)</td><td style="text-align:center">速度快；唯一支持XML</td><td style="text-align:center">需要安装lxml</td></tr><tr><td style="text-align:center">Html5lib</td><td style="text-align:center">BeautifulSoup(markup,’html5lib’)</td><td style="text-align:center">容错性最好</td><td style="text-align:center">速度慢；需要安装html5lib</td></tr></tbody></table><p>在我们知道解析器之后，我们还要做的就是通过什么去选择标签。这里一般有四种常用选择器</p><table><thead><tr><th style="text-align:center">选择器</th><th style="text-align:center">作用</th><th style="text-align:center">使用方法</th></tr></thead><tbody><tr><td style="text-align:center">节点选择器</td><td style="text-align:center">通过节点名称嵌套选取信息</td><td style="text-align:center">soup.div.next_sibling.ul.li.p</td></tr><tr><td style="text-align:center">方法选择器</td><td style="text-align:center">find_all()和find()函数</td><td style="text-align:center">soup.find(name=’p’,class=’ ‘)</td></tr><tr><td style="text-align:center">css选择器</td><td style="text-align:center">Select方法</td><td style="text-align:center">body&gt;div.content&gt;ul&gt;li:nth-child(1)&gt;p</td></tr><tr><td style="text-align:center">Xpath</td><td style="text-align:center">用于在xml文档中搜索元素的路径语言</td><td style="text-align:center">/html/body/div[2]/ul/li[1]/p</td></tr></tbody></table><p>当我们基本了解之后就可以使用了。</p><p>在下面的使用中，就利用select方法</p><p><img src="/2018/11/26/python-对猫眼网的top100的爬取/333.png" alt="333"></p><p>我们能看到黄色的地方就是我们需要的title标签所指向的地方。</p><p>右击这个标签，点击copy—-&gt;copy selector就是利用css选择器，这之后复制出来的标签走向最后复制到select()方法中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_one_page</span><span class="params">(html)</span>:</span></span><br><span class="line">    soup=BeautifulSoup(<span class="string">''</span>.join(html),<span class="string">'lxml'</span>)</span><br><span class="line"><span class="comment">#在这里我们是得到了R.txt的文本，但是我们不能输出，所以我们得利用print来输出</span></span><br><span class="line">    titles=soup.select(<span class="string">'#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; div &gt; div &gt; div.movie-item-info &gt; p.name &gt; a'</span>)</span><br><span class="line">    pics=soup.select(<span class="string">'#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; a &gt; img.board-img'</span>)</span><br><span class="line">    actors=soup.select(<span class="string">'#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; div &gt; div &gt; div.movie-item-info &gt; p.star'</span>)</span><br><span class="line">    days=soup.select(<span class="string">'#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; div &gt; div &gt; div.movie-item-info &gt; p.releasetime'</span>)</span><br><span class="line">    scores1=soup.select(<span class="string">'#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; div &gt; div &gt; div.movie-item-number.score-num &gt; p &gt; i.integer'</span>)</span><br><span class="line">    scores2=soup.select(<span class="string">'#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; div &gt; div &gt; div.movie-item-number.score-num &gt; p &gt; i.fraction'</span>)</span><br><span class="line">    <span class="keyword">for</span> title,pic,actor,day,scores,scoress <span class="keyword">in</span> zip(titles,pics,actors,days,scores1,scores2):</span><br><span class="line">        info=&#123;</span><br><span class="line">                <span class="string">'title'</span>:title.get_text(),</span><br><span class="line">                <span class="string">'pic'</span>:pic.get(<span class="string">'alt'</span>),</span><br><span class="line">                <span class="string">'actor'</span>:actor.get_text(),</span><br><span class="line">                <span class="string">'day'</span>:day.get_text(),</span><br><span class="line">                <span class="string">'scores'</span>:scores.get_text()+scoress.get_text(),</span><br><span class="line">                &#125;</span><br><span class="line">        write_to_file(info)</span><br><span class="line">        print(info)</span><br></pre></td></tr></table></figure><p>在上面有一个自己定义的wirte_to_file()函数。爬取完数据后，一直放在控制台显示只能证明我们爬取成功了。所以定义函数将我们所请求到的数据放入一个文件中，可以供我们需要的时候看看。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_to_file</span><span class="params">(content)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'maoyan.text'</span>,<span class="string">'a'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(json.dumps(content,ensure_ascii=<span class="keyword">False</span>)+<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure><p>with open()这个函数的使用时，有四种文本可以保存，分别是text，json，csv，excel。后两种还可以利用pandas来处理统计。</p><p>完整代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_one_page</span><span class="params">(url)</span>:</span></span><br><span class="line">    headers=&#123;<span class="string">'user-agent'</span>:<span class="string">'Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/53.0.2785.104 Safari/537.36 Core/1.53.2263.400 QQBrowser/9.5.10429.400'</span>&#125;</span><br><span class="line">    response=requests.get(url,headers=headers)</span><br><span class="line">    <span class="keyword">if</span> response.status_code==<span class="number">200</span>:</span><br><span class="line">        <span class="keyword">return</span> response.text</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">data=[]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_one_page</span><span class="params">(html)</span>:</span></span><br><span class="line">    soup=BeautifulSoup(<span class="string">''</span>.join(html),<span class="string">'lxml'</span>)</span><br><span class="line"><span class="comment">#在这里我们是得到了R.txt的文本，但是我们不能输出，所以我们得利用print来输出</span></span><br><span class="line">    titles=soup.select(<span class="string">'#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; div &gt; div &gt; div.movie-item-info &gt; p.name &gt; a'</span>)</span><br><span class="line">    pics=soup.select(<span class="string">'#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; a &gt; img.board-img'</span>)</span><br><span class="line">    actors=soup.select(<span class="string">'#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; div &gt; div &gt; div.movie-item-info &gt; p.star'</span>)</span><br><span class="line">    days=soup.select(<span class="string">'#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; div &gt; div &gt; div.movie-item-info &gt; p.releasetime'</span>)</span><br><span class="line">    scores1=soup.select(<span class="string">'#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; div &gt; div &gt; div.movie-item-number.score-num &gt; p &gt; i.integer'</span>)</span><br><span class="line">    scores2=soup.select(<span class="string">'#app &gt; div &gt; div &gt; div.main &gt; dl &gt; dd &gt; div &gt; div &gt; div.movie-item-number.score-num &gt; p &gt; i.fraction'</span>)</span><br><span class="line">    <span class="keyword">for</span> title,pic,actor,day,scores,scoress <span class="keyword">in</span> zip(titles,pics,actors,days,scores1,scores2):</span><br><span class="line">        info=&#123;</span><br><span class="line">                <span class="string">'title'</span>:title.get_text(),</span><br><span class="line">                <span class="string">'pic'</span>:pic.get(<span class="string">'alt'</span>),</span><br><span class="line">                <span class="string">'actor'</span>:actor.get_text(),</span><br><span class="line">                <span class="string">'day'</span>:day.get_text(),</span><br><span class="line">                <span class="string">'scores'</span>:scores.get_text()+scoress.get_text(),</span><br><span class="line">                &#125;</span><br><span class="line">        write_to_file(info)</span><br><span class="line">        print(info)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_to_file</span><span class="params">(content)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">'maoyan.excel'</span>,<span class="string">'a'</span>,encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(json.dumps(content,ensure_ascii=<span class="keyword">False</span>)+<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(offset)</span>:</span></span><br><span class="line">    url=<span class="string">'https://maoyan.com/board/4?offset='</span>+str(offset)</span><br><span class="line">    html=get_one_page(url)</span><br><span class="line">    parse_one_page(html)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    main(offset=i*<span class="number">10</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>以上就是我们的爬取过程，并不算复杂，而且是比较容易爬取的！可以让你瞬间有成就感的那种！</p><p>爬取出来的是放在字典内的，一条一条在文本文件中，观看是非常醒目的。动手试试吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;python我从今年过年开始自学，断断续续的，最近参加了一个爬虫训练营，我发现爬虫对开始学习python是非常合适的，只不过首先得具备一些HTML的知识储备，毕竟爬虫是需要解析网页的。而且爬虫实现后的成就感是非常巨大的。所以，根据上周学习的一些知识，做一个小的总结。&lt;/p&gt;
      
    
    </summary>
    
    
      <category term="python-爬虫" scheme="https://skrskr66.github.io/tags/python-%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
</feed>
